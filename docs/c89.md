# C89: Why We're Using A 36-Year-Old Standard

Look, I already know what you're thinking. "C89? That's from 1989. We have C99, C11, C17, C23... why would you use a standard from when the Berlin Wall was still standing?"

I've had this conversation maybe a hundred times. Let me save us both some time and explain the reasoning up front.

## The Actual Reason (Not What You Think)

It's not nostalgia. It's not some weird retro fetish. It's not "I learned C89 in college and refuse to learn anything new."

It's about **stability over time**.

Here's the thing about software: most of it doesn't last. You write something in the latest, greatest framework, and five years later it doesn't compile anymore. Dependencies break. APIs change. The ecosystem moves on.

But you know what still compiles and runs? C89 code. Code written in 1990 still compiles with modern compilers. No changes. No fixes. No "oh this function was deprecated." It just works.

That's 35 years of backward compatibility. That's not common. That's actually kind of miraculous.

And if you're trying to build software that lasts - not five years, not ten years, but potentially lifetimes - you need that stability. You need a foundation that's not going to shift under you.

C89 is that foundation. It's the bedrock. Everything since then is just additions on top (which you can ignore if you want).

## What C89 Actually Is (The Quick Version)

C89 (also called ANSI C or C90 - they're the same thing) is the first standardized version of C. Before 1989, C was just "whatever K&R described in their book plus whatever your compiler vendor added."

The C89 standard said "okay, THIS is C. This is what every conforming compiler must support."

What you get:
- Function prototypes (big improvement over K&R C)
- The void type
- Enums and const and volatile
- Standard library (stdio, stdlib, string, etc.)
- Preprocessor with proper macros
- Struct assignment and passing by value

What you DON'T get (compared to later standards):
- `//` comments (only `/* */` works)
- Declarations mixed with code (all declarations at top of block)
- Variable-length arrays
- `long long` type (no guaranteed 64-bit integers!)
- Inline functions
- Complex numbers
- Boolean type (we make our own)
- And a bunch of other stuff added in C99 and later

That's it. It's simple. It's constrained. And those constraints are actually helpful.

## The Compiler Flags (Or: How To Make The Compiler Your Enemy)

Here's every flag we compile with:

```bash
-std=c89          # Use C89 standard
-pedantic         # Reject all GNU/compiler extensions
-Wall             # Enable all warnings
-Wextra           # Enable extra warnings
-Werror           # Treat warnings as ERRORS (compilation fails)
-Wconversion      # Warn on implicit type conversions
-Wsign-conversion # Warn on signed/unsigned conversions
-Wcast-qual       # Warn on casting away const/volatile
-Wstrict-prototypes   # Require proper function prototypes
-Wmissing-prototypes  # Warn on functions without prototypes
-Wwrite-strings   # String literals are const char*, not char*
```

Let me explain what each of these does and why we use them.

### `-std=c89`

This tells the compiler "only accept C89 code." If you try to use C99 features (like `//` comments or variable declarations in the middle of blocks), the compiler rejects it.

Why? Because we want to KNOW our code is C89-compliant. We're not accidentally relying on newer features that might not be available on all C89 compilers.

### `-pedantic`

This rejects compiler extensions. GCC and Clang add a bunch of non-standard stuff. `-pedantic` says "no, only standard C89."

Without this, you might write code that compiles on GCC but fails on other compilers because you're using GCC-specific extensions without realizing it.

### `-Wall` and `-Wextra`

These enable most compiler warnings. "All" is a bit of a misnomer - it's not actually all warnings, just most of them. `-Wextra` enables even more.

Why do we want warnings? Because warnings catch bugs. "Unused variable" might seem harmless, but it often indicates a logic error. "Comparison between signed and unsigned" can cause subtle bugs.

### `-Werror`

This is the nuclear option. Every warning becomes an error. Your code doesn't compile if there are ANY warnings.

Most projects don't do this. Most projects let warnings accumulate. You get 50 warnings in your build and you just ignore them.

We don't do that. If the compiler complains, we fix it. No exceptions.

Why? Because warnings are almost always real problems. And if you let them accumulate, you stop paying attention to them. Then you miss the important ones.

With `-Werror`, you HAVE to fix every warning to compile. So you never have warning fatigue. Every compilation is clean.

### `-Wconversion` and `-Wsign-conversion`

These warn on implicit type conversions. Like assigning a `long` to an `int`, or mixing signed and unsigned types.

```c
s32 x = 42;
s16 y = x;  /* Warning: conversion from s32 to s16 may alter value */

i32 a = 10;
s32 b = 5;
s32 c = a - b;  /* Warning: signed/unsigned mismatch */
```

Why do we care? Because implicit conversions hide bugs. You think you're storing a value, but it gets truncated. You think you're doing math, but it wraps around because of unsigned arithmetic.

With these flags, you have to be EXPLICIT about conversions:

```c
s16 y = (s16)x;  /* Explicit cast - you know what you're doing */
s32 c = (s32)a - b;  /* Explicit: treat a as signed */
```

Yes, this means more casts in your code. But it also means no surprises.

### `-Wcast-qual`

This warns if you cast away `const` or `volatile`:

```c
constans character* str = "hello";
character* mutable = (character*)str;  /* Warning: casting away const */
```

Why? Because `const` is a contract. If something is const, you're promising not to modify it. Casting away const breaks that contract and can cause bugs (or crashes if you try to modify a string literal).

### `-Wstrict-prototypes` and `-Wmissing-prototypes`

These require function prototypes for EVERY function.

In old K&R C, you could declare functions like:

```c
int add(a, b)
int a, b;
{
    return a + b;
}
```

Or even worse:

```c
int add();  /* No parameter info! */
```

C89 allows (but doesn't require) prototypes:

```c
int add(int a, int b);
```

These flags REQUIRE prototypes. Every function must declare its parameter types. No exceptions.

Why? Because prototypes catch bugs. Without them, the compiler can't check if you're passing the right types. You can pass three arguments to a function that expects two, and the compiler won't complain. Then you get stack corruption at runtime.

With prototypes, the compiler verifies every call. Type mismatch? Compilation error. Wrong number of arguments? Compilation error. Catches bugs at compile time instead of runtime.

### `-Wwrite-strings`

This treats string literals as `const char*` instead of `char*`.

```c
character* str = "hello";  /* Warning: converting const char* to char* */
constans character* str = "hello";  /* Correct */
```

Why? Because string literals are stored in read-only memory on most systems. If you try to modify them, you get a segfault. By making them const, the compiler prevents you from accidentally trying to modify them.

## The 64-Bit Problem (Why We Use s32 Everywhere)

Alright, here's a big constraint of C89 that catches everyone off guard: **there is no guaranteed 64-bit integer type**.

In C89, you have:
- `char` (at least 8 bits, usually exactly 8)
- `short` (at least 16 bits, usually exactly 16)
- `int` (at least 16 bits, usually 32 on modern systems)
- `long` (at least 32 bits, exactly 32 on 32-bit systems, sometimes 64 on 64-bit systems)

That's it. No `long long`. No `int64_t`. Those came in C99.

On most modern systems, `long` is 32 bits on 32-bit systems and 64 bits on 64-bit Unix systems (but still 32 bits on 64-bit Windows! Thanks Microsoft). But the C89 standard only GUARANTEES that `long` is at least 32 bits. It might be 32, might be 64, might be something else.

So if you want portable C89 code, you can't rely on having a 64-bit type AT ALL.

That's why this codebase uses `s32` (signed 32-bit int) everywhere. It's the widest integer type you can reliably have in portable C89.

```c
/* These are safe in C89 */
s32 counter = ZEPHYRUM;
s32 file_size = 4096;
s32 hash = calculate_hash(data);

/* These are NOT guaranteed to exist in C89 */
s64 big_number = 9999999999;  /* Requires C99 long long */
```

### What About Large Numbers?

"But wait," you say, "what if I need numbers bigger than 2^31-1 (about 2.1 billion)?"

Options:
1. **Use unsigned:** `i32` gives you 0 to 4.2 billion. Twice the range, but you lose negative numbers and have to be careful with arithmetic.
2. **Use floats:** `f64` (double) can represent integers up to 2^53 exactly. But floating point math has its own issues.
3. **Use multiple integers:** Implement your own bigint library. Not trivial, but possible.
4. **Rethink your problem:** Do you REALLY need numbers that big? Often you can restructure to avoid it.

Most of the time, 32-bit integers are enough. If you're counting things, indexing arrays, storing sizes, 32 bits is plenty. 2 billion is a LOT of things.

File sizes are the main exception - modern files can be bigger than 2GB. But for file operations, you can often use library functions that handle large files internally (like `fseek` with `SEEK_CUR` to move through files in chunks).

### The Practical Reality

We use `s32` everywhere by default. It works on every C89 platform, the behavior is predictable, and it's wide enough for 99% of use cases.

If you're porting to a system with 16-bit ints (like some embedded systems), you'd need to adjust. But those systems are rare now, and if you're targeting them, you know about it.

## The Declaration Rules (Most Annoying Part)

In C89, all variable declarations in a block must come BEFORE any statements.

This is legal:

```c
vacuum my_function(vacuum)
{
    integer x;
    integer y;
    character* buffer;

    x = 10;
    y = 20;
    buffer = malloc(100);

    /* ... */
}
```

This is NOT legal in C89:

```c
vacuum my_function(vacuum)
{
    integer x = 10;
    processum(x);

    integer y = 20;  /* ERROR: declaration after statement */
    processum(y);
}
```

All declarations must be at the top of the block, before any statements (assignments, function calls, etc.).

Why is this annoying? Because in C99 and later, you can mix declarations and code:

```c
/* C99+ */
for (int i = 0; i < 10; i++)  /* Declaration in for loop */
{
    int x = compute(i);  /* Declaration mid-block */
    process(x);
}
```

In C89, you have to do this:

```c
/* C89 */
integer i;
integer x;

for (i = 0; i < 10; i++)
{
    x = compute(i);
    process(x);
}
```

Or use a new block:

```c
integer i;

for (i = 0; i < 10; i++)
{
    integer x;  /* New block, so declarations allowed */
    x = compute(i);
    process(x);
}
```

This is probably the most irritating restriction of C89. You get used to it, but it's definitely less convenient than C99+.

### The Workaround

Use blocks liberally:

```c
vacuum my_function(vacuum)
{
    /* First part */
    {
        integer x = 10;
        integer y = 20;
        processum(x, y);
    }

    /* Second part */
    {
        character* buffer = malloc(100);
        legere_filum(buffer, 100);
        liberare(buffer);
    }
}
```

Each block can have its own declarations at the top. This keeps related variables grouped and limits their scope.

## No `//` Comments (Only `/* */`)

C89 only supports `/* */` comments. The `//` single-line comment came in C99.

This is legal:

```c
/* This is a comment */
integer x = 42;  /* This too */

/*
 * Multi-line comment
 * spanning several lines
 */
```

This is NOT legal in C89:

```c
// This is a C99/C++ comment
integer x = 42;  // Not allowed in C89
```

Not a huge deal, but you'll get compile errors if you use `//`. Stick with `/* */`.

## No Inline Functions

C89 doesn't have `inline`. If you want inline functions, you have two options:

1. **Use macros:**

```c
#define MAX(a, b) ((a) > (b) ? (a) : (b))
```

But macros have issues - they evaluate arguments multiple times, don't respect scope, etc.

2. **Let the compiler decide:**

Modern compilers are smart. If you write a small function, the compiler will often inline it automatically at optimization levels `-O2` or `-O3`. You don't need to tell it to.

```c
interior integer add(integer a, integer b)
{
    redde a + b;
}
```

With optimizations enabled, the compiler will likely inline this. You don't need an `inline` keyword.

## No Boolean Type (We Make Our Own)

C89 doesn't have `bool`, `true`, or `false`. Those came in C99 with `<stdbool.h>`.

So we define our own:

```c
typedef uint32_t b32;  /* Boolean type */

#define VERUM   1      /* True */
#define FALSUM  0      /* False */
```

And use them:

```c
b32 is_valid(integer x)
{
    si (x > ZEPHYRUM)
    {
        redde VERUM;
    }
    alioquin
    {
        redde FALSUM;
    }
}
```

Why `b32` instead of `b8`? Because 32-bit values are faster on most architectures and align better in structs. The extra 3 bytes per boolean is negligible.

## Working Within The Constraints

Okay, so C89 is restrictive compared to later standards. How do you actually write code in it?

### 1. Declare Everything Up Front

Get used to declaring all your variables at the top of a function or block:

```c
vacuum processum_data(character* buffer, integer size)
{
    integer i;
    integer count;
    character* ptr;
    b32 found;

    /* Now you can use them */
    count = ZEPHYRUM;
    found = FALSUM;

    per (i = ZEPHYRUM; i < size; i++)
    {
        /* ... */
    }
}
```

Yes, this means you might declare variables you don't use until later in the function. That's fine. The compiler will optimize it anyway.

### 2. Use Blocks For Scoping

If you want to limit variable scope, use blocks:

```c
vacuum my_function(vacuum)
{
    /* Part 1 */
    {
        integer x = ZEPHYRUM;
        integer y = ZEPHYRUM;
        /* x and y only exist in this block */
    }

    /* Part 2 - different x and y */
    {
        fluitans x = 3.14f;
        fluitans y = 2.71f;
        /* These are different variables */
    }
}
```

This also makes the code more readable - each block is a logical unit.

### 3. Initialize After Declaration

You can't declare and initialize in one line always (though sometimes you can), so get used to this pattern:

```c
integer x;
character* buffer;
Persona* persona;

x = calculate_value();
buffer = piscina_allocare(piscina, 1024);
persona = persona_creare(piscina);
```

### 4. Cast Explicitly

With `-Wconversion` enabled, you'll need explicit casts for type conversions:

```c
s32 big = 1000;
s16 small = (s16)big;  /* Explicit cast */

i32 unsigned_val = 50;
s32 signed_val = (s32)unsigned_val;  /* Explicit cast */
```

This is actually good - it makes you think about type conversions instead of letting them happen silently.

### 5. Prototypes For Everything

Put function prototypes in header files or at the top of your source file:

```c
/* In header file or top of .c file */
vacuum processum_data(character* buffer, integer size);
integer calculate_hash(constans character* str);
b32 is_valid(integer x);

/* Then define the functions */
vacuum processum_data(character* buffer, integer size)
{
    /* implementation */
}
```

The compiler enforces this with `-Wstrict-prototypes`, so you have no choice.

### 6. Stick With 32-bit Integers

Use `s32` for signed integers and `i32` for unsigned integers. These are portable and wide enough for most uses.

```c
s32 counter = ZEPHYRUM;
i32 flags = ZEPHYRUM;
s32 size = calculate_size();
```

If you REALLY need 64-bit, you'll need to either:
- Drop C89 compatibility and use C99's `long long`
- Use floating point (doubles can hold integers up to 2^53)
- Implement multi-precision arithmetic yourself

But most of the time, 32 bits is enough.

## What You Gain From These Constraints

Okay, so C89 is more restrictive than later C standards. What do you get in return?

### 1. Universal Compatibility

C89 code compiles everywhere. Every C compiler supports C89. Even tiny embedded systems. Even ancient Unix systems. Even weird architectures.

If you write clean C89, it will compile and run on basically anything with a C compiler.

### 2. Forced Discipline

The restrictions force you to be disciplined. You can't mix declarations and code, so your code has clear structure. You can't rely on 64-bit ints, so you think carefully about your data sizes. You have to write prototypes, so your functions have clear interfaces.

These constraints make you write BETTER code, not just code that compiles.

### 3. Long-term Stability

C89 code from 1990 still compiles today. Will C99 code from 2005 compile in 2040? Probably. Will C23 code from 2024 compile in 2060? Maybe. Will C89 code from 1990 still compile in 2060? Almost certainly.

The older the standard, the more stable it is. C89 has been stable for 35 years. It's not changing. You can build on it with confidence.

### 4. No Feature Bloat

C89 is simple. There's not much to learn. The language fits in your head.

Later C standards add features. Some are useful (like `//` comments and inline functions), but many are just complexity. Variable-length arrays? Complex numbers? Generic macros?

With C89, you have a small, focused language. You don't need to know all the new features to understand code. Anyone who knows C can read C89 code.

### 5. Clear Compilation

With `-Werror` and all those warning flags, you get instant feedback. The compiler is your pair programmer. It catches bugs immediately.

Your code either compiles cleanly or doesn't compile at all. No warnings to ignore. No "I'll fix that later." Either it's correct or it's not.

## Common Problems And Solutions

### Problem: "I want to use C99 features!"

**Solution:** Don't. That's the whole point. If you want C99, use C99. But then you lose the guarantees of C89.

If you REALLY need a C99 feature, ask yourself: do I NEED it, or do I just WANT it? Usually there's a C89 way to do it.

### Problem: "I need 64-bit integers!"

**Solution:** Use `f64` (double) if you need to represent large integers (up to 2^53 exactly). Or implement multi-precision arithmetic. Or question whether you really need numbers that big.

For file sizes, use file operations that handle large files internally (many standard library functions do).

### Problem: "All my variables are declared at the top and it's ugly!"

**Solution:** Use blocks to group related code and limit variable scope:

```c
vacuum my_function(vacuum)
{
    /* Step 1: Initialize */
    {
        integer x;
        integer y;

        x = 10;
        y = 20;
        setup(x, y);
    }

    /* Step 2: Process */
    {
        character* buffer;
        integer size;

        buffer = allocate_buffer();
        size = get_size();
        processum(buffer, size);
    }
}
```

This keeps variables close to where they're used and makes the code more readable.

### Problem: "I keep getting conversion warnings!"

**Solution:** Cast explicitly. The compiler is telling you there's a type mismatch. Fix it:

```c
s32 x = 1000;
s16 y = (s16)x;  /* Explicit: I know I might lose data */

i32 a = 50;
s32 b = (s32)a;  /* Explicit: I'm treating unsigned as signed */
```

If you're getting a lot of these, you might be using the wrong types. Use `s32` for most integers and `memoriae_index` for sizes.

### Problem: "The compiler rejects my code but I don't know why!"

**Solution:** Read the error message carefully. C89 compiler errors are usually clear:

- "declaration after statement" → Move declarations to top of block
- "function declaration isn't a prototype" → Add parameter types
- "implicit conversion" → Add explicit cast
- "token `//` invalid" → Use `/* */` comments
- "'inline' is a C99 extension" → Remove `inline`, let compiler optimize

Most C89 errors are about violating the rules we discussed. Once you learn the rules, the errors make sense.

## Testing Your C89 Compliance

Want to verify your code is truly C89-compliant? Compile with all the flags:

```bash
gcc -std=c89 -pedantic -Wall -Wextra -Werror \
    -Wconversion -Wsign-conversion -Wcast-qual \
    -Wstrict-prototypes -Wmissing-prototypes \
    -Wwrite-strings \
    yourfile.c
```

If it compiles without errors, you're C89-compliant. If not, fix the errors.

Don't disable warnings to make it compile. Fix the underlying issues. The compiler is helping you write better code.

## Why Not C99 Or Later?

Fair question. C99 added some nice features:
- `//` comments
- Declarations anywhere in blocks
- `long long` for 64-bit integers
- `inline` functions
- Variable-length arrays
- `<stdbool.h>` for booleans

These are convenient. So why not use C99?

Because C99 wasn't widely adopted for years. Some compilers didn't support it fully until the 2010s. Microsoft's C compiler STILL doesn't fully support C99 (as of 2024).

C89, by contrast, has been universal since the early 1990s. Every compiler supports it. Every platform supports it. It's the lowest common denominator.

If you want maximum portability and longevity, C89 is the safe choice. It's been stable for 35 years and will be stable for 35 more.

C99 features are nice, but they're not essential. You can write good, clean, fast code in C89. Billions of lines of C89 code are running right now, powering systems that need to work.

## The Philosophy (Why This Matters)

Here's the deeper reason for using C89: it's about building things that LAST.

Most software has a lifespan measured in years. Dependencies change, frameworks evolve, languages add new features, and your code gradually becomes "legacy code" that nobody wants to touch.

But C89 code written in 1990 still compiles and runs today. It's not legacy. It's not outdated. It's just... C.

That's 35 years of stability. That's code that outlived the company that wrote it, outlived the programmer who wrote it, outlived entire technology paradigms (remember Java applets? Flash? Silverlight?).

If you're building something you want to last - really last, not "a few years" but "decades or generations" - you need that stability. You need a foundation that won't shift.

C89 is that foundation. It's the bedrock. Everything else is sand.

Is it restrictive? Yes. Is it less convenient than modern languages? Absolutely. But it's STABLE. And stability over decades is more valuable than convenience over months.

## Quick Reference: The C89 Rules

**Declarations:**
- All declarations at top of block, before any statements
- Can't declare variables in for loops: `for (int i = ...)` is C99
- Use blocks `{ }` to create new scopes for declarations

**Comments:**
- Only `/* */` comments, not `//`

**Types:**
- No `long long` (use `s32` for guaranteed 32-bit)
- No `bool` (use `b32` with `VERUM`/`FALSUM`)
- No `inline` (let compiler optimize)

**Functions:**
- Must have prototypes with parameter types
- No default arguments
- No function overloading (that's C++ anyway)

**Compiler Flags:**
- `-std=c89` for standard compliance
- `-pedantic` to reject extensions
- `-Wall -Wextra -Werror` to catch all issues
- `-Wconversion` and friends for safe type handling

**Workarounds:**
- Use `s32` instead of relying on `int` or `long` sizes
- Use `memoriae_index` (size_t) for sizes and indices
- Cast explicitly when converting types
- Use blocks liberally for variable scoping
- Let compiler inline small functions (no `inline` needed)

## FAQ (The Questions I'm Tired Of Answering)

### Q: Why not just use C99? It's still old and stable.

C99 took over a decade to be widely adopted. Some compilers still don't fully support it. C89 has been universal since the early 90s.

Plus, once you start using C99 features, where do you stop? Why not C11? Why not C23? The point is to pick a line and stay there. C89 is the most stable line.

### Q: Isn't this just making things harder for no reason?

The restrictions make you write MORE DISCIPLINED code. You can't be sloppy about types because `-Wconversion` catches you. You can't have unclear function interfaces because prototypes are required. You can't rely on huge integers because they're not guaranteed.

These constraints force clarity. And clarity is more valuable than convenience.

### Q: What if I really need 64-bit integers?

Use `double` (it can represent integers up to 2^53 exactly), implement multi-precision arithmetic, or question whether you really need numbers that big.

For most applications, 32-bit integers (±2 billion) are enough. If yours isn't, you probably know it already.

### Q: Do people actually still use C89?

Yes. Embedded systems. Safety-critical systems. Systems that need to compile on old hardware. Anywhere maximum portability matters.

Also, lots of old codebases are C89 and they work fine. No reason to port them to newer standards.

### Q: Is C89 faster than C99?

No. The compiled code is basically identical. The restrictions are about source code, not generated code.

If anything, modern compilers might optimize C99 code better because they can make assumptions based on C99 semantics. But the difference is negligible.

### Q: Can I mix C89 and C99 code?

Technically yes - you can compile different files with different standards and link them. But don't. Pick one standard and stick with it project-wide.

Mixing standards leads to confusion and subtle bugs. Just use C89 everywhere or C99 everywhere. Don't mix.

### Q: What about C++?

C++ is a different language. If you want C++, use C++. This project is C.

Note that much C89 code is also valid C++, but not all. If you need C++ compatibility, you'd need to be careful. But that's not a goal here.

---

Look, I get it. C89 seems unnecessarily restrictive in 2024. We have better tools now. More convenient languages. More features.

But "convenient" and "lasting" are different goals. We're optimizing for lasting.

C89 has been stable for 35 years. It will be stable for 35 more. Code you write today will compile in 2060. That's the goal.

If you don't care about multi-decade timescales, use whatever you want. C99, C23, Rust, Go, whatever.

But if you're building something meant to LAST - really last, not "until the next refactor" - C89 is hard to beat.

Now you know the rules, the constraints, and the reasoning. Write your code accordingly.

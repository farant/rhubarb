/* capsula.h - File Embedding Library (Go embed-style)
 *
 * Bibliotheca pro embedding files in binaries.
 * Nomen ex Latina "capsula" (small container/capsule).
 *
 * Duo componentes:
 *   1. Build tool (capsula_generare) - legit config, comprimit files, generat C headers
 *   2. Runtime library (hic) - legit embedded files per path at runtime
 *
 * USUS:
 *   Capsula* cap = capsula_aperire(&capsula_libri, piscina);
 *   CapsulaFructus res = capsula_legere(cap, "books/pg1342.txt", piscina);
 *   si (res.status == CAPSULA_OK) { ... use res.datum ... }
 */

#ifndef CAPSULA_H
#define CAPSULA_H

#include "latina.h"
#include "chorda.h"
#include "piscina.h"


/* ========================================================================
 * CONSTANTIAE
 * ======================================================================== */

#define CAPSULA_MAGICA     0x53504143  /* "CAPS" in little-endian */
#define CAPSULA_VERSIO     I


/* ========================================================================
 * TYPI - STATUS
 * ======================================================================== */

nomen enumeratio {
    CAPSULA_OK = 0,
    CAPSULA_FRACTA_MAGICA,       /* Bad magic number */
    CAPSULA_FRACTA_VERSIO,       /* Unsupported version */
    CAPSULA_FRACTA_ALLOCATIO,    /* Allocation failed */
    CAPSULA_NON_INVENTUM,        /* File not found */
    CAPSULA_FRACTA_INFLATIO,     /* Decompression failed */
    CAPSULA_FRACTA_DATUM         /* Invalid data format */
} CapsulaStatus;


/* ========================================================================
 * TYPI - EMBEDDED DATA (Generated)
 * ======================================================================== */

/* Reference to embedded data blob (generated by capsula_generare) */
nomen structura {
    constans i8* datum;
    i32          mensura;
} CapsulaEmbed;


/* ========================================================================
 * TYPI - RUNTIME STRUCTURES
 * ======================================================================== */

/* TOC entry (parsed at runtime) */
nomen structura {
    chorda  via;                 /* File path */
    i32     data_offset;         /* Offset into data blob */
    i32     mensura_compressa;   /* Compressed size (0 if uncompressed) */
    i32     mensura_cruda;       /* Original uncompressed size */
    b32     compressa;           /* Is file gzipped? */
} CapsulaIndexum;


/* Opened capsule (runtime state) */
nomen structura {
    constans i8*     datum;           /* Pointer to embedded data */
    i32              mensura;         /* Total size of data blob */
    i32              numerus_filorum; /* Number of files */
    CapsulaIndexum*  index;           /* Parsed TOC array */
    Piscina*         piscina;         /* Arena used for parsing */
} Capsula;


/* Result of reading a file */
nomen structura {
    CapsulaStatus status;
    chorda        datum;         /* File contents (decompressed if needed) */
} CapsulaFructus;


/* Iterator for walking all files */
nomen structura {
    Capsula* capsula;
    i32      positus;            /* Current position (1-indexed after proximus) */
} CapsulaIter;


/* ========================================================================
 * FUNCTIONES - APERIRE / CLAUDERE
 * ======================================================================== */

/* Aperire capsulam embedded
 *
 * embed:   Pointer to generated CapsulaEmbed struct
 * piscina: Arena for allocating parsed index
 *
 * Redde: Capsula pointer, vel NIHIL si error
 *
 * Nota: Capsula vivit in piscina - no separate destruere needed
 */
Capsula*
capsula_aperire(
    constans CapsulaEmbed* embed,
    Piscina*               piscina);


/* ========================================================================
 * FUNCTIONES - LEGERE
 * ======================================================================== */

/* Legere file per path
 *
 * capsula: Opened capsule
 * via:     File path (C string, null-terminated)
 * piscina: Arena for decompressed data
 *
 * Redde: CapsulaFructus with status and data
 */
CapsulaFructus
capsula_legere(
    Capsula*            capsula,
    constans character* via,
    Piscina*            piscina);


/* Legere file per chorda path */
CapsulaFructus
capsula_legere_chorda(
    Capsula* capsula,
    chorda   via,
    Piscina* piscina);


/* ========================================================================
 * FUNCTIONES - QUAERERE
 * ======================================================================== */

/* Verificare si file existit
 *
 * capsula: Opened capsule
 * via:     File path to check
 *
 * Redde: VERUM si existit
 */
b32
capsula_habet(
    Capsula*            capsula,
    constans character* via);


/* Invenire index entry per path (vel NIHIL si non inventum) */
CapsulaIndexum*
capsula_invenire(
    Capsula*            capsula,
    constans character* via);


/* ========================================================================
 * FUNCTIONES - ITERATIO
 * ======================================================================== */

/* Obtinere numerum filorum */
i32
capsula_numerus(Capsula* capsula);


/* Obtinere index entry per position (0-indexed) */
CapsulaIndexum*
capsula_indexum(Capsula* capsula, i32 index);


/* Creare iterator */
CapsulaIter
capsula_iter(Capsula* capsula);


/* Avanzare ad proximum file
 *
 * Redde: VERUM si est proximum, FALSUM si finis
 *
 * Post call, access current entry via:
 *   CapsulaIndexum* curr = capsula_indexum(iter->capsula, iter->positus - 1);
 */
b32
capsula_iter_proximus(CapsulaIter* iter);


/* ========================================================================
 * FUNCTIONES - UTILITATES
 * ======================================================================== */

/* Obtinere error message pro status */
constans character*
capsula_status_nuntium(CapsulaStatus status);


#endif /* CAPSULA_H */

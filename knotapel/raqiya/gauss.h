/*
 * gauss.h -- Algebraic Graph Density Analysis for Z[i]
 * =====================================================
 *
 * Single-header C89 library. Analyzes relationships between elements
 * of the Gaussian integers Z[i] = Z[sqrt(-1)].
 *
 * Seven relationship detectors:
 *   1. Unit orbits (+/- i^k associates, 4-element group)
 *   2. Sign pattern distance (ternary Hamming, 2 components)
 *   3. Sum zero-component count (cancellation structure)
 *   4. Norm classes (a^2 + b^2 grouping, integer-valued)
 *   5. Product structure (real/pure-imaginary products)
 *   6. Galois orbit membership (conjugation: a+bi -> a-bi)
 *   7. Axis agreement (real vs imaginary axis)
 *
 * Parallel to raqiya.h (Z[zeta_8]) -- same architecture, simpler ring.
 *
 * C89, zero dependencies beyond stdlib.h/string.h.
 */

#ifndef GAUSS_H
#define GAUSS_H

#include <stdlib.h>
#include <string.h>

/* ================================================================
 * Gauss_Z -- Exact arithmetic in Z[i]
 *
 * Basis: {1, i} with i^2 = -1.
 * Components: a + b*i
 * ================================================================ */

typedef struct {
    long a, b;
} Gauss_Z;

static Gauss_Z gauss_make(long a, long b) {
    Gauss_Z z; z.a = a; z.b = b; return z;
}

static Gauss_Z gauss_zero(void) { return gauss_make(0, 0); }
static Gauss_Z gauss_one(void)  { return gauss_make(1, 0); }

static Gauss_Z gauss_add(Gauss_Z x, Gauss_Z y) {
    return gauss_make(x.a + y.a, x.b + y.b);
}

static Gauss_Z gauss_neg(Gauss_Z x) {
    return gauss_make(-x.a, -x.b);
}

static Gauss_Z gauss_sub(Gauss_Z x, Gauss_Z y) {
    return gauss_add(x, gauss_neg(y));
}

/* Multiplication in Z[i]: (a+bi)(c+di) = (ac-bd) + (ad+bc)i */
static Gauss_Z gauss_mul(Gauss_Z x, Gauss_Z y) {
    return gauss_make(
        x.a * y.a - x.b * y.b,
        x.a * y.b + x.b * y.a
    );
}

static int gauss_eq(Gauss_Z x, Gauss_Z y) {
    return x.a == y.a && x.b == y.b;
}

static int gauss_is_zero(Gauss_Z x) {
    return x.a == 0 && x.b == 0;
}

/* Complex conjugation: a+bi -> a-bi */
static Gauss_Z gauss_conj(Gauss_Z z) {
    return gauss_make(z.a, -z.b);
}

/* Norm: a^2 + b^2 (integer-valued, always non-negative) */
static long gauss_norm(Gauss_Z z) {
    return z.a * z.a + z.b * z.b;
}

/* Multiply by i: (a,b) -> (-b, a)
 * i * (a+bi) = ai + bi^2 = -b + ai
 */
static Gauss_Z gauss_mul_i(Gauss_Z z) {
    return gauss_make(-z.b, z.a);
}

/* Galois automorphism: only one nontrivial, which is conjugation.
 * Gal(Q(i)/Q) = Z/2, generated by complex conjugation.
 */
/* (gauss_conj already defined above) */

/* Count zero components (0-2) */
static int gauss_zero_count(Gauss_Z z) {
    int cnt = 0;
    if (z.a == 0) cnt++;
    if (z.b == 0) cnt++;
    return cnt;
}

/* Sign distance (ternary Hamming on sign vectors, 2 components) */
static int gauss_sign_distance(Gauss_Z x, Gauss_Z y) {
    int d = 0;
    int sx_a = (x.a > 0 ? 2 : (x.a < 0 ? 0 : 1));
    int sy_a = (y.a > 0 ? 2 : (y.a < 0 ? 0 : 1));
    int sx_b = (x.b > 0 ? 2 : (x.b < 0 ? 0 : 1));
    int sy_b = (y.b > 0 ? 2 : (y.b < 0 ? 0 : 1));
    if (sx_a != sy_a) d++;
    if (sx_b != sy_b) d++;
    return d;
}

/* Ternary sign pattern as integer in [0, 8] (base-3 encoding, 2 digits) */
static int gauss_sign_pattern(Gauss_Z z) {
    int sa = (z.a > 0 ? 2 : (z.a < 0 ? 0 : 1));
    int sb = (z.b > 0 ? 2 : (z.b < 0 ? 0 : 1));
    return sa * 3 + sb;
}

/* Axis identification.
 * Returns: 0=real axis (b==0), 1=imaginary axis (a==0),
 *          -1=zero, -2=off-axis (both nonzero).
 */
static int gauss_axis(Gauss_Z z) {
    if (z.a == 0 && z.b == 0) return -1;
    if (z.b == 0) return 0;  /* real */
    if (z.a == 0) return 1;  /* imaginary */
    return -2;               /* off-axis */
}

/* Coefficient for axis-aligned values.
 * Returns the nonzero component, 0 for zero.
 */
static long gauss_coeff(Gauss_Z z) {
    if (z.a != 0) return z.a;
    if (z.b != 0) return z.b;
    return 0;
}

/* 2-adic valuation of an integer */
static int gauss_int_2adic_val(long n) {
    int v = 0;
    if (n == 0) return -1;
    if (n < 0) n = -n;
    while (n % 2 == 0) { v++; n /= 2; }
    return v;
}

/* Gaussian norm 2-adic valuation: v_2(a^2+b^2) */
static int gauss_norm_2adic_val(Gauss_Z z) {
    long n = gauss_norm(z);
    return gauss_int_2adic_val(n);
}

/* Hash a Gauss_Z value */
static unsigned long gauss_hash(Gauss_Z z) {
    unsigned long h = 5381;
    h = h * 31 + (unsigned long)(z.a + 1000000);
    h = h * 31 + (unsigned long)(z.b + 1000000);
    return h;
}

/* ================================================================
 * Gauss_ValueSet -- Hash-based distinct value collection
 * ================================================================ */

typedef struct {
    Gauss_Z *values;
    int count;
    int capacity;
    int *hash_head;
    int *hash_next;
    int hash_size;
} Gauss_ValueSet;

static void gauss_vs_init(Gauss_ValueSet *vs, int capacity) {
    int i;
    int primes[] = {127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749};
    int n_primes = 9;
    vs->hash_size = primes[n_primes - 1];
    for (i = 0; i < n_primes; i++) {
        if (primes[i] > 2 * capacity) {
            vs->hash_size = primes[i];
            break;
        }
    }
    vs->capacity = capacity;
    vs->count = 0;
    vs->values = (Gauss_Z *)calloc((size_t)capacity, sizeof(Gauss_Z));
    vs->hash_head = (int *)malloc((size_t)vs->hash_size * sizeof(int));
    vs->hash_next = (int *)malloc((size_t)capacity * sizeof(int));
    for (i = 0; i < vs->hash_size; i++) vs->hash_head[i] = -1;
    for (i = 0; i < capacity; i++) vs->hash_next[i] = -1;
}

static void gauss_vs_free(Gauss_ValueSet *vs) {
    free(vs->values);
    free(vs->hash_head);
    free(vs->hash_next);
    vs->values = NULL;
    vs->count = 0;
}

static int gauss_vs_find(const Gauss_ValueSet *vs, Gauss_Z z) {
    int bucket = (int)(gauss_hash(z) % (unsigned long)vs->hash_size);
    int idx = vs->hash_head[bucket];
    while (idx >= 0) {
        if (gauss_eq(vs->values[idx], z)) return idx;
        idx = vs->hash_next[idx];
    }
    return -1;
}

static int gauss_vs_insert(Gauss_ValueSet *vs, Gauss_Z z) {
    int bucket, idx;
    idx = gauss_vs_find(vs, z);
    if (idx >= 0) return idx;
    if (vs->count >= vs->capacity) return -1;
    bucket = (int)(gauss_hash(z) % (unsigned long)vs->hash_size);
    idx = vs->count;
    vs->values[idx] = z;
    vs->hash_next[idx] = vs->hash_head[bucket];
    vs->hash_head[bucket] = idx;
    vs->count++;
    return idx;
}

/* ================================================================
 * Partition and PairHist -- reuse raqiya types or define own
 *
 * These are type-agnostic. We define our own copies here so
 * gauss.h is standalone, but they are structurally identical
 * to Raq_Partition / Raq_PairHist.
 * ================================================================ */

typedef struct {
    int *group_id;
    int *group_sizes;
    int n_groups;
    int n_values;
} Gauss_Partition;

static void gauss_partition_free(Gauss_Partition *p) {
    free(p->group_id);
    free(p->group_sizes);
    p->group_id = NULL;
    p->group_sizes = NULL;
}

static int gauss_partition_related_pairs(const Gauss_Partition *p) {
    int count = 0, i;
    for (i = 0; i < p->n_groups; i++)
        count += p->group_sizes[i] * (p->group_sizes[i] - 1) / 2;
    return count;
}

static int gauss_partition_refines(const Gauss_Partition *a,
                                    const Gauss_Partition *b) {
    int ga, i;
    if (a->n_values != b->n_values) return 0;
    for (ga = 0; ga < a->n_groups; ga++) {
        int first_b = -1;
        for (i = 0; i < a->n_values; i++) {
            if (a->group_id[i] != ga) continue;
            if (first_b == -1)
                first_b = b->group_id[i];
            else if (b->group_id[i] != first_b)
                return 0;
        }
    }
    return 1;
}

static int gauss_partition_equal(const Gauss_Partition *a,
                                  const Gauss_Partition *b) {
    return gauss_partition_refines(a, b) && gauss_partition_refines(b, a);
}

typedef struct {
    int bins[3];  /* distance 0, 1, 2 (only 2 components) */
    int n_pairs;
    long total;
} Gauss_PairHist;

/* ================================================================
 * Detector 1: Unit Orbits
 *
 * Units of Z[i] are {1, i, -1, -i}.
 * Groups values by y = i^k * x for k in {0,1,2,3}.
 * Max orbit size = 4 (but can be 1 or 2 for special values).
 * ================================================================ */

static Gauss_Partition gauss_detect_unit_orbits(const Gauss_Z *values, int n) {
    Gauss_Partition p;
    int oi, oj, k;

    p.n_values = n;
    p.n_groups = 0;
    p.group_id = (int *)calloc((size_t)n, sizeof(int));
    p.group_sizes = (int *)calloc((size_t)n, sizeof(int));
    for (oi = 0; oi < n; oi++) p.group_id[oi] = -1;

    for (oi = 0; oi < n; oi++) {
        Gauss_Z rotated;
        if (p.group_id[oi] >= 0) continue;
        p.group_id[oi] = p.n_groups;

        rotated = values[oi];
        for (k = 0; k < 4; k++) {
            for (oj = oi + 1; oj < n; oj++) {
                if (p.group_id[oj] >= 0) continue;
                if (gauss_eq(values[oj], rotated))
                    p.group_id[oj] = p.n_groups;
            }
            rotated = gauss_mul_i(rotated);
        }
        p.n_groups++;
    }

    for (oi = 0; oi < n; oi++)
        p.group_sizes[p.group_id[oi]]++;

    return p;
}

/* ================================================================
 * Detector 2: Sign Pattern Distance
 * ================================================================ */

static Gauss_PairHist gauss_detect_sign_distances(const Gauss_Z *values,
                                                    int n) {
    Gauss_PairHist h;
    int oi, oj;

    memset(&h, 0, sizeof(h));
    h.n_pairs = n * (n - 1) / 2;

    for (oi = 0; oi < n; oi++)
        for (oj = oi + 1; oj < n; oj++) {
            int d = gauss_sign_distance(values[oi], values[oj]);
            h.bins[d]++;
            h.total += d;
        }

    return h;
}

static int gauss_count_sign_patterns(const Gauss_Z *values, int n) {
    int seen[9]; /* 3^2 = 9 possible patterns */
    int count = 0, i;

    memset(seen, 0, sizeof(seen));
    for (i = 0; i < n; i++) {
        int pat = gauss_sign_pattern(values[i]);
        seen[pat] = 1;
    }
    for (i = 0; i < 9; i++)
        if (seen[i]) count++;
    return count;
}

/* ================================================================
 * Detector 3: Sum/Difference Zero-Component Count
 * ================================================================ */

static Gauss_PairHist gauss_detect_sum_zeros(const Gauss_Z *values, int n) {
    Gauss_PairHist h;
    int oi, oj;

    memset(&h, 0, sizeof(h));
    h.n_pairs = n * (n - 1) / 2;

    for (oi = 0; oi < n; oi++)
        for (oj = oi + 1; oj < n; oj++) {
            Gauss_Z s = gauss_add(values[oi], values[oj]);
            int zc = gauss_zero_count(s);
            h.bins[zc]++;
            h.total += zc;
        }

    return h;
}

static Gauss_PairHist gauss_detect_diff_zeros(const Gauss_Z *values, int n) {
    Gauss_PairHist h;
    int oi, oj;

    memset(&h, 0, sizeof(h));
    h.n_pairs = n * (n - 1) / 2;

    for (oi = 0; oi < n; oi++)
        for (oj = oi + 1; oj < n; oj++) {
            Gauss_Z d = gauss_sub(values[oi], values[oj]);
            int zc = gauss_zero_count(d);
            h.bins[zc]++;
            h.total += zc;
        }

    return h;
}

static int gauss_count_neg_pairs(const Gauss_Z *values, int n) {
    int count = 0, oi, oj;
    for (oi = 0; oi < n; oi++)
        for (oj = oi + 1; oj < n; oj++)
            if (gauss_is_zero(gauss_add(values[oi], values[oj])))
                count++;
    return count;
}

/* ================================================================
 * Detector 4: Norm Classes
 *
 * Norm N(a+bi) = a^2 + b^2. Integer-valued (simpler than Z[zeta_8]
 * where norm lives in Z[sqrt(2)]).
 * ================================================================ */

static Gauss_Partition gauss_detect_norm_classes(const Gauss_Z *values, int n) {
    Gauss_Partition p;
    long *norms;
    int i, j;

    p.n_values = n;
    p.n_groups = 0;
    p.group_id = (int *)calloc((size_t)n, sizeof(int));
    p.group_sizes = (int *)calloc((size_t)n, sizeof(int));
    norms = (long *)calloc((size_t)n, sizeof(long));

    for (i = 0; i < n; i++) {
        norms[i] = gauss_norm(values[i]);
        p.group_id[i] = -1;
    }

    for (i = 0; i < n; i++) {
        if (p.group_id[i] >= 0) continue;
        p.group_id[i] = p.n_groups;
        for (j = i + 1; j < n; j++) {
            if (p.group_id[j] >= 0) continue;
            if (norms[i] == norms[j])
                p.group_id[j] = p.n_groups;
        }
        p.n_groups++;
    }

    for (i = 0; i < n; i++)
        p.group_sizes[p.group_id[i]]++;

    free(norms);
    return p;
}

/* ================================================================
 * Detector 5: Product Structure
 * ================================================================ */

typedef struct {
    Gauss_PairHist zero_components;
    int n_real;   /* products with b=0 (real) */
    int n_imag;   /* products with a=0 (pure imaginary) */
} Gauss_ProductResult;

static Gauss_ProductResult gauss_detect_products(const Gauss_Z *values, int n) {
    Gauss_ProductResult r;
    int oi, oj;

    memset(&r, 0, sizeof(r));
    r.zero_components.n_pairs = n * (n - 1) / 2;

    for (oi = 0; oi < n; oi++)
        for (oj = oi + 1; oj < n; oj++) {
            Gauss_Z p = gauss_mul(values[oi], values[oj]);
            int zc = gauss_zero_count(p);
            r.zero_components.bins[zc]++;
            r.zero_components.total += zc;
            if (p.b == 0) r.n_real++;
            if (p.a == 0) r.n_imag++;
        }

    return r;
}

/* ================================================================
 * Detector 6: Galois Orbit Membership
 *
 * Gal(Q(i)/Q) = Z/2: identity and conjugation (a+bi -> a-bi).
 * Orbits are either singletons (real values, a+0i) or pairs.
 * ================================================================ */

static Gauss_Partition gauss_detect_galois_orbits(const Gauss_Z *values,
                                                    int n) {
    Gauss_Partition p;
    int i, oi, oj;

    p.n_values = n;
    p.n_groups = 0;
    p.group_id = (int *)calloc((size_t)n, sizeof(int));
    p.group_sizes = (int *)calloc((size_t)n, sizeof(int));
    for (i = 0; i < n; i++) p.group_id[i] = -1;

    for (oi = 0; oi < n; oi++) {
        Gauss_Z conj;
        if (p.group_id[oi] >= 0) continue;
        p.group_id[oi] = p.n_groups;

        conj = gauss_conj(values[oi]);
        for (oj = oi + 1; oj < n; oj++) {
            if (p.group_id[oj] >= 0) continue;
            if (gauss_eq(values[oj], conj))
                p.group_id[oj] = p.n_groups;
        }
        p.n_groups++;
    }

    for (i = 0; i < n; i++)
        p.group_sizes[p.group_id[i]]++;

    return p;
}

/* ================================================================
 * Detector 7: Axis Agreement
 *
 * Partitions values by which axis they live on:
 *   Group for real axis (b=0), imaginary axis (a=0), zero, off-axis.
 * ================================================================ */

static Gauss_Partition gauss_detect_axis_classes(const Gauss_Z *values, int n) {
    Gauss_Partition p;
    int i;
    /* slots: 0=real, 1=imag, 2=zero, 3=off-axis */
    int slot_to_group[4];
    int slot_used[4];

    p.n_values = n;
    p.n_groups = 0;
    p.group_id = (int *)calloc((size_t)n, sizeof(int));
    p.group_sizes = (int *)calloc((size_t)n, sizeof(int));

    memset(slot_used, 0, sizeof(slot_used));
    for (i = 0; i < 4; i++) slot_to_group[i] = -1;

    for (i = 0; i < n; i++) {
        int ax = gauss_axis(values[i]);
        int slot;
        if (ax >= 0)       slot = ax;   /* 0=real, 1=imag */
        else if (ax == -1) slot = 2;    /* zero */
        else               slot = 3;    /* off-axis */
        slot_used[slot] = 1;
    }

    for (i = 0; i < 4; i++) {
        if (slot_used[i])
            slot_to_group[i] = p.n_groups++;
    }

    for (i = 0; i < n; i++) {
        int ax = gauss_axis(values[i]);
        int slot;
        if (ax >= 0)       slot = ax;
        else if (ax == -1) slot = 2;
        else               slot = 3;
        p.group_id[i] = slot_to_group[slot];
        p.group_sizes[slot_to_group[slot]]++;
    }

    return p;
}

/* ================================================================
 * Divisibility (same-axis integer divisibility)
 * ================================================================ */

typedef struct {
    int n_divides;
    int n_same_axis;
    int n_values;
} Gauss_DivisResult;

static Gauss_DivisResult gauss_detect_divisibility(const Gauss_Z *values,
                                                     int n) {
    Gauss_DivisResult r;
    int i, j;

    r.n_values = n;
    r.n_divides = 0;
    r.n_same_axis = 0;

    for (i = 0; i < n; i++) {
        int ax_i = gauss_axis(values[i]);
        long c_i = gauss_coeff(values[i]);

        for (j = i + 1; j < n; j++) {
            int ax_j = gauss_axis(values[j]);
            long c_j = gauss_coeff(values[j]);

            if (ax_i == -1 && ax_j == -1) {
                r.n_same_axis++;
                r.n_divides += 2;
                continue;
            }
            if (ax_j == -1) { r.n_divides++; continue; }
            if (ax_i == -1) { r.n_divides++; continue; }
            if (ax_i < 0 || ax_j < 0) continue;
            if (ax_i != ax_j) continue;

            r.n_same_axis++;
            if (c_i != 0 && c_j % c_i == 0) r.n_divides++;
            if (c_j != 0 && c_i % c_j == 0) r.n_divides++;
        }
    }

    return r;
}

/* ================================================================
 * 2-Adic Valuation Classes (on the norm)
 * ================================================================ */

static Gauss_Partition gauss_detect_norm_2adic_classes(const Gauss_Z *values,
                                                        int n) {
    Gauss_Partition p;
    int *vals;
    int i, j;

    p.n_values = n;
    p.n_groups = 0;
    p.group_id = (int *)calloc((size_t)n, sizeof(int));
    p.group_sizes = (int *)calloc((size_t)n, sizeof(int));
    vals = (int *)calloc((size_t)n, sizeof(int));

    for (i = 0; i < n; i++) {
        vals[i] = gauss_norm_2adic_val(values[i]);
        p.group_id[i] = -1;
    }

    for (i = 0; i < n; i++) {
        if (p.group_id[i] >= 0) continue;
        p.group_id[i] = p.n_groups;
        for (j = i + 1; j < n; j++) {
            if (p.group_id[j] >= 0) continue;
            if (vals[i] == vals[j])
                p.group_id[j] = p.n_groups;
        }
        p.n_groups++;
    }

    for (i = 0; i < n; i++)
        p.group_sizes[p.group_id[i]]++;

    free(vals);
    return p;
}

/* ================================================================
 * Full Analysis
 * ================================================================ */

typedef struct {
    int n_values;
    Gauss_Partition unit_orbits;
    Gauss_Partition norm_classes;
    Gauss_Partition galois_orbits;
    Gauss_Partition axis_classes;
    Gauss_Partition norm_2adic_classes;
    Gauss_DivisResult divisibility;
    Gauss_PairHist sign_distances;
    Gauss_PairHist sum_zeros;
    Gauss_PairHist diff_zeros;
    Gauss_ProductResult products;
    int n_sign_patterns;
    int n_neg_pairs;
} Gauss_Analysis;

static Gauss_Analysis gauss_analyze(const Gauss_Z *values, int n) {
    Gauss_Analysis a;
    a.n_values = n;
    a.unit_orbits = gauss_detect_unit_orbits(values, n);
    a.norm_classes = gauss_detect_norm_classes(values, n);
    a.galois_orbits = gauss_detect_galois_orbits(values, n);
    a.axis_classes = gauss_detect_axis_classes(values, n);
    a.norm_2adic_classes = gauss_detect_norm_2adic_classes(values, n);
    a.divisibility = gauss_detect_divisibility(values, n);
    a.sign_distances = gauss_detect_sign_distances(values, n);
    a.sum_zeros = gauss_detect_sum_zeros(values, n);
    a.diff_zeros = gauss_detect_diff_zeros(values, n);
    a.products = gauss_detect_products(values, n);
    a.n_sign_patterns = gauss_count_sign_patterns(values, n);
    a.n_neg_pairs = gauss_count_neg_pairs(values, n);
    return a;
}

static void gauss_analysis_free(Gauss_Analysis *a) {
    gauss_partition_free(&a->unit_orbits);
    gauss_partition_free(&a->norm_classes);
    gauss_partition_free(&a->galois_orbits);
    gauss_partition_free(&a->axis_classes);
    gauss_partition_free(&a->norm_2adic_classes);
}

/* ================================================================
 * Print layer (optional, requires stdio.h before include)
 * ================================================================ */

#ifdef GAUSS_PRINT

static void gauss_print_z(Gauss_Z z) {
    if (z.b == 0) {
        printf("%ld", z.a);
    } else if (z.a == 0) {
        if (z.b == 1) printf("i");
        else if (z.b == -1) printf("-i");
        else printf("%ldi", z.b);
    } else {
        if (z.b == 1) printf("%ld+i", z.a);
        else if (z.b == -1) printf("%ld-i", z.a);
        else if (z.b > 0) printf("%ld+%ldi", z.a, z.b);
        else printf("%ld%ldi", z.a, z.b);
    }
}

static void gauss_print_partition(const char *titulis,
                                   const Gauss_Partition *p,
                                   const Gauss_Z *values) {
    int g, i;
    printf("  %s: %d groups\n", titulis, p->n_groups);
    for (g = 0; g < p->n_groups; g++) {
        printf("    [%d] (size %d):", g, p->group_sizes[g]);
        for (i = 0; i < p->n_values; i++) {
            if (p->group_id[i] != g) continue;
            printf(" ");
            gauss_print_z(values[i]);
        }
        printf("\n");
    }
}

static void gauss_print_pair_hist(const char *titulis,
                                   const Gauss_PairHist *h) {
    int i;
    printf("  %s: %d pairs, total=%ld\n", titulis, h->n_pairs, h->total);
    printf("    bins:");
    for (i = 0; i < 3; i++) printf(" [%d]=%d", i, h->bins[i]);
    printf("\n");
}

static void gauss_print_analysis(const Gauss_Analysis *a,
                                  const Gauss_Z *values) {
    printf("=== Gauss Z[i] Analysis (%d values) ===\n", a->n_values);

    gauss_print_partition("Unit orbits", &a->unit_orbits, values);
    gauss_print_partition("Norm classes", &a->norm_classes, values);
    gauss_print_partition("Galois orbits", &a->galois_orbits, values);
    gauss_print_partition("Axis classes", &a->axis_classes, values);
    gauss_print_partition("Norm 2-adic", &a->norm_2adic_classes, values);

    printf("  Divisibility: %d divides, %d same-axis pairs\n",
           a->divisibility.n_divides, a->divisibility.n_same_axis);

    gauss_print_pair_hist("Sign distances", &a->sign_distances);
    gauss_print_pair_hist("Sum zeros", &a->sum_zeros);
    gauss_print_pair_hist("Diff zeros", &a->diff_zeros);

    printf("  Products: %d real, %d imag\n",
           a->products.n_real, a->products.n_imag);
    printf("  Sign patterns: %d distinct\n", a->n_sign_patterns);
    printf("  Neg pairs: %d\n", a->n_neg_pairs);
}

#endif /* GAUSS_PRINT */

#endif /* GAUSS_H */

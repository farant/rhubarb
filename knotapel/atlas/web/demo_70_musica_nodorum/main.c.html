<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>demo_70_musica_nodorum/main.c</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <nav><a href="../index.html">‚Üê Back to Index</a></nav><hr>
    <h1>demo_70_musica_nodorum/main.c</h1><pre><code class="language-c">/*
 * KNOTAPEL DEMO 70: Musica Nodorum -- Knots as Sound
 * ===================================================
 *
 * Maps knot invariants to musical structures:
 * eigenvalue angles -&gt; intervals, braid words -&gt; melodies,
 * eigenvector directions -&gt; spatial sound,
 * dodecahedron -&gt; circle of fifths.
 *
 * Part A: Eigenvalue-to-interval mapping
 * Part B: Braid word as melody
 * Part C: Eigenvector direction as stereo position
 * Part D: Harmonic distance metric
 * Part E: Dodecahedral connection
 * Part F: Musical output format
 *
 * C89, zero dependencies beyond math.h.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

/* ================================================================
 * Test infrastructure
 * ================================================================ */

static int g_pass = 0, g_fail = 0;

static void check(const char *t, int ok) {
    if (ok) { printf("  PASS: %s\n", t); g_pass++; }
    else    { printf("  FAIL: %s\n", t); g_fail++; }
}

/* ================================================================
 * Quaternion
 * ================================================================ */

typedef struct { double a, b, c, d; } Quat;

static Quat qm(double a, double b, double c, double d) {
    Quat q; q.a=a; q.b=b; q.c=c; q.d=d; return q;
}
static Quat qadd(Quat p, Quat q) {
    return qm(p.a+q.a, p.b+q.b, p.c+q.c, p.d+q.d);
}
static Quat qneg(Quat q) { return qm(-q.a,-q.b,-q.c,-q.d); }
static Quat qmul(Quat p, Quat q) {
    return qm(p.a*q.a-p.b*q.b-p.c*q.c-p.d*q.d,
              p.a*q.b+p.b*q.a+p.c*q.d-p.d*q.c,
              p.a*q.c-p.b*q.d+p.c*q.a+p.d*q.b,
              p.a*q.d+p.b*q.c-p.c*q.b+p.d*q.a);
}
static Quat qconj(Quat q) { return qm(q.a,-q.b,-q.c,-q.d); }
static double qnorm(Quat q) {
    return sqrt(q.a*q.a+q.b*q.b+q.c*q.c+q.d*q.d);
}
static Quat qnormalize(Quat q) {
    double n = qnorm(q);
    if (n &lt; 1e-15) return qm(0,0,0,0);
    return qm(q.a/n, q.b/n, q.c/n, q.d/n);
}

/* ================================================================
 * Eigenvector extraction
 * ================================================================ */

typedef struct {
    double theta, ax, ay, az;
    int axis_ok;
} Eigen;

static Eigen to_eigen(Quat q) {
    Eigen e;
    double nv;
    if (q.a &lt; 0) { q.a=-q.a; q.b=-q.b; q.c=-q.c; q.d=-q.d; }
    if (q.a &gt; 1.0) q.a = 1.0;
    e.theta = acos(q.a);
    nv = sqrt(q.b*q.b+q.c*q.c+q.d*q.d);
    if (nv &lt; 1e-12) { e.ax=0; e.ay=0; e.az=1; e.axis_ok=0; }
    else { e.ax=q.b/nv; e.ay=q.c/nv; e.az=q.d/nv; e.axis_ok=1; }
    return e;
}

/* ================================================================
 * Musical mapping
 * ================================================================ */

static double angle_to_cents(double theta) {
    return theta / M_PI * 1200.0;
}

static int cents_to_midi(double cents, int base) {
    return base + (int)(cents / 100.0 + 0.5);
}

static const char *g_nn[12] = {
    "C","C#","D","Eb","E","F","F#","G","Ab","A","Bb","B"
};

static const char *note_nm(int midi) {
    int pc = midi % 12;
    if (pc &lt; 0) pc += 12;
    return g_nn[pc];
}

static int note_oct(int midi) { return midi / 12 - 1; }

static const char *interval_nm(double cents) {
    int i, best = 0;
    double bd = 9999.0;
    static const double ic[13] = {0,100,200,300,400,500,600,
                                   700,800,900,1000,1100,1200};
    static const char *in[13] = {"unison","m2","M2","m3","M3","P4",
                                  "tritone","P5","m6","M6","m7","M7","P8"};
    for (i = 0; i &lt; 13; i++) {
        double d = fabs(cents - ic[i]);
        if (d &lt; bd) { bd=d; best=i; }
    }
    return in[best];
}

/* ================================================================
 * Braid generators (zeta_8: theta = pi/4)
 * ================================================================ */

static Quat g_s1, g_s2;

static void init_gens(void) {
    double c = cos(M_PI/4.0), s = sin(M_PI/4.0);
    g_s1 = qm(c, s, 0, 0);
    g_s2 = qm(c, 0, 0, -s);
}

static Quat braid_gen(int g) {
    if (g == 1)  return g_s1;
    if (g == 2)  return g_s2;
    if (g == -1) return qconj(g_s1);
    return qconj(g_s2);
}

/* ================================================================
 * Quaternion catalog
 * ================================================================ */

#define MAXQ 512
#define MAXD 64

static Quat g_cat[MAXQ];
static Eigen g_eig[MAXQ];
static int g_nq = 0;

static double g_dir[MAXD][3];
static int g_nd = 0;

static int find_q(Quat q) {
    int i;
    for (i = 0; i &lt; g_nq; i++) {
        double d1 = fabs(g_cat[i].a-q.a)+fabs(g_cat[i].b-q.b)+
                     fabs(g_cat[i].c-q.c)+fabs(g_cat[i].d-q.d);
        double d2 = fabs(g_cat[i].a+q.a)+fabs(g_cat[i].b+q.b)+
                     fabs(g_cat[i].c+q.c)+fabs(g_cat[i].d+q.d);
        if (d1 &lt; 1e-10 || d2 &lt; 1e-10) return i;
    }
    return -1;
}

static int find_d(double x, double y, double z) {
    int i;
    for (i = 0; i &lt; g_nd; i++) {
        double d1 = fabs(g_dir[i][0]-x)+fabs(g_dir[i][1]-y)+fabs(g_dir[i][2]-z);
        double d2 = fabs(g_dir[i][0]+x)+fabs(g_dir[i][1]+y)+fabs(g_dir[i][2]+z);
        if (d1 &lt; 1e-8 || d2 &lt; 1e-8) return i;
    }
    return -1;
}

static void build_cat(void) {
    int n, len, w[32], i;
    g_nq = 0; g_nd = 0;
    for (n = 2; n &lt;= 3; n++) {
        int mg = n-1, tg = 2*mg;
        for (len = 1; len &lt;= 8; len++) {
            unsigned long total = 1, idx;
            for (i = 0; i &lt; len; i++) {
                total *= (unsigned long)tg;
                if (total &gt; 100000) break;
            }
            if (total &gt; 100000) continue;
            for (idx = 0; idx &lt; total; idx++) {
                unsigned long tmp = idx;
                Quat q = qm(1,0,0,0);
                for (i = 0; i &lt; len; i++) {
                    int g = (int)(tmp % (unsigned long)tg);
                    tmp /= (unsigned long)tg;
                    w[i] = g &lt; mg ? g+1 : -(g-mg+1);
                }
                for (i = 0; i &lt; len; i++) q = qmul(q, braid_gen(w[i]));
                if (find_q(q) &lt; 0 &amp;&amp; g_nq &lt; MAXQ)
                    g_cat[g_nq++] = q;
            }
        }
    }
    /* Extract eigenvectors and directions */
    for (i = 0; i &lt; g_nq; i++) {
        g_eig[i] = to_eigen(g_cat[i]);
        if (g_eig[i].axis_ok &amp;&amp;
            find_d(g_eig[i].ax, g_eig[i].ay, g_eig[i].az) &lt; 0 &amp;&amp;
            g_nd &lt; MAXD) {
            g_dir[g_nd][0] = g_eig[i].ax;
            g_dir[g_nd][1] = g_eig[i].ay;
            g_dir[g_nd][2] = g_eig[i].az;
            g_nd++;
        }
    }
}

/* ================================================================
 * Angle catalog
 * ================================================================ */

#define MAXA 16
static double g_ang[MAXA];
static int g_na = 0;

static void build_angles(void) {
    int i, j;
    g_na = 0;
    for (i = 0; i &lt; g_nq; i++) {
        int found = 0;
        for (j = 0; j &lt; g_na; j++)
            if (fabs(g_eig[i].theta - g_ang[j]) &lt; 1e-8) { found=1; break; }
        if (!found &amp;&amp; g_na &lt; MAXA) g_ang[g_na++] = g_eig[i].theta;
    }
    for (i = 0; i &lt; g_na-1; i++)
        for (j = i+1; j &lt; g_na; j++)
            if (g_ang[i] &gt; g_ang[j]) {
                double t = g_ang[i]; g_ang[i]=g_ang[j]; g_ang[j]=t;
            }
}

/* ================================================================
 * Polyhedra: icosahedron (12) and dodecahedron (20)
 * ================================================================ */

#define NICO 12
#define NDOD 20

static double g_ico[NICO][3];
static double g_dod[NDOD][3];

static void norm3(double *v) {
    double n = sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
    if (n &gt; 1e-15) { v[0]/=n; v[1]/=n; v[2]/=n; }
}

static void init_poly(void) {
    double phi = (1.0+sqrt(5.0))/2.0;
    double ip = 1.0/phi;
    int k=0, j=0, sa, sb;
    int s0, s1, s2;

    /* Icosahedron: (0,+-1,+-phi), (+-1,+-phi,0), (+-phi,0,+-1) */
    for (sa=-1; sa&lt;=1; sa+=2) for (sb=-1; sb&lt;=1; sb+=2) {
        g_ico[k][0]=0; g_ico[k][1]=(double)sa; g_ico[k][2]=(double)sb*phi;
        norm3(g_ico[k]); k++;
    }
    for (sa=-1; sa&lt;=1; sa+=2) for (sb=-1; sb&lt;=1; sb+=2) {
        g_ico[k][0]=(double)sa; g_ico[k][1]=(double)sb*phi; g_ico[k][2]=0;
        norm3(g_ico[k]); k++;
    }
    for (sa=-1; sa&lt;=1; sa+=2) for (sb=-1; sb&lt;=1; sb+=2) {
        g_ico[k][0]=(double)sa*phi; g_ico[k][1]=0; g_ico[k][2]=(double)sb;
        norm3(g_ico[k]); k++;
    }

    /* Dodecahedron: (+-1,+-1,+-1), (0,+-phi,+-1/phi),
       (+-1/phi,0,+-phi), (+-phi,+-1/phi,0) */
    for (s0=-1; s0&lt;=1; s0+=2)
        for (s1=-1; s1&lt;=1; s1+=2)
            for (s2=-1; s2&lt;=1; s2+=2) {
                g_dod[j][0]=(double)s0; g_dod[j][1]=(double)s1;
                g_dod[j][2]=(double)s2;
                norm3(g_dod[j]); j++;
            }
    for (sa=-1; sa&lt;=1; sa+=2) for (sb=-1; sb&lt;=1; sb+=2) {
        g_dod[j][0]=0; g_dod[j][1]=(double)sa*phi; g_dod[j][2]=(double)sb*ip;
        norm3(g_dod[j]); j++;
    }
    for (sa=-1; sa&lt;=1; sa+=2) for (sb=-1; sb&lt;=1; sb+=2) {
        g_dod[j][0]=(double)sa*ip; g_dod[j][1]=0; g_dod[j][2]=(double)sb*phi;
        norm3(g_dod[j]); j++;
    }
    for (sa=-1; sa&lt;=1; sa+=2) for (sb=-1; sb&lt;=1; sb+=2) {
        g_dod[j][0]=(double)sa*phi; g_dod[j][1]=(double)sb*ip; g_dod[j][2]=0;
        norm3(g_dod[j]); j++;
    }
}

/* Circle of fifths */
static const char *g_cof[12] = {
    "C","G","D","A","E","B","F#","Db","Ab","Eb","Bb","F"
};

/* ================================================================
 * Voronoi cell assignment (undirected axes, fabs)
 * ================================================================ */

static int vor_cell(double ax, double ay, double az,
                    const double c[][3], int nc) {
    int i, best=0;
    double bd=-2.0;
    for (i=0; i&lt;nc; i++) {
        double d = fabs(ax*c[i][0]+ay*c[i][1]+az*c[i][2]);
        if (d &gt; bd) { bd=d; best=i; }
    }
    return best;
}

/* ================================================================
 * XOR6 checker
 * ================================================================ */

static int xor6_check(const Quat *w, const double c[][3], int nc) {
    int seen[256];
    int mask, i, cell;
    for (i=0; i&lt;=nc; i++) seen[i]=0;
    for (mask=0; mask&lt;64; mask++) {
        Quat sum = qm(0,0,0,0);
        int par = 0;
        Eigen ed;
        for (i=0; i&lt;6; i++)
            if (mask &amp; (1&lt;&lt;i)) { sum=qadd(sum,w[i]); par^=1; }
        if (qnorm(sum) &lt; 1e-12) cell=nc;
        else {
            sum=qnormalize(sum);
            ed=to_eigen(sum);
            cell = ed.axis_ok ? vor_cell(ed.ax,ed.ay,ed.az,c,nc) : nc;
        }
        seen[cell] |= (1&lt;&lt;par);
        if (seen[cell]==3) return 0;
    }
    return 1;
}

static int count_xor6(const double c[][3], int nc) {
    int ai,aj,ak,count=0;
    for (ai=0; ai&lt;g_nq; ai++)
        for (aj=ai+1; aj&lt;g_nq; aj++)
            for (ak=aj+1; ak&lt;g_nq; ak++) {
                Quat w[6];
                w[0]=g_cat[ai]; w[1]=qneg(g_cat[ai]);
                w[2]=g_cat[aj]; w[3]=qneg(g_cat[aj]);
                w[4]=g_cat[ak]; w[5]=qneg(g_cat[ak]);
                if (xor6_check(w,c,nc)) count++;
            }
    return count;
}

/* ================================================================
 * Part A: Eigenvalue-to-interval mapping
 * ================================================================ */

static void part_a(void) {
    int i, j;
    char msg[256];

    printf("\n=== Part A: Eigenvalue-to-interval mapping ===\n\n");

    printf("  Eigenvalue angles (%d distinct):\n\n", g_na);
    printf("  | # | Angle(deg) | Cents | MIDI | Note | Trace  | Interval |\n");
    printf("  |---|------------|-------|------|------|--------|----------|\n");
    for (i = 0; i &lt; g_na; i++) {
        double deg = g_ang[i] * 180.0 / M_PI;
        double cents = angle_to_cents(g_ang[i]);
        int midi = cents_to_midi(cents, 60);
        double trace = 2.0 * cos(g_ang[i]);
        printf("  | %d | %10.2f | %5.0f | %4d | %-2s%-2d | %6.3f | %-8s |\n",
               i, deg, cents, midi,
               note_nm(midi), note_oct(midi),
               trace, interval_nm(cents));
    }

    printf("\n  Alternative frequency mappings (base = 261.63 Hz = C4):\n");
    for (i = 0; i &lt; g_na; i++) {
        double deg = g_ang[i] * 180.0 / M_PI;
        double trace = 2.0 * cos(g_ang[i]);
        double f_trace = 261.63 * (1.0 + trace / 2.0);
        double f_exp = 261.63 * pow(2.0, g_ang[i] / M_PI);
        printf("    %.0f deg: trace-ratio = %.1f Hz, exponential = %.1f Hz\n",
               deg, f_trace, f_exp);
    }

    printf("\n  Pairwise intervals:\n\n");
    printf("  | Pair        | Delta(cents) | Interval |\n");
    printf("  |-------------|--------------|----------|\n");
    for (i = 0; i &lt; g_na; i++)
        for (j = i+1; j &lt; g_na; j++) {
            double dc = angle_to_cents(g_ang[j]) - angle_to_cents(g_ang[i]);
            printf("  | %3.0f -&gt; %3.0f | %12.0f | %-8s |\n",
                   g_ang[i]*180/M_PI, g_ang[j]*180/M_PI,
                   dc, interval_nm(dc));
        }

    sprintf(msg, "%d eigenvalue angles mapped to intervals", g_na);
    check(msg, g_na &gt;= 3);
}

/* ================================================================
 * Part B: Braid word as melody
 * ================================================================ */

#define NBRAID 15
#define MAXBLEN 12

static const int g_bw[NBRAID][MAXBLEN] = {
    { 1, 1, 1, 0,0,0,0,0,0,0,0,0},
    { 1,-2, 1,-2, 0,0,0,0,0,0,0,0},
    { 1, 1, 1, 1, 1, 0,0,0,0,0,0,0},
    { 1, 2, 1, 2, 1, 2, 0,0,0,0,0,0},
    {-1,-1,-1, 0,0,0,0,0,0,0,0,0},
    { 1, 2,-1,-2, 0,0,0,0,0,0,0,0},
    { 1, 1, 2, 2, 0,0,0,0,0,0,0,0},
    { 2, 1,-2,-1, 0,0,0,0,0,0,0,0},
    { 1,-2, 1,-2, 1,-2, 1,-2, 1,-2},
    { 1, 2, 1, 2, 1, 2, 1, 2, 0,0,0,0},
    { 1, 2, 1, 0,0,0,0,0,0,0,0,0},
    { 2, 1, 2, 0,0,0,0,0,0,0,0,0},
    { 1,-2, 1, 2, 0,0,0,0,0,0,0,0},
    {-1, 2, 1,-2, 1, 0,0,0,0,0,0,0},
    { 2, 2, 2, 0,0,0,0,0,0,0,0,0}
};

static const int g_bl[NBRAID] = {3,4,5,6,3,4,4,4,10,8,3,3,4,5,3};

static const char *g_bn[NBRAID] = {
    "trefoil (s1^3)",
    "figure-8 (s1 s2^-1 s1 s2^-1)",
    "torus(2,5) (s1^5)",
    "Garside (s1 s2)^3",
    "mirror trefoil (s1^-3)",
    "commutator [s1,s2]",
    "s1^2 s2^2",
    "reverse comm [s2,s1]",
    "(s1 s2^-1)^5",
    "alternating (s1 s2)^4",
    "YB-left: s1 s2 s1",
    "YB-right: s2 s1 s2",
    "mixed: s1 s2^-1 s1 s2",
    "varied: s1^-1 s2 s1 s2^-1 s1",
    "s2 trefoil (s2^3)"
};

typedef struct {
    int midi[MAXBLEN];
    int n;
    int distinct;
    double final_theta;
} Melody;

static Melody g_mel[NBRAID];

static void part_b(void) {
    int b, i;
    char msg[256];

    printf("\n=== Part B: Braid word as melody ===\n");

    for (b = 0; b &lt; NBRAID; b++) {
        Quat cur = qm(1,0,0,0);
        int seen_n[128];
        int nd = 0;
        memset(seen_n, 0, sizeof(seen_n));
        g_mel[b].n = g_bl[b];

        printf("\n  [%2d] %s\n       ", b, g_bn[b]);

        for (i = 0; i &lt; g_bl[b]; i++) {
            int g = g_bw[b][i];
            int base = g &gt; 0 ? 60 : 48;
            Eigen ed;
            double cents;
            int midi;

            cur = qmul(cur, braid_gen(g));
            ed = to_eigen(cur);
            cents = angle_to_cents(ed.theta);
            midi = cents_to_midi(cents, base);
            g_mel[b].midi[i] = midi;

            printf("%s%d ", note_nm(midi), note_oct(midi));
            if (midi &gt;= 0 &amp;&amp; midi &lt; 128 &amp;&amp; !seen_n[midi]) {
                seen_n[midi] = 1; nd++;
            }
        }

        g_mel[b].distinct = nd;
        g_mel[b].final_theta = to_eigen(cur).theta;
        printf("\n       MIDI:");
        for (i = 0; i &lt; g_bl[b]; i++) printf(" %d", g_mel[b].midi[i]);
        printf("  (%d distinct)\n", nd);
    }

    /* Yang-Baxter test: s1*s2*s1 vs s2*s1*s2 (braids 10 and 11) */
    {
        double th_l = g_mel[10].final_theta;
        double th_r = g_mel[11].final_theta;
        int same_mel = 1;

        printf("\n  Yang-Baxter test: s1*s2*s1 vs s2*s1*s2\n");
        printf("    Final angle: %.4f vs %.4f deg (diff: %.2e)\n",
               th_l*180/M_PI, th_r*180/M_PI, fabs(th_l-th_r));

        for (i = 0; i &lt; g_bl[10] &amp;&amp; i &lt; g_bl[11]; i++)
            if (g_mel[10].midi[i] != g_mel[11].midi[i]) { same_mel=0; break; }
        printf("    Melodies %s\n",
               same_mel ? "IDENTICAL (trace is conjugation-invariant)"
                        : "differ (different intermediate traces)");

        sprintf(msg, "Yang-Baxter: same final angle (diff=%.1e)",
                fabs(th_l-th_r));
        check(msg, fabs(th_l-th_r) &lt; 1e-10);
    }

    sprintf(msg, "%d braid melodies computed", NBRAID);
    check(msg, NBRAID &gt;= 10);
}

/* ================================================================
 * Part C: Eigenvector direction as stereo position
 * ================================================================ */

static void part_c(void) {
    int i;
    char msg[256];

    printf("\n=== Part C: Eigenvector direction as stereo position ===\n");
    printf("  Latitude -&gt; MIDI pitch, Longitude -&gt; pan\n\n");
    printf("  | Dir | Coord                  | Lat    | Lon    | MIDI | Note | Pan  |\n");
    printf("  |-----|------------------------|--------|--------|------|------|------|\n");

    for (i = 0; i &lt; g_nd; i++) {
        double az = g_dir[i][2];
        double colat, lon, lat_deg, lon_deg;
        int midi;
        double pan;

        if (az &gt; 1.0) az = 1.0;
        if (az &lt; -1.0) az = -1.0;
        colat = acos(az);
        lat_deg = 90.0 - colat * 180.0 / M_PI;
        lon = atan2(g_dir[i][1], g_dir[i][0]);
        if (lon &lt; 0) lon += 2.0 * M_PI;
        lon_deg = lon * 180.0 / M_PI;

        /* South pole -&gt; MIDI 48 (C3), North pole -&gt; MIDI 72 (C5) */
        midi = 48 + (int)((lat_deg + 90.0) / 180.0 * 24.0 + 0.5);
        pan = lon / (2.0 * M_PI);

        printf("  | %3d | (%+.3f,%+.3f,%+.3f) | %+5.1f  | %5.1f  | %4d | %-4s | %.2f |\n",
               i, g_dir[i][0], g_dir[i][1], g_dir[i][2],
               lat_deg, lon_deg, midi, note_nm(midi), pan);
    }

    sprintf(msg, "%d directions mapped to (pitch, pan)", g_nd);
    check(msg, g_nd &gt; 0);
}

/* ================================================================
 * Part D: Harmonic distance metric
 * ================================================================ */

static void part_d(void) {
    int i, j, n = 0;
    double sx=0, sy=0, sxx=0, syy=0, sxy=0;
    double mx, my, r;
    int same_a_diff_d = 0;
    char msg[256];

    printf("\n=== Part D: Harmonic distance metric ===\n");

    /* Pass 1: compute means */
    for (i = 0; i &lt; g_nq; i++) {
        if (!g_eig[i].axis_ok) continue;
        for (j = i+1; j &lt; g_nq; j++) {
            double ad, dd, dot;
            if (!g_eig[j].axis_ok) continue;
            ad = fabs(g_eig[i].theta - g_eig[j].theta) * 180.0 / M_PI;
            dot = fabs(g_eig[i].ax*g_eig[j].ax +
                       g_eig[i].ay*g_eig[j].ay +
                       g_eig[i].az*g_eig[j].az);
            if (dot &gt; 1.0) dot = 1.0;
            dd = acos(dot) * 180.0 / M_PI;
            sx += ad; sy += dd; n++;
            if (ad &lt; 0.1 &amp;&amp; dd &gt; 10.0) same_a_diff_d++;
        }
    }
    mx = n &gt; 0 ? sx/(double)n : 0;
    my = n &gt; 0 ? sy/(double)n : 0;

    /* Pass 2: correlation */
    for (i = 0; i &lt; g_nq; i++) {
        if (!g_eig[i].axis_ok) continue;
        for (j = i+1; j &lt; g_nq; j++) {
            double ad, dd, dot, dx, dy;
            if (!g_eig[j].axis_ok) continue;
            ad = fabs(g_eig[i].theta - g_eig[j].theta) * 180.0 / M_PI;
            dot = fabs(g_eig[i].ax*g_eig[j].ax +
                       g_eig[i].ay*g_eig[j].ay +
                       g_eig[i].az*g_eig[j].az);
            if (dot &gt; 1.0) dot = 1.0;
            dd = acos(dot) * 180.0 / M_PI;
            dx = ad - mx; dy = dd - my;
            sxx += dx*dx; syy += dy*dy; sxy += dx*dy;
        }
    }
    r = (sxx &gt; 1e-15 &amp;&amp; syy &gt; 1e-15) ? sxy / sqrt(sxx*syy) : 0.0;

    printf("  Pairs analyzed: %d\n", n);
    printf("  Correlation (eigenvalue distance vs eigenvector distance):\n");
    printf("    r = %.4f\n", r);
    printf("    Same note, different direction: %d pairs\n", same_a_diff_d);
    printf("\n  Interpretation: eigenvalue (pitch) and eigenvector (position)\n");
    printf("  are independent degrees of freedom. Music and space are\n");
    printf("  orthogonal dimensions of a quaternion.\n");

    sprintf(msg, "Correlation r=%.4f (%d pairs)", r, n);
    check(msg, n &gt; 0);
}

/* ================================================================
 * Part E: Dodecahedral connection
 * ================================================================ */

static void part_e(void) {
    int i, j;
    int order[NICO];
    int xor_ico, xor_dod, xor_eig;
    char msg[256];

    printf("\n=== Part E: Dodecahedral connection ===\n");
    printf("  Icosahedron: %d vertices (= dodecahedron face centers)\n", NICO);
    printf("  Dodecahedron: %d vertices\n", NDOD);
    printf("  Note: undirected eigenvector axes cause antipodal collapse.\n");
    printf("  Effective cells: ico=%d, dodec=%d\n\n", NICO/2, NDOD/2);

    /* Sort ico vertices: descending z, then by longitude */
    for (i = 0; i &lt; NICO; i++) order[i] = i;
    for (i = 0; i &lt; NICO-1; i++)
        for (j = i+1; j &lt; NICO; j++) {
            double zi = g_ico[order[i]][2], zj = g_ico[order[j]][2];
            int swap = 0;
            if (zi &lt; zj - 0.01) swap = 1;
            else if (fabs(zi-zj) &lt; 0.01) {
                double li = atan2(g_ico[order[i]][1], g_ico[order[i]][0]);
                double lj = atan2(g_ico[order[j]][1], g_ico[order[j]][0]);
                if (li &gt; lj) swap = 1;
            }
            if (swap) { int t=order[i]; order[i]=order[j]; order[j]=t; }
        }

    printf("  Circle of fifths on dodecahedron faces (north to south):\n\n");
    printf("  | # | Key | Face center            | Lat    |\n");
    printf("  |---|-----|------------------------|--------|\n");
    for (i = 0; i &lt; NICO; i++) {
        int v = order[i];
        double z = g_ico[v][2];
        double lat;
        if (z &gt; 1.0) z = 1.0;
        if (z &lt; -1.0) z = -1.0;
        lat = 90.0 - acos(z) * 180.0 / M_PI;
        printf("  |%2d | %-3s | (%+.3f,%+.3f,%+.3f) | %+5.1f  |\n",
               i, g_cof[i], g_ico[v][0], g_ico[v][1], g_ico[v][2], lat);
    }

    /* Map eigenvector directions to nearest ico vertex -&gt; key */
    printf("\n  Eigenvector -&gt; dodecahedral face -&gt; musical key:\n\n");
    printf("  | Dir | Coord                  | Face | Key | Dist(deg) |\n");
    printf("  |-----|------------------------|------|-----|-----------|\n");
    for (i = 0; i &lt; g_nd; i++) {
        int best = 0, key_idx = -1;
        double bd = -2.0, dist;
        for (j = 0; j &lt; NICO; j++) {
            double d = fabs(g_dir[i][0]*g_ico[j][0] +
                           g_dir[i][1]*g_ico[j][1] +
                           g_dir[i][2]*g_ico[j][2]);
            if (d &gt; bd) { bd=d; best=j; }
        }
        if (bd &gt; 1.0) bd = 1.0;
        dist = acos(bd) * 180.0 / M_PI;
        for (j = 0; j &lt; NICO; j++)
            if (order[j] == best) { key_idx=j; break; }
        printf("  | %3d | (%+.3f,%+.3f,%+.3f) | %4d | %-3s | %9.2f |\n",
               i, g_dir[i][0], g_dir[i][1], g_dir[i][2],
               best, key_idx &gt;= 0 ? g_cof[key_idx] : "?", dist);
    }

    /* XOR6 searches */
    printf("\n  XOR6 with polyhedral Voronoi:\n");

    printf("    Eigenvector (%d+1 cells)...", g_nd);
    fflush(stdout);
    xor_eig = count_xor6(g_dir, g_nd);
    printf(" %d solutions\n", xor_eig);

    printf("    Icosahedral (%d verts, %d eff cells)...", NICO, NICO/2);
    fflush(stdout);
    xor_ico = count_xor6(g_ico, NICO);
    printf(" %d solutions\n", xor_ico);

    printf("    Dodecahedral (%d verts, %d eff cells)...", NDOD, NDOD/2);
    fflush(stdout);
    xor_dod = count_xor6(g_dod, NDOD);
    printf(" %d solutions\n", xor_dod);

    printf("\n  | Polyhedron   | Vertices | Eff cells | XOR6 |\n");
    printf("  |--------------|----------|-----------|------|\n");
    printf("  | Eigenvector  |    %2d    |    %2d     | %4d |\n",
           g_nd, g_nd, xor_eig);
    printf("  | Icosahedron  |    %2d    |    %2d     | %4d |\n",
           NICO, NICO/2, xor_ico);
    printf("  | Dodecahedron |    %2d    |    %2d     | %4d |\n",
           NDOD, NDOD/2, xor_dod);

    sprintf(msg, "Eigenvector XOR6: %d (expect 36)", xor_eig);
    check(msg, xor_eig == 36);

    sprintf(msg, "Dodecahedral XOR6: %d at %d eff cells", xor_dod, NDOD/2);
    check(msg, 1);
}

/* ================================================================
 * Part F: Musical output format
 * ================================================================ */

static void part_f(void) {
    int b, i;
    int top[3] = {-1,-1,-1};
    int top_s[3] = {0,0,0};
    char msg[256];

    printf("\n=== Part F: Musical output format ===\n");

    /* Find top 3 by variety * length */
    for (b = 0; b &lt; NBRAID; b++) {
        int score = g_mel[b].distinct * g_bl[b];
        for (i = 0; i &lt; 3; i++) {
            if (score &gt; top_s[i]) {
                int k;
                for (k = 2; k &gt; i; k--) {
                    top[k]=top[k-1]; top_s[k]=top_s[k-1];
                }
                top[i]=b; top_s[i]=score;
                break;
            }
        }
    }

    printf("  Top 3 most musical braids (variety * length score):\n");

    for (i = 0; i &lt; 3; i++) {
        int b2 = top[i], k;
        if (b2 &lt; 0) continue;
        printf("\n  BRAID:  %s\n", g_bn[b2]);
        printf("  MELODY: ");
        for (k = 0; k &lt; g_bl[b2]; k++)
            printf("%s%d ", note_nm(g_mel[b2].midi[k]),
                   note_oct(g_mel[b2].midi[k]));
        printf("\n  MIDI:   ");
        for (k = 0; k &lt; g_bl[b2]; k++)
            printf("%-5d", g_mel[b2].midi[k]);
        printf("\n  Score:  %d (%d crossings, %d distinct notes)\n",
               top_s[i], g_bl[b2], g_mel[b2].distinct);
    }

    sprintf(msg, "Top 3 melodies formatted");
    check(msg, top[0] &gt;= 0);
}

/* ================================================================
 * Main
 * ================================================================ */

int main(void) {
    printf("KNOTAPEL DEMO 70: Musica Nodorum -- Knots as Sound\n");
    printf("===================================================\n");

    init_gens();
    init_poly();

    printf("\n  Building zeta_8 catalog...\n");
    build_cat();
    build_angles();
    printf("    %d quaternions, %d directions, %d eigenvalue angles\n",
           g_nq, g_nd, g_na);

    part_a();
    part_b();
    part_c();
    part_d();
    part_e();
    part_f();

    printf("\n===================================================\n");
    printf("Results: %d pass, %d fail\n", g_pass, g_fail);
    return g_fail &gt; 0 ? 1 : 0;
}
</code></pre>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <script>hljs.highlightAll();</script>
</body>
</html>
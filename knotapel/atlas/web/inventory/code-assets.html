<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>inventory/code-assets.md</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <nav><a href="../index.html">← Back to Index</a></nav><hr>
    <h1>Code Assets Catalog</h1>
<p>Reusable code patterns across 109 knotapel demos. Updated 2026-02-26 (added Demos 102-109).</p>
<p>---</p>
<h2>1. Polynomial / Ring Arithmetic</h2>
<h3>1.1 Laurent Polynomial Ring (Poly)</h3>
<ul>
<li><strong>What it does</strong>: Integer-coefficient Laurent polynomials (negative and positive exponents) with full ring operations — the symbolic backbone of Demos 01-09.</li>
<li><strong>Introduced in</strong>: Demo 01</li>
<li><strong>Reused in</strong>: Demos 02, 03, 04, 05, 06, 07, 08, 09</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>Poly</code> struct: <code>lo</code> (lowest exponent) + <code>coeffs[]</code> array, <code>MAX_TERMS=64</code> (120 in Demo 04+)</li>
<li><code>p_zero()</code>, <code>p_mono(coeff, exp)</code>, <code>p_trim()</code> — constructors</li>
<li><code>p_add()</code>, <code>p_mul()</code>, <code>p_eq()</code>, <code>p_print()</code> — core algebra</li>
<li><code>p_neg()</code>, <code>p_sub()</code> — added Demo 06</li>
<li><code>p_div_exact()</code> — exact polynomial division with remainder check (Demo 06)</li>
<li><strong>Approximate size</strong>: ~120 lines</li>
<li><strong>Notes</strong>: Copied verbatim between demos (no shared library extraction). MAX_TERMS varies (64 in early demos, 120 in Demo 04+). Replaced by numerical <code>Cx</code> type from Demo 10 onward for performance.</li>
</ul>
<h3>1.2 Complex Arithmetic (Cx)</h3>
<ul>
<li><strong>What it does</strong>: Double-precision complex number type with full arithmetic, unit-circle evaluation, and approximate equality — the numerical workhorse for all demos from 10 onward.</li>
<li><strong>Introduced in</strong>: Demo 10</li>
<li><strong>Reused in</strong>: Demos 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 35, 45, 46, 47, 48, 49, 50, 53, 54, 55, 56, 57, 58, 59, 61, 62, 64, 65, 66, 67, 68, 69, 70, 71, 85</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>Cx</code> struct: <code>re</code>, <code>im</code> doubles</li>
<li><code>cx_make()</code>, <code>cx_zero()</code>, <code>cx_one()</code>, <code>cx_real()</code> — constructors</li>
<li><code>cx_add()</code>, <code>cx_sub()</code>, <code>cx_mul()</code>, <code>cx_div()</code>, <code>cx_neg()</code> — ring operations</li>
<li><code>cx_abs()</code>, <code>cx_abs2()</code> — magnitude</li>
<li><code>cx_exp_i(theta)</code> — unit circle point</li>
<li><code>cx_pow_int(z, n)</code> — binary exponentiation (handles negative n)</li>
<li><code>cx_near(a, b, tol)</code> — approximate equality</li>
<li><code>cx_phase(z)</code> — argument in [0, 2pi)</li>
<li><code>cx_scale(z, r)</code> — real scalar multiplication</li>
<li><code>cx_print()</code> — formatted output</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: 16 bytes per entry (vs ~808 bytes for Poly) — 50x memory reduction. Used as the float companion to every exact cyclotomic ring.</li>
</ul>
<h3>1.3 Cyclotomic Z[zeta_8] (Cyc8)</h3>
<ul>
<li><strong>What it does</strong>: Exact integer arithmetic in the 8th cyclotomic ring — basis {1, zeta_8, zeta_8^2, zeta_8^3} with zeta_8^4 = -1. The natural home for bracket values at delta=0 (A = e^{i*5pi/4}).</li>
<li><strong>Introduced in</strong>: Demo 29</li>
<li><strong>Reused in</strong>: Demos 35, 48, 49, 50, 63, 64, 74, 100, 101, 102, 103, 104, 105, 106, 107, 108</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>Cyc8</code> struct: 4 <code>long</code> coefficients <code>(a, b, c, d)</code></li>
<li><code>cyc8_make()</code>, <code>cyc8_zero()</code>, <code>cyc8_one()</code> — constructors</li>
<li><code>cyc8_add()</code>, <code>cyc8_sub()</code>, <code>cyc8_neg()</code>, <code>cyc8_mul()</code>, <code>cyc8_scale()</code> — ring operations</li>
<li><code>cyc8_mul()</code>: 16 integer muls + 12 adds, zero floating-point</li>
<li><code>cyc8_eq()</code> — exact equality</li>
<li><code>cyc8_conj()</code> — complex conjugation: conj(a,b,c,d) = (a,-d,-c,-b); doubles as inverse for units</li>
<li><code>cyc8_pow_int(z, n)</code> — positive and negative exponents (via conjugate for negative)</li>
<li><code>cyc8_to_cx()</code> — convert to float for verification</li>
<li><code>cyc8_is_axial()</code> — tests single-component property (at most one nonzero coordinate)</li>
<li><code>cyc8_print()</code> — formatted output</li>
<li><strong>Approximate size</strong>: ~200 lines</li>
<li><strong>Notes</strong>: All bracket values at A = -zeta_8 are cyclotomic integers in this ring. The delta=0 condition (A^2 + A^{-2} = 0) means only single-loop smoothing states survive, massively simplifying exact computation. Reused in Demo 64 for matroid deletion-contraction verification — exact arithmetic is critical to eliminate floating-point association-order failures near sector boundaries (420 spurious failures eliminated).</li>
</ul>
<h3>1.4 Eisenstein Integers Z[omega] (Eis)</h3>
<ul>
<li><strong>What it does</strong>: Exact arithmetic in the ring of Eisenstein integers — basis {1, omega} where omega = e^{i*2pi/3} is a cube root of unity, omega^2 + omega + 1 = 0.</li>
<li><strong>Introduced in</strong>: Demo 53</li>
<li><strong>Reused in</strong>: (Demo 53 only — ring-specific to ell=3/delta=1)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>Eis</code> struct: 2 integer coefficients <code>(a, b)</code> representing a + b*omega</li>
<li><code>eis_add()</code>, <code>eis_sub()</code>, <code>eis_neg()</code>, <code>eis_mul()</code> — ring operations</li>
<li><code>eis_conj()</code> — conjugation, norm = a^2 - ab + b^2</li>
<li><code>eis_a_power(n)</code> — A^n where A = omega, cycling mod 3</li>
<li><code>eis_is_axial()</code> — tests if value is a scalar multiple of {1, omega, omega^2}</li>
<li><code>eis_to_cx()</code> — convert to float</li>
<li><strong>Approximate size</strong>: ~80 lines</li>
<li><strong>Notes</strong>: 2-dimensional over Z (simplest non-trivial cyclotomic ring). At delta=1, TL generators are idempotent (e_i^2 = e_i) and all smoothing states contribute.</li>
</ul>
<h3>1.5 Cyclotomic Z[zeta_16] (Cyc16)</h3>
<ul>
<li><strong>What it does</strong>: Exact 8-dimensional cyclotomic integer arithmetic for bracket evaluation at ell=4 (delta=sqrt(2), Ising anyons).</li>
<li><strong>Introduced in</strong>: Demo 54</li>
<li><strong>Reused in</strong>: Demos 55, 56, 57, 65, 109</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>Cyc16</code> struct: 8 <code>long</code> coefficients, basis {1, zeta_16, ..., zeta_16^7}, zeta^8 = -1</li>
<li><code>cyc16_zero()</code>, <code>cyc16_one()</code>, <code>cyc16_make()</code>, <code>cyc16_zeta_power()</code> — constructors</li>
<li><code>cyc16_add()</code>, <code>cyc16_neg()</code>, <code>cyc16_scale()</code>, <code>cyc16_mul()</code> — ring operations</li>
<li><code>cyc16_eq()</code>, <code>cyc16_is_zero()</code> — comparison</li>
<li><code>cyc16_a_power(n)</code> — A^k = zeta^{5k} with reduction (order 16)</li>
<li><code>cyc16_delta_power(k)</code> — delta^k where delta=sqrt(2): even powers → integer (2^{k/2}), odd → integer*delta</li>
<li><code>cyc16_is_axial()</code> — strict axiality (1 nonzero component)</li>
<li><code>cyc16_is_zi_axial()</code> — Z[i]-axiality (at most one active pair (k, k+4))</li>
<li><code>cyc16_zi_decompose()</code> — factors as (a+bi)*zeta^c</li>
<li><code>cyc16_to_cx()</code>, <code>cyc16_print()</code> — output</li>
<li><code>cyc16_is_real()</code> — tests zero imaginary part (odd components = 0)</li>
<li><code>cyc16_is_zeta8_valued()</code> — tests Z[zeta_8] subring membership (even-indexed only)</li>
<li><strong>Approximate size</strong>: ~250 lines</li>
<li><strong>Notes</strong>: A = zeta_16^5, delta = zeta^2 - zeta^6 = sqrt(2). Generators are delta-potent (e_i^2 = sqrt(2)*e_i). Contains Z[zeta_8] and Z[i] as subrings.</li>
</ul>
<h3>1.6 Cyclotomic Z[zeta_5] (Cyc5)</h3>
<ul>
<li><strong>What it does</strong>: Exact 4-dimensional cyclotomic arithmetic for the Fibonacci anyon evaluation level (ell=5, delta=phi=golden ratio).</li>
<li><strong>Introduced in</strong>: Demo 58</li>
<li><strong>Reused in</strong>: (Demo 58 only — ring-specific to ell=5)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>Cyc5</code> struct: 4 <code>long</code> coefficients, basis {1, zeta_5, zeta_5^2, zeta_5^3}</li>
<li>Reduction: zeta_5^4 = -(1 + zeta_5 + zeta_5^2 + zeta_5^3)</li>
<li><code>cyc5_zero()</code>, <code>cyc5_one()</code>, <code>cyc5_add()</code>, <code>cyc5_neg()</code>, <code>cyc5_mul()</code> — ring operations</li>
<li><code>cyc5_a_power(n)</code> — A = (1,1,1,1) = -zeta_5^4 = zeta_10^3, order 10; precomputed <code>A_table[10]</code></li>
<li><code>cyc5_delta_power(k)</code> — delta^k via Fibonacci: phi^k = F(k-1) + F(k)*phi</li>
<li><code>cyc5_to_cx()</code>, <code>cyc5_print()</code> — output</li>
<li><strong>Approximate size</strong>: ~150 lines</li>
<li><strong>Notes</strong>: Delta = phi = (1+sqrt(5))/2 — Fibonacci numbers appear as delta power coefficients. Coefficients grow with braid length (unlike bounded coefficients at delta=0).</li>
</ul>
<h3>1.7 Cyclotomic Z[zeta_24] (Cyc24)</h3>
<ul>
<li><strong>What it does</strong>: Exact 8-dimensional cyclotomic arithmetic for Q=3 Potts model evaluation (ell=6, delta=sqrt(3)).</li>
<li><strong>Introduced in</strong>: Demo 59</li>
<li><strong>Reused in</strong>: (Demo 59 only — ring-specific to ell=6)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>Cyc24</code> struct: 8 <code>long</code> coefficients, basis {1, zeta_24, ..., zeta_24^7}</li>
<li>Reduction: Phi_24(x) = x^8 - x^4 + 1, so zeta^8 = zeta^4 - 1</li>
<li><code>cyc24_zero()</code>, <code>cyc24_one()</code>, <code>cyc24_add()</code>, <code>cyc24_neg()</code>, <code>cyc24_mul()</code> — ring operations</li>
<li><code>A_table[24]</code> — precomputed A^k for k=0..23 (A = zeta_24^7, order 24)</li>
<li><code>cyc24_delta_power(k)</code> — delta^k where delta=sqrt(3): delta^{2k}=3^k, delta^{2k+1}=3^k*sqrt(3)</li>
<li><code>cyc24_to_cx()</code>, <code>cyc24_print()</code> — output</li>
<li><strong>Approximate size</strong>: ~200 lines</li>
<li><strong>Notes</strong>: Third independent ring confirming 11/13 Re&gt;0 wall. Q = delta^2 = 3 connects to 3-state Potts model.</li>
</ul>
<h3>1.8 Gaussian Integer Tracking (GaussInt)</h3>
<ul>
<li><strong>What it does</strong>: Lightweight Gaussian integer Z[i] catalog with negation/conjugation pair detection.</li>
<li><strong>Introduced in</strong>: Demo 54 (Experiment 5)</li>
<li><strong>Reused in</strong>: (Demo 54 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>GaussInt</code> struct: <code>a</code>, <code>b</code> integers (a + bi)</li>
<li><code>gi_catalog_contains()</code> — deduplication</li>
<li>Negation pair / conjugation pair tracking</li>
<li><strong>Approximate size</strong>: ~30 lines</li>
<li><strong>Notes</strong>: Z[i] appears as a subring of Z[zeta_16] (via zeta^4 = i). Used to strip the zeta^c axis from Z[i]-axial bracket values.</li>
</ul>
<h3>1.9 Cubic Extension Field Arithmetic (F_p[x]/(f))</h3>
<ul>
<li><strong>What it does</strong>: Polynomial arithmetic over F_p modulo an irreducible cubic — enables exact computation in cubic number fields like Q(2cos(pi/7)) without floating point.</li>
<li><strong>Introduced in</strong>: Demo 39 (specialized for ell=7 cubic root finding)</li>
<li><strong>Reused in</strong>: Demo 60 (full cubic extension field TL analysis)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>Poly3</code> type (Demo 39) / inline polynomial arrays (Demo 60): coefficients of degree &lt;= 2 polynomials in F_p[x]/(x^3 - x^2 - 2x + 1)</li>
<li><code>poly_mul()</code>, <code>poly_pow()</code> — multiplication with reduction mod f(x), repeated-squaring exponentiation</li>
<li><code>pdeg()</code>, <code>pmod()</code>, <code>pgcd()</code> — degree, polynomial reduction, polynomial GCD over F_p</li>
<li><code>p3_mul()</code>, <code>p3_pow()</code> (Demo 39) — specialized Poly3 operations</li>
<li>Reduction rule: x^3 = x^2 + 2x - 1, x^4 = 3x^2 + x - 1</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: First non-quadratic number field in the Chebyshev parameter hierarchy. The minimal polynomial x^3 - x^2 - 2x + 1 for 2cos(pi/7) is well-known in algebraic number theory.</li>
</ul>
<p>---</p>
<h2>2. Knot / Braid Computation</h2>
<h3>2.1 PD Notation &amp; State-Sum Bracket (Symbolic)</h3>
<ul>
<li><strong>What it does</strong>: Represents knots via planar diagram (PD) notation and computes Kauffman brackets by brute-force state-sum over all 2^n crossing resolutions using symbolic Laurent polynomials.</li>
<li><strong>Introduced in</strong>: Demo 01</li>
<li><strong>Reused in</strong>: Demos 02, 07, 08, 09</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>Knot</code> struct: array of <code>Xing</code> (crossing) structs with arc labels and signs, MAX_X=16</li>
<li><code>Xing</code> struct: 4 arc labels + crossing sign</li>
<li><code>kauffman_bracket(knot)</code> — O(2^n) state-sum over crossing resolutions</li>
<li><code>count_loops(knot, state)</code> — traces cycles through arc connectivity for a given resolution state</li>
<li><code>jones_from_bracket(knot)</code> — writhe normalization to get f-polynomial</li>
<li><code>make_trefoil()</code>, <code>make_figure_eight()</code>, <code>make_hopf()</code> — standard PD constructors</li>
<li><strong>Approximate size</strong>: ~200 lines</li>
<li><strong>Notes</strong>: The ground-truth oracle for all later demos. Limited to ~16 crossings by exponential state enumeration.</li>
</ul>
<h3>2.2 Union-Find Loop Counter</h3>
<ul>
<li><strong>What it does</strong>: Path-compressed union-find for counting connected components (loops) in resolved knot/braid diagrams. The most-reused utility across all demos.</li>
<li><strong>Introduced in</strong>: Demo 02</li>
<li><strong>Reused in</strong>: Demos 03, 04, 05, 07, 08, 09, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 45, 46, 47, 48, 49, 50, 53, 54, 55, 56, 57, 58, 59, 64, 65, 66, 67, 68, 69, 70, 71, 74 (bracket loop counting in full catalog builder), 108 (parity detection in bracket catalog), 109 (state-sum bracket loop counting)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>uf_parent[]</code> — global or local parent array</li>
<li><code>uf_init(n)</code>, <code>uf_find(x)</code>, <code>uf_union(x, y)</code> — standard union-find with path compression</li>
<li><code>braid_loops(word, len, n_strands)</code> / <code>braid_count_loops()</code> — counts loops in resolved braid closure</li>
<li><strong>Approximate size</strong>: ~40 lines</li>
<li><strong>Notes</strong>: Path-halving variant in later demos. Used in every state-sum bracket computation. Sometimes local arrays, sometimes global.</li>
</ul>
<h3>2.3 Braid Word State-Sum Bracket (Numerical)</h3>
<ul>
<li><strong>What it does</strong>: Evaluates Kauffman bracket from braid word via O(2^n) state-sum, using either symbolic polynomials or numerical complex evaluation at a specific angle.</li>
<li><strong>Introduced in</strong>: Demo 02 (symbolic), Demo 10 (numerical)</li>
<li><strong>Reused in</strong>: Nearly every demo from 02 onward</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>Braid</code> struct: <code>word[]</code> (signed generator indices), <code>len</code>, <code>n</code> (strand count)</li>
<li><code>braid_bracket(word, len, n)</code> — symbolic state-sum (Poly result)</li>
<li><code>braid_bracket_at(word, len, n, A)</code> — numerical state-sum at complex A (Cx result)</li>
<li><code>braid_writhe()</code>, <code>braid_jones()</code> — writhe computation and normalization</li>
<li><strong>Approximate size</strong>: ~100 lines (numerical version)</li>
<li><strong>Notes</strong>: The numerical version (<code>braid_bracket_at</code>) is the primary validation oracle for all later demos. Evaluates at specific A = e^{i*theta} on the unit circle.</li>
</ul>
<h3>2.4 Braid-to-PD Bridge</h3>
<ul>
<li><strong>What it does</strong>: Converts braid words to PD notation via strand closure, enabling cross-validation between the two computation worlds.</li>
<li><strong>Introduced in</strong>: Demo 07</li>
<li><strong>Reused in</strong>: Demos 08, 09</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>braid_to_pd(braid)</code> — core bridge: tracks per-position crossing lists, assigns arc labels, builds PD with correct over/under conventions</li>
<li><code>seifert_circles(knot)</code> — Seifert resolution on PD notation (sign-dependent pairing)</li>
<li><code>link_components(knot)</code> — traces strands via (p+2)%4 exit rule</li>
<li><strong>Approximate size</strong>: ~200 lines</li>
<li><strong>Notes</strong>: Confirmed: braid closure PD bracket = braid state-sum bracket for all tested knots.</li>
</ul>
<h3>2.5 PD-to-Braid Compiler (Vogel's Algorithm)</h3>
<ul>
<li><strong>What it does</strong>: Compiles PD notation to braid word via Seifert circle decomposition — the reverse direction of Demo 07's bridge.</li>
<li><strong>Introduced in</strong>: Demo 08</li>
<li><strong>Reused in</strong>: (Demo 08 + round-trip tests)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>pd_to_braid()</code> — full 7-step compiler (Seifert membership → crossing-circle map → Seifert graph → circle ordering → crossing trace → braid ordering → emit)</li>
<li><code>seifert_membership()</code> — union-find Seifert resolution</li>
<li><code>trace_circles()</code> — cyclic crossing order per Seifert circle</li>
<li><code>find_braid_order()</code> — topological sort for braid word ordering</li>
<li><strong>Approximate size</strong>: ~250 lines</li>
<li><strong>Notes</strong>: Only handles path-graph Seifert graphs. Full Vogel moves for non-path graphs not implemented.</li>
</ul>
<h3>2.6 Reidemeister Move Infrastructure</h3>
<ul>
<li><strong>What it does</strong>: Applies R1 (twist/kink) and R2 (poke) moves to PD notation and verifies bracket/Jones invariance computationally.</li>
<li><strong>Introduced in</strong>: Demo 09</li>
<li><strong>Reused in</strong>: (Demo 09 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>writhe(knot)</code> — sum of crossing signs</li>
<li><code>jones_poly(knot)</code> — (-A^3)^{-w} * bracket(K)</li>
<li><code>apply_r1(knot, edge, sign)</code> — adds kink to specified edge</li>
<li><code>apply_r2(knot, edge1, edge2)</code> — adds opposite-sign crossing pair</li>
<li><code>remap_second()</code> — edge splitting utility</li>
<li><strong>Approximate size</strong>: ~150 lines</li>
</ul>
<h3>2.7 Numerical Bracket Engine (Matrix Method)</h3>
<ul>
<li><strong>What it does</strong>: Computes Kauffman bracket via tensor product R-matrix representation and quantum trace — the scalable alternative to state-sum for large strand counts.</li>
<li><strong>Introduced in</strong>: Demo 10</li>
<li><strong>Reused in</strong>: Demos 11-17 (via numerical_bracket), indirectly by all later demos using the unit-circle evaluation pattern</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>CMat</code> struct: heap-allocated NxN complex matrix</li>
<li><code>CMAT(m, i, j)</code> macro for row-major access</li>
<li><code>cmat_alloc()</code>, <code>cmat_free()</code>, <code>cmat_zero()</code>, <code>cmat_id()</code>, <code>cmat_mul()</code>, <code>cmat_scale()</code>, <code>cmat_add()</code>, <code>cmat_qtrace()</code>, <code>cmat_tensor()</code>, <code>cmat_eq_approx()</code></li>
<li><code>build_R4()</code> — 4x4 R-matrix and inverse for given A</li>
<li><code>build_Ri(R4, i, n)</code> — I^{x(i-1)} x R x I^{x(n-i-1)} via tensor products</li>
<li><code>build_Kn(n)</code> — K^{xn} diagonal weights for quantum trace</li>
<li><code>braid_product_n(word, len, n, A)</code> — braid word to matrix product in 2^n dimensions</li>
<li><code>numerical_bracket(word, len, n, A)</code> — full pipeline: braid → product → qtrace → sign correction</li>
<li><strong>Approximate size</strong>: ~300 lines</li>
<li><strong>Notes</strong>: Scales to n=8 (256x256). Memory is ~50MB per matrix at n=6. Sign convention: (-1)^{n+1} correction.</li>
</ul>
<h3>2.8 Bracket with Closure Support</h3>
<ul>
<li><strong>What it does</strong>: Extends the state-sum bracket to support 4 different closure types (trace, plat_A, plat_B, plat_C), enabling multi-readout experiments from a single braid.</li>
<li><strong>Introduced in</strong>: Demo 21</li>
<li><strong>Reused in</strong>: Demos 22, 23, 25</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>Closure</code> enum: <code>CL_TRACE</code>, <code>CL_PLAT_A</code> (01|23), <code>CL_PLAT_B</code> (02|13), <code>CL_PLAT_C</code> (03|12)</li>
<li><code>bracket_cl(word, len, n, A, closure)</code> — state-sum bracket with configurable closure</li>
<li><code>braid_loops_cl(word, len, n, state, closure)</code> — loop counting with 4 closure types</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: Key discovery: different closures of the same braid typically yield different Boolean functions (&gt;=80% closure-dependent). Parity function (0x96/0x69) found zero times across all braids and closures.</li>
</ul>
<h3>2.9 Exact Bracket at delta=0 (Cyc8)</h3>
<ul>
<li><strong>What it does</strong>: Computes exact Kauffman bracket in Z[zeta_8] arithmetic, exploiting delta=0 simplification where only single-loop smoothing states survive.</li>
<li><strong>Introduced in</strong>: Demo 29</li>
<li><strong>Reused in</strong>: Demos 35, 48, 49, 50, 108 (bracket catalog builder)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>braid_bracket_exact(word, len, n)</code> — exact state-sum in Cyc8 at A = -zeta_8; skips all multi-loop states</li>
<li><strong>Approximate size</strong>: ~50 lines</li>
<li><strong>Notes</strong>: Critical optimization: at delta=0, delta^{loops-1} = 0 for loops &gt; 1, so only single-loop states contribute. This makes exact computation feasible.</li>
</ul>
<h3>2.10 Exact Bracket at General Delta (Ring-Parametric)</h3>
<ul>
<li><strong>What it does</strong>: State-sum bracket evaluation using exact cyclotomic arithmetic at various evaluation levels where delta != 0.</li>
<li><strong>Introduced in</strong>: Demo 53 (Eis/delta=1), Demo 54 (Cyc16/delta=sqrt(2)), Demo 58 (Cyc5/delta=phi), Demo 59 (Cyc24/delta=sqrt(3))</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>state_sum_bracket_d1()</code> — delta=1, all states contribute equally (delta^{L-1} = 1)</li>
<li><code>state_sum_bracket()</code> at Cyc16 — delta=sqrt(2), weights by delta^{loops-1} using exact delta powers</li>
<li><code>state_sum_bracket()</code> at Cyc5 — delta=phi, weights via Fibonacci numbers</li>
<li><code>state_sum_bracket()</code> at Cyc24 — delta=sqrt(3), weights via 3^k scaling</li>
<li><strong>Approximate size</strong>: ~80 lines per ring</li>
<li><strong>Notes</strong>: All use planar diagram composition instead of union-find for loop counting. Cross-validated against float evaluation.</li>
</ul>
<h3>2.11 Dual Bracket (Standard + Neglecton)</h3>
<ul>
<li><strong>What it does</strong>: Evaluates both the standard bracket (loops=1 states) and the first-order neglecton bracket (4 x loops=2 states) simultaneously, for investigating TL_4 radical contributions.</li>
<li><strong>Introduced in</strong>: Demo 49</li>
<li><strong>Reused in</strong>: (Demo 49 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>DualBracket</code> struct: paired standard + neglecton Cyc8 values</li>
<li><code>braid_bracket_dual(word, len, n)</code> — evaluates BOTH brackets in exact arithmetic, skipping loops &gt;= 3</li>
<li><strong>Approximate size</strong>: ~80 lines</li>
<li><strong>Notes</strong>: Neglecton bracket = 4 * Sum_{states with loops=2} A^{a-b}. Scale factor 4 = d(delta)/d(epsilon). Found 148 new values from 15,242 previously invisible braids, but all share angles with standard catalog values.</li>
</ul>
<h3>2.12 Braid Word Decoder/Enumerator</h3>
<ul>
<li><strong>What it does</strong>: Converts integer indices to braid crossing sequences for exhaustive enumeration of all braids up to a given length.</li>
<li><strong>Introduced in</strong>: Demo 22</li>
<li><strong>Reused in</strong>: Demos 23, 25, 35, 48, 49, 50, 53, 54, 55, 56, 57, 58, 59, 64, 65, 66, 67, 68, 69, 70, 71, 74 (catalog builder), 108 (bracket catalog for parity detection), 109 (state-sum bracket enumeration)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>decode_word(code, len, word)</code> — maps integer to braid word using generator map</li>
<li><code>decode_word3()</code> — 3-strand variant (4 generators: {1,-1,2,-2})</li>
<li><code>decode_word4()</code> — 4-strand variant (6 generators: {1,-1,2,-2,3,-3})</li>
<li><code>decode_braid()</code> — general version for n strands</li>
<li><code>gen_map[]</code> — generator alphabet array</li>
<li><strong>Approximate size</strong>: ~25 lines</li>
<li><strong>Notes</strong>: Search spaces: 4^k for 3-strand, 6^k for 4-strand. Used in every exhaustive braid enumeration.</li>
</ul>
<h3>2.13 Knot Table Builder</h3>
<ul>
<li><strong>What it does</strong>: Constructs collections of knots (torus knots, connected sums, mirrors) for classification experiments with deduplication.</li>
<li><strong>Introduced in</strong>: Demo 13</li>
<li><strong>Reused in</strong>: Demos 14, 15, 16, 17</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>add_torus_2n(table, n, sign)</code> — generates T(2,n) torus knot braid word</li>
<li><code>add_connected_sum(table, k1, k2)</code> — concatenates braid words for connected sum</li>
<li><code>dedup_knots(table)</code> — removes duplicates by bracket comparison at 2 reference angles</li>
<li><code>init_knots(table)</code> — full table initialization</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: Dedup finds interesting equivalences (e.g., T23#fig8 == T(2,5)*). Braid concatenation != diagram connected sum (factorization fails).</li>
</ul>
<p>---</p>
<h2>3. TL Algebra</h2>
<h3>3.1 Planar Matching Enumeration</h3>
<ul>
<li><strong>What it does</strong>: Recursively enumerates non-crossing perfect matchings (planar diagrams) on 2n boundary points — the basis for Temperley-Lieb algebra representations.</li>
<li><strong>Introduced in</strong>: Demo 35</li>
<li><strong>Reused in</strong>: Demos 38, 39, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 107 (non-crossing matching enumerator for bipartiteness verification)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>PlanarMatch</code> struct: array of pairs, each matching endpoint a with endpoint b</li>
<li><code>enumerate_basis(n, basis, count)</code> — segment-based recursive algorithm</li>
<li><code>enum_segments()</code>, <code>build_boundary_order()</code> — internal recursion helpers</li>
<li>Produces Catalan numbers: C_2=2, C_3=5, C_4=14, C_5=42, C_6=132, C_7=429, C_8=1430</li>
<li><strong>Approximate size</strong>: ~80 lines</li>
<li><strong>Notes</strong>: Ring-independent — pure combinatorics. Used identically across all cyclotomic ring demos and all radical analysis demos. Supports n up to 8 (C_8=1430 basis elements).</li>
</ul>
<h3>3.2 Diagram Composition</h3>
<ul>
<li><strong>What it does</strong>: Stacks two TL diagrams vertically, connects matching endpoints at the glue, and counts closed loops formed at the junction.</li>
<li><strong>Introduced in</strong>: Demo 35</li>
<li><strong>Reused in</strong>: Demos 38, 39, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>compose_diagrams(d1, d2, n, result, loops)</code> — composes two PlanarMatch diagrams, returns resulting diagram + loop count</li>
<li><code>find_basis_index()</code> — lookup composed result in enumerated basis</li>
<li><strong>Approximate size</strong>: ~50 lines</li>
<li><strong>Notes</strong>: The loop count determines the delta^loops coefficient. At delta=0, any composition producing loops &gt; 0 contributes zero.</li>
</ul>
<h3>3.3 TL Matrix Algebra (Ring-Parametric)</h3>
<ul>
<li><strong>What it does</strong>: Matrix algebra over TL_n basis elements with coefficients in various cyclotomic rings.</li>
<li><strong>Introduced in</strong>: Demo 35 (Cyc8)</li>
<li><strong>Reused in</strong>: Demos 51 (integer), 52 (mod-p), 53 (Eis), 54 (Cyc16), 55, 58 (Cyc5), 59 (Cyc24)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>TLMatrix</code> / <code>TLMat</code> type: up to C_n x C_n matrix over the coefficient ring</li>
<li><code>tlmat_zero()</code>, <code>tlmat_identity()</code> — constructors</li>
<li><code>tlmat_add()</code>, <code>tlmat_scale()</code>, <code>tlmat_mul()</code> — algebra operations (mul uses loop-weighted delta^k)</li>
<li><code>tlmat_eq()</code>, <code>tlmat_is_zero()</code>, <code>tlmat_nonzero_count()</code>, <code>tlmat_print()</code></li>
<li><strong>Approximate size</strong>: ~200 lines per ring variant</li>
<li><strong>Notes</strong>: Matrix dimensions are Catalan numbers. The multiplication kernel is identical across rings; only the coefficient arithmetic changes. At n=5, matrices are 42x42.</li>
</ul>
<h3>3.4 TL Generator &amp; Braid Generator Builders</h3>
<ul>
<li><strong>What it does</strong>: Constructs TL generator matrices e_i and braid generator matrices sigma_i = A<em>I + A^{-1}</em>e_i in the planar matching basis.</li>
<li><strong>Introduced in</strong>: Demo 35</li>
<li><strong>Reused in</strong>: Demos 51, 52, 53, 54, 55, 58, 59</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>build_generator_matrix(basis, dim, i, n, delta)</code> — constructs e_i via diagram composition</li>
<li><code>build_braid_generator(basis, dim, i, n, A)</code> — sigma_i = A<em>I + A^{-1}</em>e_i</li>
<li><code>eval_braid_word(word, len, generators, dim)</code> — multiplies generator matrices for arbitrary crossing sequences</li>
<li><strong>Approximate size</strong>: ~80 lines</li>
<li><strong>Notes</strong>: At delta=0: e_i^2 = 0 (nilpotent). At delta=1: e_i^2 = e_i (idempotent). At delta=sqrt(2): e_i^2 = sqrt(2)*e_i (delta-potent).</li>
</ul>
<h3>3.5 Trace Closure Functional</h3>
<ul>
<li><strong>What it does</strong>: Extracts the Kauffman bracket from a TL matrix representation via the trace closure operation.</li>
<li><strong>Introduced in</strong>: Demo 35</li>
<li><strong>Reused in</strong>: Demos 51, 52, 53, 54, 55, 58, 59</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>compute_bracket_trace(matrix, basis, dim, n, delta)</code> — sums identity column with delta^{trace_loops-1} weights</li>
<li><code>trace_closure_loops(diagram, n)</code> — counts loops in trace closure of a planar matching diagram</li>
<li><strong>Approximate size</strong>: ~40 lines</li>
<li><strong>Notes</strong>: Cross-validated against state-sum bracket for every ring.</li>
</ul>
<h3>3.6 TL_3 5x5 Representation (at delta=0)</h3>
<ul>
<li><strong>What it does</strong>: Hardcoded 5x5 TL_3 representation for fast braid evaluation and nilpotent compression at delta=0.</li>
<li><strong>Introduced in</strong>: Demo 22</li>
<li><strong>Reused in</strong>: (Demo 22 only — superseded by general TL_n from Demo 35)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>Mat5</code> type: 5x5 complex matrix</li>
<li><code>mat5_zero()</code>, <code>mat5_id()</code>, <code>mat5_scale()</code>, <code>mat5_add()</code>, <code>mat5_mul()</code>, <code>mat5_eq()</code></li>
<li><code>tl3_init(A)</code> — builds e1, e2 and sigma matrices</li>
<li><code>tl3_braid_matrix(word, len, A)</code> — evaluates braid as TL_3 matrix product</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: TL_3 at delta=0 is SEMISIMPLE (radical dim = 0), an anomaly — most TL_n at delta=0 are non-semisimple. Used to prove nilpotent compression: distinct TL_3 matrices grow subexponentially vs 4^k braids.</li>
</ul>
<h3>3.7 Polynomial Matrix Algebra (Mat, Mat2, Mat4)</h3>
<ul>
<li><strong>What it does</strong>: Matrix algebra over Laurent polynomials for symbolic tensor product, quantum trace, and Yang-Baxter verification.</li>
<li><strong>Introduced in</strong>: Demo 03 (Mat2 2x2), Demo 03 (Mat4 4x4), Demo 04 (Mat NxN up to 8x8)</li>
<li><strong>Reused in</strong>: Demos 04, 05, 06</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>Mat2</code> (2x2): identity, multiply, scale, add, trace, equality, print</li>
<li><code>Mat4</code> (4x4): zero, multiply, equality, tensor product</li>
<li><code>Mat</code> (NxN, up to 8x8 or heap-allocated):</li>
<li><code>mat_alloc()</code>, <code>mat_free()</code> — heap allocation (Demo 05+)</li>
<li><code>mat_zero()</code>, <code>mat_id()</code>, <code>mat_mul()</code>, <code>mat_scale()</code>, <code>mat_add()</code>, <code>mat_trace()</code>, <code>mat_eq()</code></li>
<li><code>mat_tensor()</code> — general Kronecker product</li>
<li><code>mat_qtrace()</code> — quantum trace with diagonal weights</li>
<li><code>MAT(m, i, j)</code> macro for row-major access</li>
<li><code>braid_product()</code> — maps braid word to matrix product</li>
<li><code>build_Ri()</code> — tensor product embedding of R-matrix for n-strand evaluation</li>
<li><code>build_Kn()</code> — K^{tensor n} weights</li>
<li><strong>Approximate size</strong>: ~300 lines (cumulative)</li>
<li><strong>Notes</strong>: Superseded by numerical CMat from Demo 10 for all practical computation, but the symbolic version proved key identities (Yang-Baxter, quantum trace formula).</li>
</ul>
<h3>3.8 Jones-Wenzl Idempotents</h3>
<ul>
<li><strong>What it does</strong>: Constructs scaled Jones-Wenzl idempotents p_2 (4x4) and p_3 (8x8) over Laurent polynomials, avoiding rational functions via scaling trick.</li>
<li><strong>Introduced in</strong>: Demo 06</li>
<li><strong>Reused in</strong>: (Demo 06 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Scaled JW recursion: Q_n = D_n * p_n (integer coefficients only)</li>
<li>Quantum dimension computation via Chebyshev recurrence: [n+1]_q = [2]_q * [n]_q - [n-1]_q</li>
<li>Markov trace decomposition verification</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: Key simplification: [2]_q/delta = -1 at delta = -(A^2 + A^{-2}).</li>
</ul>
<p>---</p>
<h2>4. Radical / Representation Theory</h2>
<h3>4.1 TL Algebra Full Structure (Integer Arithmetic)</h3>
<ul>
<li><strong>What it does</strong>: Computes the complete algebraic structure of TL_n(delta=0) — multiplication table, radical, radical filtration, orthogonal idempotents, and Peirce decomposition — using exact integer arithmetic.</li>
<li><strong>Introduced in</strong>: Demo 51</li>
<li><strong>Reused in</strong>: Demo 52 (extended to general delta via modular arithmetic), Demo 60 (TLAlgebra struct and init_tl() reused for cubic field analysis)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>TLAlgebra</code> struct: basis, identity/generator indices, full multiplication table</li>
<li><code>AlgElem</code> type: integer-coefficient algebra elements</li>
<li><code>init_tl_algebra(n)</code> / <code>init_tl(n)</code> — full initialization (enumerate, find identity/generators, build multiplication table)</li>
<li><code>alg_mul(a, b, algebra)</code> — multiplication via precomputed table</li>
<li><code>compute_radical_dim(algebra)</code> — trace form Gram matrix + Gaussian elimination for rank</li>
<li><code>extract_radical_basis(algebra)</code> — null space of Gram matrix via augmented row reduction</li>
<li><code>radical_filtration(algebra)</code> — computes rad^1, rad^2, ... dimensions until zero</li>
<li><code>compute_next_radical_power()</code> — generates rad^{k+1} from rad^k x rad products</li>
<li><code>find_gen_product_idempotents()</code> — searches length-2 products for idempotents</li>
<li><code>build_orthogonal_set()</code> — greedy maximal orthogonal idempotent set</li>
<li><code>compute_peirce_dim()</code> — Peirce block dimensions f_i <em> A </em> f_j via rank computation</li>
<li><code>try_add_to_echelon()</code> — incremental echelon basis for independence testing</li>
<li><strong>Approximate size</strong>: ~600 lines</li>
<li><strong>Notes</strong>: Key discovery: TL_3(delta=0) is SEMISIMPLE despite nilpotent generators (radical dim = 0). TL_2 is NOT semisimple (dual numbers). TL_4+ have non-trivial radicals.</li>
</ul>
<h3>4.2 General-Delta TL Analysis (Modular Arithmetic)</h3>
<ul>
<li><strong>What it does</strong>: Extends radical anatomy to arbitrary delta values using modular arithmetic (mod large prime) for exact computation.</li>
<li><strong>Introduced in</strong>: Demo 52</li>
<li><strong>Reused in</strong>: (Demo 52 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>analyze_tl_delta(n, delta_mod_p, prime)</code> — full analysis at arbitrary delta</li>
<li>Weighted Gram matrix with delta^loops weighting (not just 0/1 for delta=0)</li>
<li>Gaussian elimination mod p for exact radical dimension</li>
<li>Radical filtration and Peirce decomposition at general delta</li>
<li><strong>Approximate size</strong>: ~300 lines</li>
<li><strong>Notes</strong>: Tests 5 delta values: 0, 1, sqrt(2), phi, sqrt(3) for n=2..8. Reveals how semisimplicity varies across the Chebyshev parameter space.</li>
</ul>
<h3>4.3 Modular Arithmetic Utilities</h3>
<ul>
<li><strong>What it does</strong>: Prime-field arithmetic needed for exact computation at algebraic delta values.</li>
<li><strong>Introduced in</strong>: Demo 52</li>
<li><strong>Reused in</strong>: Demos 38, 39, 60, 85, 86</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>mod_reduce(x, p)</code> — reduction to [0, p)</li>
<li><code>mod_inv(x, p)</code> — modular inverse via extended Euclidean algorithm</li>
<li><code>mod_pow(base, exp, p)</code> — modular exponentiation</li>
<li><code>mod_sqrt_ts(n, p)</code> / <code>mod_sqrt()</code> — Tonelli-Shanks algorithm for modular square roots</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: Default prime p = 10^9+7. Separate prime (999999751) used for phi/sqrt(5). Demo 60 uses two independent primes (10^9+7 and 10^9+9) for cross-validation of cubic field results.</li>
</ul>
<h3>4.4 Gaussian Elimination / Gram Matrix</h3>
<ul>
<li><strong>What it does</strong>: Computes rank of trace form Gram matrix to determine radical dimension — the core tool for semisimplicity detection.</li>
<li><strong>Introduced in</strong>: Demo 51</li>
<li><strong>Reused in</strong>: Demos 38, 39, 52, 60, 102 (stacked TL generator radical dim computation), 103 (variable-dim radical dim), 104 (streaming catalog rank computation)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Gram matrix construction from multiplication table + trace form fixed points</li>
<li><code>compute_fixpt()</code> — precomputes sum of delta^loops over elements p such that result(p,k)=k, enabling efficient Gram matrix construction (Demo 39, 60)</li>
<li>Float-path Gaussian elimination (for small dims, gives integer vectors)</li>
<li>Mod-p Gaussian elimination (exact for any dim)</li>
<li><code>compute_rank()</code> / <code>matrix_rank_modp()</code> — forward elimination rank computation mod p (Demo 39, 60)</li>
<li>Null space extraction for radical basis</li>
<li>Augmented [G|I] row reduction for simultaneous radical basis and projection extraction (Demo 38)</li>
<li><strong>Approximate size</strong>: ~150 lines</li>
<li><strong>Notes</strong>: Radical dimension = algebra dimension - rank(Gram). All nonzero trace form fixed-point values are Catalan numbers.</li>
</ul>
<h3>4.5 Dimension Reduction at delta=0 (Quotient Algebra)</h3>
<ul>
<li><strong>What it does</strong>: Proves and exploits the fact that at delta=0, TL_n(0)/rad is isomorphic to TL_{n-1}(0) for even n, yielding asymptotic ~4x dimension reduction (~64x speedup for O(dim^3) matrix operations).</li>
<li><strong>Introduced in</strong>: Demo 38</li>
<li><strong>Reused in</strong>: (Demo 38 only — feeds into Demo 45-50 DKC research arc)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>count_through_strands()</code> — counts propagating (top-to-bottom matched) strands in a planar matching diagram; classifies basis elements by through-strand sector</li>
<li><code>sector_gram_rank()</code> — extracts per-sector Gram submatrix and computes rank independently</li>
<li><code>build_reduced_gen()</code> — projects TL generators onto the quotient basis using RREF pivot columns, yielding C_{n-1} x C_{n-1} reduced generators</li>
<li><code>verify_reduced_tl_relations()</code> — checks nilpotency (e_i^2=0), adjacent relation (e_i<em>e_{i+1}</em>e_i=e_i), and far commutativity on reduced generators</li>
<li><code>quotient_nonzero_products()</code> — counts nonzero products in the quotient multiplication table, verifying structural isomorphism with TL_{n-1}</li>
<li>Modular RREF with augmented [G|I] matrix — full row reduction over Z/pZ, tracks pivot columns, extracts radical basis from null rows and projection from RREF columns</li>
<li>Flat matrix algebra mod p: <code>mat_zero</code>, <code>mat_mul</code>, <code>mat_eq</code>, <code>mat_is_zero</code> over long integers mod prime</li>
<li><strong>Approximate size</strong>: ~781 lines (full demo)</li>
<li><strong>Notes</strong>: Even/odd dichotomy: odd n is semisimple (full rank C_n), even n has Gram rank C_{n-1}. Reduction factors: 2.00x (n=2), 2.80x (n=4), 3.14x (n=6), 3.33x (n=8), approaching 4x asymptotically. Through-strand sector j=0 is entirely DEAD (radical) at even n. Verified n=2 through n=8.</li>
</ul>
<h3>4.6 Symmetry Decomposition (Cellular Structure)</h3>
<ul>
<li><strong>What it does</strong>: Decomposes TL_n by through-strand count into cellular sectors, verifying sector sizes match cell module dimension formula d(n,j)^2, computing per-sector Gram ranks at multiple delta values, proving cell filtration monotonicity, and mapping the semisimplicity boundary.</li>
<li><strong>Introduced in</strong>: Demo 39</li>
<li><strong>Reused in</strong>: (Demo 39 only — provides algebraic explanation of DKC parity wall)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>cell_module_dim(n, j)</code> — computes d(n,j) = C(n,(n-j)/2) - C(n,(n-j)/2-1), the Graham-Lehrer cell module dimension formula</li>
<li><code>classify_sectors()</code> — partitions basis elements by through-strand count, returns sector j-values, counts, and number of distinct sectors</li>
<li><code>build_gram_sub()</code> — constructs the bilinear form restricted to a subset of basis elements, using fixpoint table and delta powers</li>
<li><code>compute_fixpt()</code> — precomputes sum of delta^loops over elements p such that result(p,k)=k, enabling efficient Gram matrix construction</li>
<li>Cell filtration verifier: exhaustively checks ts(a*b) &lt;= min(ts(a), ts(b)) for all diagram pairs</li>
<li>Generator block structure analyzer: checks block-lower-triangular vs block-diagonal form in sector-ordered basis</li>
<li>Multi-delta comparison: tests ranks at delta=0, 1, sqrt(2), phi simultaneously</li>
<li><code>find_l7_root()</code> — Cantor-Zassenhaus style cubic root finder for 2cos(pi/7) (minimal polynomial x^3-x^2-2x+1) over F_p</li>
<li><strong>Approximate size</strong>: ~1072 lines (full demo)</li>
<li><strong>Notes</strong>: Sector sizes verified: |V_j| = d(n,j)^2 for n=2..8. Cross-sector coupling grows: 0 (n=4), 4 (n=6), 104 (n=8). Critical finding: semisimple algebras are NOT block-diagonal in the standard basis — true change-of-basis needed. Graham-Lehrer semisimplicity boundary confirmed: TL_n semisimple iff n &lt; ell.</li>
</ul>
<h3>4.7 Cubic Number Field TL Analysis (ell=7)</h3>
<ul>
<li><strong>What it does</strong>: First test of Temperley-Lieb radical anatomy at a cubic number field — extends all dimension formulas from quadratic cases (ell=3-6) to the cubic case (ell=7), confirming universality of radical structure across number field degree.</li>
<li><strong>Introduced in</strong>: Demo 60</li>
<li><strong>Reused in</strong>: (Demo 60 only — feeds into Demo 61 angular proof)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>find_cubic_root()</code> — Cantor-Zassenhaus algorithm for finding roots of x^3-x^2-2x+1 mod p; uses x^p mod f(x) followed by polynomial GCD and randomized factoring</li>
<li><code>find_good_prime(start, root_out)</code> — searches for primes where the cubic minimal polynomial splits, returning both prime and verified root</li>
<li><code>analyze()</code> — complete radical anatomy pipeline: delta power precomputation, weighted fixed-point trace form, augmented Gram matrix, Gaussian elimination for rank, radical basis extraction, rad^2/rad^3 computation via product echelon, nilpotency determination</li>
<li><code>fibonacci_rank_test()</code> — decomposes rad^2 generator by through-strand sectors into bilinear matrices, computes rank of each sector, sums to verify F(ell-1) prediction</li>
<li><code>count_through_strands()</code> — through-strand classifier (reused from Demo 38/39)</li>
<li><code>matrix_rank_modp()</code> — generic Gaussian elimination rank computation on flat matrices mod p</li>
<li>Full polynomial arithmetic over F_p mod f(x): <code>poly_mul()</code>, <code>poly_pow()</code> (repeated squaring), <code>pdeg()</code>, <code>pmod()</code>, <code>pgcd()</code></li>
<li><strong>Approximate size</strong>: ~1012 lines (full demo)</li>
<li><strong>Notes</strong>: All formulas confirmed at ell=7: rad(TL_7)=11=2*7-3, rad(TL_8)=39=7^2-7-3, rad^2 is 1-dimensional, nilpotency=3, Fibonacci rank=F(6)=8. Cross-validated at two independent primes (10^9+7 and 10^9+9). Semisimple for n&lt;7, non-semisimple for n&gt;=7. Universality conjecture strengthened — radical structure independent of number field degree.</li>
</ul>
<h3>4.8 Three Gram Forms Infrastructure (Demo 39 Parts G-J)</h3>
<ul>
<li><strong>What it does</strong>: Computes fixpt, Markov, and cell module Gram matrices at the semisimplicity boundary, along with multi-level radical dimensions and Markov excess analysis.</li>
<li><strong>Introduced in</strong>: Demo 39 (Parts G-J)</li>
<li><strong>Reused in</strong>: (foundational for future RT truncation studies)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>build_markov_gram()</code>: constructs Markov trace bilinear form B_M(a,b) using closure loop counting</li>
<li><code>closure_loops()</code>: counts loops created when a TL diagram is planar-closed (top connected to bottom)</li>
<li>Cell module Gram verification: per-sector d(n,j) × d(n,j) Gram matrix for Graham-Lehrer bilinear form</li>
<li>Multi-level radical computation: radical at n=ℓ through n=ℓ+3 for each ℓ=2..7</li>
<li><strong>Approximate size</strong>: ~400 lines (Parts G-J combined)</li>
<li><strong>Notes</strong>: The prime p=1000002361 (≡1 mod 840) was chosen to guarantee all roots of unity for ℓ=2..7 exist as quadratic residues. Previous p=10^9+7 had 5 as QNR, making ℓ=5 appear semisimple erroneously.</li>
</ul>
<p>---</p>
<h2>5. Neural / Boolean</h2>
<h3>5.1 NPN Equivalence Classification</h3>
<ul>
<li><strong>What it does</strong>: Classifies all 256 3-input Boolean truth tables into 14 NPN equivalence classes (13 non-trivial + constant) via exhaustive application of input permutation, input negation, and output negation.</li>
<li><strong>Introduced in</strong>: Demo 23</li>
<li><strong>Reused in</strong>: Demos 45, 46, 47, 48, 49, 50, 55, 56, 57, 58, 59, 61, 62, 64, 65, 66, 67, 68, 69, 70, 71, 75, 76, 77, 78, 79, 80, 81, 82, 109</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>npn_canon[256]</code> — precomputed canonical form for all truth tables</li>
<li><code>npn_init()</code> — computes canonical forms via 96 transforms (6 perms x 8 input-neg x 2 output-neg)</li>
<li><code>npn_transform(tt, perm, neg_mask, out_neg)</code> — applies a single transform</li>
<li><code>npn_build_classes()</code> — extracts 13 non-trivial classes with orbit sizes</li>
<li><code>NPNClass</code> struct: canon_tt, orbit_size, topo_freq, convergence info</li>
<li><code>fn_name(tt)</code> — human-readable name lookup (~40 entries: AND, OR, XOR, MUX, MAJ, etc.)</li>
<li><code>are_perm_related(tt1, tt2)</code> — checks input-permutation equivalence</li>
<li><strong>Approximate size</strong>: ~130 lines</li>
<li><strong>Notes</strong>: 13 non-trivial classes: AND3' (0x01), AND2' (0x03), ~A(B^C) (0x06), ~A~(BC) (0x07), BUF (0x0F), EXACT1 (0x16), MAJ' (0x17), ISOLATE (0x18), 3v-0x19 (0x19), 3v-0x1B (0x1B), A^(B|C) (0x1E), XOR2 (0x3C), XNOR3 (0x69).</li>
</ul>
<h3>5.2 Expression Tree Boolean Compiler</h3>
<ul>
<li><strong>What it does</strong>: Compiles arbitrary Boolean expressions into braid-bracket evaluation trees, with derived gates (AND, OR, XOR) from the {NOT, NAND} universal set.</li>
<li><strong>Introduced in</strong>: Demo 19</li>
<li><strong>Reused in</strong>: Demos 20, 21</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>Expr</code> type: tagged union with <code>EXPR_VAR</code>, <code>EXPR_NOT</code>, <code>EXPR_NAND</code> nodes</li>
<li>Arena-based expression pool (<code>EXPR_POOL_SIZE=1024</code>, <code>expr_pool_reset()</code>)</li>
<li><code>expr_var(i)</code>, <code>expr_not(e)</code>, <code>expr_nand(a, b)</code> — constructors</li>
<li><code>expr_and(a, b)</code>, <code>expr_or(a, b)</code>, <code>expr_xor(a, b)</code> — derived gates</li>
<li><code>eval_expr(expr, inputs, A, gate_count)</code> — recursive evaluator with amplitude thresholding per gate</li>
<li><code>expr_size(expr)</code> — counts expression tree nodes</li>
<li><strong>Approximate size</strong>: ~150 lines</li>
<li><strong>Notes</strong>: Gate braid words: NOT = [-1,-1,-1,-1,-1,-1] (6 crossings), NAND = [-1,-1,-1,2,2] (5 crossings). Full adder verified (8/8 truth table entries). Evaluation angle: A = e^{i*5pi/4}.</li>
</ul>
<h3>5.3 Braid Logic Gate Infrastructure</h3>
<ul>
<li><strong>What it does</strong>: Searches for and evaluates specific braid words that compute classical logic gates via bracket amplitude thresholding.</li>
<li><strong>Introduced in</strong>: Demo 18</li>
<li><strong>Reused in</strong>: Demos 19, 20, 21, 22</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>GateResult</code> struct: gate word, strand count, length, best separation, optimal angle, threshold, found flag</li>
<li><code>gate_output(word, len, n, input_bit, A)</code> — 1-bit gate: prepends input sub-braid, evaluates bracket amplitude</li>
<li><code>gate_output_2bit(word, len, n, input_a, input_b, A)</code> — 2-bit gate</li>
<li><code>make_gate_braid(input_word, gate_word, full_braid)</code> — concatenates input encoding + gate template</li>
<li><code>compute_thresholds()</code> — dynamic threshold per angle (midpoint of high/low amplitudes)</li>
<li><strong>Approximate size</strong>: ~80 lines</li>
<li><strong>Notes</strong>: Input encoding: identity braid = 0, single crossing = 1. Gates work at multiple angles (not single fragile point). XOR not found at short lengths (non-threshold gate).</li>
</ul>
<h3>5.4 Complex-Valued Neural Network (Single Neuron)</h3>
<ul>
<li><strong>What it does</strong>: Single complex neuron with split-sigmoid activation that solves XOR with 6 real parameters where real networks need 9.</li>
<li><strong>Introduced in</strong>: Demo 27</li>
<li><strong>Reused in</strong>: Demo 28</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>CxNeuron</code> struct: w1, w2 complex weights + b complex bias = 6 real parameters</li>
<li><code>cx_neuron_init()</code> — random initialization</li>
<li><code>cx_neuron_forward(x1, x2)</code> — z = w1<em>x1 + w2</em>x2 + b → split-sigmoid → smooth XOR readout</li>
<li><code>cx_neuron_train_xor(epochs, lr)</code> — full backpropagation</li>
<li><code>cx_sigmoid(z)</code> — sigmoid applied independently to Re and Im</li>
<li>Smooth XOR decision: p = h.re<em>(1-h.im) + (1-h.re)</em>h.im</li>
<li><strong>Approximate size</strong>: ~150 lines</li>
<li><strong>Notes</strong>: Reproduces Nitta (2003) result. 20 training trials tracked with convergence rate.</li>
</ul>
<h3>5.5 Complex-Valued Neural Network (3-Hidden)</h3>
<ul>
<li><strong>What it does</strong>: 3-input complex network with 3 hidden neurons for training all 13 NPN classes of Boolean functions.</li>
<li><strong>Introduced in</strong>: Demo 45</li>
<li><strong>Reused in</strong>: Demos 46, 47</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>CxNet3</code> struct: wh[3][3] complex hidden weights, bh[3] complex biases, vo[6] real output weights, bo real bias (31 real parameters)</li>
<li><code>cxnet3_init()</code>, <code>cxnet3_forward()</code>, <code>cxnet3_train()</code> — initialization, forward pass with split-sigmoid, backprop</li>
<li><strong>Approximate size</strong>: ~200 lines</li>
<li><strong>Notes</strong>: All 13 NPN classes converge with 10 trials per class, max 50000 epochs.</li>
</ul>
<h3>5.6 Variable-Width Complex Network (CxNetVar)</h3>
<ul>
<li><strong>What it does</strong>: Variable hidden-neuron-count complex network (1-6 neurons) supporting multiple activation functions with activation-specific gradient computation.</li>
<li><strong>Introduced in</strong>: Demo 47</li>
<li><strong>Reused in</strong>: (Demo 47 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>CxNetVar</code> struct: variable hidden neuron count (nh=1..6)</li>
<li>Three activations: <code>cx_sigmoid()</code> (split-sigmoid), <code>cx_mvn_cont()</code> (z/|z|), <code>cx_mvn_k8()</code> (snap to nearest 8th root)</li>
<li><code>cx_activate(z, ActType)</code> — unified dispatch</li>
<li>Activation-specific backprop: sigmoid derivative, Jacobian of normalization (MVN), STE (MVN-k8)</li>
<li><strong>Approximate size</strong>: ~250 lines</li>
<li><strong>Notes</strong>: MVN converges 5-10x faster than split-sigmoid. More neurons help parity: nh=3→nh=6 drops pn-RMS from 0.89 to 0.51.</li>
</ul>
<h3>5.7 Multiple Activation Functions</h3>
<ul>
<li><strong>What it does</strong>: Collection of complex-valued activation functions with uniform classification interface for DKC Boolean function search.</li>
<li><strong>Introduced in</strong>: Demo 28 (split-sigmoid, modReLU, cardioid, phase-only)</li>
<li><strong>Extended in</strong>: Demo 47 (MVN-continuous, MVN-k8), Demo 50 (k-sector), Demo 55+ (Re&gt;0, Im&gt;0, magnitude), Demo 65 (generalized binary labeling — arbitrary binary sector coloring as activation), Demo 66 (quaternion Voronoi, 24-cell nearest-vertex), Demo 67 (eigenvalue k-sector, Hopf base/phase, Cayley-Klein, custom S² Voronoi), Demo 68 (stereographic Voronoi with S²/Euclidean metric), Demo 70 (dodecahedral/icosahedral Voronoi), Demo 71 (spherical harmonic reconstruction threshold), Demo 77 (S¹×S² combined product activation — Sec(k)×Voronoi, S³ Voronoi, polar direction×magnitude), Demo 81 (combined_cell Sec×Vor for capacity scaling), Demo 82 (sector activation with depth-tracked subsets)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>split_sigmoid_classify(z)</code> — smooth XOR of Re/Im sigmoids &gt; 0.5</li>
<li><code>sector_classify(z, k)</code> — k-sector MVN: angle → sector → j mod 2</li>
<li><code>re_positive_classify(z)</code> — Re(z) &gt; 0</li>
<li><code>im_positive_classify(z)</code> — Im(z) &gt; 0</li>
<li><code>magnitude_classify(z, tau)</code> — |z| &gt; tau</li>
<li><code>cx_sigmoid(z)</code> — sigmoid(Re) + i*sigmoid(Im)</li>
<li><code>cx_mvn_cont(z)</code> — z/|z| (unit circle normalization)</li>
<li><code>cx_mvn_k8(z)</code> — snap to nearest 8th root of unity</li>
<li><code>apply_activation(z, type)</code> — multi-activation dispatch</li>
<li><code>activation_backward()</code> — per-activation Jacobian for backprop</li>
<li><strong>Approximate size</strong>: ~120 lines</li>
<li><strong>Notes</strong>: Different activations access different sectors of the bracket algebra. Topology-frequency correlation REVERSES under MVN vs split-sigmoid.</li>
</ul>
<h3>5.8 Bracket Catalog Builder (Float)</h3>
<ul>
<li><strong>What it does</strong>: Enumerates braids across multiple strand counts and lengths, storing distinct complex bracket values as a codebook for DKC experiments.</li>
<li><strong>Introduced in</strong>: Demo 26</li>
<li><strong>Reused in</strong>: Demos 27, 28, 45, 46, 47</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>CxCatalogEntry</code> struct: braid word + full complex bracket + amplitude + phase</li>
<li><code>build_complex_catalog(max_strands, max_len, A)</code> — enumerates braids, stores values with |bracket| &gt; 0.5</li>
<li><code>find_nearest_cx(z, catalog)</code> — nearest-neighbor search in complex plane</li>
<li><code>find_nearest_amp(r, catalog)</code> — nearest-neighbor in amplitude only</li>
<li><strong>Approximate size</strong>: ~80 lines</li>
<li><strong>Notes</strong>: Typical catalog size: 64 distinct complex values from 2-3 strand braids length 1-8 at A = e^{i*5pi/4}. Covering radius estimated from random probes.</li>
</ul>
<h3>5.9 Exact Bracket Catalog Builder (Cyc8)</h3>
<ul>
<li><strong>What it does</strong>: Enumerates braids and builds catalog of distinct exact Z[zeta_8] bracket values with paired float representations.</li>
<li><strong>Introduced in</strong>: Demo 29</li>
<li><strong>Reused in</strong>: Demos 48, 49, 50, 108 (bracket catalog builder for parity vocabulary analysis)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>CatalogEntry</code> struct: exact Cyc8 value + float Cx value + source braid info</li>
<li><code>build_exact_catalog(max_strands, max_len)</code> — enumerates up to 100,000 braids per configuration</li>
<li>Deduplication by exact Cyc8 equality</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: ~100 distinct values from 2-3 strand braids length 1-8. At delta=0, amplitudes are integers.</li>
</ul>
<h3>5.10 Forward DKC Search Engine</h3>
<ul>
<li><strong>What it does</strong>: Exhaustive search over bracket catalog quartets/triples to find exact weight configurations that compute Boolean functions without training.</li>
<li><strong>Introduced in</strong>: Demo 29 (XOR triples)</li>
<li><strong>Extended in</strong>: Demo 48 (all 13 NPN classes, 100M quartets), Demo 50 (k-sector activation), Demo 64 (matroid deletion-contraction), Demo 65 (generalized binary labeling), Demo 66 (quaternionic S³), Demo 67 (multi-coordinate-system), Demo 68 (stereographic), Demo 69 (multi-root comparison), Demo 75 (multi-channel angle+cell search over 36 winning triples), Demo 76 (exhaustive C(24,4) quadruple search with conflict counting), Demo 77 (14-activation comparative search for XOR8), Demo 78 (recursive XOR10 from XOR8 parents), Demo 79 (multi-root recursive ladder at ζ₁₂), Demo 81 (snapshot-based XOR capacity scaling), Demo 82 (subset-based capacity measurement), Demo 108 (parity vocabulary with k=6 XOR3 search)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Quartet search: O(n^4) with precomputed partial sums (s12 outside w3 loop)</li>
<li><code>test_xor_triple(w1, w2, b)</code> — split-sigmoid XOR verification</li>
<li><code>search_for_k(k)</code> — exhaustive triple search with k-sector MVN activation</li>
<li>Per-NPN-class solution counting and example storage</li>
<li>Parity distance tracking (Hamming distance to 0x69/0x96)</li>
<li><strong>Approximate size</strong>: ~150 lines (varies by demo)</li>
<li><strong>Notes</strong>: Demo 48: 100M quartets, XNOR3 has exactly 0 solutions (split-sigmoid). Demo 50: parity reachable at k=6 with 906 solutions.</li>
</ul>
<h3>5.11 Multiplicative/Additive DKC Batch Search</h3>
<ul>
<li><strong>What it does</strong>: Unified search engine testing multiple activation functions simultaneously with both multiplicative (z = w1^x1 <em> w2^x2 </em> w3^x3) and additive (z = x1<em>w1 + x2</em>w2 + x3*w3) encodings.</li>
<li><strong>Introduced in</strong>: Demo 55</li>
<li><strong>Reused in</strong>: Demos 57, 58, 59</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>search_3input_batch(catalog, encode_mode, activations)</code> — runs ALL activations in single pass through catalog triples</li>
<li><code>search_2input(catalog, encode_mode, activations)</code> — 2-input variant</li>
<li>Encode modes: <code>ENCODE_MUL</code>, <code>ENCODE_ADD</code></li>
<li><code>Activation</code> table: name/function-pointer/param for batch dispatch</li>
<li>Per-NPN-class aggregation across activations</li>
<li><strong>Approximate size</strong>: ~150 lines</li>
<li><strong>Notes</strong>: Key discovery: additive Re&gt;0 reaches only 5/13 NPN classes (convexity constraint). Multiplicative Re&gt;0 reaches 11/13 universally across ell=4,5,6.</li>
</ul>
<h3>5.12 Truth Table from Braid</h3>
<ul>
<li><strong>What it does</strong>: Evaluates a braid word with closure and input encoding, determines optimal amplitude threshold, and returns an 8-bit truth table.</li>
<li><strong>Introduced in</strong>: Demo 22</li>
<li><strong>Reused in</strong>: Demos 23, 25</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>compute_tt(word, len, n, closure, A)</code> — evaluates all 8 input combinations, sorts amplitudes, finds largest-gap threshold, returns truth table (or -1 if no clean threshold)</li>
<li><strong>Approximate size</strong>: ~50 lines</li>
<li><strong>Notes</strong>: Input encoding: single crossing for bit=1, identity for bit=0. The largest-gap method finds the natural binary partition of amplitude values.</li>
</ul>
<h3>5.13 U(1) Gauge Sweep (Global)</h3>
<ul>
<li><strong>What it does</strong>: Finds the optimal global phase rotation that minimizes RMS distance from trained network weights to nearest bracket catalog entries.</li>
<li><strong>Introduced in</strong>: Demo 27</li>
<li><strong>Reused in</strong>: Demos 28, 45, 46</li>
<li><strong>Key types/functions</strong>:</li>
<li>360-angle sweep: rotates all weights by e^{i*theta}, computes RMS to nearest catalog entry</li>
<li><code>find_best_gauge(weights, catalog)</code> — returns best angle and RMS</li>
<li><strong>Approximate size</strong>: ~50 lines</li>
<li><strong>Notes</strong>: Optimal gauge angles cluster at pi/4 multiples (aligned with Z[zeta_8] structure). Single-parameter optimization (1D sweep).</li>
</ul>
<h3>5.14 Per-Neuron Gauge Sweep</h3>
<ul>
<li><strong>What it does</strong>: Independent U(1) rotation per hidden neuron (3D optimization for 3 neurons), improving on global gauge by ~20%.</li>
<li><strong>Introduced in</strong>: Demo 46</li>
<li><strong>Reused in</strong>: Demo 47</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>pn_gauge_3d()</code> — coarse 36^3 grid (10-degree steps) + refinement 11^3 (1-degree steps)</li>
<li><code>pn_gauge_coord()</code> — coordinate descent for nh &gt; 3 (72 steps/axis, 3 iterations)</li>
<li>Three-way comparison: global gauge vs per-neuron gauge vs amplitude-only</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: Key finding: amplitude-only (RMS 0.33) still beats per-neuron gauge (0.57) — phase decoherence from split-sigmoid is the bottleneck, not gauge approximation.</li>
</ul>
<h3>5.15 Measurement Matrix Framework</h3>
<ul>
<li><strong>What it does</strong>: Computes 4x8 amplitude matrices (4 closures x 8 inputs) per braid, then analyzes rank structure, mutual information, and SVD.</li>
<li><strong>Introduced in</strong>: Demo 25</li>
<li><strong>Reused in</strong>: (Demo 25 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>MeasMatrix</code> struct: 4x8 amplitude matrix + 4 thresholded truth tables + braid word</li>
<li><code>compute_meas_matrix()</code> — full measurement matrix for one braid across all closures and inputs</li>
<li><code>svd_4x8()</code> — SVD via M*M^T eigendecomposition</li>
<li><code>sym4x4_eigenvalues()</code> — Jacobi eigenvalue algorithm for 4x4 symmetric matrices</li>
<li>8x8 Jacobi eigenvalue solver for covariance analysis</li>
<li>Mutual information between closure pairs (joint/marginal frequency tables)</li>
<li>ANOVA (between/within class variance) for Hamming weight grouping</li>
<li><strong>Approximate size</strong>: ~200 lines</li>
<li><strong>Notes</strong>: All 1554 braids (lengths 1-4) have universal full rank 4. Parity confirmed unreachable (zero appearances).</li>
</ul>
<h3>5.16 Spearman Rank Correlation</h3>
<ul>
<li><strong>What it does</strong>: Computes Spearman rank correlation coefficient with tie handling for comparing ordinal rankings (e.g., topology frequency vs decomposition quality).</li>
<li><strong>Introduced in</strong>: Demo 45</li>
<li><strong>Reused in</strong>: Demos 46, 47, 48, 49</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>spearman_rho(x, y, n)</code> — Spearman rank correlation</li>
<li><code>assign_ranks(values, ranks, n)</code> — ranking with average tie-breaking</li>
<li><strong>Approximate size</strong>: ~40 lines</li>
<li><strong>Notes</strong>: Key finding: rho(RMS, topo_freq) = -0.8167 (forward-reverse duality).</li>
</ul>
<h3>5.17 Real Backprop Network (2-2-1)</h3>
<ul>
<li><strong>What it does</strong>: Standard 2-hidden-neuron real-valued sigmoid network for XOR, serving as baseline for complex network comparisons.</li>
<li><strong>Introduced in</strong>: Demo 26</li>
<li><strong>Reused in</strong>: Demo 27</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>RealXorNet</code> struct: 2-2-1 architecture (9 parameters)</li>
<li><code>real_net_init()</code>, <code>real_net_forward()</code>, <code>real_net_train_xor()</code> — full backprop</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: Baseline: 9 parameters, amplitude-only RMS = 0.2641.</li>
</ul>
<h3>5.18 Semicircle / Half-Plane Proof Framework</h3>
<ul>
<li><strong>What it does</strong>: Pure integer-arithmetic framework for proving which NPN classes are reachable by semicircle (half-plane) activations on multiplicative angle-sum encodings.</li>
<li><strong>Introduced in</strong>: Demo 61</li>
<li><strong>Reused in</strong>: Demo 62</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>truth_table(p1, p2, p3, theta, N)</code> — computes 8-bit truth table from integer angles mod N</li>
<li><code>in_semi(angle, theta, N)</code> — semicircle membership test</li>
<li><code>search(grid_n)</code> — exhaustive (p1, p2, p3) in Z_N^3 with 8 boundary positions</li>
<li><code>build_npn()</code> — NPN canonical form (includes output negation)</li>
<li><code>is_affine(tt)</code> — tests GF(2) affine subspace membership</li>
<li><code>masked_feasible(target, mask, grid_n)</code> — partial truth table feasibility</li>
<li><code>find_min_obstruction(target, grid_n)</code> — minimum infeasible constraint subset</li>
<li><code>wrap(angle)</code> — angle normalization</li>
<li><strong>Approximate size</strong>: ~200 lines</li>
<li><strong>Notes</strong>: Proves exactly 11/13 NPN classes reachable. 0x06 obstruction: parallelogram gap argument. 0x1B obstruction: 3-step algebraic contradiction. Zero floating-point in proof.</li>
</ul>
<h3>5.19 Octant-Sector Classification (Demo 63)</h3>
<ul>
<li><strong>What it does</strong>: Classifies Z[zeta_8] lattice points into 8 discrete octants, maps sector boundaries to class-1 octant sets, and computes oriented matroid types for weight triples.</li>
<li><strong>Introduced in</strong>: Demo 63</li>
<li><strong>Reused in</strong>: (foundational for future Z[zeta_16] scaling demos)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>angle_to_octant()</code>: classifies a Cyc8 value into one of 8 discrete octants (0-7)</li>
<li><code>cross_sign(a, b)</code>: sign of 2D cross product of two octant vectors</li>
<li><code>om_encode(s12, s13, s23)</code>: encodes oriented matroid type as a single integer from 3 pairwise cross-product signs</li>
<li><code>om_decode()</code>: decodes OM integer back to sign triple</li>
<li>Sector-octant mapping: iterates k-sector boundaries to compute class-1 octant set for arbitrary k</li>
<li><strong>Approximate size</strong>: ~80 lines</li>
<li><strong>Notes</strong>: Oriented matroid classification is the key tool for characterizing parity — alternating OM type is necessary and sufficient for 3-input parity.</li>
</ul>
<h3>5.20 Recursive N-Input Parity Search (Demo 63)</h3>
<ul>
<li><strong>What it does</strong>: General recursive search for n-input parity solutions in Z[zeta_8] MVN networks. Tests all 2^n-1 non-empty subset sums against sector-parity constraints.</li>
<li><strong>Introduced in</strong>: Demo 63</li>
<li><strong>Reused in</strong>: (foundational for future parity scaling studies)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>collect_class1(k)</code>: collects all class-1 sector vectors for given sector count k</li>
<li><code>compute_tt4_at_k(k)</code>: 4-input DKC truth table search with 4-level pruning (checks 1-weight, 2-weight, 3-weight, 4-weight sum parities)</li>
<li><code>pj_search(n, k)</code>: general recursive n-input parity search — iterates over all n-tuples of catalog values, checks all 2^n-1 subset sums for correct sector parity</li>
<li><strong>Approximate size</strong>: ~200 lines (Part H: 4-input ~80 lines, Part I: 5-input ~60 lines, Part J: recursive ~60 lines)</li>
<li><strong>Notes</strong>: Search pruning is critical for performance — 4-input uses early rejection at each weight addition. 5-input at k=15 has 7 class-1 octants (100 values each), making brute force feasible.</li>
</ul>
<h3>5.21 Matroid Deletion-Contraction Infrastructure (Demo 64)</h3>
<ul>
<li><strong>What it does</strong>: Exhaustive weight-set subtraction and contraction across the XOR parity hierarchy {XOR2, XOR3, XOR4, XOR5}, verifying 100% deletion-contraction closure (minor chain), tracking collision multiplicity, and analyzing vocabulary stratification.</li>
<li><strong>Introduced in</strong>: Demo 64</li>
<li><strong>Reused in</strong>: (foundational for future matroid/parity scaling studies)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Deletion map with collision tracking: for each XOR_n solution set, subtracts each weight and records which XOR_{n-1} child it maps to; counts distinct children vs. total instances to identify collisions</li>
<li>Upward extension search: for each XOR_n weight set, tests all 83 class-1 catalog values as candidate (n+1)-th weight, records Hamming distance to XOR_{n+1} truth table</li>
<li>Vocabulary stratification analysis: separates catalog values into good (appear in extensible sets), poison (appear only in orphan sets), and absent categories; annotates by octant</li>
<li>Error-weight decomposition: bins output errors by input Hamming weight (weight-0 through weight-6) to isolate interaction-level vs. single-weight failures</li>
<li>Self-doubling classifier: detects w[n+1]=w[i] cases; computes angle-preservation argument symbolically showing scalar doubling preserves sector class</li>
<li><strong>Approximate size</strong>: ~400 lines</li>
<li><strong>Notes</strong>: Key findings — 100% downward closure (deletion→XOR_{n-1}, contraction→XNOR_{n-1}) verified at all levels. Upward coverage collapses funnel-shaped: 99.3% → 39.2% → 19.2% → 0% from XOR3→XOR2 up to XOR6→XOR5. 44 good values / 31 poison values in the class-1 k=15 catalog; poison values avoid octant 4. Minimum wall Hamming distance is d=4; self-doubling accounts for 89.5% of closest misses. Exact Cyc8 arithmetic is mandatory — float arithmetic introduces 420 spurious failures near sector boundaries.</li>
</ul>
<h3>5.22 Generalized Binary Sector Labeling (Demo 65)</h3>
<ul>
<li><strong>What it does</strong>: Tests arbitrary binary colorings of k sectors (not just the standard odd/even convention) as DKC activations, enabling a much larger search space for XOR6 and XOR7 solutions.</li>
<li><strong>Introduced in</strong>: Demo 65</li>
<li><strong>Reused in</strong>: (Demo 65 only — new framework for non-standard MVN colorings)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>generalized_xor6_check(k)</code>: iterates over all (XOR5-set, extension-weight) candidate pairs at arbitrary k, tests all 2^k binary colorings for whether any coloring of k sectors realizes XOR6; reports passing count</li>
<li>Even/odd k landscape sweep: systematic sweep of even k=2..64 generalized XOR6 pass counts</li>
<li>Antipodal structure analyzer: decomposes n-tuple into antipodal pairs and lone weights, reports margin to sector boundaries</li>
<li>XOR7 broader search: extends from single extensions to all C(100,2) weight pairs, 136,350 7-tuples per k</li>
<li>Multi-catalog XOR search: runs full sector sweep with both 36-value and 56-value catalogs, distinguishes catalog incompleteness artifacts from genuine walls</li>
<li><strong>Approximate size</strong>: ~400 lines</li>
<li><strong>Notes</strong>: Key findings — absolute wall at k&lt;=23 (zero solutions under ANY binary labeling); first generalized XOR6 at k=24 (3 of 2700 pairs). All passing solutions have exactly zero margin to sector boundary (lattice sums land exactly on lattice directions). Even k works near threshold; odd k (25, 27, 29, 31) all fail. k=38 is sole even exception with zero solutions. Parity ceiling n=5 is algebra-independent: identical at Z[zeta_8] and Z[zeta_16]. Gap-of-2 hypothesis refuted: pigeonhole rises to 14 at Cyc16 but ceiling stays at n=5 (gap widens to 9).</li>
</ul>
<h3>5.23 SU(2) Braid Representation and 24-Cell Geometry (Demo 66)</h3>
<ul>
<li><strong>What it does</strong>: Lifts the Kauffman bracket from S^1 (complex trace) to S^3 (unit quaternion) via an SU(2) braid representation, generates the 24-cell polytope from braid enumeration, and searches for XOR6 solutions using quaternionic Voronoi activation.</li>
<li><strong>Introduced in</strong>: Demo 66</li>
<li><strong>Reused in</strong>: Demos 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82 (24-cell catalog and quaternion arithmetic used throughout the extended arc)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>quat_mul(p, q)</code>: quaternion multiplication (4-component real vector)</li>
<li><code>quat_norm(q)</code>: quaternion normalization to unit sphere S^3</li>
<li><code>quat_nearest_24cell(q, catalog)</code>: finds nearest 24-cell vertex by dot-product maximization</li>
<li><code>enumerate_braids(max_len, gen_sigma1, gen_sigma2, catalog)</code>: generates all braids up to target length, applies SU(2) generators, collects distinct quaternion outputs (finds exactly 24 = binary octahedral group)</li>
<li>Voronoi partition on S^3: assigns arbitrary unit quaternions to nearest 24-cell vertex; 25 cells = 24 vertices + 1 zero cell</li>
<li>Antipodal-pair XOR6 search: restricts combinatorial search to 3-antipodal-pair sextets; evaluates XOR6 over Voronoi cells</li>
<li>F4 symmetry orbit computation: generates all 576 two-sided symmetry elements of the 24-cell and groups solutions into orbits</li>
<li>Hash collision analysis: pair-table construction and four-way bracket/quaternion intersection counting</li>
<li><strong>Approximate size</strong>: ~500 lines</li>
<li><strong>Notes</strong>: SU(2) generators sigma_1 -&gt; (1+i)/sqrt(2), sigma_2 -&gt; (1-k)/sqrt(2). Produces exactly 24 quaternions from 87,890 braids (binary octahedral group). 35 Voronoi XOR6 solutions; universal 7/7/11 cell-label structure. F4 symmetry group (576 elements) decomposes 35 solutions into 6 orbits in two families: edge-dominant (22) and body-dominant (13). Complementary with bracket: quaternion resolves 450 bracket collisions; bracket resolves 8,424 quaternion collisions.</li>
</ul>
<h3>5.24 Eigenvector Extraction and Multi-Coordinate Activation (Demo 67)</h3>
<ul>
<li><strong>What it does</strong>: Decomposes SU(2) quaternions into eigenvector direction (S^2) and eigenvalue angle, then systematically compares all natural coordinate systems (Hopf, Cayley-Klein, eigenvalue k-sector, custom S^2 Voronoi) as DKC activations.</li>
<li><strong>Introduced in</strong>: Demo 67</li>
<li><strong>Reused in</strong>: Demos 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82 (13-direction S^2 Voronoi and eigenvector extraction are the canonical activation throughout <a href="./entries/demo_68.html">D68</a>-<a href="./entries/demo_82.html">D82</a>)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>eigenvector_extract(q, dir_out, theta_out)</code>: decomposes SU(2) quaternion into eigenvector direction (mod +-) and eigenvalue angle theta = arccos(a)</li>
<li>Custom Voronoi on S^2: assigns quaternion to nearest of 13 data-derived directions (3 axis + 6 edge-midpoint + 4 body-diagonal); handles identity/zero as degenerate cell 0</li>
<li>Platonic solid Voronois: octahedral (6 cells), icosahedral (12 cells), cuboctahedral (12 cells) — all yield zero XOR6 solutions</li>
<li>Hopf coordinate decomposition: converts quaternion to Hopf (eta, xi_1, xi_2); separates base (eta, xi_2) and fiber (xi_1) activations</li>
<li>Cayley-Klein parameterization: (|alpha|, arg(alpha)) grid activation</li>
<li>Eigenvalue k-sector activation: partitions [0, pi] into k equal sectors on eigenvalue angle theta</li>
<li>Comparative activation harness: unified XOR6 DKC search applicable across all coordinate systems; reports solutions and sol/cell efficiency</li>
<li><strong>Approximate size</strong>: ~400 lines</li>
<li><strong>Notes</strong>: Key finding: Hopf PHASE (fiber xi_1) carries zero DKC information at ALL tested resolutions (k=4..32, exhaustive). Computation lives entirely on S^2 Hopf base. Custom 13-dir Voronoi achieves 36 solutions at 14 cells (2.57 sol/cell) — more than full 25-cell S^3 Voronoi (35). Platonic solids fail because they have wrong symmetry group. Eigenvalue paradox: theta = arccos(a) succeeds; Hopf fiber xi_1 = atan2(b,a) fails — they extract different information. High-resolution rankings at 64 cells: Hopf base (292) &gt; eigenvector lat-lon (204) &gt; Cayley-Klein (106).</li>
</ul>
<h3>5.25 Stereographic Projection and ASCII Voronoi Renderer (Demo 68)</h3>
<ul>
<li><strong>What it does</strong>: Projects the S^2 eigenvector Voronoi onto R^2 via stereographic projection, renders solutions as ASCII images, extracts perceptron weights, and measures conformality via Monte Carlo area estimation.</li>
<li><strong>Introduced in</strong>: Demo 68</li>
<li><strong>Reused in</strong>: (Demo 68 only — visualization and planarity-proof infrastructure)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Stereographic projection / inverse: north-pole projection of S^2 to R^2 and back; round-trip precision ~1e-15 (machine epsilon); south pole is excluded as it coincides with a catalog direction</li>
<li>Projected Voronoi with S^2 metric: assigns R^2 query point to nearest of 13 projected centers using back-projected dot product; preserves all 36 solutions identical to Demo 67</li>
<li>Euclidean Voronoi in R^2: same structure but using Euclidean distance; yields ZERO solutions (preserved as negative-result comparison proving intrinsic curvature)</li>
<li>ASCII renderer: 65x33 grid over bounding box; renders 0/1 regions, Voronoi boundaries (+), weight positions (*), and center labels (0-9, A-C)</li>
<li>Perceptron weight extractor: builds 6x2 matrix from stereographic projections of winning solution weight quaternions</li>
<li>Monte Carlo area estimator: samples Voronoi cell areas in R^2 for conformality analysis; largest cell 17%, smallest 1%, ratio 16.5x</li>
<li><strong>Approximate size</strong>: ~350 lines</li>
<li><strong>Notes</strong>: Key finding: Euclidean metric in R^2 gives zero solutions; S^2 great-circle metric gives 36. Area distortion (16.5x) is irrelevant when S^2 metric is used — conformality is sufficient, area-preservation is not needed. The stereographic image is a valid visualization but not a valid computational domain. "Visualize on the plane, compute on the sphere." 13 catalog direction centers project to bounding box x in [-2.41, 1.37], y in [-1.00, 2.41].</li>
</ul>
<h3>5.26 Multi-Root SU(2) Catalog Comparison (Demo 69)</h3>
<ul>
<li><strong>What it does</strong>: Generates quaternion and eigenvector catalogs for multiple cyclotomic roots (zeta_8, zeta_16, zeta_32), verifies direction nesting (zeta_N subset zeta_{2N}), and compares XOR6 solution counts across roots at both natural Voronoi and fixed cell counts.</li>
<li><strong>Introduced in</strong>: Demo 69</li>
<li><strong>Reused in</strong>: (Demo 69 only — multi-root comparison infrastructure)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Multi-root catalog enumeration: generates quaternion and eigenvector catalogs for arbitrary zeta_N with configurable MAX_QCAT and MAX_ECAT caps; fair comparison at same braid enumeration depth across roots</li>
<li>Direction nesting comparator: for each zeta_8 direction, finds nearest match in zeta_{2N} catalog and reports angular distance; classifies as RIGIDITY (0 degrees), DRIFT (small positive), or INDEPENDENCE (large positive)</li>
<li>Adaptive Voronoi XOR6 search: builds natural Voronoi from catalog directions, enumerates all weight triples, reports sol/cell and percentage of C(N,3)</li>
<li>Fixed-resolution grid activation: lat-lon grid with specified cell count applied to all roots for apples-to-apples comparison</li>
<li>Catalog explosion enumeration: counts quaternions and directions as braid length grows for each root</li>
<li>Trivialization detection: identifies when solution rate approaches 100% (pigeonhole saturation — too many cells, too few constraint inputs)</li>
<li><strong>Approximate size</strong>: ~300 lines</li>
<li><strong>Notes</strong>: Key finding: zeta_8 -&gt; zeta_16 nesting is RIGID (13/13, 0.000 degrees drift). Algebraic proof: (zeta_16)^2 = zeta_8 so every zeta_8 braid word is a doubled word in zeta_16; squaring a quaternion preserves the rotation axis. zeta_8 is the computational sweet spot: coarsest root producing the 13-direction structure. At natural Voronoi resolution, zeta_16 (3,457 cells): 90.6% solutions; zeta_32 (4,096+ cells): 89.6% — pigeonhole trivialization. At fixed 16 cells: zeta_16 (450) &gt; zeta_32 (393).</li>
</ul>
<h3>5.27 Eigenvalue-to-Pitch Mapping and Braid Melody Extraction (Demo 70)</h3>
<ul>
<li><strong>What it does</strong>: Maps SU(2) quaternion eigenvalue angles to musical intervals and note names, extracts melodies from braid words, and provides spatial sound mapping from eigenvector directions to stereo pan and pitch.</li>
<li><strong>Introduced in</strong>: Demo 70</li>
<li><strong>Reused in</strong>: Demo 71 (musical note connection in spectral analysis)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Eigenvalue-to-interval mapping: quaternion trace -&gt; theta = arccos(trace/2) -&gt; cents = theta * (1200/pi) -&gt; note name (C=0, Eb=45, E=60, F#=90 degrees); covers unison through tritone</li>
<li>Braid word melody generator: running quaternion product per crossing; extracts note at each step from the partial product eigenvalue angle</li>
<li>Spatial sound mapper: eigenvector direction -&gt; latitude/longitude -&gt; MIDI pitch (C3 south to C5 north) + stereo pan (longitude)</li>
<li>Platonic solid vertex generators: icosahedron (12 vertices) and dodecahedron (20 vertices / 10 effective post-antipodal-collapse) for comparative Voronoi testing — both give zero XOR6 solutions</li>
<li>XOR6 checker: evaluates XOR6 truth table against arbitrary Voronoi cell assignments</li>
<li>ABC notation formatter: outputs top braid melodies in standard ABC music notation for rendering/playback</li>
<li><strong>Approximate size</strong>: ~300 lines</li>
<li><strong>Notes</strong>: 4 eigenvalue angles (0, 45, 60, 90 degrees) map to 4 notes (C, Eb, E, F#): maximum consonance to maximum dissonance. Conjugation-invariance of melody proven: tr(q) = 2cos(theta) is conjugation-invariant so melody depends only on product length not which generators used. Yang-Baxter relation sigma_1<em>sigma_2</em>sigma_1 = sigma_2<em>sigma_1</em>sigma_2 produces identical melodies step-by-step. Hopf orthogonality: pitch and spatial position are independent (Pearson r = -0.0624). Garside element (s1*s2)^3 melody: Eb E F# E Eb C. Tritone-antipodal correspondence: antipodal dodecahedron faces carry tritone pairs.</li>
</ul>
<h3>5.28 Spherical Harmonic Engine and Spectral Analysis (Demo 71)</h3>
<ul>
<li><strong>What it does</strong>: Full spherical harmonic analysis infrastructure for decomposing arbitrary S^2 functions into per-l-mode power, finding the phase-transition bandwidth for DKC solutions, and characterizing XOR6 Voronoi labelings spectrally.</li>
<li><strong>Introduced in</strong>: Demo 71</li>
<li><strong>Reused in</strong>: (foundational for future analytical S^2 bandwidth proofs)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Spherical harmonic engine: real Y_lm via associated Legendre polynomials with stable three-term recurrence; numerically stable to l=12+; orthonormality max error 6.82e-14</li>
<li>Gauss-Legendre quadrature on S^2: 64-point integration in theta; uniform 128-point grid in phi; 64x128=8,192 total grid points; produces integration weights on S^2</li>
<li><code>spectrum_of_function(voronoi_label_fn, l_max)</code>: decomposes arbitrary S^2 function (given as Voronoi label array evaluated over grid) into power per l-mode from l=0 to l_max</li>
<li><code>bandwidth_test(winners, l_cut)</code>: reconstructs function from spherical harmonic coefficients up to l_cut, evaluates winner recovery fraction; finds sharp phase-transition threshold</li>
<li>von Mises-Fisher density on S^2: direction density representation for the 13-direction catalog; high-kappa (kappa=50) approximation of point-like directions</li>
<li>Comparative spectrum harness: runs spectral decomposition over all 36 winners, aggregates power-per-mode statistics (mean, min, max per mode)</li>
<li><strong>Approximate size</strong>: ~450 lines</li>
<li><strong>Notes</strong>: Key finding: sharp phase transition at l=6 (0% recovery at l&lt;=5, 100% at l=6). The 13=13 theorem: minimum bandwidth l=6 because 2<em>6+1=13 = number of eigenvector directions — at l=5 system is underdetermined (11 components for 13 regions). l=6 mode carries ~80.7% of power on average across all 36 winners (spectral universality). Only even modes carry power (antipodal symmetry of the Voronoi partition). 3.5x super-Nyquist compression explained by compressed sensing (binary function at known support positions). Musical connection: l=6 maps to 200 cents (note D, whole tone) — above the eigenvalue-resonant modes (l=2 tritone, l=3 major 3rd, l=4 minor 3rd). Trivialization prediction for zeta_16: minimum bandwidth l&gt;=1728 (2</em>1728+1=3,457 directions), Nyquist ~3M cells — explains Demo 69's ~90% solution rate.</li>
</ul>
<p>---</p>
<h2>6. Utility</h2>
<h3>6.1 LCG Random Number Generator</h3>
<ul>
<li><strong>What it does</strong>: Linear Congruential Generator for reproducible random experiments across all DKC and neural network demos.</li>
<li><strong>Introduced in</strong>: Demo 13</li>
<li><strong>Reused in</strong>: Demos 26, 27, 28, 45, 46, 47, 48, 49, 50, 72 (perturbation trials for spherical optimizer), 88 (simulated annealing), 89 (random subset baselines), 90 (random subset loading), 92 (Monte Carlo census)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>rng_seed(s)</code> — set seed</li>
<li><code>rng_uniform()</code> — uniform [0, 1) double</li>
<li><code>rng_normal()</code> — standard normal via Box-Muller transform</li>
<li><strong>Approximate size</strong>: ~25 lines</li>
<li><strong>Notes</strong>: Standard LCG constants (multiplier, increment, modulus). Seed 12345 used for most baseline experiments. <a href="./entries/demo_89.html">D89</a>+ uses <code>shuffle()</code> companion (Fisher-Yates) for random subset generation.</li>
</ul>
<h3>6.2 Quantization</h3>
<ul>
<li><strong>What it does</strong>: Uniform quantize-dequantize for encoding bracket values at reduced bit depths.</li>
<li><strong>Introduced in</strong>: Demo 12</li>
<li><strong>Reused in</strong>: Demos 13, 16, 17</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>quantize(x, lo, hi, bits)</code> — scalar uniform quantization</li>
<li><code>cx_quantize(z, lo, hi, bits)</code> — independent Re/Im quantization</li>
<li><code>cx_ternary(z, threshold)</code> — {-1, 0, +1} per component (BitNet-style 1.58-bit)</li>
<li><code>cx_sign(z)</code> — quadrant / 1-bit per component</li>
<li><code>QuantVal</code> struct — integer quantized value</li>
<li><strong>Approximate size</strong>: ~40 lines</li>
<li><strong>Notes</strong>: Key finding: granny/square knots have identical amplitude (need phase to distinguish). Pareto frontier: precision x width trade-off.</li>
</ul>
<h3>6.3 Greedy Angle Selection</h3>
<ul>
<li><strong>What it does</strong>: Iteratively selects evaluation angles that maximize minimum pairwise bracket distance across all knot pairs.</li>
<li><strong>Introduced in</strong>: Demo 11</li>
<li><strong>Reused in</strong>: Demos 12, 13, 15, 16, 17</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>select_greedy_angles()</code> / <code>greedy_angles()</code> — max-min-distance greedy selection from 256-sample waveforms</li>
<li><code>count_separated_pairs()</code> — multi-angle pairwise distance check</li>
<li><code>pairwise_separation()</code> — finds best single angle, hardest pair, full separation matrix</li>
<li><code>min_dist_from_vals()</code> — minimum pairwise distance from precomputed values</li>
<li><strong>Approximate size</strong>: ~80 lines</li>
<li><strong>Notes</strong>: Best single angle (1.805<em>pi) independently converges to within 1.5% of WRT level-3 evaluation point (11</em>pi/6). 3 WRT angles on reduced bracket separate all 21 knot types.</li>
</ul>
<h3>6.4 WRT Angle Computation</h3>
<ul>
<li><strong>What it does</strong>: Computes Witten-Reshetikhin-Turaev evaluation angles for level r.</li>
<li><strong>Introduced in</strong>: Demo 15</li>
<li><strong>Reused in</strong>: (Demo 15 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>wrt_angle(r)</code> — theta = 2*pi - pi/(2r)</li>
<li><code>SepMetrics</code> struct: separated count, min_dist, mean_dist, sum_log_dist</li>
<li><code>measure_separation()</code> — full pairwise metrics for a set of angles</li>
<li><strong>Approximate size</strong>: ~50 lines</li>
</ul>
<h3>6.5 Delta Exponent Detection</h3>
<ul>
<li><strong>What it does</strong>: Determines how many factors of delta = -(A^2 + A^{-2}) divide the bracket polynomial.</li>
<li><strong>Introduced in</strong>: Demo 15</li>
<li><strong>Reused in</strong>: Demos 16, 17</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>delta_exponent(braid, A)</code> — evaluates bracket at 4 delta-zero angles (pi/4, 3pi/4, 5pi/4, 7pi/4) + perturbation test</li>
<li><code>reduced_bracket_at(braid, A)</code> — g(A) = bracket(A) / delta^k with zero-avoidance fallback</li>
<li><strong>Approximate size</strong>: ~50 lines</li>
<li><strong>Notes</strong>: Delta exponents take values {0, 1, 2} for test knots. The reduced bracket g has fewer zeros and better classification power.</li>
</ul>
<h3>6.6 Waveform Analysis</h3>
<ul>
<li><strong>What it does</strong>: Sweeps bracket evaluation around the full unit circle to produce waveform signatures for knot classification.</li>
<li><strong>Introduced in</strong>: Demo 11</li>
<li><strong>Reused in</strong>: Demo 12</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>compute_waveforms()</code> — 256-sample sweep for all knots</li>
<li><code>waveform_stats()</code> — min/max amplitude, dynamic range, zero count</li>
<li><code>ascii_waveforms()</code> — ASCII art visualization (60-column, 5 intensity bands)</li>
<li><code>cross_validate()</code> — consistency check with direct evaluation</li>
<li><code>test_symmetries()</code> — chiral amplitude identity, amphichiral reflection</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: Chiral pairs have identical amplitude waveforms; only phase distinguishes them.</li>
</ul>
<h3>6.7 Fortuin-Kasteleyn Partition Function</h3>
<ul>
<li><strong>What it does</strong>: Computes the FK cluster expansion of the Potts model partition function, bridging knot invariants to statistical mechanics.</li>
<li><strong>Introduced in</strong>: Demo 56</li>
<li><strong>Reused in</strong>: (Demo 56 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>LatticeStrip</code> struct: rectangular grid with edge arrays</li>
<li><code>build_strip(w, h)</code> — constructs lattice with horizontal + vertical edges</li>
<li><code>fk_partition(strip, Q, v)</code> — full 2^|E| subset enumeration with precomputed powers</li>
<li><code>ising_spin_sum(strip, v)</code> — direct 2^|V| spin configuration sum for integer-coupling cross-validation</li>
<li><strong>Approximate size</strong>: ~150 lines</li>
<li><strong>Notes</strong>: Establishes Q=delta^2 dictionary: ell=3→Q=1 (percolation, trivial), ell=4→Q=2 (Ising), ell=6→Q=3 (3-state Potts). FK values are algebraically richer (4D) than bracket values (2D Z[i]-axial).</li>
</ul>
<h3>6.8 Pairwise Separation Metrics</h3>
<ul>
<li><strong>What it does</strong>: Computes minimum pairwise distance, mean distance, and separation counts for knot classification evaluation.</li>
<li><strong>Introduced in</strong>: Demo 11</li>
<li><strong>Reused in</strong>: Demos 12, 13, 14, 15, 16, 17</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>pairwise_separation()</code> — best angle, hardest pair, full matrix</li>
<li><code>min_dist_from_vals()</code> — minimum pairwise distance from value arrays</li>
<li><code>count_separated_pairs()</code> — threshold-based pair counting</li>
<li><code>min_dist_subset()</code> / <code>min_dist_all()</code> — for knot subsets</li>
<li><strong>Approximate size</strong>: ~40 lines</li>
</ul>
<h3>6.9 Cantor-Zassenhaus Root Finding</h3>
<ul>
<li><strong>What it does</strong>: Probabilistic algorithm for finding roots of polynomials over finite fields, used to compute modular representations of algebraic numbers like 2cos(pi/7).</li>
<li><strong>Introduced in</strong>: Demo 39 (specialized cubic for ell=7)</li>
<li><strong>Reused in</strong>: Demo 60 (generalized with prime search)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>find_l7_root()</code> (Demo 39) / <code>find_cubic_root()</code> (Demo 60) — finds root of x^3-x^2-2x+1 mod p using x^p mod f(x) followed by polynomial GCD</li>
<li><code>find_good_prime(start, root_out)</code> (Demo 60) — searches for primes where the cubic splits completely, returns both prime and verified root</li>
<li>Polynomial GCD and reduction over F_p</li>
<li><strong>Approximate size</strong>: ~80 lines</li>
<li><strong>Notes</strong>: The cubic x^3-x^2-2x+1 is the minimal polynomial of 2cos(pi/7), the first non-quadratic case in the Chebyshev parameter hierarchy. Not all primes split the cubic — the search routine finds suitable primes automatically. Two independent primes used for cross-validation.</li>
</ul>
<p>---</p>
<h2>7. Spherical Design and Geometric Optimization</h2>
<h3>7.1 Spherical t-Design Tester</h3>
<ul>
<li><strong>What it does</strong>: Tests whether a finite point set on S² achieves the t-design property by computing max |S_{l,m}| for each l up to t, where S_{l,m} = (1/N) Σ Y_lm(p_i). Supports both directed (N points) and undirected (antipodal identification) modes, and independent even/odd mode streams.</li>
<li><strong>Introduced in</strong>: Demo 72</li>
<li><strong>Reused in</strong>: Demo 88 (<code>design_residual</code> for anti-correlation analysis and constrained optimization), Demo 90 (spherical harmonic decomposition of S² point clouds for spectral inversion analysis)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Real spherical harmonics Y_lm evaluated at arbitrary direction vectors (associated Legendre + trig)</li>
<li><code>design_residual(pts, N, T)</code>: computes max over l=1..T of max_m |S_{l,m}|; single reusable quality metric</li>
<li>Even/odd mode separation: independent t-design test for even and odd l separately</li>
<li>S³ monomial design test: tests degree-d polynomial averages over quaternion sets against exact S³ integrals via double-factorial formula</li>
<li>Delsarte bound lookup: theoretical minimum N for degree-t designs on S^d</li>
<li><strong>Approximate size</strong>: ~200 lines</li>
<li><strong>Notes</strong>: Key finding: the 13 eigenvector directions are t=0 (worst possible) for directed design but t_even=2 for even modes (DKC-relevant). First DKC-relevant (even) failure is l=4. The undirected 26-point configuration (both ± directions) achieves t=3. Design quality anti-correlates with DKC computational quality: better-distributed designs give fewer XOR6 solutions (36 vs 4).</li>
</ul>
<h3>7.2 Stochastic Spherical Optimizer</h3>
<ul>
<li><strong>What it does</strong>: Gradient-free simulated annealing optimizer that minimizes the t-design residual of an N-point configuration on S² via Gaussian perturbation and normalization. Used to find "geometrically optimal" directions for comparison with the algebraically selected eigenvectors.</li>
<li><strong>Introduced in</strong>: Demo 72</li>
<li><strong>Reused in</strong>: (Demo 72 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Gaussian perturbation + re-normalization: perturbs each coordinate by N(0,σ), renormalizes to unit sphere; no explicit gradient</li>
<li>Simulated annealing: 20 random restarts, 2000 steps each; accept-by-improvement only (T=0 SA)</li>
<li><code>count_xor6_ext(pts, N)</code>: counts XOR6 solutions for an arbitrary direction set (not just the canonical 13)</li>
<li>LCG + Box-Muller for perturbation trials (self-contained, no stdlib rand dependency)</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: Achieves 2.6× better geometric distribution vs eigenvectors (residual 0.93 vs 2.43) with only 4 XOR6 solutions vs 36. Confirms Algebra &gt; Geometry Principle.</li>
</ul>
<h3>7.3 Perturbation Sensitivity Harness</h3>
<ul>
<li><strong>What it does</strong>: Applies random angular perturbations (1°, 5°, 10°, 20°) to the canonical 13-direction configuration and measures mean XOR6 solution count over multiple trials, establishing robustness thresholds.</li>
<li><strong>Introduced in</strong>: Demo 72</li>
<li><strong>Reused in</strong>: (Demo 72 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Spherical cap perturbation: rotate direction by random angle up to δ around random axis via cross product + Rodrigues formula</li>
<li>Batch trial loop: N_TRIALS replicates per perturbation magnitude; accumulates mean count</li>
<li>Non-monotonicity detector: reports when perturbed mean exceeds unperturbed count (local optimum signature)</li>
<li><strong>Approximate size</strong>: ~80 lines</li>
<li><strong>Notes</strong>: Robustness threshold ~5° (matching Voronoi cell angular radius). Non-monotonic at 1° (mean 38 &gt; baseline 36) indicates local-not-global optimum. Collapses at 10° (mean 11.5). The algebraic placement is sharp to ~5°.</li>
</ul>
<p>---</p>
<h2>8. Automaton / Trajectory Analysis</h2>
<h3>8.1 Generic Automaton Determinism Checker</h3>
<ul>
<li><strong>What it does</strong>: Given a trajectory array (N_inputs × N_steps) of state assignments, measures what fraction of (prev_state, input_bit, step) triples are deterministic — i.e., always produce the same next state regardless of history. Reports per-step determinism and prints split events.</li>
<li><strong>Introduced in</strong>: Demo 73</li>
<li><strong>Reused in</strong>: (Demo 73 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>determinism_test(trajs, N_inputs, N_steps, n_states)</code>: full report version with split event printing</li>
<li><code>determinism_pct(trajs, N_inputs, N_steps, n_states)</code>: quiet version returning fraction; used in batch loop over all 36 winners</li>
<li>Split event: a (prev_cell, bit, step) triple where different histories reaching the same cell produce different next cells</li>
<li><strong>Approximate size</strong>: ~80 lines</li>
<li><strong>Notes</strong>: Found universal structural constant: all 36 XOR6 winning triples have exactly 82.8% (48/58) determinism. Universality follows from binary octahedral group acting transitively on the 13 directions.</li>
</ul>
<h3>8.2 Multiplicative vs Additive Trajectory Builder</h3>
<ul>
<li><strong>What it does</strong>: Computes the per-input cell-trajectory tables for both the multiplicative braid product formulation and the additive weight-sum formulation of DKC, enabling comparison of their automaton properties.</li>
<li><strong>Introduced in</strong>: Demo 73</li>
<li><strong>Reused in</strong>: (Demo 73 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>compute_mul_trajectories(trajs)</code>: 64×6 cell trajectory table for braid product M = σ₁^±1 · σ₂^±1 · ...</li>
<li><code>compute_add_trajectories(triple, trajs)</code>: 64×6 cell trajectory table for additive sum S_k = S_{k-1} + w_k</li>
<li><code>vor_cell_signed(q)</code>: signed Voronoi partition (26 directions, no antipodal identification); returns cell in 0..25 with identity pseudo-cell at 26</li>
<li>Distinct partial sum counter: counts unique quaternion vectors at each step (O(N²) exact comparison)</li>
<li>Sufficient statistic tester: for each cell at each step, checks whether all inputs reaching that cell have a consistent final output</li>
<li><strong>Approximate size</strong>: ~150 lines</li>
<li><strong>Notes</strong>: Key finding: multiplicative formulation cannot compute XOR6 at all — every cell is perfectly balanced (parity-blind by M→M⁻¹ argument). Additive formulation achieves 82.8% determinism and computes XOR6. 27 cells needed for 100% direction-level determinism; signed 27-cell partition only reaches 87.1%.</li>
</ul>
<h3>8.3 Cell Collision Detector</h3>
<ul>
<li><strong>What it does</strong>: Identifies instances where distinct quaternion partial sums land in the same Voronoi cell, characterizing the source of non-determinism in the DKC automaton.</li>
<li><strong>Introduced in</strong>: Demo 73</li>
<li><strong>Reused in</strong>: (Demo 73 only — the concept is central to all <a href="./entries/demo_74.html">D74</a>+ analyses)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Pair-scan over all partial sums at each step: O(N²) collision detection</li>
<li>Collision classification: same cell but different magnitude vs different eigenvalue angle</li>
<li>Cell 0 split count: specific tracking for the main non-determinism source</li>
<li><strong>Approximate size</strong>: ~60 lines</li>
<li><strong>Notes</strong>: 1,296 collision instances across all steps (N_inputs=64, N_steps=6). Cell 0 is the main split point. The Voronoi cell discards magnitude information (odometer) — this is the precise source of non-determinism.</li>
</ul>
<p>---</p>
<h2>9. Braid Invariant Comparison</h2>
<h3>9.1 Full Catalog Builder with Bracket Computation</h3>
<ul>
<li><strong>What it does</strong>: Simultaneously computes Kauffman bracket at A=-ζ₈ and SU(2) quaternion for every braid up to length 8 on 2 and 3 strands, building a unified correspondence record for collision and separation analysis between the two invariants.</li>
<li><strong>Introduced in</strong>: Demo 74</li>
<li><strong>Reused in</strong>: (Demo 74 only — the 2,000-braid correspondence dataset is specific to this analysis)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Per-braid <code>CorrespondenceRecord</code> struct: stores (quaternion, bracket, qcat_idx, bcat_idx, braid_word, word_len, n_strands) simultaneously</li>
<li>Union-find loop counter reused for TL state-sum bracket (exact Cyc8)</li>
<li>Braid word enumerator reused for catalog generation</li>
<li>Deduplication at both quaternion catalog and bracket catalog levels</li>
<li><strong>Approximate size</strong>: ~150 lines</li>
<li><strong>Notes</strong>: 2,000 braids yield 24 distinct quaternions, 100 distinct bracket values, 119 (bracket,cell) combined classes. The combined invariant is 19% finer than bracket alone.</li>
</ul>
<h3>9.2 Bracket Collision Separation Analysis</h3>
<ul>
<li><strong>What it does</strong>: Given a correspondence dataset, counts pairs by (same/different bracket) × (same/different cell) at both the braid level and the quaternion-catalog level; computes the separation fractions in both directions.</li>
<li><strong>Introduced in</strong>: Demo 74</li>
<li><strong>Reused in</strong>: (Demo 74 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Braid-level pair scan: O(N²) over all braid pairs; classifies into (B=B', Q=Q'), (B=B', Q≠Q'), (B≠B', Q=Q'), (B≠B', Q≠Q')</li>
<li>Catalog-level pair scan: O(24²) over unique quaternions; same 4-way classification</li>
<li>Separation fraction computation: fraction of bracket collisions separated by cell (97.8% at braid level), fraction of cell collisions separated by bracket (54% at catalog level)</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: Key finding: the two invariants capture orthogonal information — neither subsumes the other. Cell separates 97.8% of bracket collisions; bracket separates 54% of cell collisions.</li>
</ul>
<h3>9.3 Computational Type Vector Extractor</h3>
<ul>
<li><strong>What it does</strong>: For each of the 14 Voronoi cells, computes the 36-bit type vector encoding its parity label (0 or 1) under each of the 36 XOR6 winning triples. Groups cells by identical type vector to identify the 6 computational orbit types.</li>
<li><strong>Introduced in</strong>: Demo 74</li>
<li><strong>Reused in</strong>: (Demo 74 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>TypeVec</code> struct: 36-bit array (one per winning triple) representing the cell's parity role</li>
<li><code>typevec_eq()</code>: equality check for type vector comparison</li>
<li><code>compute_type_vectors(winners, cells, catalog)</code>: fills type vector for all 14 cells from all 36 winning triples</li>
<li><code>braid_type_idx(cell)</code>: maps cell index to type index (0–5)</li>
<li>Orbit type map: axis-σ₁ (type 0), axis-σ₂ (type 1), body-60° (type 2), edge (type 3), axis-third (type 4), identity (type 5)</li>
<li><strong>Approximate size</strong>: ~80 lines</li>
<li><strong>Notes</strong>: 6 computational types from 14 cells — 4 body cells are interchangeable, 6 edge cells are interchangeable. The DKC computation is invariant under permutation within each symmetry orbit.</li>
</ul>
<h3>9.4 Refinement Chain Builder</h3>
<ul>
<li><strong>What it does</strong>: Constructs the hierarchical refinement chain bracket → type → quaternion for the set of braids in the correspondence dataset, reporting subgroup counts at each level.</li>
<li><strong>Introduced in</strong>: Demo 74</li>
<li><strong>Reused in</strong>: (Demo 74 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li>For each of the 100 bracket values appearing in braids, partition its braids by type vector (type subgroups)</li>
<li>For each type subgroup, partition by quaternion (quaternion subgroups)</li>
<li>Chain: 43 bracket groups → 61 type subgroups → 168 quaternion subgroups</li>
<li>Max types per bracket value: 4; max quaternions per type within a bracket: 8</li>
<li><strong>Approximate size</strong>: ~60 lines</li>
<li><strong>Notes</strong>: Chain uses only braids appearing in the length-1–8 catalog. The ratio (bracket→type→quat) is an empirical measure of how much information the type vector adds beyond the bracket.</li>
</ul>
<p>---</p>
<h2>10. Multi-Channel DKC and Activation Architecture</h2>
<h3>10.1 Quaternion Arithmetic Suite (Demos 75–82)</h3>
<ul>
<li><strong>What it does</strong>: Full quaternion arithmetic — add, multiply, conjugate, normalize, eigenvalue-angle extraction — shared across the extended DKC arc from Demo 75 onward. Includes the core binocular channel decomposition.</li>
<li><strong>Introduced in</strong>: Demo 66 (core); extended with angle/magnitude analysis in Demo 75</li>
<li><strong>Reused in</strong>: Demos 75, 76, 77, 78, 79, 80, 81, 82</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>eigenvalue_angle(q)</code>: computes rotation half-angle arccos(q.a) for a unit quaternion (S¹ component)</li>
<li><code>classify_magnitude(s)</code>: bins |S| into algebraic classes {√0, √1, √2, √3, √4, √6}; identifies the √n pattern</li>
<li><code>mutual_information(chan_a, chan_b, N)</code>: entropy-based MI computation for two discrete channels over N inputs</li>
<li><code>triple_angle_function(triple, masks, N)</code>: maps each of N input masks to an angle class for a given winning triple</li>
<li><code>product_channel_analysis(catalog, triple)</code>: computes quaternion product and extracts eigenvalue + eigenvector for the multiplicative channel</li>
<li><strong>Approximate size</strong>: ~120 lines (angle/channel extensions beyond <a href="./entries/demo_66.html">D66</a> core)</li>
<li><strong>Notes</strong>: Seven distinct eigenvalue angles appear in additive sums: 0°, 30°, 35.264°, 45°, 60°, 65.905°, 90°. The three non-canonical angles (30°, 35.264°, 65.905°) arise only through quaternion addition breaking the 24-cell group structure. √5 is algebraically unreachable from the 24-cell inner product structure.</li>
</ul>
<h3>10.2 14-Activation Comparison Framework</h3>
<ul>
<li><strong>What it does</strong>: Exhaustive search over all C(24,k) k-tuples under each of 14 distinct activation functions in a single loop, with pluggable activation callback. The canonical benchmark harness for the <a href="./entries/demo_77.html">D77</a> activation zoo.</li>
<li><strong>Introduced in</strong>: Demo 77</li>
<li><strong>Reused in</strong>: Demo 78 (test_combined reused), Demo 81 (combined_cell reused)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>sector_activate(q, k)</code>: bins quaternion eigenvalue angle into k equal sectors on [0°, 360°); Aizenberg MVN in quaternion context</li>
<li><code>polar_activate(q, n_dir, n_mag)</code>: joint direction (Voronoi cell) × magnitude bin; configurable bin count for magnitude axis</li>
<li><code>s3_voronoi_activate(q, catalog)</code>: nearest-quaternion in 24-cell catalog on S³ (no antipodal identification)</li>
<li><code>product_activate(q, k_sec, n_dir)</code>: S¹ × S² combined activation; cell = sector_index * n_dir + voronoi_cell; the key new activation enabling XOR8</li>
<li>Accuracy ladder: 14 activations ranked by best XOR8 accuracy — S²Vor(50%) → Sec4(77.7%) → Sec8(85.2%) → S³Vor(90.2%) → ... → Sec8×Vor(100%)</li>
<li><strong>Approximate size</strong>: ~200 lines</li>
<li><strong>Notes</strong>: Critical finding: neither S¹ (sector) alone nor S² (Voronoi) alone can compute XOR8. Only the product S¹ × S² achieves 100%. This confirms the incomparability of bracket and cell invariants (Demo 74) is computationally load-bearing.</li>
</ul>
<h3>10.3 Combined Sec(k)×Vor Activation (<code>test_combined</code> / <code>combined_cell</code>)</h3>
<ul>
<li><strong>What it does</strong>: Pre-computes all 2^N quaternion sums for a given N-tuple once, then tests multiple k-sector values cheaply by sweeping k without recomputing sums. The combined activation maps each sum to (sector, Voronoi-cell) pair. Used as the standard XOR tester for all <a href="./entries/demo_78.html">D78</a>-<a href="./entries/demo_92.html">D92</a> capacity searches.</li>
<li><strong>Introduced in</strong>: Demo 78 (as <code>test_combined</code>)</li>
<li><strong>Reused in</strong>: Demos 79, 80, 81, 82, 83 (via <code>find_capacity</code>), 84 (via <code>find_capacity</code> + <code>count_xor6_at_k</code>), 87, 88, 89, 90, 91, 92 (standard activation infrastructure throughout the depth-law and function-scaling arcs)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>test_combined(indices, n_idx, k_sec, acc_out)</code>: generic XOR tester; pre-computes all 2^N sums, caches angle and cell, sweeps k values cheaply</li>
<li><code>combined_cell(q, k_sec, n_dir)</code>: maps a quaternion sum to a (sector × n_dir + voronoi_cell) index; the inner function used in capacity surveys</li>
<li>Early-exit XOR verification with sparse cell cleanup via <code>touched_cells[]</code> array</li>
<li>Handles up to 4096 masks and 512 cells without heap allocation</li>
<li><strong>Approximate size</strong>: ~80 lines</li>
<li><strong>Notes</strong>: The pre-computation pattern (compute all 2^N sums once, then sweep k values) is the critical performance optimization for the <a href="./entries/demo_78.html">D78</a>–<a href="./entries/demo_82.html">D82</a> capacity survey work — avoids redundant sum computation across multiple k tests.</li>
</ul>
<h3>10.4 Paired Quaternion Detector</h3>
<ul>
<li><strong>What it does</strong>: For a winning k-tuple, enumerates all C(k, k-2) sub-tuples (dropping pairs) to identify "shadow" or "paired" quaternions — entries sharing the same eigenvector direction but differing in eigenvalue angle. Establishes the recursive structure of XOR winners.</li>
<li><strong>Introduced in</strong>: Demo 77 (as <code>xor6_subsets</code>)</li>
<li><strong>Reused in</strong>: Demo 78 (<code>part_e_recursive</code> verifies shadow structure for XOR8→XOR6 decomposition)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>xor6_subsets(quad_indices)</code>: for a winning quadruple, enumerates all C(4,3)=4 triples and identifies which are XOR6 winners</li>
<li><code>part_e_recursive(winners8, n8, winners6, n6)</code>: verifies parent-shadow structure — reports cell sharing, half-angle, and pairing for each shadow</li>
<li>Shadow detection: checks that dropped element shares Voronoi cell with at least one remaining parent element; verifies half-angle</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: All 6 XOR8 winners contain exactly 2 XOR6-winning triple subsets. All shadows have eigenvalue half-angle = 45°. Shadow pairs are {0,1}, {4,5}, {19,21} — each pair shares direction and half-angle, differs only in sign/orientation. Recursive Shadow Conjecture confirmed for XOR6→XOR8.</li>
</ul>
<h3>10.5 Exhaustive k-Tuple Search with Conflict Counting</h3>
<ul>
<li><strong>What it does</strong>: Enumerates all C(N,k) index k-tuples from a quaternion catalog, computes all 2^(2n) sums under a given activation, counts conflict cells (cells containing both even and odd parity inputs), and returns the minimum conflict count and best accuracy.</li>
<li><strong>Introduced in</strong>: Demo 76 (quadruple search for XOR8)</li>
<li><strong>Reused in</strong>: Demo 78 (quintuple search for XOR10)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>conflict_count(weights, k, activation)</code>: counts Voronoi cells containing mixed parity masks</li>
<li><code>best_accuracy(weights, k, activation)</code>: majority-vote accuracy per cell for non-zero-conflict configurations</li>
<li>Direction concentration metric: counts cells used and fraction of masks per dominant cell</li>
<li>Eigenvalue angle histogram: bins sum-quaternion angles to discover algebraic structure at different input counts</li>
<li>Deduplication with <code>is_win6/8/10</code> linear-scan lookups to prevent redundant testing</li>
<li><strong>Approximate size</strong>: ~120 lines</li>
<li><strong>Notes</strong>: C(24,4)=10,626 quadruples for XOR8; C(24,5)=42,504 quintuples for XOR10 (both fully exhausted). 4-term sums yield 86 near-continuous angles vs 7 discrete for 3-term sums — algebraic structure breakdown.</li>
</ul>
<p>---</p>
<h2>11. Group Theory and Algebraic Structure</h2>
<h3>11.1 Group Closure Algorithm (<code>build_closure</code>)</h3>
<ul>
<li><strong>What it does</strong>: Starting from a set of generators (and their inverses and the identity), iteratively multiplies all current group elements by all generators until no new elements appear or a size cap is hit. Returns 1 if the group is finite (closed below cap), 0 if it hit the cap (infinite).</li>
<li><strong>Introduced in</strong>: Demo 80</li>
<li><strong>Reused in</strong>: Demo 81 (as <code>init_su2_generators</code> + BFS closure with snapshot tracking), Demo 82 (closure with depth tracking), Demo 83 (writhe tracking added alongside depth), Demo 84 (writhe tracking + cross-root loop), Demos 87, 88, 89, 90, 91, 92 (standard BFS closure with depth tracking — core infrastructure for all <a href="./entries/demo_87.html">D87</a>-<a href="./entries/demo_92.html">D92</a> experiments)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>build_closure(generators, n_gen, catalog_out, max_size, rounds_out)</code>: generic closure; quaternion multiplication with deduplication by tolerance comparison</li>
<li>Closure round tracking: records which round each element was born in (gives depth/crossing-depth interpretation)</li>
<li>Convergence test: compares pre/post element count; terminates when stable</li>
<li><code>g_writhe[]</code> array (added <a href="./entries/demo_83.html">D83</a>/<a href="./entries/demo_84.html">D84</a>): updated alongside <code>g_depth[]</code>; each new product inherits parent writhe plus generator writhe contribution (σ₁=+1, σ₁⁻¹=-1, σ₂=+1, σ₂⁻¹=-1)</li>
<li><strong>Approximate size</strong>: ~80 lines (core); ~10 lines added for writhe tracking in <a href="./entries/demo_83.html">D83</a>-<a href="./entries/demo_84.html">84</a></li>
<li><strong>Notes</strong>: ζ₄ closes in 2 rounds (4 elements, Binary Dihedral Q₄); ζ₈ closes in 4 rounds (24 elements, Binary Octahedral). All other tested roots (ζ₆, ζ₁₀, ζ₁₂, ζ₁₆, ζ₂₀) hit the cap (infinite groups). Writhe range at ζ₁₂ (4096 entries): [-9, 9]; 91.4% of entries have nonzero writhe.</li>
</ul>
<h3>11.2 ADE Type Detector</h3>
<ul>
<li><strong>What it does</strong>: Maps a finite SU(2) subgroup (identified by order) to its ADE classification — binary cyclic (A), binary dihedral (D), binary tetrahedral/octahedral/icosahedral (E₆/E₇/E₈).</li>
<li><strong>Introduced in</strong>: Demo 80</li>
<li><strong>Reused in</strong>: (Demo 80 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>identify_ade(order)</code>: maps group size to ADE string; handles Q₄ (order 8), binary tetrahedral (24), binary octahedral (48), binary icosahedral (120), binary dihedral (4n), cyclic (n)</li>
<li><code>RootResult</code> struct: compact per-root survey storage (N, angle, finite flag, size, rounds, dirs, angles, ADE string)</li>
<li>Summary table formatter: side-by-side comparison across all surveyed roots</li>
<li><strong>Approximate size</strong>: ~50 lines</li>
<li><strong>Notes</strong>: ζ₄ → Binary Dihedral (D-series, order 8). ζ₈ → Binary Octahedral (E₇, order 48). E₆ and E₈ are not reachable under the two-perpendicular-axes generator construction. Quantum dimension [2]_q vanishes exactly at ζ₈ (q=i, [2]_q = i + 1/i = 0).</li>
</ul>
<h3>11.3 Quantum Dimension Computation</h3>
<ul>
<li><strong>What it does</strong>: Computes the quantum dimension [2]_q = q + q⁻¹ at q = exp(2πi/N) for each root of unity, identifying lattice points where the dimension vanishes (Kuperberg tractability condition).</li>
<li><strong>Introduced in</strong>: Demo 80</li>
<li><strong>Reused in</strong>: (Demo 80 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Inline computation: [2]_q = 2cos(2π/N); check against 0 and ±2 (classical limits)</li>
<li>Classification: [2]_q = 0 ↔ lattice root ↔ finite group ↔ Kuperberg tractable</li>
<li><strong>Approximate size</strong>: ~20 lines</li>
<li><strong>Notes</strong>: At ζ₈, [2]_q = 0 exactly. The two finite-group roots (ζ₄, ζ₈) are precisely the roots where [2]_q ∈ {-2, 0} — the lattice/tractable regime. Non-lattice roots (all infinite groups) correspond to the #P-hard regime of Kuperberg.</li>
</ul>
<h3>11.4 Parameterized SU(2) Generator Initializer</h3>
<ul>
<li><strong>What it does</strong>: Initializes the two SU(2) braid generators σ₁ and σ₂ for an arbitrary cyclotomic root ζ_N, enabling catalog construction for any root without code changes.</li>
<li><strong>Introduced in</strong>: Demo 79 (as <code>init_su2_generators(half_angle)</code>)</li>
<li><strong>Reused in</strong>: Demos 80, 81, 82</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>init_su2_generators(half_angle)</code>: sets σ₁ = rotation by 2<em>half_angle around x-axis, σ₂ = rotation by 2</em>half_angle around z-axis</li>
<li>Inverse generator computation: quaternion conjugation</li>
<li>Multi-root sweep: <code>test_root(N)</code> calls init with half_angle = 2π/N</li>
<li><strong>Approximate size</strong>: ~40 lines</li>
<li><strong>Notes</strong>: Pattern: half_angle = π/N for ζ_N. Previously the generators were hardcoded for ζ₈ only; this parameterization enables the multi-root surveys of <a href="./entries/demo_79.html">D79</a>-<a href="./entries/demo_82.html">D82</a>.</li>
</ul>
<h3>11.5 Catalog Save/Restore Pattern</h3>
<ul>
<li><strong>What it does</strong>: Saves the full current quaternion catalog (quaternions + depth arrays + metadata) to a static backup, then restores it; enables repeated subset experiments with different roots or subsets without rebuilding the full closure.</li>
<li><strong>Introduced in</strong>: Demo 79</li>
<li><strong>Reused in</strong>: Demos 80, 81, 82, 83 (extended to also save writhe array), 84 (same extension; also enables bracket→Jones→bracket switching), 87 (null-removal experiments), 88 (perturbation experiments), 89 (depth-stratified experiments), 90 (subset loading for comparative tests), 91 (depth-cutoff experiments), 92 (depth-sweep experiments)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>save_catalog()</code>: copies <code>g_cat[]</code>, <code>g_cat_size</code>, <code>g_depth[]</code>, <code>g_nd</code>, <code>g_na</code> to static backup arrays; extended in <a href="./entries/demo_83.html">D83</a>-<a href="./entries/demo_84.html">84</a> to also save <code>g_writhe[]</code></li>
<li><code>restore_catalog()</code>: restores from backup; resets derived quantities (directions, angles)</li>
<li><code>find_quat_in(q, arr, arr_size)</code>: searches for a quaternion in an arbitrary array (not just global catalog); used for nesting/overlap verification</li>
<li><code>load_subset(indices, count)</code> (added <a href="./entries/demo_84.html">D84</a>): loads an arbitrary index subset of the saved catalog into <code>g_cat[]</code>; enables null-only / non-null-only experiments without separate catalog arrays</li>
<li><strong>Approximate size</strong>: ~40 lines (core); ~10 lines added in <a href="./entries/demo_83.html">D83</a>-<a href="./entries/demo_84.html">84</a> for writhe array and <code>load_subset</code></li>
<li><strong>Notes</strong>: Eliminates the need for separate static arrays per root. Critical for Demo 79 Part E (nesting verification between ζ₈ and ζ₁₂), Demo 82 (shallow/strided/deep subset comparisons), Demo 83 (bracket→Jones→bracket switching without rebuilding closure), and Demo 84 (null-only vs non-null-only subset experiments).</li>
</ul>
<h3>11.6 Recursive XOR Ladder (<code>find_recursive</code>)</h3>
<ul>
<li><strong>What it does</strong>: Generic recursive extension from level-(N-2) XOR winners to level-N XOR winners by appending one new catalog entry to each existing winner and testing with <code>test_combined</code>. Replaces per-level search functions with a single parameterized routine.</li>
<li><strong>Introduced in</strong>: Demo 79</li>
<li><strong>Reused in</strong>: Demos 81, 82, 87 (capacity pipeline for null-removal experiments), 89 (depth-stratified capacity measurement), 90 (winner search for axis cancellation analysis)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>find_recursive(level)</code>: searches all (winner at level-1, new_entry) combinations; deduplicates via sorted-tuple comparison</li>
<li>Sorted tuple insertion: maintains sorted index arrays when extending N-tuples without full re-sort</li>
<li><code>g_win[8][MAX_WIN][MAX_TUPLE]</code>: unified winner storage for XOR6 through XOR14 (levels 3–7) in a single array indexed by level</li>
<li>Generic winner storage: <code>g_nwin[8]</code> count array; <code>g_win_depth[8][][]</code> for depth analysis (Demo 82)</li>
<li><strong>Approximate size</strong>: ~80 lines</li>
<li><strong>Notes</strong>: Replaces the per-XOR-level functions of Demo 78 (<code>find_xor6</code>, <code>find_xor8</code>, <code>find_xor10</code>) with one routine. The pattern scales cleanly to XOR14 and beyond.</li>
</ul>
<h3>11.7 Depth-Tracked Closure and Subset Constructors</h3>
<ul>
<li><strong>What it does</strong>: Augments group closure with per-element birth-round tracking (depth), then provides three reusable subset construction strategies — shallow (first N entries), strided (every K-th entry), deep (last N entries from deepest round) — for capacity comparison experiments.</li>
<li><strong>Introduced in</strong>: Demo 82</li>
<li><strong>Reused in</strong>: Demo 83 (<code>find_capacity()</code> reused unchanged — called three times: bracket, Jones, ζ₈ control), Demo 84 (<code>find_capacity()</code> reused; also called on null-only and non-null-only subsets via <code>load_subset</code>), Demos 89, 90 (<code>load_single_depth</code>, <code>load_cumulative</code>, <code>load_deep</code>, <code>load_shallow</code>, <code>load_strided</code>, <code>load_random</code> for depth-stratified experiments), Demos 91, 92 (<code>load_up_to_depth</code> for depth-sweep experiments)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>g_depth[]</code> array: assigned the current closure round index at element birth; identity + generators get depth 0</li>
<li>Shallow subset: copy first N entries from <code>g_cat[]</code> by natural closure order</li>
<li>Strided subset: copy every K-th entry from full catalog (deterministic, maximum spatial spread)</li>
<li>Deep subset: copy last N entries (all from deepest closure round, maximum algebraic coherence)</li>
<li><code>CapResult</code> struct: captures dirs, angles, xor6, xor8, xor10, xor12, max_xor in one place; enables clean side-by-side comparison tables</li>
<li><code>find_capacity(cat_size, CapResult *r)</code>: unified driver — builds dirs, counts angles, runs find_xor6 + find_recursive chain up to XOR12; returns <code>CapResult</code>; extended in <a href="./entries/demo_83.html">D83</a>-<a href="./entries/demo_84.html">84</a> to accept explicit <code>cat_size</code> parameter rather than using global size</li>
<li><strong>Approximate size</strong>: ~150 lines</li>
<li><strong>Notes</strong>: Key finding: deep subsets (maximum algebraic coherence) consistently outperform strided subsets (maximum vocabulary) at matched size — deep 564 entries reach XOR12 while strided 564 entries (with more directions and angles) only reach XOR10. Linear depth law: max_xor ≈ depth + 6. In <a href="./entries/demo_83.html">D83</a>-<a href="./entries/demo_84.html">84</a>, <code>find_capacity</code> is the main workhorse called repeatedly on different catalog views (bracket, Jones-normalized, null-only, non-null-only, cross-root).</li>
</ul>
<h3>11.8 Vocabulary-by-Depth Scanner</h3>
<ul>
<li><strong>What it does</strong>: Single-pass O(N²) scan accumulating unique directions (eigenvector axes) and unique half-angles in per-depth buckets, characterizing the direction-explosion regime (new directions dominate, depths 0–6) and the angle-refinement regime (directions saturate, angles accelerate, depths 7–8).</li>
<li><strong>Introduced in</strong>: Demo 82</li>
<li><strong>Reused in</strong>: (Demo 82 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Per-depth direction count: new directions contributed by each round (explosion: 2/4/16/24/68/125/268 per depth 0–6)</li>
<li>Per-depth angle count: new angles per round (slow early, accelerating at saturation: +14 at depth 7, +8 at depth 8)</li>
<li>Phase boundary detection: identifies the round where new-direction growth slows and angle growth accelerates</li>
<li><strong>Approximate size</strong>: ~60 lines</li>
<li><strong>Notes</strong>: Direction saturation (MAX_DIR=512) occurs at depth 7 for ζ₁₂ (catalog round 7). After saturation, angular diversity alone drives further XOR capacity gains (XOR10→XOR12 transition).</li>
</ul>
<h3>11.9 Snapshot-Based Scaling Measurement</h3>
<ul>
<li><strong>What it does</strong>: Records per-round "snapshots" of the group closure process, running the full XOR6→XOR12 capacity pipeline at each snapshot. Produces the data needed to fit the logarithmic (or linear) scaling law.</li>
<li><strong>Introduced in</strong>: Demo 81</li>
<li><strong>Reused in</strong>: (Demo 81 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>Snap</code> struct: stores (round, catalog_size, n_dirs, n_angles, max_xor, winner_counts) per snapshot</li>
<li><code>test_snapshot(round_end_idx)</code>: runs full XOR6→XOR12 pipeline on catalog prefix up to round_end_idx</li>
<li><code>round_end[]</code> array: BFS-style group closure records where each round ends in the catalog</li>
<li>Logarithmic fit: inline slope/intercept computation from (log₂(catalog_size), max_xor) data points</li>
<li>Transition cost in doublings: between XOR level transitions, compute doublings = log₂(cat_hi / cat_lo)</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: Scaling law: max_xor ≈ 0.62 × log₂(catalog_size) + 4.6 for ζ₁₂. Equivalently, each +2 XOR level costs ~3.2 more doublings (~10× more entries). The decreasing gap series (3.35 → 2.43 → 2.05 doublings) hints at possible O(log N / log log N) behavior.</li>
</ul>
<h3>11.10 Winner Depth Analysis</h3>
<ul>
<li><strong>What it does</strong>: For each XOR level (XOR6 through XOR12), computes depth histogram and mean depth of all winning tuples, verifying that mean depth is monotonically non-decreasing as the required XOR level increases.</li>
<li><strong>Introduced in</strong>: Demo 82</li>
<li><strong>Reused in</strong>: (Demo 82 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Per-level depth histogram: iterates over all winner tuples, indexes into <code>g_depth[]</code>, accumulates histogram</li>
<li>Min/max/mean depth per XOR level: characterizes the depth profile of winning sets</li>
<li>Monotonicity verifier: checks mean_depth(XOR_{n+2}) &gt;= mean_depth(XOR_n)</li>
<li>Two-component architecture check: verifies that depth-0 entries (generators + identity) appear in every winner at every XOR level</li>
<li><strong>Approximate size</strong>: ~50 lines</li>
<li><strong>Notes</strong>: Mean winner depth: XOR6=0.52, XOR8=0.63, XOR10=1.00, XOR12=1.98. Every winner has at least one depth-0 element (generator), forming the "shallow core." The progressively deeper elements provide additional eigenvalue resolution. Sample XOR12 winner depths: [0,0,0,1,3,5].</li>
</ul>
<h3>11.11 Jones Normalization (<code>jones_normalize_catalog</code>)</h3>
<ul>
<li><strong>What it does</strong>: Applies the Jones polynomial's writhe-normalization phase to each quaternion in the catalog — rotating by <code>w <em> -(3</em>half_angle + pi)</code> for each entry with writhe <code>w</code>. Converts a bracket-value catalog into a Jones-value catalog in-place. Works for any root via <code>g_half_angle</code>.</li>
<li><strong>Introduced in</strong>: Demo 83</li>
<li><strong>Reused in</strong>: (Demo 83 only — first test of Jones vs bracket capacity)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>jones_normalize_catalog(cat_size)</code>: iterates all entries; computes <code>jones_phase_per_w = -(3<em>g_half_angle + pi)</code>; for each entry applies rotation by <code>phi = writhe[i] </em> jones_phase_per_w</code> as a unit quaternion left-multiplier</li>
<li><code>save_catalog()</code> / <code>restore_catalog()</code> (Section 11.5): called before normalization to preserve bracket catalog; called after Jones XOR measurement to restore original</li>
<li><strong>Approximate size</strong>: ~30 lines</li>
<li><strong>Notes</strong>: Jones normalization reduces distinct quaternions from 4096 to 2710 (-33.8%) and angles from 43 to 31 (-28%) at ζ₁₂, while leaving direction count unchanged (512 → 512). The angular vocabulary reduction is the mechanism of the exact 2-level XOR capacity loss. The function is root-agnostic: the same code confirms -2 at both ζ₈ and ζ₁₂.</li>
</ul>
<h3>11.12 Writhe-Sourced XOR Verifier (<code>test_xor_writhe</code>)</h3>
<ul>
<li><strong>What it does</strong>: Standalone XOR verifier that uses writhe sums (instead of quaternion sums) as the cell index. Treats writhe as a scalar computational channel: maps each of 2^N input masks to a writhe sum in the range [-64, +64] (offset by 64 for array indexing), tests whether the mapping is parity-pure.</li>
<li><strong>Introduced in</strong>: Demo 83</li>
<li><strong>Reused in</strong>: (Demo 83 only — single-channel writhe test)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>test_xor_writhe(tuple, n)</code>: flat array of 129 cells (writhe offset 64, range -64 to +64); computes writhe sum for each mask; checks parity consistency per cell</li>
<li>Winner writhe analysis loop: iterates saved winner tuples and indexes into <code>g_writhe[]</code>; per-level writhe histogram, min/max/mean absolute writhe, mixed-writhe fraction</li>
<li><strong>Approximate size</strong>: ~60 lines</li>
<li><strong>Notes</strong>: 32 XOR6 winners found using writhe-only scoring, confirming writhe as a standalone computational unit. Writhe alone cannot reach XOR8 — full power requires writhe × lattice interaction. Mixed-writhe fractions at XOR winners: XOR6 41%, XOR8 25%, XOR10 9%, XOR12 12%; higher XOR levels exploit chirality variation.</li>
</ul>
<h3>11.13 Exact Quaternion Deduplication Counter (<code>count_distinct_quats</code>)</h3>
<ul>
<li><strong>What it does</strong>: O(N²) exact comparison over all pairs in a quaternion catalog, checking both <code>q</code> and <code>-q</code> as representatives (antipodal identification), to count truly distinct quaternions after a transformation such as Jones normalization.</li>
<li><strong>Introduced in</strong>: Demo 83</li>
<li><strong>Reused in</strong>: (Demo 83 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>count_distinct_quats(cat, size)</code>: double loop; two quaternions are the same if <code>|q1 - q2| &lt; tol</code> or <code>|q1 + q2| &lt; tol</code></li>
<li><strong>Approximate size</strong>: ~25 lines</li>
<li><strong>Notes</strong>: Used to measure information collapse between bracket and Jones catalogs (4096 → 2710 at ζ₁₂). The <code>-q</code> check is necessary because antipodal quaternions represent the same rotation.</li>
</ul>
<h3>11.14 Null Classifier and Subset Index Arrays (<code>classify_null</code>, <code>null_idx</code>, <code>nonnull_idx</code>)</h3>
<ul>
<li><strong>What it does</strong>: Classifies each catalog entry as bracket-null (|Re(q)| &lt; 1e-10) or non-null; builds two index arrays that partition the catalog; these arrays are reused throughout all subsequent subset experiments.</li>
<li><strong>Introduced in</strong>: Demo 84</li>
<li><strong>Reused in</strong>: Demos 87 (null dispensability at zeta_12), 88 (perturbation sensitivity by null/non-null type)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>classify_null(cat_size)</code>: single pass over catalog; fills <code>is_null[]</code> boolean array; returns null count</li>
<li><code>null_idx[]</code> / <code>nonnull_idx[]</code>: index arrays built once after <code>classify_null</code>; reused for <code>load_subset</code> calls in Parts C–F</li>
<li><code>is_null[]</code> array: persistent boolean per entry; used in winner null-prevalence analysis (Part D) and direction geometry analysis (Part E)</li>
<li><strong>Approximate size</strong>: ~30 lines</li>
<li><strong>Notes</strong>: ζ₈ null count: 9/24 (37.5%). Depth distribution: depth-0 = 0% null, depth-1 = 20%, depth-2 = 75%, depth-3 = 100%. Every maximally-deep ζ₈ entry is bracket-null. Distinct |Re(q)| spectrum: exactly 4 values {0, 0.5, 0.707, 1.0} with a hard gap of 0.5 between null and nearest non-null.</li>
</ul>
<h3>11.15 Direction Geometry Analyzer and Cross-Root Comparison Loop</h3>
<ul>
<li><strong>What it does</strong>: Two related patterns: (1) per-direction null/non-null count arrays that classify each S² direction as null-only, non-null-only, or both, computing directional efficiency ratio; (2) a multi-root loop that calls <code>init_su2()</code> with different half-angles (ζ₄, ζ₈, ζ₁₂), runs <code>build_closure()</code>, <code>classify_null()</code>, and direction analysis for each, producing a unified cross-root null-fraction table.</li>
<li><strong>Introduced in</strong>: Demo 84</li>
<li><strong>Reused in</strong>: (Demo 84 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Per-direction null/non-null arrays: for each of the n_dirs S² directions, count how many catalog entries pointing there are null vs non-null; classify into three groups</li>
<li>Directional efficiency: null efficiency = null-only directions / null count; non-null efficiency = non-null-only dirs / non-null count</li>
<li><code>count_xor6_at_k(bf_limit, k_sec)</code>: XOR6 count at a fixed k_sec without winner storage; used for the k_sec sweep (Part C.4) that decomposes S¹ vs S² contributions to null-only capacity</li>
<li><code>random_subset(subset, subset_size, total_size)</code>: Fisher-Yates partial shuffle producing a random size-N subset of [0, total_size); used for 100-trial random-control experiment to establish baseline max_xor for 15-entry subsets</li>
<li>Cross-root loop: iterates [ζ₄=π/2, ζ₈=π/4, ζ₁₂=π/6]; for each root calls init, close, classify, direction-analyze; reports unified table</li>
<li><strong>Approximate size</strong>: ~120 lines</li>
<li><strong>Notes</strong>: Null-only directions: 6 (cube edge midpoints, ±1/√2 components). Non-null-only directions: 4 (tetrahedral axes, ±1/√3 components). Shared: 3 (coordinate axes). Directional efficiency: null = 1.00 dir/entry, non-null = 0.47 dir/entry. Cross-root null fractions: ζ₄=75%, ζ₈=37.5%, ζ₁₂=3.0%. The k_sec sweep confirming flat XOR6 count across k=1,2,4,6,8 for null-only establishes that all bracket-null entries sit at a single S¹ point (half-angle=90°), so all capacity comes from S² directional diversity alone.</li>
</ul>
<p>---</p>
<h2>12. Capacity Theory</h2>
<h3>12.1 Masks-per-Cell Capacity Argument</h3>
<ul>
<li><strong>What it does</strong>: The elementary pigeonhole bound that limits DKC computational capacity: with 2^n input masks and C cells, each cell receives 2^n/C masks on average. Parity-pure cells require at most one parity class per cell, so C must be at least 2^n / (max_masks_per_cell) where max_masks_per_cell is empirically ~4.6 for the ζ₈ sweet spot.</li>
<li><strong>Introduced in</strong>: Demo 76 (explicit 256/14 argument)</li>
<li><strong>Reused in</strong>: Demo 77 (motivates product activation threshold ~100 cells), Demo 78 (confirms wall at ζ₈), Demo 81 (capacity scaling law interpretations)</li>
<li><strong>Key types/functions</strong>:</li>
<li>No explicit function — the bound is computed inline as (2^n) / C</li>
<li>Direction concentration metric (Demo 76): fraction of 2^n masks mapping to dominant cell</li>
<li>Phase transition threshold computation: find k where n_cells = k * n_dir crosses ~100</li>
<li><strong>Approximate size</strong>: ~20 lines (inline in each demo)</li>
<li><strong>Notes</strong>: Sweet spot at ζ₈ XOR6: 64 masks / 14 cells = 4.57. At XOR8 with S² only: 256/14 = 18.3 — geometrically impossible. Product activation expands to 112 cells: 256/112 = 2.29 — achievable. The ~4.6 masks/cell empirical constant may be a universal sweet spot for this lattice structure.</li>
</ul>
<h3>12.2 Finite vs Infinite Group Capacity Ceiling Theorem</h3>
<ul>
<li><strong>What it does</strong>: The mathematical relationship between group finiteness and DKC computational capacity: finite SU(2) subgroups (only ζ₄ and ζ₈ under the standard construction) impose hard XOR capacity ceilings because their catalogs are fixed; infinite groups have no such ceiling.</li>
<li><strong>Introduced in</strong>: Demo 79 (finiteness as key variable), Demo 80 (exhaustive group survey)</li>
<li><strong>Reused in</strong>: Demo 81 (logarithmic scaling is consequence of infinite group growth), Demo 82 (depth law as mechanism)</li>
<li><strong>Key types/functions</strong>:</li>
<li>No separate function — the insight is demonstrated by running closure on multiple roots and comparing XOR capacity</li>
<li><code>build_closure</code> (Section 11.1) is the core test</li>
<li><strong>Notes</strong>: ζ₈ (finite, 24 elements) caps at XOR8. ζ₁₂ (infinite, doubling per round) has no observed ceiling through XOR12. The linear depth law (max_xor ≈ depth + 6) is the mechanistic explanation: finite groups have bounded depth (ζ₈ max depth 3), infinite groups grow without bound.</li>
</ul>
<p>---</p>
<h2>13. TL Algebra Full Infrastructure (Demos 85-86)</h2>
<h3>13.1 Full TL Algebra Infrastructure (AlgDiagram)</h3>
<ul>
<li><strong>What it does</strong>: Complete TL_n algebra representation using explicit planar matching diagrams (as opposed to the standard-module link states of Section 3.1). Enumerates the full Catalan-number-dimensional basis, builds the complete multiplication table with loop counts, implements the star anti-involution, closure loop counting, and through-line sector analysis — everything needed for representation-theoretic computations on the regular representation.</li>
<li><strong>Introduced in</strong>: Demo 85</li>
<li><strong>Reused in</strong>: Demo 86 (reused verbatim for left ideal construction and restricted Hamiltonian)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>AlgDiagram</code> struct: <code>match[MAX_ALG_2N]</code> — planar matching on 2n boundary points (top n + bottom n)</li>
<li><code>AlgSegment</code> struct: <code>points[MAX_ALG_2N]</code> with <code>count</code> — for recursive segment-based enumeration</li>
<li><code>alg_enumerate_basis(n, basis_out)</code> — segment-based recursive enumeration of all non-crossing matchings on 2n points; produces Catalan(n) diagrams</li>
<li><code>alg_compose(n, d1, d2, result, loops)</code> — vertical stacking of two diagrams: connects bottom of d1 to top of d2, traces through glue layer counting closed loops, returns composed diagram + loop count</li>
<li><code>alg_compute_mult_table()</code> — fills <code>alg_mt[i][j]</code> (result index at delta=0, -1 if loops&gt;0), <code>alg_mt_full[i][j]</code> (result index always), <code>alg_mt_nloops[i][j]</code> (loop count) for all i,j pairs</li>
<li><code>alg_star(d, n)</code> — star anti-involution: top/bottom swap (vertical flip); <code>alg_compute_star_indices()</code> precomputes star[i] for all basis elements</li>
<li><code>alg_closure_loops(d, n)</code> — counts loops formed when trace-closing a single diagram (connecting top to bottom directly)</li>
<li><code>alg_count_through(d, n)</code> — counts propagating strands (top point matched to bottom point); classifies basis elements by through-line sector</li>
<li><code>alg_make_identity(n)</code>, <code>alg_make_generator(n, gen)</code> — construct identity (straight-through matchings) and TL generator e_i (pair sites 2i,2i+1 on both top and bottom)</li>
<li><code>alg_find_index(m, basis, num, n)</code> — looks up a diagram in the enumerated basis</li>
<li><code>alg_init(n)</code> — full initialization: enumerate basis, find identity/generators, build multiplication table, compute star indices</li>
<li><code>analyze_through_line_sectors()</code> — classifies basis by through-line count, checks L_H sector preservation</li>
<li><strong>Approximate size</strong>: ~400 lines</li>
<li><strong>Notes</strong>: This is structurally different from the link-state standard module (Section 3.1). Link states enumerate the standard module W_{n,0} (dimension C_{n/2}); AlgDiagram enumerates the FULL algebra TL_n (dimension C_n). TL_4 standard module dim=2; TL_4 full algebra dim=14. The full algebra supports left ideal construction, projective cover analysis, and regular representation — none of which are possible on the standard module alone. The multiplication table is O(dim^2) entries, each requiring an O(n) composition — total build cost O(C_n^2 * n).</li>
</ul>
<h3>13.2 Link State Enumeration and Hamiltonian (Standard Module at delta=0)</h3>
<ul>
<li><strong>What it does</strong>: Recursive enumeration of non-crossing perfect matchings on n boundary points (the link states of the standard module W_{n,0}) with TL generator action at delta=0 and Hamiltonian construction H = -(e_0 + ... + e_{n-2}).</li>
<li><strong>Introduced in</strong>: Demo 85 (standalone implementation independent of Section 3.1)</li>
<li><strong>Reused in</strong>: Demo 85 (standard-module diagonalizability proof), Demo 105 (j=0 programmatic TL generators for W_{8,0})</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>LinkState</code> struct: <code>pair[MAX_SITES]</code> — pairing array for n/2 non-crossing arcs</li>
<li><code>enumerate_link_states(n, basis)</code> — recursive generator; dimensions match C_{n/2}: W_4=2, W_6=5, W_8=14, W_10=42, W_12=132</li>
<li><code>apply_ei(i, in, out, n)</code> — TL generator e_i action on a link state at delta=0: creates new pairing; returns 1 if no loops created, 0 if loop (annihilates at delta=0)</li>
<li><code>find_ls_index(ls, basis, dim, n)</code> — lookup by exhaustive comparison</li>
<li><code>build_hamiltonian(n, basis, dim, H)</code> — constructs H = -(e_0 + ... + e_{n-2}) as integer matrix on the standard module</li>
<li><strong>Approximate size</strong>: ~120 lines</li>
<li><strong>Notes</strong>: Key finding: the Hamiltonian on the standard module is FULLY DIAGONALIZABLE at delta=0 for all tested sizes (n=4,6,8,10,12). Jordan blocks only exist on the full regular representation and projective covers. This falsified Gemini's claim about standard-module Jordan structure.</li>
</ul>
<h3>13.3 Faddeev-LeVerrier Characteristic Polynomial (Modular)</h3>
<ul>
<li><strong>What it does</strong>: Computes the characteristic polynomial of an integer matrix via the Faddeev-LeVerrier algorithm in modular arithmetic (mod 10^9+7), avoiding floating-point entirely.</li>
<li><strong>Introduced in</strong>: Demo 85</li>
<li><strong>Reused in</strong>: Demo 86 (for characteristic polynomial of restricted Hamiltonian on left ideals)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>char_poly_mod(H, dim, c)</code> — fills coefficient array c[0..dim] with modular char poly coefficients; algorithm: iterate A_k = A_{k-1}<em>H + c_k</em>I where c_k = -tr(A_{k-1}*H)/k</li>
<li><code>poly_deriv_mod(f, deg_f, fp)</code> — formal derivative of polynomial mod p</li>
<li><code>poly_gcd_degree_mod(a, deg_a, b, deg_b)</code> — Euclidean algorithm GCD degree; returns degree(gcd(a,b)) mod p</li>
<li><strong>Approximate size</strong>: ~80 lines</li>
<li><strong>Notes</strong>: The Faddeev-LeVerrier algorithm avoids eigenvalue computation entirely — it produces the characteristic polynomial symbolically from the trace sequence. Combined with the polynomial GCD, this gives the definitive diagonalizability test: gcd(char_poly, char_poly') = 0 iff fully diagonalizable (no repeated roots). Used for both standard module and full algebra diagonalizability tests.</li>
</ul>
<h3>13.4 Krylov Minimal Polynomial (Modular)</h3>
<ul>
<li><strong>What it does</strong>: Computes the minimal polynomial of an integer matrix via Krylov iteration in modular arithmetic. The minimal polynomial is the lowest-degree polynomial annihilating the matrix — more informative than the characteristic polynomial for Jordan block detection.</li>
<li><strong>Introduced in</strong>: Demo 85</li>
<li><strong>Reused in</strong>: Demo 86 (for Jordan block detection on left ideals)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>min_poly_mod(H, dim, m, deg_m)</code> — Krylov iteration: starting from random vector v, compute v, Hv, H^2v, ...; maintain echelon form of the Krylov matrix; when a new column becomes linearly dependent, read off the minimal polynomial from the dependency relation</li>
<li><code>has_jordan_blocks(H, dim)</code> — convenience wrapper: computes min poly and its derivative, returns 1 if gcd(mu, mu') &gt; 0 (i.e., repeated roots in minimal polynomial = Jordan blocks)</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: The minimal polynomial divides the characteristic polynomial and has the same roots but potentially lower multiplicity. gcd(mu, mu') &gt; 0 is necessary and sufficient for Jordan blocks. This is more definitive than the char_poly test because the char_poly can have repeated roots from geometric multiplicity (multiple eigenspaces of same eigenvalue) without Jordan blocks. The min_poly test catches only actual non-diagonalizability.</li>
</ul>
<h3>13.5 Left Ideal Closure (Projective Cover Construction)</h3>
<ul>
<li><strong>What it does</strong>: BFS closure of a set of seed algebra elements under left multiplication by all algebra elements (at delta=0). Generates the left ideal e*TL_n for any idempotent or generator e — this is the projective cover P_{0,0} when seeded with a 2-through-line generator.</li>
<li><strong>Introduced in</strong>: Demo 85</li>
<li><strong>Reused in</strong>: Demo 86 (constructs P_{0,0} at TL_4, TL_6, TL_8 for direct b computation)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>left_ideal_closure(gens, n_gens, ideal, ideal_size)</code> — BFS queue; starts from seed generators; at each step multiplies each ideal element by all algebra basis elements; adds results not already in the ideal; terminates when queue empty</li>
<li><code>in_ideal[]</code> boolean array for O(1) membership test</li>
<li>Returns ideal as sorted index array into the algebra basis</li>
<li><strong>Approximate size</strong>: ~50 lines</li>
<li><strong>Notes</strong>: At TL_4, seeding with any 2-through-line generator produces P_{0,0} of dimension 5 = C_3 (next Catalan number). At TL_6, P_{0,0} has dimension 14 = C_4. At TL_8, dimension 42 = C_5. Pattern: dim(P_{0,0}) at TL_n = C_{n/2+1}. All 2-through-line generators produce IDENTICAL left ideals (generator independence, confirmed in <a href="./entries/demo_86.html">D86</a>).</li>
</ul>
<h3>13.6 Eigenvalue Sweep and Geometric Multiplicity</h3>
<ul>
<li><strong>What it does</strong>: Numerical sweep for real eigenvalues of integer matrices via characteristic polynomial sign changes and golden-section refinement; plus rank-based geometric multiplicity computation at given eigenvalue.</li>
<li><strong>Introduced in</strong>: Demo 85</li>
<li><strong>Reused in</strong>: (Demo 85 only — used for eigenvalue analysis of H on standard module and projective covers)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>find_eigenvalues_sweep(H, dim, evals, n_evals)</code> — evaluates char poly on fine grid [-max..max], detects sign changes, refines roots by golden-section search; handles both simple and double roots (via local minimum detection for same-sign dips)</li>
<li><code>geometric_multiplicity(H, dim, lambda)</code> — computes dim(ker(H - lambda*I)) by RREF rank subtraction</li>
<li><code>extract_null_space(M, dim, null_vecs, n_null)</code> — RREF-based null space extraction for integer matrices</li>
<li><code>extract_null_space_d(M, dim, null_vecs, n_null)</code> — double-precision version for irrational eigenvalues</li>
<li><strong>Approximate size</strong>: ~150 lines</li>
<li><strong>Notes</strong>: Handles both integer eigenvalues (from integer char poly) and irrational eigenvalues (e.g., +/-sqrt(2) at TL_4 P_{0,0}). Golden-section refinement achieves ~10^{-12} precision. Used to establish that standard modules have no Jordan blocks while projective covers do.</li>
</ul>
<h3>13.7 Jordan Analysis (ker/ker^2 Method)</h3>
<ul>
<li><strong>What it does</strong>: Detects Jordan blocks at a specific integer eigenvalue by comparing ker(H-lambda<em>I) vs ker((H-lambda</em>I)^2). If dim(ker(M^2)) &gt; dim(ker(M)), there is a Jordan block of size &gt;= 2 at lambda.</li>
<li><strong>Introduced in</strong>: Demo 85</li>
<li><strong>Reused in</strong>: (Demo 85 only — the Krylov min_poly method supersedes this for definitive testing)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>jordan_analysis(H, dim, lambda, rank1, rank2, nullity1, nullity2)</code> — computes M = H - lambda*I, M^2, ranks of both; Jordan blocks exist iff nullity2 &gt; nullity1</li>
<li><strong>Approximate size</strong>: ~40 lines</li>
<li><strong>Notes</strong>: This is the direct definition-based test. Limited to integer eigenvalues. The Krylov minimal polynomial method (Section 13.4) is more general (works for irrational eigenvalues via modular arithmetic) and more definitive.</li>
</ul>
<h3>13.8 Complex Arithmetic Suite (Cx for Demo 85)</h3>
<ul>
<li><strong>What it does</strong>: Complex number type with matrix operations — multiplication, null space, absolute determinant — used for spin chain representation at q=i.</li>
<li><strong>Introduced in</strong>: Demo 85 (matrix extensions beyond the basic Cx from Section 1.2)</li>
<li><strong>Reused in</strong>: (Demo 85 only — specific to the spin chain representation analysis)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>Cx</code> struct (same as Section 1.2): <code>re</code>, <code>im</code> doubles</li>
<li><code>cx_mat_mul(A, B, C, dim)</code> — complex matrix multiplication</li>
<li><code>cx_mat_vec(A, v, w, dim)</code> — complex matrix-vector product</li>
<li><code>cx_null_space(M, dim, null_vecs, n_null)</code> — RREF-based complex null space</li>
<li><code>cx_absdet(M, dim)</code> — complex matrix absolute determinant via LU decomposition</li>
<li><code>cx_find_real_evals(H, dim, evals, n_evals)</code> — finds real eigenvalues of a complex matrix by sweeping |det(H-lambda*I)| for local minima</li>
<li><strong>Approximate size</strong>: ~200 lines</li>
<li><strong>Notes</strong>: Used for the spin chain representation of TL_n at q=i (delta=0): basis is Sz=0 sector of (C^2)^{tensor n}, generators involve complex entries. The eigenvalue finder works by detecting local minima of |det|, then refining with golden-section search.</li>
</ul>
<h3>13.9 Spin Chain Representation at q=i</h3>
<ul>
<li><strong>What it does</strong>: Builds the TL representation on the Sz=0 sector of (C^2)^{tensor n} at q=i (delta=0). Constructs generator matrices, verifies all TL relations, and builds the Hamiltonian for Jordan block analysis on the spin chain.</li>
<li><strong>Introduced in</strong>: Demo 85</li>
<li><strong>Reused in</strong>: (Demo 85 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>sc_enumerate_sz0(n, basis)</code> — enumerates all n-bit strings with equal 0s and 1s (Sz=0 sector); dimensions: n=4→6, n=6→20, n=8→70</li>
<li><code>sc_apply_ei(i, in_state, q)</code> — applies e_i on spin chain at q=i: projects sites (i, i+1) onto singlet, replaces with q-weighted singlet reconstruction</li>
<li><code>sc_build_generator(i, n, basis, dim, gen)</code> — builds full dim×dim complex matrix for e_i</li>
<li><code>sc_build_hamiltonian(n, basis, dim, H)</code> — H = -(e_0 + ... + e_{n-2}) on spin chain</li>
<li><strong>Approximate size</strong>: ~150 lines</li>
<li><strong>Notes</strong>: Verified: e_i^2=0, braid relation e_i<em>e_{i+1}</em>e_i = e_i, far commutativity. H is symmetric (conformal/transpose form). The spin chain provides an independent representation for Jordan block analysis, complementing the diagram-algebraic approach.</li>
</ul>
<h3>13.10 Delta-Parameterized Form Builders</h3>
<ul>
<li><strong>What it does</strong>: Constructs Gram and Hamiltonian matrices as functions of a formal delta parameter, enabling perturbative analysis of the delta→0 limit. The delta-form G_delta[i][j] = delta^{L(i,j)} where L = compose_loops + closure_loops; the leading coefficients as delta→0 extract the indecomposability parameter b.</li>
<li><strong>Introduced in</strong>: Demo 85</li>
<li><strong>Reused in</strong>: Demo 86 (delta-parameterized b computation on left ideals — the approach that universally diverges)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>build_gram_matrix_delta(...)</code> — per-pair delta-power computation L[i][j] = compose_loops + closure_loops; builds integer matrix of delta exponents for star (loop) form</li>
<li><code>build_hamiltonian_delta(...)</code> — similar for the trace (no star) form</li>
<li>Leading-coefficient extraction: for each pair, identifies minimum delta-power, sums coefficients at that power, computes ratio b = coeff_Tt / coeff_tt</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: This is the core method that produces b = -5/8 at TL_4. The key insight is that at delta=0, almost all products vanish (loops→0); the delta-parameterized approach retains the structure by working at finite delta and taking the limit. The valuation condition p_tt = 2*p_Tt must hold for b to be finite; it fails at TL_6 and on all single P_{0,0} copies (Demo 86).</li>
</ul>
<h3>13.11 Gauge Analysis Infrastructure</h3>
<ul>
<li><strong>What it does</strong>: Exhaustive scan over gauge parameters (cosets of the null space of the bilinear form) computing the quadratic decomposition b(c) = (c^T M c + E^T c + L) / (c^T M' c + E'^T c + L') for the fixed-point form. Detects flat (affine) manifolds vs quadratic surfaces.</li>
<li><strong>Introduced in</strong>: Demo 85</li>
<li><strong>Reused in</strong>: (Demo 85 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Full N-dimensional coset scan computing A, D, L, E, M matrices for the quadratic b decomposition</li>
<li>Critical point finding via Cramer's rule (3D case)</li>
<li>Gauge freedom dimension = dim(ker(Gram)), typically 3 at TL_4</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: At TL_4, the quadratic coefficient matrix M = 0, making b_fixpt purely AFFINE in gauge parameters with no unique critical point. Both -2 and -5/8 are reachable on this flat manifold. The delta-form breaks the gauge degeneracy by introducing a non-degenerate form.</li>
</ul>
<p>---</p>
<h2>14. Direct b Computation on Projective Covers (Demo 86)</h2>
<h3>14.1 Restricted Hamiltonian Builder</h3>
<ul>
<li><strong>What it does</strong>: Constructs L_H = -(e_0 + ... + e_{n-2}) restricted to an arbitrary left ideal subspace of TL_n, with verification that the subspace is actually L_H-invariant.</li>
<li><strong>Introduced in</strong>: Demo 86</li>
<li><strong>Reused in</strong>: (Demo 86 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>build_restricted_hamiltonian(ideal, ideal_size, L_sub)</code> — builds the full algebra L_H first, then restricts to the ideal subspace by extracting the relevant rows/columns with index remapping; verifies invariance by checking that L_H maps ideal elements to ideal elements</li>
<li><strong>Approximate size</strong>: ~60 lines</li>
<li><strong>Notes</strong>: The ideal subspace is typically P_{0,0} from <code>left_ideal_closure</code>. Invariance verification catches bugs where the ideal is not actually a left module.</li>
</ul>
<h3>14.2 Delta-Form b Computation (Shifted and Unshifted)</h3>
<ul>
<li><strong>What it does</strong>: Computes the indecomposability parameter b on a restricted subspace (left ideal) using the delta-parameterized Gram matrix approach, at both integer eigenvalues (lambda=0, unshifted) and irrational eigenvalues (lambda≠0, shifted to double precision).</li>
<li><strong>Introduced in</strong>: Demo 86</li>
<li><strong>Reused in</strong>: (Demo 86 only — the approach universally diverges, so it is a negative-result asset)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>compute_b_on_ideal(ideal, ideal_size, L_sub)</code> — integer arithmetic version for lambda=0: finds Jordan partners via ker(L_H^2)\ker(L_H), computes loop power matrix, extracts leading delta-power coefficients, tests valuation condition</li>
<li><code>compute_b_shifted(ideal, ideal_size, L_sub, lambda)</code> — double-precision version for irrational eigenvalues: same algorithm but with floating-point shifted operator M = L_sub - lambda*I</li>
<li><code>compute_loop_power(i, j, ideal, ideal_size, use_star)</code> — computes total loop count for G_delta[i][j] using either star (loop form, predicting b=-5/8) or direct (trace form, predicting b=-2) composition</li>
<li><strong>Approximate size</strong>: ~150 lines</li>
<li><strong>Notes</strong>: Universal negative result: the valuation condition p_tt = 2*p_Tt NEVER holds on a single P_{0,0} at any eigenvalue, any lattice size, either form. The multiplicity from the regular representation is structurally essential. This is a novel finding — nobody in the literature has tried this specific approach.</li>
</ul>
<p>---</p>
<h2>15. Null Indispensability and Direction Partition (Demo 87)</h2>
<h3>15.1 Direction Partition Framework (DirPartition)</h3>
<ul>
<li><strong>What it does</strong>: Builds the direction catalog from a quaternion catalog, then classifies each S² direction as null-only (all entries pointing there are bracket-null), non-null-only (all non-null), or shared (both types present). Returns a compact <code>DirPartition</code> struct summarizing the partition.</li>
<li><strong>Introduced in</strong>: Demo 87</li>
<li><strong>Reused in</strong>: Demo 88 (direction classification for perturbation sensitivity by type)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>DirPartition</code> struct: <code>{total_dirs, null_only, nonnull_only, shared}</code> — compact partition summary</li>
<li><code>compute_dir_partition(cat_size)</code> — builds local direction catalog, per-direction null/non-null counts (<code>dir_null_cnt[]</code>, <code>dir_nonnull_cnt[]</code>), classifies each direction, returns <code>DirPartition</code></li>
<li>Operates on the global <code>is_null[]</code> array populated by <code>classify_null()</code></li>
<li><strong>Approximate size</strong>: ~80 lines</li>
<li><strong>Notes</strong>: At zeta_8: 6 null-only + 3 shared + 4 non-null-only = 13 directions. At zeta_12: 67 null-only + 54 shared + 1922 non-null-only = 2043 directions. The partition reveals that null entries command exclusive S² directions unavailable to non-null entries — this is the geometric basis of null indispensability.</li>
</ul>
<h3>15.2 Capacity Pipeline (find_capacity + CapResult)</h3>
<ul>
<li><strong>What it does</strong>: Unified capacity measurement pipeline — builds direction catalog, runs XOR6 brute-force search then recursive extension through XOR8/10/12 with k-ladder, returns a compact result struct.</li>
<li><strong>Introduced in</strong>: Demo 87</li>
<li><strong>Reused in</strong>: Demo 88 (capacity measurement before/after perturbation), Demo 89 (depth-stratified capacity)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>CapResult</code> struct: <code>{n_dirs, xor6, xor8, xor10, xor12, max_xor}</code> — reusable capacity result type</li>
<li><code>find_capacity(cat_size, bf_limit, CapResult *r)</code> — unified driver: builds dirs, runs <code>find_xor6(bf_limit)</code> + <code>find_recursive(4)</code> + <code>find_recursive(5)</code> + <code>find_recursive(6)</code> chain; fills CapResult</li>
<li>Uses K_LADDER = {1, 6, 8, 10, 12, 16, 20, 24} for multi-resolution XOR testing</li>
<li><strong>Approximate size</strong>: ~40 lines</li>
<li><strong>Notes</strong>: The <code>bf_limit</code> parameter controls the brute-force window for XOR6 (first <code>bf_limit</code> entries in the catalog for triple search). Extension to XOR8+ uses all stored XOR6 winners. The pipeline pattern is reused in multiple demos for comparing capacity across catalog subsets (null-only, non-null-only, depth-filtered, perturbation-filtered).</li>
</ul>
<h3>15.3 Phase-Modular Demo Structure</h3>
<ul>
<li><strong>What it does</strong>: Organizes the demo into self-contained phase functions (phase1_catalog, phase2_capacity, phase3_direction_analysis, phase4_depth) each taking a root name as parameter, enabling the same analysis pipeline to run on multiple roots of unity.</li>
<li><strong>Introduced in</strong>: Demo 87</li>
<li><strong>Reused in</strong>: (Demo 87 only — but the pattern is adopted in <a href="./entries/demo_89.html">D89</a>-<a href="./entries/demo_92.html">D92</a>)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>phase1_catalog(root_name)</code> — build closure, classify null, print summary</li>
<li><code>phase2_capacity(root_name)</code> — run find_capacity on full catalog and non-null subset, compare</li>
<li><code>phase3_direction_analysis(root_name)</code> — compute direction partition, print classification</li>
<li><code>phase4_depth(root_name)</code> — depth distribution cross-tabulated with null status</li>
<li><strong>Approximate size</strong>: ~40 lines per phase</li>
<li><strong>Notes</strong>: Each phase is independently callable and prints its own test assertions. This modular structure makes it easy to add new phases or skip phases during debugging.</li>
</ul>
<p>---</p>
<h2>16. Anti-Correlation and Spherical Design (Demo 88)</h2>
<h3>16.1 Spherical Design Residual Function</h3>
<ul>
<li><strong>What it does</strong>: Computes the spherical t-design residual for an arbitrary set of S² directions, using real spherical harmonics Y_lm evaluated via associated Legendre polynomials.</li>
<li><strong>Introduced in</strong>: Demo 88</li>
<li><strong>Reused in</strong>: Demo 90 (spherical harmonic decomposition for spectral inversion analysis)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>design_residual(dirs, nd, t)</code> — computes max over all (l,m) with 1&lt;=l&lt;=t of |sum_i Y_l^m(dir_i)|; single scalar quality metric</li>
<li><code>assoc_legendre(l, m, x)</code> — associated Legendre polynomial P_l^m(x) via three-term recurrence; stable to l=16+</li>
<li><code>ylm_real(l, m, theta, phi)</code> — real spherical harmonic evaluation with normalization</li>
<li><code>factorial_d(n)</code>, <code>ylm_norm(l, m)</code> — helper functions for normalization constants</li>
<li><strong>Approximate size</strong>: ~80 lines</li>
<li><strong>Notes</strong>: The residual metric quantifies how far a point set is from a t-design. Key finding: the 13 zeta_8 directions have Res(t=6) = 2.225, among the worst for 13 points on S². Yet they are computationally optimal for DKC — establishing the anti-correlation between spherical design quality and computational power.</li>
</ul>
<h3>16.2 Jacobi Eigendecomposition</h3>
<ul>
<li><strong>What it does</strong>: Jacobi eigenvalue algorithm for small symmetric real matrices — iterative rotation sweeps that zero off-diagonal elements until convergence. Returns sorted eigenvalues (descending).</li>
<li><strong>Introduced in</strong>: Demo 88</li>
<li><strong>Reused in</strong>: (Demo 88 only — used for Gram eigenspectrum analysis)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>jacobi_eigen(a, n, evals)</code> — in-place Jacobi rotation with convergence check; up to 200 iterations; eigenvalues sorted in descending order</li>
<li><strong>Approximate size</strong>: ~60 lines</li>
<li><strong>Notes</strong>: Used to analyze the |dot| Gram matrix of the 13 directions. Discovered golden ratio eigenvalue pairs (phi = 1.618, -phi+1 = -0.618) arising from the specific angular ratios of the three Oh (octahedral) orbits.</li>
</ul>
<h3>16.3 Perturbation Sensitivity Framework</h3>
<ul>
<li><strong>What it does</strong>: Applies Gaussian random perturbation to S² directions (selective by type: null-only, non-null-only, or all), measures XOR6 solution count change. Supports both unconstrained perturbation and constrained perturbation (angular clamp relative to original algebraic placement).</li>
<li><strong>Introduced in</strong>: Demo 88</li>
<li><strong>Reused in</strong>: (Demo 88 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Gaussian direction perturbation: adds N(0,eps) noise to direction components, renormalize to unit sphere</li>
<li>Selective perturbation by direction type (using <code>dir_type[]</code> from <code>classify_directions</code>)</li>
<li>Constrained mode: clamps angular displacement from original algebraic direction to maximum eps degrees</li>
<li><code>normalize3(x, y, z)</code> — renormalize perturbed direction to unit sphere</li>
<li><strong>Approximate size</strong>: ~60 lines</li>
<li><strong>Notes</strong>: Key finding: non-null body-diagonal directions are the fragile computational anchors (8% loss at eps=10), while null edge-midpoint directions are flexible scaffolding (-2.4% loss at eps=10, actually improving computation). This inverted the prediction that null directions would be more sensitive.</li>
</ul>
<h3>16.4 Simulated Annealing Optimizer</h3>
<ul>
<li><strong>What it does</strong>: Temperature-decay random jitter optimizer that minimizes spherical design residual, with optional angular clamping for constrained optimization (null directions free, non-null clamped to max angular displacement).</li>
<li><strong>Introduced in</strong>: Demo 88</li>
<li><strong>Reused in</strong>: (Demo 88 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Simulated annealing loop: 5000 steps with accept-if-better policy (T=0)</li>
<li>Per-direction Gaussian jitter + renormalization</li>
<li>Optional angular clamp: if direction type is non-null or shared, clamp displacement to max_deg degrees from original</li>
<li>Residual evaluation via <code>design_residual</code> at each step</li>
<li><strong>Approximate size</strong>: ~60 lines</li>
<li><strong>Notes</strong>: Constrained optimization (nulls free, non-nulls clamped to 2 deg) achieves 48% design improvement with only 2.8% XOR loss. Unconstrained achieves 52% improvement with 6.4% loss. <a href="./entries/demo_72.html">D72</a>'s Voronoi-only showed 89% loss under similar optimization — the k-ladder activation provides 14x better perturbation resilience.</li>
</ul>
<h3>16.5 Direction Classification (<code>classify_directions</code>)</h3>
<ul>
<li><strong>What it does</strong>: Extends the direction partition from Demo 87 with explicit per-direction type labels (null-only=0, shared=1, non-null-only=2), enabling type-selective perturbation, analysis, and constrained optimization.</li>
<li><strong>Introduced in</strong>: Demo 88</li>
<li><strong>Reused in</strong>: (Demo 88 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>classify_directions(cat_size)</code> — builds per-direction null/non-null counts, assigns <code>dir_type[i]</code> for each direction, counts <code>n_null_only_dirs</code>, <code>n_shared_dirs</code>, <code>n_nonnull_only_dirs</code></li>
<li><code>dir_type[]</code> array: 0=null-only, 1=shared, 2=non-null-only; used by perturbation framework and constrained optimizer</li>
<li><strong>Approximate size</strong>: ~50 lines</li>
<li><strong>Notes</strong>: At zeta_8: 6 null-only (cube edge midpoints), 3 shared (coordinate axes), 4 non-null-only (body diagonals). The three types form the three orbits of the octahedral symmetry group acting on RP².</li>
</ul>
<p>---</p>
<h2>17. Depth Law Mechanism (Demos 89-91)</h2>
<h3>17.1 Depth-Stratified Subset Loaders</h3>
<ul>
<li><strong>What it does</strong>: A family of subset-loading functions that extract specific depth slices or depth-filtered subsets from the saved catalog, enabling controlled experiments that isolate depth as a variable.</li>
<li><strong>Introduced in</strong>: Demo 89</li>
<li><strong>Reused in</strong>: Demo 90 (<code>load_deep</code>, <code>load_shallow</code>, <code>load_strided</code>, <code>load_random</code>), Demo 91 (<code>load_up_to_depth</code>)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>load_single_depth(d)</code> — loads entries at exactly depth d into g_cat[]</li>
<li><code>load_cumulative(max_d)</code> — loads all entries up to depth max_d</li>
<li><code>load_random_from_depth(d, n)</code> — Fisher-Yates shuffle to select n random entries from depth d</li>
<li><code>load_random_full(n)</code> — n random entries from entire catalog</li>
<li><code>load_deep(n)</code> / <code>load_shallow(n)</code> / <code>load_strided(n)</code> / <code>load_random(n)</code> (Demo 90) — four strategies for N=564 comparative tests</li>
<li><code>load_up_to_depth(max_d)</code> (Demo 91, 92) — loads saved catalog up to depth max_d, returns loaded count</li>
<li><strong>Approximate size</strong>: ~100 lines (all variants combined)</li>
<li><strong>Notes</strong>: The subset-loading pattern is the key experimental infrastructure for the depth-law arc. By controlling which entries are loaded, each phase can isolate the effect of depth, size, or randomness on computational capacity.</li>
</ul>
<h3>17.2 Pairwise Coherence Metrics</h3>
<ul>
<li><strong>What it does</strong>: Computes mean absolute quaternion dot product across all pairs in a catalog subset — a measure of collective alignment/coherence. Used to test (and KILL) the hypothesis that pairwise quaternion alignment explains the depth law.</li>
<li><strong>Introduced in</strong>: Demo 89</li>
<li><strong>Reused in</strong>: (Demo 89 only — the hypothesis was killed)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>qdot(p, q)</code> — absolute quaternion dot product |p.a<em>q.a + p.b</em>q.b + p.c<em>q.c + p.d</em>q.d|</li>
<li><code>mean_pairwise_qdot(cat_size)</code> — O(N²) mean over all pairs in g_cat[0..cat_size-1]</li>
<li><strong>Approximate size</strong>: ~30 lines</li>
<li><strong>Notes</strong>: Result: mean |qdot| is flat at ~0.42 across all depths and identical to random baseline. Pairwise coherence is NOT the mechanism for the depth law.</li>
</ul>
<h3>17.3 Cayley Graph Density Analysis</h3>
<ul>
<li><strong>What it does</strong>: Tests whether entries close in the Cayley graph (one generator step apart) are better for DKC computation than entries far apart. Counts Cayley edges within subsets and compares to XOR capacity.</li>
<li><strong>Introduced in</strong>: Demo 89</li>
<li><strong>Reused in</strong>: (Demo 89 only — the hypothesis was killed and INVERTED)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>is_cayley_neighbor(a, b, gens, n_gens)</code> — tests whether quaternions a and b are one generator step apart (|a*g - b| &lt; tol for some generator g)</li>
<li><strong>Approximate size</strong>: ~30 lines</li>
<li><strong>Notes</strong>: Same-depth entries have ZERO mutual Cayley edges (mathematically necessary from BFS construction). Deep-564 has 0 edges; strided-564 has 58. Yet deep beats strided on XOR capacity. The mechanism is ANTI-correlated with Cayley density.</li>
</ul>
<h3>17.4 Angle and Direction Extractors</h3>
<ul>
<li><strong>What it does</strong>: Extracts rotation angle in degrees from a quaternion, and Voronoi cell index from quaternion rotation axis. Used across multiple phases of the depth-law investigation.</li>
<li><strong>Introduced in</strong>: Demo 89</li>
<li><strong>Reused in</strong>: Demo 90 (<code>extract_angle</code>, <code>extract_axis</code>, <code>axis_dot</code>), Demo 92 (angle extraction)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>extract_angle(q)</code> — full rotation angle in degrees [0, 360) from quaternion; handles non-unit quaternions via normalization</li>
<li><code>quat_vor(q)</code> — Voronoi cell index from quaternion rotation axis; used for shadow pair detection</li>
<li><code>extract_axis(q, ax, ay, az)</code> (Demo 90) — unit rotation axis from quaternion, sign-canonicalized</li>
<li><code>axis_dot(p, q)</code> (Demo 90) — dot product between rotation axes of two quaternions</li>
<li><strong>Approximate size</strong>: ~40 lines</li>
<li><strong>Notes</strong>: <code>extract_angle</code> and <code>extract_axis</code> together decompose a quaternion into its S¹ (angle) and S² (axis) components. This decomposition is the basis for axis cancellation analysis (Demo 90) and spectral decomposition (Demo 90 Phase 5).</li>
</ul>
<h3>17.5 Paired Extension Framework (Shadow Pair Detector)</h3>
<ul>
<li><strong>What it does</strong>: Detects "shadow pairs" in XOR winners — entries sharing the same Voronoi direction but differing in eigenvalue angle. Tests the nesting property: does removing a shadow element leave a valid lower-arity winner?</li>
<li><strong>Introduced in</strong>: Demo 89 (Phase 11)</li>
<li><strong>Reused in</strong>: (Demo 89 only — confirms <a href="./entries/demo_77.html">D77</a>'s shadow pair structure at zeta_12)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Shadow pair detection: for each winner tuple element, checks whether another element shares its Voronoi direction (same <code>quat_vor</code> value) but has a different angle</li>
<li>Nesting test: remove shadow element, check whether remaining elements form a valid winner at (n_weights-1) level</li>
<li>Reports: total winners, shadow count, shadow fraction, nesting verification</li>
<li><strong>Approximate size</strong>: ~60 lines</li>
<li><strong>Notes</strong>: At zeta_12 (275 entries, 114 dirs): XOR6 has 6% shadow pairs, XOR8 has 20%, with 100% nesting. At zeta_8 (24 entries, 13 dirs): 100% shadow pairs. The shift from shadow-dominant (sparse directions) to diversity-dominant (dense directions) is a key structural insight.</li>
</ul>
<h3>17.6 Resolution Sweep Infrastructure (Demo 91)</h3>
<ul>
<li><strong>What it does</strong>: Systematic sweep of activation resolution parameters (k_sec from 2 to 48, Voronoi direction counts from 2 to 114) at fixed catalog depth, measuring whether increased resolution enables higher XOR arity or just more solutions at the same arity.</li>
<li><strong>Introduced in</strong>: Demo 91</li>
<li><strong>Reused in</strong>: (Demo 91 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>count_xor_winners(n_weights, bf_limit, k_sec)</code> — brute-force enumeration of all C(bf, n_weights) tuples that pass test_xor at a specific k_sec; supports 3/4/5-weight tuples</li>
<li><code>phase1_ksec_sweep()</code> — sweeps k_sec at fixed depth, measures XOR6/XOR8/XOR10 counts and max arity</li>
<li><code>phase2_voronoi_sweep()</code> — sweeps Voronoi direction count at fixed k_sec, measures capacity</li>
<li><code>phase3_depth_ksec_interaction()</code> — full 9×9 grid (depths 0-8 × k_sec 2-48), computes max arity + winner counts + depth gap analysis</li>
<li><code>build_dirs_from_saved(max_d)</code> — builds direction set from saved catalog up to a specific depth (not from current loaded catalog)</li>
<li><strong>Approximate size</strong>: ~200 lines</li>
<li><strong>Notes</strong>: Key finding: max_xor is INDEPENDENT of activation resolution (k_sec 2-48 all give max_xor=8 at depth 4). Resolution affects count (586 to 7652 XOR8 winners, ~13x), not existence. The depth gap (XOR6→XOR8) is invariant across all k_sec values. This confirms the balanced exponentials explanation: the wall is parity, not activation.</li>
</ul>
<p>---</p>
<h2>18. Sum-Angle Structure and Spectral Analysis (Demo 90)</h2>
<h3>18.1 Sum-Angle Census</h3>
<ul>
<li><strong>What it does</strong>: Computes all pairwise quaternion sum angles for a catalog subset, generates histogram, and counts distinct angles within tolerance. Used to characterize the distribution of sum angles across different subsets (deep, shallow, strided, random).</li>
<li><strong>Introduced in</strong>: Demo 90</li>
<li><strong>Reused in</strong>: (Demo 90 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>sum_angle_census(label, out_n_distinct)</code> — computes all C(N,2) pairwise quaternion sums, extracts rotation angle of each sum, prints 12-bin histogram (0-180°), min/max/mean, and distinct count (via <code>count_distinct</code>)</li>
<li><code>entry_angle_census(label)</code> — individual entry angle statistics for comparison</li>
<li><code>count_distinct(angles, n, tol)</code> — counts distinct values within tolerance using <code>g_distinct[]</code> buffer (MAX_DISTINCT=2048)</li>
<li><strong>Approximate size</strong>: ~80 lines</li>
<li><strong>Notes</strong>: All subsets (deep, strided, shallow, random at N=564) produce 2048+ distinct pairwise sum angles. The discriminating feature is the distribution shape (deep skews toward 135-180°), not the count.</li>
</ul>
<h3>18.2 Axis Cancellation Analysis</h3>
<ul>
<li><strong>What it does</strong>: Compares axis alignment (rotation axis dot product) between XOR winners and random non-winners. Identifies anti-aligned axis pairs as the geometric mechanism of "algebraic coherence."</li>
<li><strong>Introduced in</strong>: Demo 90 (Phase 2b)</li>
<li><strong>Reused in</strong>: (Demo 90 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>extract_axis(q, ax, ay, az)</code> — extracts unit rotation axis from quaternion (sign-canonicalized)</li>
<li><code>axis_dot(p, q)</code> — dot product between rotation axes; negative values indicate anti-alignment</li>
<li><code>phase2b_winning_anatomy()</code> — for XOR8 winners vs random non-winners, computes min_dot, mean_dot, and mean sum angle; reports statistical comparison</li>
<li><strong>Approximate size</strong>: ~60 lines</li>
<li><strong>Notes</strong>: XOR8 winners: mean(min_dot) = -0.75 vs -0.65 for non-winners. Anti-aligned axis pairs produce low sum angles (30-66°) needed for sector separation. This is the concrete geometric realization of "algebraic coherence."</li>
</ul>
<h3>18.3 Cross-Depth Sum-Angle Vocabulary</h3>
<ul>
<li><strong>What it does</strong>: Analyzes how the sum-angle vocabulary grows across depth levels. Measures distinct pairwise sum angles for shallow×shallow, deep×deep, and (critically) generator×deep cross-depth pairs.</li>
<li><strong>Introduced in</strong>: Demo 90 (Phases 2c, 2d, 2e)</li>
<li><strong>Reused in</strong>: (Demo 90 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>phase2c_cross_depth_sum_angles()</code> — shallow×shallow vs deep×deep vs cross-depth angle count comparison</li>
<li><code>phase2d_cross_depth_by_level()</code> — per-depth-level vocabulary growth: computes gen × depth_d pairwise sum angles, tracks cumulative distinct set, measures growth rate</li>
<li>Phase 2e: low-angle (&lt;70°) tail analysis — exponential growth but shrinking fraction</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: Key finding: generator × deep-entry sums produce only 73 distinct angles from 50K pairs, vs 1313 for deep × deep. BFS-derived entries have constrained pairwise sums with their ancestors — this is the algebraic constraint underlying the depth law.</li>
</ul>
<h3>18.4 Spherical Harmonic Decomposition of S² Point Cloud</h3>
<ul>
<li><strong>What it does</strong>: Full spherical harmonic power spectrum P(l) = sum_m f_lm^2 of the S² point cloud of rotation axes, per depth level and cumulative. Computes bandwidth metrics BW_90% and BW_99% (minimum l capturing that fraction of total power).</li>
<li><strong>Introduced in</strong>: Demo 90 (Phase 5)</li>
<li><strong>Reused in</strong>: (Demo 90 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>assoc_legendre(l, m, x)</code> — associated Legendre polynomial (same implementation as Demo 88)</li>
<li><code>ylm_real(l, m, theta, phi)</code> — real spherical harmonic evaluation, LMAX=16 (289 coefficients)</li>
<li><code>cart_to_sph(ax, ay, az, theta, phi)</code> — Cartesian to spherical coordinate conversion</li>
<li><code>phase5_spectral_decomposition()</code> — per-depth and cumulative spectral tables with BW_90% and BW_99% bandwidth</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: Key finding (SPECTRAL INVERSION): bandwidth DECREASES with depth. BW_90% drops from l=4 (depth 0) to l=2 (cumulative). The point cloud converges to uniform (l=0 dominant). Computational power grows while positional information content SHRINKS — proving the depth law mechanism is relational (axis cancellation, cross-depth constraints), not positional.</li>
</ul>
<p>---</p>
<h2>19. Function Scaling and Parity Lock (Demo 92)</h2>
<h3>19.1 Generalized Boolean Function Tester</h3>
<ul>
<li><strong>What it does</strong>: Tests whether a weight tuple computes an arbitrary Boolean function (not just XOR) by checking whether the combined_cell activation separates class-0 from class-1 masks as defined by any truth table.</li>
<li><strong>Introduced in</strong>: Demo 92</li>
<li><strong>Reused in</strong>: (foundational for future encoding design and function-targeting work)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>test_bool_func(indices, n_weights, k_sec, truth_table)</code> — generalized test: for each input mask, computes quaternion sum, maps through combined_cell activation, checks whether all masks in each cell have the same truth value according to the provided truth table. Returns 1 if separable, 0 if not.</li>
<li><code>count_bool_winners(n_weights, bf_limit, truth_table)</code> — counts weight tuples achieving a given Boolean function across the short k-ladder {6, 12, 24}; supports 3/4/5-weight tuples</li>
<li><strong>Approximate size</strong>: ~80 lines</li>
<li><strong>Notes</strong>: Generalizes the XOR-specific <code>test_xor</code> used in <a href="./entries/demo_78.html">D78</a>-<a href="./entries/demo_91.html">D91</a> to arbitrary Boolean functions. The truth table is passed as an integer array indexed by mask. This is the key tool for proving that AND/OR/MAJ are structurally impossible under the +/-q encoding.</li>
</ul>
<h3>19.2 Truth Table Generators</h3>
<ul>
<li><strong>What it does</strong>: Generates truth tables for standard Boolean functions given n_inputs: XOR, AND, OR, MAJ (majority), and THRESHOLD-k.</li>
<li><strong>Introduced in</strong>: Demo 92</li>
<li><strong>Reused in</strong>: (foundational for future Boolean function exploration)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>make_xor_tt(tt, n_inputs)</code> — popcount mod 2</li>
<li><code>make_and_tt(tt, n_inputs)</code> — all bits set</li>
<li><code>make_or_tt(tt, n_inputs)</code> — any bit set</li>
<li><code>make_maj_tt(tt, n_inputs)</code> — popcount &gt; n/2</li>
<li><code>make_threshold_tt(tt, n_inputs, k)</code> — popcount &gt;= k</li>
<li><code>popcount(x)</code> — bit population count helper</li>
<li><strong>Approximate size</strong>: ~50 lines</li>
<li><strong>Notes</strong>: XOR is the only function where f(0...0) = f(1...1) (both 0 for even-length inputs). This property is what makes XOR uniquely compatible with the +/-q encoding where masks 0...0 and 1...1 produce identical quaternion sums (both zero).</li>
</ul>
<h3>19.3 Equivalence Class Analysis</h3>
<ul>
<li><strong>What it does</strong>: Analyzes the 3^k equivalence classes induced by the +/-q encoding (per-weight effective states {-q, 0, +q}), checking each standard Boolean function for constancy on each class to identify structural impossibilities.</li>
<li><strong>Introduced in</strong>: Demo 92 (Phase 1d)</li>
<li><strong>Reused in</strong>: (Demo 92 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>phase1d_class_analysis()</code> — enumerates all 27 (=3^3) equivalence classes for 3 weights; for each class computes the set of masks it contains; checks XOR/AND/OR/MAJ for constancy on each class; reports conflict counts and cell assignments</li>
<li><strong>Approximate size</strong>: ~80 lines</li>
<li><strong>Notes</strong>: XOR has 0/27 class conflicts (constant on all classes). AND has 1/27 (class (0,0,0) contains masks 000000 and 111111, which have different AND values). MAJ has 19/27 — the most conflicts. The encoding creates a quotient structure that perfectly preserves parity but destroys all non-parity functions.</li>
</ul>
<h3>19.4 Separability Checker and Truth Table Census</h3>
<ul>
<li><strong>What it does</strong>: Checks whether a given cell-labeling can separate a truth table (all masks in each cell have the same truth value), and runs Monte Carlo census of separability across random weight triples.</li>
<li><strong>Introduced in</strong>: Demo 92 (Phases 1b, 1c)</li>
<li><strong>Reused in</strong>: (Demo 92 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>check_separability(cell_labels, truth_table, n_masks)</code> — checks whether the cell labeling is consistent with the truth table</li>
<li><code>phase1b_truth_table_census()</code> — 10,000 random 3-weight triples; tests XOR/AND/OR/MAJ separability; reports fraction separable</li>
<li><code>phase1c_mask_collisions()</code> — exhaustive pairwise collision check (C(64,2) pairs), classifies by parity agreement; confirms same-parity-only collision structure</li>
<li><code>tt_equal(a, b, n)</code> — truth table equality check</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: 83.7% of random triples are XOR6-separable. AND/OR/MAJ = 0.0% each. 76 exact quaternion-sum collisions, ALL 76 same-parity (0 cross-parity). The parity-lock is structural, not statistical.</li>
</ul>
<h3>19.5 Sign-Flip Symmetry Decomposition</h3>
<ul>
<li><strong>What it does</strong>: Decomposes the combined_cell activation into its sector (S¹) and Voronoi (S²) components, then verifies that sign-flipped sums (+S and -S) produce identical cell assignments — establishing a second parity-lock mechanism.</li>
<li><strong>Introduced in</strong>: Demo 92 (Phase 1e)</li>
<li><strong>Reused in</strong>: (Demo 92 only — feeds into <a href="./entries/demo_93.html">D93</a> complement-blindness theorem)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>sector_of(sa, sb, sc, sd, k_sec)</code> — extracts angular sector index from quaternion sum</li>
<li><code>voronoi_of(sa, sb, sc, sd)</code> — extracts Voronoi cell index from quaternion sum</li>
<li><code>phase1e_sign_flip_symmetry()</code> — checks all 13 sign-flip pairs for sector/Voronoi/cell/parity agreement; also multi-triple analysis comparing winners vs non-winners on distinct cell count</li>
<li><strong>Approximate size</strong>: ~60 lines</li>
<li><strong>Notes</strong>: All 13 sign-flip pairs map to identical sector, Voronoi cell, combined cell, and parity. This is provable from the combined_cell code: normalization by |qa| maps S and -S identically. XOR winners use 11-13 distinct cells (of 27 classes); non-winners use 6-11.</li>
</ul>
<p>---</p>
<h2>20. Complement-Blindness and Phase-Cell Activation (Demo 93)</h2>
<h3>20.1 Phase-Sensitive Activation (<code>phase_cell</code>)</h3>
<ul>
<li><strong>What it does</strong>: Identical to <code>combined_cell</code> but WITHOUT the <code>if (qa &lt; 0)</code> sign-flip normalization. The sector spans [0, 360) instead of [0, 180), breaking the S &lt;-&gt; -S complement symmetry. This is the key activation enabling computation of all Boolean functions under 1wpi encoding.</li>
<li><strong>Introduced in</strong>: Demo 93</li>
<li><strong>Reused in</strong>: Demo 94 (1wpi framework for all three group comparisons)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>phase_cell(sa, sb, sc, sd, k_sec)</code> — maps quaternion sum to (sector x Voronoi cell) index; sector computed from atan2 without absolute-value normalization; returns cell index in [0, k_sec * n_dir)</li>
<li>Contrast with <code>combined_cell</code>: same inputs, same Voronoi partition, different sector computation (full [0,360) vs folded [0,180))</li>
<li><strong>Approximate size</strong>: ~20 lines</li>
<li><strong>Notes</strong>: The removal of one line of code (<code>if (qa &lt; 0) { qa = -qa; ... }</code>) transforms the activation from complement-blind to complement-sensitive. Under combined_cell: mask m and ~m always map to the same cell (100% sharing). Under phase_cell: sharing drops to 1.1%, and all 13 NPN classes become achievable at N=3. This is the architectural discovery enabling the circuit complexity hierarchy.</li>
</ul>
<h3>20.2 1wpi Boolean Function Testers (<code>test_1wpi</code>, <code>test_1wpi_phase</code>)</h3>
<ul>
<li><strong>What it does</strong>: Tests whether a weight tuple in the 1-weight-per-input encoding separates class-0 from class-1 masks for an arbitrary Boolean function under either combined_cell or phase_cell activation.</li>
<li><strong>Introduced in</strong>: Demo 93</li>
<li><strong>Reused in</strong>: Demo 94 (shared pattern for all group comparisons)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>test_1wpi(indices, n_weights, k_sec, truth_table)</code> — 1wpi test under combined_cell; for each input mask, builds quaternion sum with signs {+1,-1} determined by mask bits; maps through combined_cell; checks purity</li>
<li><code>test_1wpi_phase(indices, n_weights, k_sec, truth_table)</code> — same as test_1wpi but uses phase_cell</li>
<li><code>count_phase_ex(n_weights, bf_limit, truth_table)</code> — exhaustive winner counting under phase_cell across K_SHORT = {6, 12, 24} ladder</li>
<li><code>sample_phase(n_weights, bf, n_samples, truth_table, rng)</code> — Monte Carlo winner sampling for larger N where exhaustive enumeration is intractable (used for N=7,8)</li>
<li><strong>Approximate size</strong>: ~120 lines</li>
<li><strong>Notes</strong>: The 1wpi encoding assigns one catalog quaternion per input bit. Mask bits determine sign: bit=1 gives +q_i, bit=0 gives -q_i. The sum S = sum(+/-q_i) is then mapped through activation. This is distinct from the +/-q encoding of <a href="./entries/demo_92.html">D92</a> where both paired values are in the catalog.</li>
</ul>
<h3>20.3 NPN Equivalence Class Enumeration (<code>init_npn</code>, <code>sweep_triple_npn</code>)</h3>
<ul>
<li><strong>What it does</strong>: Enumerates all 14 NPN equivalence classes for 3-input Boolean functions. For each weight triple under phase_cell, identifies which NPN classes are achievable by testing all possible cell-to-output assignments.</li>
<li><strong>Introduced in</strong>: Demo 93</li>
<li><strong>Reused in</strong>: (Demo 93 only — used for Phase 4 and Phase 5 complement-invariant and phase-cell diagnostics)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>init_npn()</code> — generates canonical truth table for each of 14 NPN classes by enumerating all 6 input permutations x 8 input complementations x output negation; deduplicates to find 14 unique representatives</li>
<li><code>npn_xform()</code> — applies an NPN transformation (permutation + complement + negation) to a truth table</li>
<li><code>sweep_triple_npn(idx, k_sec, cls_hit)</code> — for a given 3-weight triple under phase_cell, tries all possible cell-to-output assignments; records which NPN classes are achievable; fills cls_hit boolean array</li>
<li><strong>Approximate size</strong>: ~120 lines</li>
<li><strong>Notes</strong>: 14 NPN classes at 3 inputs include constant (1), threshold/AND/OR (4), XOR (1), MAJ (1), and 7 others. Only 2 non-trivial classes are complement-invariant. Under phase_cell: 12/13 non-trivial classes achieved at depth 0, last class at depth 1. Under combined_cell: 0/13 at any depth (all zero for odd N).</li>
</ul>
<h3>20.4 BFS Closure with Depth Tracking (<code>build_closure</code>)</h3>
<ul>
<li><strong>What it does</strong>: SU(2) group closure with BFS round tracking, producing a catalog with per-element depth assignments. Extended from <a href="./entries/demo_80.html">D80</a>-<a href="./entries/demo_92.html">D92</a> with snapshot/filter pattern for cumulative depth experiments.</li>
<li><strong>Introduced in</strong>: Demo 80 (original); Demo 93 (snapshot/filter extensions)</li>
<li><strong>Reused in</strong>: Demo 94 (shared infrastructure)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>build_closure(verbose)</code> — BFS closure with g_depth[] tracking; identity + generators at depth 0</li>
<li><code>save_catalog()</code> / <code>load_up_to_depth(max_d)</code> — snapshot/filter pattern enabling depth-stratified experiments without rebuilding closure</li>
<li><strong>Approximate size</strong>: ~80 lines</li>
<li><strong>Notes</strong>: <a href="./entries/demo_93.html">D93</a> uses zeta_12 with 4096 entries across 9 BFS rounds. The snapshot pattern enables rapid iteration across depth cutoffs for the scaling analysis in Phases 7-8.</li>
</ul>
<p>---</p>
<h2>21. Binary Icosahedral Group and Exact Z[sqrt5] Arithmetic (Demo 94)</h2>
<h3>21.1 Z[sqrt5] Ring Arithmetic (<code>Zr5</code>)</h3>
<ul>
<li><strong>What it does</strong>: Exact integer arithmetic in the ring Z[sqrt5]. Each element represents a + b*sqrt(5) using two long integers. Full ring operations with no floating point.</li>
<li><strong>Introduced in</strong>: Demo 94</li>
<li><strong>Reused in</strong>: (Demo 94 only — but reusable for any Z[sqrt5] computation including icosian ring, Fibonacci-parameter TQC)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>Zr5</code> struct: two <code>long</code> fields <code>a</code>, <code>b</code> representing a + b*sqrt(5)</li>
<li><code>zr5_make(a, b)</code>, <code>zr5_add(x, y)</code>, <code>zr5_sub(x, y)</code>, <code>zr5_neg(x)</code> — basic ring operations</li>
<li><code>zr5_mul(x, y)</code> — multiplication using identity (a + b<em>sqrt5)(c + d</em>sqrt5) = (ac + 5bd) + (ad + bc)*sqrt5</li>
<li><code>zr5_eq(x, y)</code> — exact equality</li>
<li><code>zr5_div4(x)</code> — division by 4 (for quaternion renormalization after /16 -&gt; /4)</li>
<li><strong>Approximate size</strong>: ~50 lines</li>
<li><strong>Notes</strong>: The key algebraic innovation: 2I group elements are quaternions over Z[sqrt5]/4, not Z[zeta_8]. phi = (1+sqrt5)/2 is represented as Zr5{1,1} (before the /2 that is absorbed into the quaternion's /4 denominator). Fully exact — no floating point in any group operation.</li>
</ul>
<h3>21.2 Quaternion over Z[sqrt5] (<code>Q2I</code>)</h3>
<ul>
<li><strong>What it does</strong>: Four-component quaternion with Zr5 entries, representing (a + b*sqrt5)/4 per component. Full quaternion algebra for the binary icosahedral group.</li>
<li><strong>Introduced in</strong>: Demo 94</li>
<li><strong>Reused in</strong>: (Demo 94 only — but reusable for icosian ring computations)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>Q2I</code> struct: four <code>Zr5</code> fields <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> representing quaternion components (real, i, j, k), each divided by 4</li>
<li><code>q2i_make(a, b, c, d)</code> — constructor from four Zr5 values</li>
<li><code>q2i_eq(p, q)</code> — exact equality</li>
<li><code>q2i_neg(p)</code> — quaternion negation</li>
<li><code>q2i_conj(p)</code> — quaternion conjugate (negate i, j, k components)</li>
<li><code>q2i_mul(p, q)</code> — Hamilton product with <code>zr5_div4</code> renormalization (products of /4 quaternions give /16 results, divided back to /4)</li>
<li><code>q2i_is_unit(p)</code> — unit norm check: |p|^2 = a^2 + b^2 + c^2 + d^2 = 16 (in the /4 representation)</li>
<li><code>q2i_to_float(p)</code> — converts exact Q2I to floating-point Quat for use with the phase_cell/Voronoi framework</li>
<li><strong>Approximate size</strong>: ~80 lines</li>
<li><strong>Notes</strong>: The /4 representation means the norm check is q.a^2 + q.b^2 + q.c^2 + q.d^2 = 16 (not 1). Multiplication involves zr5_mul for each Hamilton product term, then zr5_div4 to renormalize from /16 back to /4. The 120 elements of 2I are all unit quaternions under this representation.</li>
</ul>
<h3>21.3 Binary Icosahedral Group BFS Closure (<code>build_2i</code>)</h3>
<ul>
<li><strong>What it does</strong>: BFS closure of the binary icosahedral group from two generators s and t. Stores elements in a global array with depth tracking. Handles mod-sign identification (120 elements -&gt; 60 bracket values).</li>
<li><strong>Introduced in</strong>: Demo 94</li>
<li><strong>Reused in</strong>: (Demo 94 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>build_2i(verbose)</code> — BFS closure: starts from identity + generators s and t; at each round, multiplies all current elements by both generators; deduplicates via exact Q2I equality (checking both +q and -q); terminates when no new elements appear</li>
<li>Generator s: (1 + i + j + k)/2, order 6 (s^6 = 1)</li>
<li>Generator t: (phi + phi_inv*i + j)/2, order 10 (involves golden ratio)</li>
<li><code>g_2i[]</code> global array: stores all 60 bracket values (120 mod sign)</li>
<li><code>g_2i_depth[]</code>: per-element BFS depth tracking</li>
<li>Depth profile: 5, 8, 11, 12, 11, 8, 4, 1 (symmetric diamond in 7 rounds)</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: The symmetric diamond depth profile is characteristic of 2I's Cayley graph. 9 conjugacy classes with half-angles at 0, 36, 60, 72, 90, 108, 120, 144, 180 degrees. ~31 distinct S2 directions (vs 13 for z8). The group is the unique non-solvable finite SU(2) subgroup.</li>
</ul>
<h3>21.4 Zeta-12 Truncated Catalog Builder (<code>build_z12_truncated</code>)</h3>
<ul>
<li><strong>What it does</strong>: Constructs a zeta_12 catalog truncated to a given BFS depth, using four generators (e^{i*pi/6} rotations). Used for the three-way comparison in Phase 4.</li>
<li><strong>Introduced in</strong>: Demo 94</li>
<li><strong>Reused in</strong>: (Demo 94 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>build_z12_truncated(max_depth)</code> — BFS closure of zeta_12 generators, stopping at the specified depth; stores in global catalog with depth tracking</li>
<li>Four generators: perpendicular-axis rotations at zeta_12 half-angle (pi/6)</li>
<li>At depth&lt;=2: produces 51 entries, 22 directions, 276 cells</li>
<li><strong>Approximate size</strong>: ~60 lines</li>
<li><strong>Notes</strong>: Provides the infinite-group non-solvable baseline for the three-way comparison. Truncation to depth&lt;=2 gives a catalog comparable in size to 2I's 60 entries, enabling fair comparison.</li>
</ul>
<h3>21.5 Fisher-Yates Shuffle for Random Subset Selection</h3>
<ul>
<li><strong>What it does</strong>: Produces random subsets of a given size from a larger array using partial Fisher-Yates shuffle with LCG-based RNG. Used for drawing random 24-element subsets from the 60-element 2I catalog.</li>
<li><strong>Introduced in</strong>: Demo 89 (<code>shuffle</code> companion to LCG); Demo 94 (partial shuffle variant for subset selection)</li>
<li><strong>Reused in</strong>: (Demo 94 Phases 2/2b)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Partial Fisher-Yates: shuffles first K elements of an N-element array without completing the full permutation</li>
<li>LCG-based RNG with deterministic seeds for reproducible trials</li>
<li>10-trial averaging for Monte Carlo comparison (Phase 2)</li>
<li><strong>Approximate size</strong>: ~20 lines</li>
<li><strong>Notes</strong>: Deterministic seeds enable reproducible comparison across groups. The 10-trial mean smooths variance from random subset selection while keeping runtime tractable for exhaustive N&lt;=6 testing.</li>
</ul>
<h3>21.6 Catalog Save/Load and Multi-Group Comparison Infrastructure</h3>
<ul>
<li><strong>What it does</strong>: Extends the catalog save/restore pattern from <a href="./entries/demo_79.html">D79</a>-<a href="./entries/demo_92.html">D92</a> to support multiple group catalogs (z8, 2I, z12) in a single demo, enabling controlled comparisons without rebuilding closures.</li>
<li><strong>Introduced in</strong>: Demo 94</li>
<li><strong>Reused in</strong>: (Demo 94 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>build_z8_catalog()</code> / <code>init_z8()</code> — constructs zeta_8 catalog (24 entries) via BFS closure of three generators; provides solvable-group baseline</li>
<li><code>load_catalog()</code> — restores a saved catalog snapshot into the global working catalog</li>
<li><code>save_z8[]</code> / <code>saved_2i[]</code> / <code>saved_z12[]</code> — static arrays for each group's catalog</li>
<li><code>build_dirs(cat_size)</code> — extracts distinct S2 directions from current catalog (1e-6 tolerance dedup); shared across all groups</li>
<li><strong>Approximate size</strong>: ~80 lines</li>
<li><strong>Notes</strong>: The multi-group infrastructure enables Phases 2-4's controlled comparisons: z8 vs random-2I-subset vs full-2I vs truncated-z12. Each comparison loads the relevant catalog, builds its direction set, and runs the same capacity pipeline.</li>
</ul>
<h2>22. Commutator Structure and Derived Series (Demo 95)</h2>
<h3>22.1 Z[sqrt2] Ring Arithmetic (<code>Zr2</code>)</h3>
<ul>
<li><strong>What it does</strong>: Exact integer type representing a + b*sqrt(2) in the ring Z[sqrt2]. The natural coefficient ring for the binary octahedral group's quaternions.</li>
<li><strong>Introduced in</strong>: Demo 95</li>
<li><strong>Reused in</strong>: Demos 96, 97</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>Zr2</code> struct: two <code>long</code> components (a, b) representing a + b*sqrt(2)</li>
<li><code>zr2_make()</code>, <code>zr2_add()</code>, <code>zr2_sub()</code>, <code>zr2_neg()</code>, <code>zr2_mul()</code>, <code>zr2_eq()</code>, <code>zr2_div2()</code></li>
<li>Multiplication uses the identity sqrt(2)^2 = 2 for exact integer arithmetic</li>
<li><strong>Approximate size</strong>: ~60 lines</li>
<li><strong>Notes</strong>: Companion to Q2I's Z[sqrt5] (Demo 94). Both rings arise from quadratic extensions needed for binary polyhedral groups. Division by 2 (<code>zr2_div2</code>) handles renormalization after quaternion multiplication (products have /4 denominators that reduce to /2).</li>
</ul>
<h3>22.2 Quaternion over Z[sqrt2] (<code>QZ8</code>)</h3>
<ul>
<li><strong>What it does</strong>: Four-component quaternion with Zr2 entries, representing elements of the binary octahedral group (order 48, 24 bracket values mod sign).</li>
<li><strong>Introduced in</strong>: Demo 95</li>
<li><strong>Reused in</strong>: Demos 96, 97</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>QZ8</code> struct: four Zr2 components (a, b, c, d) each representing (a + b*sqrt(2))/2</li>
<li><code>qz8_make()</code>, <code>qz8_eq()</code>, <code>qz8_neg()</code>, <code>qz8_conj()</code>, <code>qz8_mul()</code></li>
<li><code>qz8_to_float()</code> — converts to double-precision Quat for phase_cell activation</li>
<li><strong>Approximate size</strong>: ~80 lines</li>
<li><strong>Notes</strong>: Exact arithmetic for all group operations — no floating point in the algebra layer. FP only at the readout boundary (qz8_to_float). Compare Q2I (Demo 94) which uses Z[sqrt5] for the binary icosahedral group.</li>
</ul>
<h3>22.3 BFS Group Closure with Depth Tracking (<code>build_z8</code>)</h3>
<ul>
<li><strong>What it does</strong>: BFS closure of the binary octahedral group from generators, with mod-sign identification and depth tracking.</li>
<li><strong>Introduced in</strong>: Demo 95</li>
<li><strong>Reused in</strong>: Demos 96, 97</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>build_z8(verbose)</code> — BFS from 4 generators: (sqrt2/2)(1+i), (sqrt2/2)(1-k), plus conjugates</li>
<li>Stores 24 bracket values in global array with depth per entry</li>
<li>Handles mod-sign identification (48 elements -&gt; 24 bracket values)</li>
<li><strong>Approximate size</strong>: ~60 lines</li>
</ul>
<h3>22.4 Derived Series Infrastructure</h3>
<ul>
<li><strong>What it does</strong>: Iteratively computes the commutator subgroup and derived series of a finite group, partitioning elements by algebraic depth.</li>
<li><strong>Introduced in</strong>: Demo 95</li>
<li><strong>Reused in</strong>: Demos 96, 97</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>z8_commutator(a, b)</code> / <code>i2_commutator(a, b)</code> — compute [a,b] = a<em>b</em>a^{-1}*b^{-1}</li>
<li><code>close_z8_subgroup(in_set)</code> — closes subset under multiplication and inverse</li>
<li><code>phase1_commutators()</code> — enumerates all single commutators, classifies COMM vs NON-COMM</li>
<li><code>phase2_derived_series()</code> — iterative commutator subgroup chain: G0 &gt; G1 &gt; G2 &gt; ... assigns level per element</li>
<li><strong>Approximate size</strong>: ~200 lines</li>
<li><strong>Notes</strong>: z8 derived series is 24 &gt; 12 &gt; 4 &gt; 1 (2O &gt; 2T &gt; Q8 &gt; center). 2I terminates immediately (perfect group, G1=G0).</li>
</ul>
<h2>23. TL-Group Cross-Classification (Demo 96)</h2>
<h3>23.1 Cell Cross-Tabulation (<code>compute_cells</code>)</h3>
<ul>
<li><strong>What it does</strong>: Cross-product of two independent partitions (bracket-null/non-null from <a href="./entries/demo_84.html">D84</a> x derived series level from <a href="./entries/demo_95.html">D95</a>) to produce a 5-cell landscape (A through E) for the z8 bracket values.</li>
<li><strong>Introduced in</strong>: Demo 96</li>
<li><strong>Reused in</strong>: (Demo 96 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>compute_null_classification()</code> — tests Re(q)=0 for each quaternion entry</li>
<li><code>compute_cells()</code> — assigns cell label (A-E) from derived_level x null_status cross-product</li>
<li><code>load_cells(cell_mask)</code> — flexible subset loader: 5-element bitmask selects union of cells into global catalog</li>
<li><code>run_subset_capacity()</code> / <code>print_subset_result()</code> — XOR capacity test at N=3,4,5,6 for loaded catalog</li>
<li><strong>Approximate size</strong>: ~150 lines</li>
<li><strong>Notes</strong>: Five cells: A(D0-null,6), B(D0-nonnull,6), C(<a href="./entries/demo_01.html">D1</a>-nonnull,8), D(<a href="./entries/demo_02.html">D2</a>-null,3), E(<a href="./entries/demo_03.html">D3</a>-identity,1). Key result: A+B+C (21 entries) beats ALL (24) — pruning Q8-null entries improves capacity.</li>
</ul>
<h2>24. Cell B Geometric Analysis (Demo 97)</h2>
<h3>24.1 Cell B Extraction and Angle Sensitivity Sweep</h3>
<ul>
<li><strong>What it does</strong>: Isolates Cell B entries (derived level 0, non-null) and parametrically tests XOR capacity across half-angles to determine the perfection mechanism.</li>
<li><strong>Introduced in</strong>: Demo 97</li>
<li><strong>Reused in</strong>: (Demo 97 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>extract_cell_b()</code> — filters z8 elements by derived level 0 and non-null real component; produces 6 entries in exact (QZ8) and float (Quat) form</li>
<li>Angle sweep: same 3 orthogonal directions tested at 21 half-angles from 10 to 90 degrees using synthetic quaternions</li>
<li><code>count_xor()</code> — iterates C(n,k) combinations at multiple k_sec values (6,12,24), reports XOR-separable tuples</li>
<li><code>test_1wpi_xor()</code> — single-tuple XOR test with signed-sum and cell-based class counting</li>
<li><strong>Approximate size</strong>: ~200 lines</li>
<li><strong>Notes</strong>: Key finding: 50-degree perfection plateau (25-75 degrees). 45 degrees is the midpoint, not a magic number. Isolated anomaly at 35 degrees (N=5 only).</li>
</ul>
<h2>25. 3-Strand TL Infrastructure (Demo 98)</h2>
<h3>25.1 TL_3 5x5 Matrix Representation (<code>TLMat</code>)</h3>
<ul>
<li><strong>What it does</strong>: Full 5x5 matrix algebra over Z[zeta_8] for the 3-strand Temperley-Lieb representation (C_3=5 non-crossing matchings).</li>
<li><strong>Introduced in</strong>: Demo 98</li>
<li><strong>Reused in</strong>: (Demo 98 only — superseded by 2x2 Delta_1 in Demo 99)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>TLMat</code> struct: 5x5 matrix of Cyc8 entries (100 long integers)</li>
<li><code>tlm_zero()</code>, <code>tlm_identity()</code>, <code>tlm_add()</code>, <code>tlm_neg()</code>, <code>tlm_scale()</code>, <code>tlm_mul()</code>, <code>tlm_eq()</code>, <code>tlm_trace()</code></li>
<li><code>PMatch</code> / <code>enumerate_basis()</code> — planar matching representation (6 boundary points, 5 matchings)</li>
<li><code>compose_diagrams()</code> — diagram multiplication with closed-loop counting</li>
<li><code>build_gen_matrix()</code> — constructs TL generator matrices e_1, e_2</li>
<li><strong>Approximate size</strong>: ~250 lines</li>
<li><strong>Notes</strong>: The 5x5 representation is REDUCIBLE. Trace readout retains only 5.1% of diversity (105/2048 distinct traces). Column 4 is LOSSLESS (2048 distinct vectors from 2048 matrices).</li>
</ul>
<h3>25.2 3-Strand BFS Catalog Builder (<code>build_3strand_catalog</code>)</h3>
<ul>
<li><strong>What it does</strong>: BFS closure of the braid group B_3 on TL_3, with bracket computation, depth/writhe tracking, and interleaving classification.</li>
<li><strong>Introduced in</strong>: Demo 98</li>
<li><strong>Reused in</strong>: (Demo 98 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>build_braid_generators()</code> — constructs sigma_1+/-, sigma_2+/- from A = -zeta_8</li>
<li><code>build_3strand_catalog()</code> — BFS with 4 generators, cap at 2048 entries</li>
<li>Interleaving bitmask: bit0=uses_sigma1, bit1=uses_sigma2</li>
<li><code>phase_cell_cyc8()</code> — trace-based activation for 3-strand (angle-based sector)</li>
<li><strong>Approximate size</strong>: ~200 lines</li>
<li><strong>Notes</strong>: Group is INFINITE at zeta_8. 98.5% interleaving. 100% entanglement vanishing for non-interleaving entries.</li>
</ul>
<h2>26. Delta_1 Standard Module Infrastructure (Demo 99)</h2>
<h3>26.1 2x2 Matrix over Cyc8 (<code>Mat2</code>)</h3>
<ul>
<li><strong>What it does</strong>: The irreducible 2-dimensional standard module Delta_1 of TL_3 at delta=0, represented as 2x2 matrices over Z[zeta_8]. The key breakthrough enabling first-ever 3-strand XOR.</li>
<li><strong>Introduced in</strong>: Demo 99</li>
<li><strong>Reused in</strong>: (Demo 99 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>Mat2</code> struct: 4 Cyc8 entries = 16 long integers</li>
<li><code>mat2_zero()</code>, <code>mat2_identity()</code>, <code>mat2_mul()</code>, <code>mat2_eq()</code>, <code>mat2_add()</code>, <code>mat2_neg()</code>, <code>mat2_max_abs()</code>, <code>mat2_commutator()</code></li>
<li><code>CycQuat</code> — quaternion extraction from Mat2: q_0=a+d, q_1=b+c, q_2=b-c, q_3=a-d</li>
<li>Hash table for BFS deduplication (FNV-style over 16 long components)</li>
<li><strong>Approximate size</strong>: ~200 lines</li>
<li><strong>Notes</strong>: Delta_1 is indecomposable but reducible: submodule L(0) and quotient L(1), extension Ext^1(L(0),L(1)) is non-zero. The Jordan block structure (sigma_1^n has off-diagonal n*A^{n-2}) proves the extension does not split and gives infinite order.</li>
</ul>
<h3>26.2 Multi-Activation Framework for Mat2</h3>
<ul>
<li><strong>What it does</strong>: Four activation functions for 2x2 matrix DKC, parametrized by number of cells.</li>
<li><strong>Introduced in</strong>: Demo 99</li>
<li><strong>Reused in</strong>: (Demo 99 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>ACT_4ENT_HASH</code> — 4 matrix entry octants hashed</li>
<li><code>ACT_QUAT_HASH</code> — 4 quaternion component octants hashed</li>
<li><code>ACT_2x2_HASH</code> — 16-component sign-bit hash (3-valued per component: pos/zero/neg). BEST activation.</li>
<li><code>ACT_TRACE_OCT</code> — trace octant only (8 cells). WORST activation.</li>
<li><code>test_xor_mat2()</code> — XOR test for Mat2 with touched-cell optimization</li>
<li><code>count_xor_bf()</code> — brute-force search over C(bf_limit, n_weights) tuples, supports 3-8 weights (XOR6-XOR16)</li>
<li><strong>Approximate size</strong>: ~150 lines</li>
<li><strong>Notes</strong>: Activation hierarchy: 2x2_hash &gt;&gt; 4ent_hash &gt;&gt; quat_hash &gt;&gt; trace_oct. The 2x2_hash achieves XOR6=500K, XOR8=48K, XOR10=485, XOR12=16, XOR14=60. XOR16=0 (genuine ceiling).</li>
</ul>
<h3>26.3 Casimir Discriminant (<code>mat2_casimir</code>)</h3>
<ul>
<li><strong>What it does</strong>: Computes C(S) = (a-d)^2 + 4<em>b</em>c for summed Mat2 matrices. Exact computation in Z[zeta_8]. Distinguishes Jordan blocks (C=0) from diagonalizable matrices.</li>
<li><strong>Introduced in</strong>: Demo 99</li>
<li><strong>Reused in</strong>: Demos 100, 101 (generalized to C_d formula)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>mat2_casimir()</code> — returns Cyc8 value, L1 norm for magnitude comparison</li>
<li>Two-regime discovery: XOR6-8 winners have LOWER |C| (inverted), XOR10-14 winners have 4.4x HIGHER |C|</li>
<li><strong>Approximate size</strong>: ~20 lines</li>
<li><strong>Notes</strong>: The Casimir measures "non-scalar-ness." Winner vs control gap (4.4x at XOR14) is the first quantitative measure of algebraic reservoir quality. Phase transition at XOR8-&gt;XOR10 coincides with shallow-&gt;deep entry transition.</li>
</ul>
<h3>26.4 sl_2 Decomposition Analysis</h3>
<ul>
<li><strong>What it does</strong>: Decomposes 2x2 matrices into sl_2 components (scalar, Cartan h, e-root, f-root) for hub anatomy analysis.</li>
<li><strong>Introduced in</strong>: Demo 99</li>
<li><strong>Reused in</strong>: (Demo 99 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Hub commutator [hub7, hub9]: traceless, strong Cartan component, e/f ratio = 6.0</li>
<li>Anti-trace classification: a=d entries have zero Cartan component</li>
<li>U-shaped Cartan correlation: both cartan=0 and cartan=11+ compute, middle is dead</li>
<li><strong>Approximate size</strong>: ~40 lines</li>
</ul>
<h2>27. 4-Strand W_{4,2} Infrastructure (Demo 100)</h2>
<h3>27.1 3x3 Matrix over Cyc8 (<code>Mat3</code>)</h3>
<ul>
<li><strong>What it does</strong>: 3-dimensional standard module W_{4,2} of TL_4 at delta=0 (non-semisimple), represented as 3x3 matrices over Z[zeta_8].</li>
<li><strong>Introduced in</strong>: Demo 100</li>
<li><strong>Reused in</strong>: (Demo 100 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>Mat3</code> struct: 9 Cyc8 entries = 36 long integers</li>
<li><code>mat3_zero()</code>, <code>mat3_identity()</code>, <code>mat3_mul()</code>, <code>mat3_eq()</code>, <code>mat3_add()</code>, <code>mat3_neg()</code>, <code>mat3_scale()</code>, <code>mat3_max_abs()</code>, <code>mat3_print()</code></li>
<li>Hash table for BFS (FNV over 36 longs, HASH_SIZE=65537)</li>
<li><strong>Approximate size</strong>: ~200 lines</li>
<li><strong>Notes</strong>: Extension structure 0 -&gt; L_{4,4} -&gt; W_{4,2} -&gt; L_{4,2} -&gt; 0. Radical direction r=(1,0,-1) verified: all TL generators annihilate r. Every braid matrix preserves the non-semisimple structure (constant radical_content=2 at all depths).</li>
</ul>
<h3>27.2 TL_4 Generator and Braid Generator Construction</h3>
<ul>
<li><strong>What it does</strong>: Constructs TL_4 generators (3x3 integer matrices e_1, e_2, e_3) and braid generators (sigma_i = A<em>I + A^{-1}</em>e_i) for the W_{4,2} module.</li>
<li><strong>Introduced in</strong>: Demo 100</li>
<li><strong>Reused in</strong>: (Demo 100 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>build_tl_generators()</code> — 3 TL generators as 3x3 integer matrices on basis {h_0, h_1, h_2}</li>
<li><code>build_braid_generators()</code> — 6 braid generators (sigma_1..3 and inverses) over Z[zeta_8]</li>
<li>Verification: e_i^2=0, Jones-Wenzl relations, far commutativity, braid relations, Hecke relations</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
</ul>
<h3>27.3 3x3 Activation and XOR Test (<code>mat3_activate</code>, <code>test_xor_mat3</code>)</h3>
<ul>
<li><strong>What it does</strong>: Novel sign-pattern activation for 3x3 matrix DKC and exhaustive XOR search infrastructure.</li>
<li><strong>Introduced in</strong>: Demo 100</li>
<li><strong>Reused in</strong>: (Demo 100 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>mat3_activate(m, k_param)</code> — sign pattern of 36 integer components (3-valued: pos/zero/neg), base-3 hash mod k_param</li>
<li><code>test_xor_mat3()</code> — 1wpi XOR test for Mat3 catalog (N weights -&gt; 2N inputs)</li>
<li><code>count_xor_bf(n_weights, k_param, bf_limit)</code> — brute-force search, supports 3-7 weights (XOR6-XOR14)</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: XOR14=70 from deep entries (d&gt;=4). 6 super-hubs in 3 Cyc8-component pairs. ALL hub commutators traceless with zero radical content.</li>
</ul>
<h3>27.4 Radical Analysis Infrastructure</h3>
<ul>
<li><strong>What it does</strong>: Measures radical content of catalog entries and their products. Tracks how the non-semisimple module structure interacts with XOR capacity.</li>
<li><strong>Introduced in</strong>: Demo 100</li>
<li><strong>Reused in</strong>: (Demo 100 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Radical direction r=(1,0,-1): verified e_i*r=0 for all TL generators</li>
<li><code>radical_content(M)</code> — computes r^T M r (how much M "touches" the radical direction)</li>
<li>Modified Casimir: C3(M) = 3*tr(M^2) - (tr M)^2 (coefficient matches module dimension)</li>
<li>Per-depth radical/Casimir statistics: radical constant at 2, Casimir grows ~2x per round</li>
<li><strong>Approximate size</strong>: ~60 lines</li>
</ul>
<h2>28. 5-Strand W_{5,3} Infrastructure (Demo 101)</h2>
<h3>28.1 4x4 Matrix over Cyc8 (<code>Mat4</code>)</h3>
<ul>
<li><strong>What it does</strong>: 4-dimensional standard module W_{5,3} of TL_5 at delta=0 (SIMPLE — no radical), represented as 4x4 matrices over Z[zeta_8].</li>
<li><strong>Introduced in</strong>: Demo 101</li>
<li><strong>Reused in</strong>: (Demo 101 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>Mat4</code> struct: 16 Cyc8 entries = 64 long integers</li>
<li><code>mat4_zero()</code>, <code>mat4_identity()</code>, <code>mat4_mul()</code>, <code>mat4_eq()</code>, <code>mat4_add()</code>, <code>mat4_neg()</code>, <code>mat4_scale()</code>, <code>mat4_max_abs()</code>, <code>mat4_print()</code></li>
<li><code>mat4_trace()</code>, <code>mat4_tr_sq()</code> — trace and trace-of-square for Casimir computation</li>
<li><code>mat4_casimir(m)</code> — C4(M) = 4*tr(M^2) - (tr M)^2 (coefficient = dim(W_{5,3}) = 4)</li>
<li><code>mat4_frob_l1()</code> — Frobenius L1 norm</li>
<li>Hash table for BFS (FNV over 64 longs, HASH_SIZE=65537)</li>
<li><strong>Approximate size</strong>: ~250 lines</li>
<li><strong>Notes</strong>: W_{5,3} is SIMPLE (radical dimension = 0). Key structural difference from <a href="./entries/demo_100.html">D100</a>'s W_{4,2}. BFS growth ~4x per round (confirming sl_4 thesis). Only 3 super-hubs (not predicted 12). XOR14=0 everywhere (vs 70 for <a href="./entries/demo_100.html">D100</a>). Casimir-XOR correlation INVERTS at higher XOR levels.</li>
</ul>
<h3>28.2 TL_5 Generator and Braid Generator Construction</h3>
<ul>
<li><strong>What it does</strong>: Constructs 4 TL generators (4x4 integer matrices e_1..e_4) and 8 braid generators for the W_{5,3} module.</li>
<li><strong>Introduced in</strong>: Demo 101</li>
<li><strong>Reused in</strong>: (Demo 101 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>build_tl_generators()</code> — 4 TL generators on basis {h_0, h_1, h_2, h_3} (A_3 Dynkin diagram pattern)</li>
<li><code>build_braid_generators()</code> — 8 braid generators (sigma_1..4 and inverses) over Z[zeta_8]</li>
<li>Verification: e_i^2=0, Jones-Wenzl relations (3 adjacent pairs), far commutativity (3 far pairs), braid relations, Hecke relations (30 tests total)</li>
<li><strong>Approximate size</strong>: ~120 lines</li>
</ul>
<h3>28.3 4x4 Activation and XOR Test (<code>mat4_activate</code>, <code>test_xor_mat4</code>)</h3>
<ul>
<li><strong>What it does</strong>: Sign-pattern activation for 4x4 matrix DKC (64 integer components) and exhaustive XOR search.</li>
<li><strong>Introduced in</strong>: Demo 101</li>
<li><strong>Reused in</strong>: (Demo 101 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>mat4_activate(m, k_param)</code> — sign pattern of 64 integer components (4x4 x 4 Cyc8), 3-valued, base-3 hash mod k_param</li>
<li><code>test_xor_mat4()</code> — 1wpi XOR test for Mat4 catalog (supports up to 8 weights / 16 inputs)</li>
<li><code>count_xor_bf(n_weights, k_param, bf_limit)</code> — brute-force search, supports 3-7 weights (XOR6-XOR14)</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: XOR6-XOR12 sustained at depth. XOR14=0 at all k values (128 through 4096). Simple module has broader but shallower capacity than <a href="./entries/demo_100.html">D100</a>'s non-semisimple module.</li>
</ul>
<h3>28.4 Casimir C_d Formula (Generalized)</h3>
<ul>
<li><strong>What it does</strong>: Generalized Casimir discriminant C_d(M) = d*tr(M^2) - (tr M)^2 where d = module dimension. Uniform formula across <a href="./entries/demo_99.html">D99</a>/<a href="./entries/demo_100.html">D100</a>/<a href="./entries/demo_101.html">D101</a>, extended through <a href="./entries/demo_102.html">D102</a>-<a href="./entries/demo_103.html">D103</a>.</li>
<li><strong>Introduced in</strong>: Demo 99 (as C2), generalized in Demo 100 (C3) and Demo 101 (C4)</li>
<li><strong>Reused in</strong>: Demo 102 (C5 for dim-5 modules W_{6,0} and W_{6,4}), Demo 103 (C5 and C9 for dim-5 and dim-9 modules), Demo 104 (via MatN Casimir)</li>
<li><strong>Key types/functions</strong>:</li>
<li><a href="./entries/demo_99.html">D99</a>: C(S) = (a-d)^2 + 4bc (2x2 form)</li>
<li><a href="./entries/demo_100.html">D100</a>: C3(M) = 3*tr(M^2) - (tr M)^2</li>
<li><a href="./entries/demo_101.html">D101</a>: C4(M) = 4*tr(M^2) - (tr M)^2</li>
<li><a href="./entries/demo_102.html">D102</a>: C5(M) = 5*tr(M^2) - (tr M)^2</li>
<li><a href="./entries/demo_103.html">D103</a>: C9(M) = 9*tr(M^2) - (tr M)^2</li>
<li>All computations exact in Z[zeta_8], L1 norm for magnitude comparison</li>
<li><strong>Notes</strong>: Casimir-XOR correlation is POSITIVE in non-semisimple modules (<a href="./entries/demo_99.html">D99</a>/<a href="./entries/demo_100.html">D100</a>) but INVERTS in simple modules (<a href="./entries/demo_101.html">D101</a>) at high XOR levels. The coefficient tracks module dimension: d=2,3,4,5,9 for TL_3/TL_4/TL_5/TL_6. <a href="./entries/demo_102.html">D102</a> extends to d=5 (XOR6 Casimir-by-level: winners=68, control=59, ratio=1.15x). <a href="./entries/demo_103.html">D103</a> shows mean |C9| for dim-9 module is 2.6x that of dim-5 module (123 vs 48).</li>
</ul>
<p>---</p>
<h2>Cross-Cutting Patterns</h2>
<h3>Copy-Paste Codebase Pattern</h3>
Each demo is a standalone <code><a href="../demo_78_recursive_scaling/main.c.html">main.c</a></code> file that copies needed infrastructure from prior demos. There is no shared library extraction. This means:
<ul>
<li>Code evolves independently per demo (e.g., MAX_TERMS varies)</li>
<li>Bug fixes in one demo don't propagate</li>
<li>Each demo compiles and runs independently</li>
<li>The "library" is the accumulated pattern knowledge, not shared object files</li>
</ul>
<h3>Ring-Parametric Architecture</h3>
Demos 53-59 follow a consistent pattern:
1. Implement cyclotomic ring arithmetic (Cyc_n type)
2. Reuse identical planar matching / diagram composition code
3. Instantiate TL matrix algebra over the new ring
4. Build state-sum bracket with ring-specific delta powers
5. Build catalog and run DKC Boolean function search
<p>The topology code (planar matchings, diagram composition, trace closure) is completely ring-independent.</p>
<h3>Radical Anatomy Pipeline</h3>
Demos 38, 39, 51, 52, 60 follow a consistent pattern for analyzing TL algebra structure:
1. Enumerate planar matching basis (Section 3.1)
2. Build multiplication table with loop counts
3. Construct Gram matrix of trace form (fixpoint-based or delta-weighted)
4. Gaussian elimination mod p for rank / radical dimension
5. Extract radical basis, compute radical filtration (rad^2, rad^3, ...)
6. Sector decomposition by through-strand count
<p>This pipeline works identically across number field degree (rational, quadratic, cubic) with only the delta representation changing.</p>
<h3>Validation Chain</h3>
Every new computation method is cross-validated against prior oracles:
<ul>
<li>Symbolic bracket (Demo 01) validates braid bracket (Demo 02)</li>
<li>Braid bracket validates matrix method (Demos 03-06)</li>
<li>Matrix method validates numerical engine (Demo 10)</li>
<li>State-sum validates TL matrix method (Demos 35, 53-59)</li>
<li>Exact Cyc8 validates float Cx (Demo 29)</li>
<li>Two-prime cross-validation for cubic field results (Demo 60)</li>
</ul>
<h3>Quaternionic / S^2 Arc Architecture (Demos 66-92)</h3>
<p>Demos 66-71 establish the foundation; Demos 72-84 extend it into a full capacity theory; Demos 85-86 establish TL algebra representation theory; Demos 87-92 investigate mechanism and limits:</p>
<p><strong>Foundation arc (<a href="./entries/demo_66.html">D66</a>-<a href="./entries/demo_71.html">D71</a>):</strong> 1. Generate the SU(2) braid representation (<a href="./entries/demo_66.html">D66</a>) — produces exactly 24 quaternions (24-cell / binary octahedral group) 2. Decompose quaternions into eigenvector direction (S^2) and eigenvalue angle (<a href="./entries/demo_67.html">D67</a>) — identifies 13 data-intrinsic directions 3. Build the custom 13-direction Voronoi on S^2 — canonical activation (36 XOR6 solutions at 14 cells) 4. Verify computation lives on S^2, not S^1 fiber (Hopf phase inert, <a href="./entries/demo_67.html">D67</a>) and not R^2 Euclidean (<a href="./entries/demo_68.html">D68</a>) 5. Confirm direction nesting across cyclotomic roots — zeta_8 is the computational sweet spot (<a href="./entries/demo_69.html">D69</a>) 6. Analyze spectral structure: l=6 bandwidth threshold = 13=13 theorem (<a href="./entries/demo_71.html">D71</a>)</p>
<p><strong>Extension arc (<a href="./entries/demo_72.html">D72</a>-<a href="./entries/demo_84.html">D84</a>):</strong> 7. Prove the 13 directions are geometrically worst (t=0 design) yet algebraically optimal (<a href="./entries/demo_72.html">D72</a>); confirm anti-correlation between sampling quality and computational quality 8. Characterize DKC as a near-finite-automaton: 82.8% universal determinism, additive not multiplicative (<a href="./entries/demo_73.html">D73</a>) 9. Prove Kauffman bracket and Voronoi cell are incomparable invariants; identify 6 computational orbit types (<a href="./entries/demo_74.html">D74</a>) 10. Discover binocular channel: angle subsumes cell (2.3× capacity), 8 triple families, √n magnitude quantization (<a href="./entries/demo_75.html">D75</a>) 11. Establish ζ₈ S²-capacity ceiling at XOR8; characterize algebraic structure breakdown (<a href="./entries/demo_76.html">D76</a>) 12. Break the ceiling with S¹×S² product activation: XOR8 solvable at ζ₈ (<a href="./entries/demo_77.html">D77</a>); recursive paired-quaternion structure identified 13. Confirm ζ₈ XOR hierarchy terminates at 8 via exhaustive C(24,5) search; non-monotonicity from π/4 incommensurability (<a href="./entries/demo_78.html">D78</a>) 14. Break the ζ₈ wall entirely with ζ₁₂: XOR10=124 winners, XOR12=50+ winners; finite vs infinite group identified as key variable (<a href="./entries/demo_79.html">D79</a>) 15. Survey all SU(2) subgroups: only ζ₄ and ζ₈ are finite; ADE classification; quantum dimension vanishes at ζ₈ (<a href="./entries/demo_80.html">D80</a>) 16. Fit logarithmic capacity scaling law for ζ₁₂: max_xor ≈ 0.62 × log₂(catalog) + 4.6 (<a href="./entries/demo_81.html">D81</a>) 17. Unify as linear depth law: max_xor ≈ depth + 6; crossing depth = knot crossing depth; algebraic coherence beats vocabulary (<a href="./entries/demo_82.html">D82</a>) 18. Prove Jones normalization costs exactly 2 XOR levels at all tested roots; writhe and depth are independent additive resources; framing is not a bookkeeping artifact — it is one discrete computational unit (<a href="./entries/demo_83.html">D83</a>) 19. Prove bracket-null entries (Re(q)=0) are indispensable: they hold 6 S² directions unavailable to non-null entries; removing them drops capacity from XOR8 to XOR6, below the random-subset baseline; connect to LCFT Jordan-cell structure and Reservoir Computing null-state hypothesis (<a href="./entries/demo_84.html">D84</a>)</p>
<p><strong>Representation theory branch (<a href="./entries/demo_85.html">D85</a>-<a href="./entries/demo_86.html">D86</a>):</strong> 20. Full TL algebra infrastructure: diagram basis, multiplication table, star anti-involution, left ideal closure, projective cover construction. Compute b = -5/8 exactly at TL_4 via leading-coefficient extraction from delta-parameterized Gram matrix (<a href="./entries/demo_85.html">D85</a>). Falsify Gemini's claim about standard-module Jordan blocks. 21. Attempt direct b computation on single P_{0,0} — UNIVERSAL DIVERGENCE at all eigenvalues, all lattice sizes, both forms. Multiplicity from the regular representation is structurally essential, not a scale factor (<a href="./entries/demo_86.html">D86</a>). Novel negative result.</p>
<p><strong>Depth law mechanism arc (<a href="./entries/demo_87.html">D87</a>-<a href="./entries/demo_91.html">D91</a>):</strong> 22. Null dispensability at zeta_12: removing 121 null entries preserves full XOR capacity. Regime transition between finite groups (nulls critical) and infinite groups (nulls redundant). Direction density is the control parameter (<a href="./entries/demo_87.html">D87</a>). 23. Anti-correlation mechanism: non-null body-diagonal directions are rigid computational anchors; null edge-midpoint directions are flexible scaffolding. K-ladder provides 14x better perturbation resilience than Voronoi-only (6.4% vs 89% loss). Constrained optimization captures 92% of design improvement at 56% less computational cost (<a href="./entries/demo_88.html">D88</a>). 24. Systematic elimination of 8 depth-law hypotheses: KILL pairwise coherence, direction coverage, Cayley density, sector diversity, angle coherence. Paired extension is real but minority (6-20% at ζ₁₂). Algebraic coherence remains the open question (<a href="./entries/demo_89.html">D89</a>). 25. Depth law mechanism FOUND: axis cancellation (anti-aligned axes → low sum angles) + cross-depth algebraic constraints (BFS ancestry → limited sum-angle vocabulary). Spectral inversion: S² point cloud bandwidth DECREASES with depth while computation INCREASES. Mechanism is relational, not positional (<a href="./entries/demo_90.html">D90</a>). 26. Activation is NOT the bottleneck: max_xor invariant across k_sec 2-48 and direction counts 2-114. Resolution affects count, not existence. Balanced exponentials confirmed: supply ~2x/depth, demand 4x/weight → slope 1 (<a href="./entries/demo_91.html">D91</a>).</p>
<p><strong>Function scaling (<a href="./entries/demo_92.html">D92</a>-<a href="./entries/demo_93.html">D93</a>):</strong> 27. Parity-Lock Theorem: the +/-q encoding is structurally parity-locked — XOR/XNOR are the ONLY computable functions. AND/OR/MAJ = 0 winners at ALL depths. 6-part proof: (0,0)≡(1,1) collision, 3^k equivalence classes, sign-flip symmetry. Encoding concentrates on the hardest function (outside AC^0) (<a href="./entries/demo_92.html">D92</a>). 28. Complement-Blindness Theorem + Phase-Cell Recovery: under combined_cell, mask m and ~m always map to the same cell (complement-blind); all non-complement-invariant functions impossible. Removing the sign flip (phase_cell) breaks the symmetry: complement sharing drops 100% to 1.1%, all 13 NPN classes recovered. Circuit complexity hierarchy emerges as AND/XOR ratio: 1.01 to infinity (N=3-8). Pigeonhole mechanism at N&gt;=7: 84 cells &lt; 128 masks kills XOR (<a href="./entries/demo_93.html">D93</a>).</p>
<p><strong>Solvability bottleneck (<a href="./entries/demo_94.html">D94</a>):</strong> 29. Binary icosahedral group 2I (order 120, unique non-solvable finite SU(2) subgroup) outperforms solvable z8 at matched catalog size, confirming Barrington's theorem prediction. AND/XOR hierarchy universal across all group structures. Crossover at N=6: 2I overtakes truncated zeta_12 where computation is hardest. Exact Z[sqrt5] arithmetic for 2I group operations (<a href="./entries/demo_94.html">D94</a>).</p>
<p><strong>Commutator structure and cross-classification (<a href="./entries/demo_95.html">D95</a>-<a href="./entries/demo_97.html">D97</a>):</strong> 30. Derived series of z8 (24&gt;12&gt;4&gt;1) reveals algebraic stratification; cross-layer synergy is the active mechanism, not commutators in isolation; 0+0&gt;0 synergy traced to algebraic origin (<a href="./entries/demo_95.html">D95</a>). 31. Two independent partitions (null/non-null x derived level) create 5-cell landscape; optimal catalog is 21 entries not 24 — pruning Q8-null noise improves capacity (<a href="./entries/demo_96.html">D96</a>). 32. Cell B perfection is geometric inevitability from orthogonal frame, not algebraic fine-tuning; 50-degree robust plateau (25-75 degrees); octahedral optimality on S^2 (<a href="./entries/demo_97.html">D97</a>).</p>
<p><strong>Multi-strand matrix DKC (<a href="./entries/demo_98.html">D98</a>-<a href="./entries/demo_105.html">D105</a>):</strong> 33. 3-strand TL_3 5x5 representation: infinite group, 2048 entries, but trace readout catastrophically lossy (ZERO XOR6). Column-4 is lossless (100% diversity). Readout, not algebra, is the bottleneck (<a href="./entries/demo_98.html">D98</a>). 34. LANDMARK: 3-strand Delta_1 (2x2 irreducible module) achieves first-ever 3-strand XOR at ALL levels through XOR14. 2x2_hash activation (16-component sign-pattern). Infinite group via Jordan block (Fibonacci growth). Ext^1 catalytic preparation thesis. Two-regime discovery: combinatorial (XOR6-8) vs algebraic (XOR10-14). Super-hub star-graph topology (<a href="./entries/demo_99.html">D99</a>). 35. 4-strand W_{4,2} (3x3, non-semisimple): ~3.1x BFS growth, XOR14=70, 6 super-hubs in 3 Cyc8-component pairs, constant radical content, Casimir-XOR positive correlation. All hub commutators traceless with zero radical content (<a href="./entries/demo_100.html">D100</a>). 36. 5-strand W_{5,3} (4x4, SIMPLE): ~4x BFS growth (confirms sl_d functor thesis across 3 data points), only 3 hubs (not predicted 12, hub-count prediction falsified), XOR14=0 (simple module ceiling), Casimir-XOR correlation INVERTS at high XOR levels. Non-semisimplicity is computationally load-bearing (<a href="./entries/demo_101.html">D101</a>). 37. 6-strand A/B test: W_{6,0} (dim=5, simple) vs W_{6,4} (dim=5, non-simple, radical dim=1). IDENTICAL BFS trees (32768 entries at every depth). Radical carries abelian writhe character — provably useless for parity by Barrington's theorem. Simple module WINS at every XOR level. Barrington-Radical Principle established (<a href="./entries/demo_102.html">D102</a>). 38. 6-strand dimension scaling: W_{6,0} (dim=5) vs W_{6,2} (dim=9), both simple. BFS growth identical (~5x, braid group invariant). Higher dimension HURTS XOR via curse of dimensionality in sign-hash. But W_{6,2} subset-hash B@sub7 (196 components) beats W_{6,0} — activation geometry matters. Variable-dimension MatN introduced (<a href="./entries/demo_103.html">D103</a>). 39. Activation coarseness sweep: W_{6,2} XOR deficit is a HASH problem — optimal 120/324 components beats W_{6,0} (Atkinson sweet spot). Cross-block &gt; within-block (branching interaction IS the signal). Sign-rank EXPANDS beyond raw rank (244→292). k is the real lever, not hash architecture (<a href="./entries/demo_104.html">D104</a>). 40. 8-strand k-regime: <a href="./entries/demo_93.html">D93</a>'s "XOR dies at N&gt;=7" REFUTED as k-regime artifact. W_{8,0} (dim=14) and W_{8,2} (dim=28) both simple. Branching interaction REVERSES at n=8 (within-block &gt; cross-block = macrame principle). Rank saturation confound discovered — all prior rank comparisons corrected (<a href="./entries/demo_105.html">D105</a>).</p>
<p><strong>Topological entropy and graph analysis (<a href="./entries/demo_106.html">D106</a>-<a href="./entries/demo_109.html">D109</a>):</strong> 41. Topological entropy is ORTHOGONAL to DKC computation — 100% participation for both periodic and pseudo-Anosov braids. TL visibility filter: writhe survives quotient, entropy does not. Relational computation thesis strengthened (<a href="./entries/demo_106.html">D106</a>). 42. Universal axis-alignment of braid matrices at delta=0 is a PROVABLE THEOREM with constructive Z/4Z phase formula. Nesting parity Z/2Z grading (novel, not KLR). Major index bipartite invariant. q-Catalan identity. Raqiya library established (<a href="./entries/demo_107.html">D107</a>). 43. Graph structure PREDICTS parity capability: Dual-Channel Theorem — parity needs product closure AND v_2 connectivity, poison fails on both. Maximum structural contrast. T-gate/Hadamard decomposition analogy (<a href="./entries/demo_108.html">D108</a>). 44. Encoding-dependent dual-channel: at delta=sqrt(2), 7/8 edge types identical between parity and non-parity. Product closure is sole discriminator with INVERTED polarity (parity wants LOW). j=0 liveness implies structural universality (<a href="./entries/demo_109.html">D109</a>).</p>
<p>Key progression: <a href="./entries/demo_65.html">D65</a> S^1 k=24 → <a href="./entries/demo_66.html">D66</a> S^3 25 cells → <a href="./entries/demo_67.html">D67</a> S^2 14 cells → <a href="./entries/demo_68.html">D68</a> R^2 visualization only → <a href="./entries/demo_72.html">D72</a>-<a href="./entries/demo_73.html">73</a> algebraic structure analysis → <a href="./entries/demo_74.html">D74</a> incomparability theorem → <a href="./entries/demo_75.html">D75</a>-<a href="./entries/demo_77.html">77</a> binocular + product activation → <a href="./entries/demo_78.html">D78</a>-<a href="./entries/demo_79.html">79</a> wall confirmation + ζ₁₂ breakthrough → <a href="./entries/demo_80.html">D80</a> ADE survey → <a href="./entries/demo_81.html">D81</a>-<a href="./entries/demo_82.html">82</a> scaling laws → <a href="./entries/demo_83.html">D83</a> framing as resource → <a href="./entries/demo_84.html">D84</a> null-state anatomy → <a href="./entries/demo_85.html">D85</a>-<a href="./entries/demo_86.html">86</a> TL representation theory (b = -5/8 + universal divergence on P_{0,0}) → <a href="./entries/demo_87.html">D87</a>-<a href="./entries/demo_88.html">88</a> null dispensability + anti-correlation → <a href="./entries/demo_89.html">D89</a>-<a href="./entries/demo_91.html">91</a> depth law mechanism (axis cancellation + parity wall) → <a href="./entries/demo_92.html">D92</a> parity-lock theorem → <a href="./entries/demo_93.html">D93</a> complement-blindness + phase_cell recovery + circuit complexity hierarchy → <a href="./entries/demo_94.html">D94</a> solvability bottleneck (2I vs z8, Barrington confirmed) → <a href="./entries/demo_95.html">D95</a>-<a href="./entries/demo_97.html">97</a> commutator structure + cross-classification + Cell B perfection → <a href="./entries/demo_98.html">D98</a> 3-strand readout bottleneck → <a href="./entries/demo_99.html">D99</a> Delta_1 LANDMARK (first 3-strand XOR, Ext^1 thesis) → <a href="./entries/demo_100.html">D100</a> 4-strand non-semisimple DKC → <a href="./entries/demo_101.html">D101</a> 5-strand simple module (sl_d functor, Casimir inversion) → <a href="./entries/demo_102.html">D102</a> 6-strand radical A/B test (Barrington-Radical Principle, writhe character on radical) → <a href="./entries/demo_103.html">D103</a> dimension scaling (BFS growth is braid group invariant, curse of dimensionality) → <a href="./entries/demo_104.html">D104</a> activation coarseness sweep (Atkinson sweet spot, sign-rank expansion, branching interaction thesis) → <a href="./entries/demo_105.html">D105</a> 8-strand k-regime (<a href="./entries/demo_93.html">D93</a> "XOR dies at N&gt;=7" REFUTED, macrame principle, rank saturation methodology) → <a href="./entries/demo_106.html">D106</a> topological entropy null (TL visibility filter, relational computation thesis) → <a href="./entries/demo_107.html">D107</a> algebraic graph density (axis-alignment theorem, nesting parity grading, Raqiya library, q-Catalan identity) → <a href="./entries/demo_108.html">D108</a> parity vocabulary (Dual-Channel Theorem, product closure discriminator) → <a href="./entries/demo_109.html">D109</a> encoding-dependent dual-channel (product closure inversion at delta=sqrt(2), 7/8 structural symmetry).</p>
<h3>Catalog Size Summary</h3>
<table><thead><tr><th>Ring</th><th>Delta</th><th>Catalog</th><th>Distinct Values</th></tr></thead><tbody><tr><td>Z[zeta_8]</td><td>0</td><td>2-3 strand, len 1-8</td><td>~100</td></tr><tr><td>Z[omega]</td><td>1</td><td>2-4 strand, len 1-8</td><td>varies</td></tr><tr><td>Z[zeta_16]</td><td>sqrt(2)</td><td>2-4 strand, len 1-6</td><td>~56</td></tr><tr><td>Z[zeta_5]</td><td>phi</td><td>2-4 strand, len 1-6</td><td>&gt;56</td></tr><tr><td>Z[zeta_24]</td><td>sqrt(3)</td><td>2-4 strand, len 1-10</td><td>varies</td></tr></tbody></table>
<h3>SU(2) / Quaternionic Catalog Summary (Demos 66-84, 94)</h3>
<table><thead><tr><th>Root</th><th>Quaternions</th><th>Directions on S^2</th><th>XOR6 at natural Voronoi</th><th>XOR8 (product activation)</th><th>XOR10</th><th>XOR12</th><th>Jones cap (bracket −2)</th></tr></thead><tbody><tr><td>zeta_4</td><td>4</td><td>2</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>zeta_6</td><td>infinite (&gt;4096)</td><td>512 (saturated)</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>zeta_8</td><td>24 (9 null)</td><td>13</td><td>36 (14 cells)</td><td>6 (Sec8×Vor, 112 cells)</td><td>0 (wall)</td><td>0 (wall)</td><td>XOR6 (<a href="./entries/demo_83.html">D83</a>)</td></tr><tr><td>zeta_10</td><td>infinite (&gt;4096)</td><td>512 (saturated, 71 angles)</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>zeta_12</td><td>infinite (&gt;4096, 121 null)</td><td>512 (saturated)</td><td>1024+</td><td>1024+</td><td>124</td><td>50+</td><td>XOR10 (<a href="./entries/demo_83.html">D83</a>)</td></tr><tr><td>2I</td><td>60 (mod sign)</td><td>31</td><td>74.8% (384 cells)</td><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>zeta_16</td><td>7,952</td><td>3,457</td><td>499,367 (90.6%)</td><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>zeta_32</td><td>32,768+</td><td>4,096+</td><td>493,654 (89.6%)</td><td>—</td><td>—</td><td>—</td><td>—</td></tr></tbody></table>
<h3>DKC XOR Capacity Scaling (ζ₁₂, Demos 81-82)</h3>
<table><thead><tr><th>XOR Level</th><th>Catalog Size</th><th>Closure Round</th><th>Directions</th><th>Half-Angles</th><th>Linear Depth</th></tr></thead><tbody><tr><td>XOR6</td><td>~5</td><td>0</td><td>2</td><td>2</td><td>depth 0</td></tr><tr><td>XOR8</td><td>~51</td><td>2</td><td>22</td><td>6</td><td>depth 2</td></tr><tr><td>XOR10</td><td>~275</td><td>4</td><td>114</td><td>12</td><td>depth 4</td></tr><tr><td>XOR12</td><td>~1140</td><td>6</td><td>507</td><td>21</td><td>depth 6</td></tr><tr><td>XOR14 (predicted)</td><td>~38,000</td><td>~11</td><td>—</td><td>—</td><td>depth ~8</td></tr></tbody></table>
<p>Scaling law: max_xor ≈ 0.62 × log₂(catalog_size) + 4.6 (logarithmic) ≡ depth + 6 (linear, since catalog grows as ~2^depth).</p>
<h3>Multi-Strand Matrix DKC Scaling (Demos 102-105)</h3>
<table><thead><tr><th>n (strands)</th><th>Demo</th><th>Module</th><th>dim</th><th>Generators</th><th>BFS growth</th><th>XOR capacity notes</th></tr></thead><tbody><tr><td>3</td><td><a href="./entries/demo_98.html">D98</a>/<a href="./entries/demo_99.html">D99</a></td><td>Delta_1</td><td>2</td><td>4</td><td>~2.2x</td><td>XOR14=60 (non-semisimple)</td></tr><tr><td>4</td><td><a href="./entries/demo_100.html">D100</a></td><td>W_{4,2}</td><td>3</td><td>6</td><td>~3.1x</td><td>XOR14=70 (non-semisimple)</td></tr><tr><td>5</td><td><a href="./entries/demo_101.html">D101</a></td><td>W_{5,3}</td><td>4</td><td>8</td><td>~4.0x</td><td>XOR14=0 (simple, ceiling)</td></tr><tr><td>6</td><td><a href="./entries/demo_102.html">D102</a></td><td>W_{6,0}</td><td>5</td><td>10</td><td>~5.0x</td><td>XOR10=1 (simple)</td></tr><tr><td>6</td><td><a href="./entries/demo_102.html">D102</a></td><td>W_{6,4}</td><td>5</td><td>10</td><td>~5.0x</td><td>XOR10=0 (non-simple, radical=1)</td></tr><tr><td>6</td><td><a href="./entries/demo_103.html">D103</a></td><td>W_{6,2}</td><td>9</td><td>10</td><td>~5.0x</td><td>XOR10=0 (simple, curse of dim)</td></tr><tr><td>8</td><td><a href="./entries/demo_105.html">D105</a></td><td>W_{8,0}</td><td>14</td><td>14</td><td>~7x</td><td>XOR8=22266 at k=4096</td></tr><tr><td>8</td><td><a href="./entries/demo_105.html">D105</a></td><td>W_{8,2}</td><td>28</td><td>14</td><td>—</td><td>Within-block &gt; cross-block</td></tr></tbody></table>
<p>Confirmed: BFS growth rate = n-1 (sl_{n-1} thesis). Growth is a braid group invariant, not a module property.</p>
<h3>Rank Saturation Summary (Demo 105 retroactive, all modules)</h3>
<table><thead><tr><th>Module</th><th>dim</th><th>cols</th><th>catalog</th><th>raw</th><th>raw%</th><th>sign</th><th>sign%</th><th>expansion</th></tr></thead><tbody><tr><td>Delta_1</td><td>2</td><td>16</td><td>32768</td><td>16</td><td>100%</td><td>16</td><td>100%</td><td>1.00x</td></tr><tr><td>W_{4,2}</td><td>3</td><td>36</td><td>32768</td><td>28</td><td>77.8%</td><td>32</td><td>88.9%</td><td>1.14x</td></tr><tr><td>W_{5,3}</td><td>4</td><td>64</td><td>32768</td><td>62</td><td>96.9%</td><td>64</td><td>100%</td><td>1.03x</td></tr><tr><td>W_{6,0}</td><td>5</td><td>100</td><td>32768</td><td>100</td><td>100%</td><td>100</td><td>100%</td><td>1.00x</td></tr><tr><td>W_{6,2}</td><td>9</td><td>324</td><td>—</td><td>244</td><td>75.3%</td><td>292</td><td>90.1%</td><td>1.20x</td></tr><tr><td>W_{8,0}</td><td>14</td><td>784</td><td>32768</td><td>710</td><td>90.6%</td><td>767</td><td>97.8%</td><td>1.08x</td></tr><tr><td>W_{8,2}</td><td>28</td><td>3136</td><td>16384</td><td>1096</td><td>34.9%</td><td>2003</td><td>63.9%</td><td>1.83x</td></tr></tbody></table>
<p>---</p>
<h2>29. 6-Strand Radical A/B Test Infrastructure (Demo 102)</h2>
<h3>29.1 5x5 Matrix over Cyc8 (<code>Mat5</code>)</h3>
<ul>
<li><strong>What it does</strong>: 5-dimensional matrix type for W_{6,0} (simple) and W_{6,4} (non-simple, radical dim=1) representations of TL_6 at delta=0. Full ring operations in exact Z[zeta_8] arithmetic.</li>
<li><strong>Introduced in</strong>: Demo 102</li>
<li><strong>Reused in</strong>: (Demo 102 only — superseded by variable-dimension <code>MatN</code> in Demo 103)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>Mat5</code> struct: 25 Cyc8 entries = 100 long integers</li>
<li><code>mat5_zero()</code>, <code>mat5_identity()</code>, <code>mat5_mul()</code>, <code>mat5_eq()</code>, <code>mat5_add()</code>, <code>mat5_sub()</code>, <code>mat5_neg()</code>, <code>mat5_scale()</code> — ring operations</li>
<li><code>mat5_max_abs()</code>, <code>mat5_print()</code> — analysis/output</li>
<li><code>mat5_trace()</code>, <code>mat5_tr_sq()</code> — trace and trace-of-square for Casimir</li>
<li><code>mat5_casimir(m)</code> — C5(M) = 5*tr(M^2) - (tr M)^2 (generalized Casimir with d=5)</li>
<li><code>mat5_frob_l1()</code>, <code>mat5_nonzero_count()</code> — Frobenius L1 norm and sparsity analysis</li>
<li><strong>Approximate size</strong>: ~250 lines</li>
<li><strong>Notes</strong>: Follows the per-dimension matrix pattern established in <a href="./entries/demo_99.html">D99</a> (Mat2), <a href="./entries/demo_100.html">D100</a> (Mat3), <a href="./entries/demo_101.html">D101</a> (Mat4). Superseded by the variable-dimension MatN in <a href="./entries/demo_103.html">D103</a>-<a href="./entries/demo_105.html">D105</a> which handles any dim up to 9.</li>
</ul>
<h3>29.2 Dual Module TL_6 Generator Construction</h3>
<ul>
<li><strong>What it does</strong>: Two separate TL_6 generator constructors for W_{6,0} (all-arc module, simple) and W_{6,4} (4-through-line module, non-simple), enabling head-to-head A/B comparison on the same braid group.</li>
<li><strong>Introduced in</strong>: Demo 102</li>
<li><strong>Reused in</strong>: Demo 103 (W_{6,0} half reused), Demo 104 (both W_{6,0} and W_{6,2} reused)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>build_tl_a()</code> — W_{6,0}: 5 half-diagrams with 0 through-lines, 5 TL generators, 15/125 nonzero entries</li>
<li><code>build_tl_b()</code> — W_{6,4}: 5 half-diagrams with 4 through-lines + 1 arc, 5 TL generators, 8/125 nonzero entries</li>
<li>Verification: e_i^2=0, Jones-Wenzl relations, far commutativity, braid relations, Hecke relations for both</li>
<li><strong>Approximate size</strong>: ~150 lines</li>
</ul>
<h3>29.3 Radical Analysis Functions</h3>
<ul>
<li><strong>What it does</strong>: Measures radical content, radical scalar, mixing row, and quotient block properties for non-semisimple W_{6,4} module, isolating the radical's computational contribution.</li>
<li><strong>Introduced in</strong>: Demo 102</li>
<li><strong>Reused in</strong>: (Demo 102 only — the radical direction is module-specific)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>compute_Mr(m)</code> — M*r = col0 - col2 + col4 for radical vector r=(1,0,-1,0,1)</li>
<li><code>radical_content(m)</code> — L1 norm of M*r (constant = 3 for all 32768 entries)</li>
<li><code>radical_scalar(m)</code> — scalar s where M<em>r = s</em>r (= A^{writhe})</li>
<li><code>mixing_row_l1(m)</code> — L1 norm of row 4, columns 0-3 (quotient-to-radical leakage)</li>
<li><code>quotient_block_l1(m)</code> — L1 of the 4x4 quotient block Q</li>
<li><code>mat5_activate_quot(m, k)</code> — quotient-only activation using 64 components from 4x4 block Q with sign corrections</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: Key finding: M<em>r = A^{writhe}</em>r for ALL 32768 catalog entries (Barrington-Radical Principle). The radical carries only the writhe homomorphism and is computationally inert for XOR.</li>
</ul>
<h3>29.4 Writhe Character Verification (<code>cyc8_A_pow</code>)</h3>
<ul>
<li><strong>What it does</strong>: Returns A^n for A = -zeta_8 using mod-8 lookup table. Used to verify the writhe character on the radical direction for every catalog entry.</li>
<li><strong>Introduced in</strong>: Demo 102</li>
<li><strong>Reused in</strong>: (Demo 102 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>cyc8_A_pow(n)</code> — precomputed A^k for k=0..7, n mod 8 lookup; handles negative writhe via mod arithmetic</li>
<li><strong>Approximate size</strong>: ~20 lines</li>
<li><strong>Notes</strong>: Enables the exhaustive writhe character verification: M<em>r = A^{writhe}</em>r tested for 32768/32768 entries (100%).</li>
</ul>
<h3>29.5 Function-Pointer Activation with XOR Search</h3>
<ul>
<li><strong>What it does</strong>: Variant of brute-force XOR search that takes a function pointer for activation, enabling testing different activation functions (full vs quotient) on the same catalog without code duplication.</li>
<li><strong>Introduced in</strong>: Demo 102</li>
<li><strong>Reused in</strong>: Demo 103 (switchable activation variants), Demo 104 (function-pointer activation switching)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>count_xor_bf_fn(activate_fn)</code> — XOR search with pluggable activation function</li>
<li>Used to compare full 100-component activation vs quotient-only 64-component activation on W_{6,4}</li>
<li><strong>Approximate size</strong>: ~40 lines</li>
</ul>
<h3>29.6 Saved-Catalog Cross-Module Comparison</h3>
<ul>
<li><strong>What it does</strong>: Module A results saved in <code>g_save_*</code> arrays for later comparison after Module B catalog replaces global <code>g_cat</code>. Enables A-vs-B analysis when only one catalog can be live at a time.</li>
<li><strong>Introduced in</strong>: Demo 102</li>
<li><strong>Reused in</strong>: Demo 103, Demo 104 (same save/restore pattern for A-vs-B comparison)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>g_save_*</code> arrays — deep sub-catalog save/restore for cross-module XOR comparison</li>
<li><strong>Approximate size</strong>: ~40 lines</li>
<li><strong>Notes</strong>: Pattern used throughout the multi-strand DKC arc. Extended in <a href="./entries/demo_103.html">D103</a>/<a href="./entries/demo_104.html">D104</a> for subset-hash activation ablation studies.</li>
</ul>
<p>---</p>
<h2>30. Variable-Dimension Matrix and Activation Architecture (Demos 103-104)</h2>
<h3>30.1 Variable-Dimension MatN Type</h3>
<ul>
<li><strong>What it does</strong>: Generic NxN matrix type (MAX_DIM=9) with runtime dimension <code>g_dim</code> controlling active size. Enables the same codebase to handle both 5x5 and 9x9 matrices (and potentially any dim up to 9) without code duplication.</li>
<li><strong>Introduced in</strong>: Demo 103</li>
<li><strong>Reused in</strong>: Demo 104 (with configurable-coarseness activation extensions), Demo 105 (extended to MAX_DIM=28 for W_{8,2})</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>MatN</code> struct: MAX_DIM x MAX_DIM array of Cyc8 entries</li>
<li><code>matN_zero()</code>, <code>matN_identity()</code> — constructors</li>
<li><code>matN_mul()</code>, <code>matN_mul_to()</code> — multiplication (standard and pointer-based hot-path variant)</li>
<li><code>matN_eq()</code>, <code>matN_add()</code>, <code>matN_sub()</code>, <code>matN_neg()</code>, <code>matN_scale()</code> — ring operations</li>
<li><code>matN_add_inplace()</code>, <code>matN_sub_inplace()</code> — in-place variants for performance</li>
<li><code>matN_max_abs()</code>, <code>matN_trace()</code>, <code>matN_tr_sq()</code>, <code>matN_casimir()</code> — analysis</li>
<li><code>matN_frob_l1()</code>, <code>matN_nonzero_count()</code> — sparsity metrics</li>
<li>Runtime dimension via global <code>g_dim</code> — all operations respect <code>g_dim</code> x <code>g_dim</code> active region</li>
<li><strong>Approximate size</strong>: ~300 lines</li>
<li><strong>Notes</strong>: This is the generalization of the per-dimension Mat2/Mat3/Mat4/Mat5 types from <a href="./entries/demo_99.html">D99</a>-<a href="./entries/demo_102.html">D102</a>. The runtime-dimension approach eliminates the need for separate matrix types per module dimension. Key design decision: MAX_DIM is compile-time (for stack allocation), but <code>g_dim</code> is runtime (for loop bounds).</li>
</ul>
<h3>30.2 Switchable Activation Function Pointer</h3>
<ul>
<li><strong>What it does</strong>: Function pointer mechanism with multiple activation variants, enabling systematic activation ablation studies without code duplication.</li>
<li><strong>Introduced in</strong>: Demo 103</li>
<li><strong>Reused in</strong>: Demo 104 (extended with <code>matN_activate_n</code>, <code>matN_activate_rand</code>, <code>matN_activate_multi</code>), Demo 105 (cross-block/within-block activation)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>g_activate</code> function pointer + <code>activate_fn</code> typedef — runtime activation switching</li>
<li><code>matN_activate()</code> — full sign-hash activation (all <code>g_dim<em>g_dim</em>4</code> ternary components)</li>
<li><code>matN_activate_sub()</code> — subblock activation (first NxN block of larger matrix)</li>
<li><code>matN_activate_stride()</code> — strided activation (every K-th component)</li>
<li><strong>Approximate size</strong>: ~80 lines</li>
<li><strong>Notes</strong>: The activation function is the readout layer in the reservoir computing framework. Being able to swap it at runtime enables controlled experiments isolating the activation's contribution to XOR capacity.</li>
</ul>
<h3>30.3 Configurable-Coarseness Sign-Hash Activation</h3>
<ul>
<li><strong>What it does</strong>: Sign-hash activation with configurable number of components, enabling the component-count sweep that is the core experiment of Demo 104.</li>
<li><strong>Introduced in</strong>: Demo 104</li>
<li><strong>Reused in</strong>: Demo 105 (partial sign-hash activation <code>matN_activate_partial</code>)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>matN_activate_n(m, k_param, num_comp)</code> — hashes first <code>num_comp</code> of <code>g_dim<em>g_dim</em>4</code> ternary sign components using base-3 polynomial hash mod k_param</li>
<li><code>matN_activate_rand(m, k_param)</code> — random-subset activation using index array <code>g_rand_idx[]</code>; hashes components at arbitrary positions</li>
<li><code>matN_activate_multi(m, k_param)</code> — multi-hash activation using two independent index arrays, producing 2D cell ID = hash1 * k + hash2</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: The non-monotonic component-count curve for W_{6,2} (peaking at 120 of 324 components) led to the "Atkinson sweet spot" naming. The random-subset variant showed high variance (spread=262), indicating information is concentrated in specific components.</li>
</ul>
<h3>30.4 Streaming Catalog Rank Computation</h3>
<ul>
<li><strong>What it does</strong>: Streaming Gaussian elimination over Z to compute rank of catalog as row vectors, processing entries one at a time to avoid allocating the full catalog x components matrix. GCD normalization prevents integer overflow.</li>
<li><strong>Introduced in</strong>: Demo 104</li>
<li><strong>Reused in</strong>: Demo 105 (rank computation with saturation checkpoints)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>compute_catalog_rank(n_entries)</code> — streaming Gaussian elimination on raw Cyc8 coefficient vectors (dim<em>dim</em>4 components per entry); returns rank</li>
<li><code>compute_sign_rank(n_entries)</code> — same streaming elimination but on ternary sign-projected vectors ({-1,0,+1}); reveals effective dimension after nonlinear quantization</li>
<li>GCD normalization: normalizes pivot rows by GCD of components to prevent overflow</li>
<li><strong>Approximate size</strong>: ~120 lines</li>
<li><strong>Notes</strong>: Key finding: sign quantization can EXPAND effective rank (W_{6,2}: raw 244, sign 292 — gain of 48). Sign-rank expansion ratio increases with module dimension (W_{8,2} at 1.83x). This tool established the rank saturation methodology: single-checkpoint measurements are unreliable, must report saturation curves.</li>
</ul>
<h3>30.5 Fisher-Yates Shuffle with Deterministic PRNG</h3>
<ul>
<li><strong>What it does</strong>: Xorshift PRNG with Fisher-Yates partial shuffle for reproducible random subset selection.</li>
<li><strong>Introduced in</strong>: Demo 104</li>
<li><strong>Reused in</strong>: Demo 105 (reusable PRNG infrastructure)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>rng_next()</code> — xorshift PRNG</li>
<li><code>shuffle_first_n(arr, total, n)</code> — Fisher-Yates partial shuffle selecting first n elements</li>
<li><strong>Approximate size</strong>: ~30 lines</li>
<li><strong>Notes</strong>: Used in Demo 104 for random-100 component selection experiments (5 trials, mean XOR6=2266, spread=262).</li>
</ul>
<p>---</p>
<h2>31. 8-Strand DKC Infrastructure (Demo 105)</h2>
<h3>31.1 j=2 Link State Enumerator</h3>
<ul>
<li><strong>What it does</strong>: Enumerates non-crossing perfect matchings with 2 through-strands on n=8 boundary points, producing 28 states split into two blocks (W_{7,1} with 14 states and W_{7,3} with 14 states). First implementation of j&gt;0 link states in knotapel.</li>
<li><strong>Introduced in</strong>: Demo 105</li>
<li><strong>Reused in</strong>: (Demo 105 only — but pattern generalizable to other j values)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>enumerate_ls_j2()</code> — segment-based recursive enumeration with Cartesian products of left/mid/right matchings; through-strand positions tracked and re-sorted</li>
<li>Produces 28 states split into two blocks: 14 states where through[1]=7, 14 states where through[1]&lt;7</li>
<li><strong>Approximate size</strong>: ~150 lines</li>
<li><strong>Notes</strong>: The symmetric 14+14 branching (unlike W_{6,2}'s asymmetric 5+4) enables the "macrame principle" discovery: within-block &gt; cross-block when blocks are individually complex.</li>
</ul>
<h3>31.2 5-Case TL Generator Action for j=2</h3>
<ul>
<li><strong>What it does</strong>: Handles all cases of TL generator e_i acting on a link state with 2 through-strands, implementing the complete action table.</li>
<li><strong>Introduced in</strong>: Demo 105</li>
<li><strong>Reused in</strong>: (Demo 105 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>apply_ei_j2(i, in_state, out_state)</code> — 5 cases: (1) both arc-paired to each other -&gt; loop/killed; (2) both arc-paired to others -&gt; redirect; (3) i through, i+1 arc-paired -&gt; swap; (4) i arc-paired, i+1 through -&gt; swap; (5) both through -&gt; loop/killed</li>
<li>Through-strand positions updated and re-sorted after each action</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
</ul>
<h3>31.3 Cross-Block / Within-Block Activation</h3>
<ul>
<li><strong>What it does</strong>: Activation functions that hash only off-diagonal or only diagonal blocks of a matrix under TL_{n-1} branching restriction, enabling branching decomposition analysis.</li>
<li><strong>Introduced in</strong>: Demo 105 (adapting <a href="./entries/demo_104.html">D104</a>'s branching decomposition concept to symmetric blocks)</li>
<li><strong>Reused in</strong>: (Demo 105 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>matN_activate_cross(m, k)</code> — hashes only off-diagonal blocks (rows &lt; BLOCK_SIZE, cols &gt;= BLOCK_SIZE and vice versa)</li>
<li><code>matN_activate_within(m, k)</code> — hashes only diagonal blocks</li>
<li><strong>Approximate size</strong>: ~60 lines</li>
<li><strong>Notes</strong>: Key finding reversal from <a href="./entries/demo_104.html">D104</a>: at n=8 with symmetric 14+14 blocks, within-block (XOR6=2940) &gt; cross-block (XOR6=532). This is the "macrame principle" — complex blocks are self-sufficient; simple blocks need connections.</li>
</ul>
<h3>31.4 Rank Computation with Saturation Checkpoints</h3>
<ul>
<li><strong>What it does</strong>: Streaming Gaussian elimination that reports rank at specified entry-count checkpoints, essential for honest rank measurement on infinite groups.</li>
<li><strong>Introduced in</strong>: Demo 105</li>
<li><strong>Reused in</strong>: (Demo 105 only — but the methodology is established as required practice)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>compute_rank_with_checkpoints(checkpoints, n_checkpoints)</code> — streaming GE with GCD normalization, reporting rank at each checkpoint entry count</li>
<li>Checkpoint series: {128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768}</li>
<li><strong>Approximate size</strong>: ~80 lines</li>
<li><strong>Notes</strong>: Established the rank saturation methodology: all prior single-checkpoint rank comparisons (D99b-<a href="./entries/demo_104.html">D104</a>) were confounded by varying oversampling ratios. Must report saturation curves.</li>
</ul>
<h3>31.5 Retroactive Rank Framework</h3>
<ul>
<li><strong>What it does</strong>: Generic tridiagonal TL generator builder + BFS + rank computation, parameterized by (dim, n_tl), enabling fair cross-module rank comparison with identical infrastructure.</li>
<li><strong>Introduced in</strong>: Demo 105 (<code><a href="../demo_105_8strand_k_regime/rank_retroactive.c.html">rank_retroactive.c</a></code>)</li>
<li><strong>Reused in</strong>: (Demo 105 only — used to correct all prior rank measurements)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Parameterized TL generator builder for arbitrary dim and n_tl</li>
<li>BFS closure + streaming rank computation at multiple checkpoints</li>
<li>Unified output format for cross-module comparison table</li>
<li><strong>Approximate size</strong>: ~500 lines (<code><a href="../demo_105_8strand_k_regime/rank_retroactive.c.html">rank_retroactive.c</a></code>)</li>
</ul>
<p>---</p>
<h2>32. Topological Entropy Infrastructure (Demo 106)</h2>
<h3>32.1 Dual BFS with Parallel Representations</h3>
<ul>
<li><strong>What it does</strong>: Maintains both TL (3x3 Cyc8) and reduced Burau (3x3 integer) matrices simultaneously during BFS, with shared parent/generator backtracking. Novel pattern for correlating algebraic and dynamical properties of the same braid words.</li>
<li><strong>Introduced in</strong>: Demo 106</li>
<li><strong>Reused in</strong>: (Demo 106 only — the dual-representation BFS pattern is reusable)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Parallel BFS: each catalog entry stores both a Mat3 (TL representation) and an iMat3 (Burau representation)</li>
<li>Shared parent/generator tracking for backtracking to reconstruct braid words</li>
<li>Single hash-based deduplication on the TL representation (Burau piggybacks)</li>
<li><strong>Approximate size</strong>: ~150 lines</li>
<li><strong>Notes</strong>: The key architectural insight is that the same braid word can be simultaneously evaluated in two different representations during a single BFS pass. This avoids the need for a second pass to compute the Burau representation after the TL catalog is built.</li>
</ul>
<h3>32.2 Reduced Burau Representation at t=-1 for B_4 (<code>iMat3</code>)</h3>
<ul>
<li><strong>What it does</strong>: 3x3 integer matrix type for the reduced Burau representation at t=-1, operating in SL(3,Z). Provides the topological entropy classification via characteristic polynomial analysis.</li>
<li><strong>Introduced in</strong>: Demo 106</li>
<li><strong>Reused in</strong>: (Demo 106 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>iMat3</code> struct: 9 integer entries</li>
<li><code>imat3_zero()</code>, <code>imat3_identity()</code>, <code>imat3_mul()</code>, <code>imat3_eq()</code> — matrix operations</li>
<li><code>imat3_det()</code> — integer determinant (always 1 for braids, SL(3,Z))</li>
<li><code>imat3_char_poly()</code> — characteristic polynomial coefficients (c0, c1, c2) where p(x) = x^3 + c2<em>x^2 + c1</em>x - 1</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: Separate type from Cyc8-based Mat3 to maintain pure integer arithmetic for exact entropy classification. The characteristic polynomial is computed without floating point; only the spectral radius (for entropy quantification) uses bisection.</li>
</ul>
<h3>32.3 Exact Integer Entropy Classification</h3>
<ul>
<li><strong>What it does</strong>: Classifies braids as periodic or pseudo-Anosov using purely integer arithmetic on the Burau characteristic polynomial, avoiding all floating point for the classification itself.</li>
<li><strong>Introduced in</strong>: Demo 106</li>
<li><strong>Reused in</strong>: (Demo 106 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Classification logic: p(x) = x^3 + c2<em>x^2 + c1</em>x - 1 with det=1. If p(1) = c2+c1 != 0, always pseudo-Anosov. If p(1) = 0, check quadratic factor |1-tr(M)| &gt; 2</li>
<li><code>spectral_radius_bisection(c2, c1)</code> — 100-iteration bisection for entropy-per-crossing quantification (only used for analysis, not classification)</li>
<li><strong>Approximate size</strong>: ~60 lines</li>
<li><strong>Notes</strong>: All 8 depth-2 pseudo-Anosov entries share characteristic polynomial x^3 - 4x^2 + 4x - 1 with spectral radius phi^2 = 2.618..., giving entropy per crossing = log(phi) = 0.481212... (theoretical optimum per Band &amp; Boyland 2007).</li>
</ul>
<h3>32.4 Boolean Function Sweep with +/- Encoding</h3>
<ul>
<li><strong>What it does</strong>: Tests entropy correlation against 8 Boolean functions simultaneously (AND3, OR3, XOR3, MAJ3, NAND3, NOR3, AND2, XOR2) using signed-addition 3-weight encoding.</li>
<li><strong>Introduced in</strong>: Demo 106</li>
<li><strong>Reused in</strong>: (Demo 106 only — but the multi-function sweep pattern is reusable)</li>
<li><strong>Key types/functions</strong>:</li>
<li>3 weights -&gt; 8 input patterns via signed addition; 8 truth tables tested per entry</li>
<li>Per-function periodic vs pseudo-Anosov rate comparison with gap reporting</li>
<li><strong>Approximate size</strong>: ~60 lines</li>
<li><strong>Notes</strong>: Maximum gap between periodic and pseudo-Anosov rates: 3.7pp (XOR2), well within noise. The null result is total across all 8 functions.</li>
</ul>
<p>---</p>
<h2>33. Raqiya Algebraic Analysis Library (Demo 107)</h2>
<h3>33.1 Raqiya Library (<code>raqiya/raqiya.h</code>)</h3>
<ul>
<li><strong>What it does</strong>: Single-header stb-style C89 library for Z[zeta_8] algebraic analysis. Provides exact cyclotomic arithmetic and relationship detectors that reveal algebraic structure of value sets, with graph analysis layer.</li>
<li><strong>Introduced in</strong>: Demo 107</li>
<li><strong>Reused in</strong>: Demo 108 (comparison mode for parity/poison vocabulary analysis, enhancements: edge density, graph diameter, degree histogram, difference closure, negation pairing), Demo 109 (adapted for Z[zeta_16] via Z[i]+axis decomposition)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>Raq_Cyc8</code> — element of Z[zeta_8], basis {1, zeta, zeta^2, zeta^3}, zeta^4=-1</li>
<li><code>Raq_ValueSet</code> — hash-based distinct value collector with insert/lookup</li>
<li><code>Raq_Partition</code> — group assignment result (group_id[], group_sizes[], n_groups)</li>
<li><code>Raq_PairHist</code> — pairwise distance histogram (bins[0..4])</li>
<li><code>Raq_Analysis</code> — full analysis result (all 6+ detectors)</li>
<li>9 relationship detectors: root-of-unity orbits, sign distances, sum/diff zeros, norm-squared classes, product structure, Galois orbits, axis agreement, divisibility, 2-adic valuation</li>
<li>Graph analysis layer: 13 edge generators, quotient graph computation, restricted graph analysis</li>
<li><code>raq_analyze()</code> — full analysis pipeline</li>
<li><code>raq_print_analysis()</code> — formatted output</li>
<li><code>raq_print_comparison()</code> — side-by-side edge density, diameter, components, bipartiteness, quotient graphs for two value sets (added <a href="./entries/demo_108.html">D108</a>)</li>
<li><code>raq_graph_sweep_v()</code> — full graph analysis with verbosity control (added <a href="./entries/demo_108.html">D108</a>)</li>
<li>208 unit tests in <code><a href="../raqiya/probatio_raqiya.c.html">probatio_raqiya.c</a></code></li>
<li><strong>Approximate size</strong>: ~2000 lines (single header)</li>
<li><strong>Notes</strong>: The core analysis tool for the <a href="./entries/demo_107.html">D107</a>-<a href="./entries/demo_109.html">D109</a> arc. Each detector partitions the value set differently, and the relationships between partitions reveal algebraic structure. The graph layer builds edge sets from pairwise relationships and computes graph-theoretic properties (components, diameter, quotients).</li>
</ul>
<h3>33.2 Nesting Counter</h3>
<ul>
<li><strong>What it does</strong>: Counts arc nestings in non-crossing matchings. A nesting = pair of arcs (a,b),(c,d) with a &lt; c &lt; d &lt; b. Used to prove nesting parity = Z/2Z bipartite grading.</li>
<li><strong>Introduced in</strong>: Demo 107</li>
<li><strong>Reused in</strong>: (Demo 107 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>count_nestings(match, n)</code> — counts nesting pairs for non-crossing matchings in boundary order</li>
<li><strong>Approximate size</strong>: ~20 lines</li>
<li><strong>Notes</strong>: Verified for ALL 195 matchings at n=2..6 with 0 mismatches: nesting count mod 2 equals the bipartite 2-coloring of TL link-state transition graphs. Confirmed as NOT a consequence of known KLR Z-grading (genuinely novel theorem).</li>
</ul>
<h3>33.3 Bipartiteness Checker</h3>
<ul>
<li><strong>What it does</strong>: Generic BFS 2-coloring for adjacency matrices, used to verify bipartiteness of TL link-state transition graphs.</li>
<li><strong>Introduced in</strong>: Demo 107</li>
<li><strong>Reused in</strong>: (Demo 107 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li>BFS 2-coloring for adjacency matrices up to 16x16 (BP_CHECK_MAX)</li>
<li>Returns bipartite flag + partition sizes</li>
<li><strong>Approximate size</strong>: ~40 lines</li>
<li><strong>Notes</strong>: Verified bipartite for TL_n left regular (n=2..6, all connected) and 6 standard modules (W_{3,1}, W_{4,2}, W_{5,3}, W_{6,0}, W_{6,2}, W_{6,4}).</li>
</ul>
<h3>33.4 TL Planar Stacking Action</h3>
<ul>
<li><strong>What it does</strong>: Independent computation of TL generator action on link states from first principles (cup stacking mechanics), used to cross-validate generator matrices from <a href="./entries/demo_103.html">D103</a>.</li>
<li><strong>Introduced in</strong>: Demo 107</li>
<li><strong>Reused in</strong>: (Demo 107 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li>TL planar stacking: 4-case action (both arc-paired -&gt; redirect, one through -&gt; swap, both through -&gt; killed, creates loop -&gt; killed)</li>
<li>Verified: 0/45 mismatches with <a href="./entries/demo_103.html">D103</a>'s 9x9 W_{6,2} generator matrices</li>
<li><strong>Approximate size</strong>: ~80 lines</li>
</ul>
<p>---</p>
<h2>34. Parity Vocabulary Graph Analysis (Demo 108)</h2>
<h3>34.1 3-Way Classification Framework</h3>
<ul>
<li><strong>What it does</strong>: Builds bracket catalog, runs parity detection (k=6 XOR3), classifies values into parity/poison/neutral, then runs Raqiya comparison on all three pairs. Reusable pattern for any "vocabulary vs anti-vocabulary vs control" graph analysis.</li>
<li><strong>Introduced in</strong>: Demo 108</li>
<li><strong>Reused in</strong>: (Demo 108 only — but the 3-way pattern is reusable for any binary classification with Raqiya)</li>
<li><strong>Key types/functions</strong>:</li>
<li>Catalog builder: 100 distinct Z[zeta_8] bracket values from TL_3 (2-3 strands, word length 1-8)</li>
<li>Parity detection: k=6 XOR3 search producing 906 solutions (from <a href="./entries/demo_50.html">D50</a>)</li>
<li>3-way classification: 41 parity / 17 poison-only / 42 neutral</li>
<li>Poison index table: hardcoded 31 <a href="./entries/demo_64.html">D64</a> poison catalog indices for fast lookup</li>
<li>14-value parity/poison overlap resolution (parity takes priority)</li>
<li><strong>Approximate size</strong>: ~150 lines</li>
<li><strong>Notes</strong>: The 3-way classification produces the Dual-Channel Theorem: parity wants HIGH product closure AND v_2 connectivity; poison fails on BOTH. Maximum structural contrast: product closure 17 edges (connected P_3) vs 0 edges (empty graph).</li>
</ul>
<h3>34.2 Raqiya Comparison Mode</h3>
<ul>
<li><strong>What it does</strong>: Side-by-side comparison of Raqiya graph analysis across two value sets, computing edge density, diameter, components, bipartiteness, and quotient graphs for all edge types.</li>
<li><strong>Introduced in</strong>: Demo 108 (added to raqiya.h)</li>
<li><strong>Reused in</strong>: Demo 109 (parity vs non-parity comparison at delta=sqrt(2))</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>raq_print_comparison()</code> — side-by-side edge density and topology for two value sets across all edge types</li>
<li><code>raq_graph_sweep_v()</code> — full graph analysis with verbosity control for compact output</li>
<li>Enhancements added for <a href="./entries/demo_108.html">D108</a>: edge density (permille), graph diameter (BFS all-pairs), degree histogram, difference closure edge generator, negation pairing edge generator</li>
<li><strong>Approximate size</strong>: ~100 lines (additions to raqiya.h)</li>
</ul>
<p>---</p>
<h2>35. Encoding-Dependent Dual-Channel Analysis (Demo 109)</h2>
<h3>35.1 Z[i]+Axis Decomposition (<code>ZiAxis</code>)</h3>
<ul>
<li><strong>What it does</strong>: Represents Z[i]-axial Z[zeta_16] values as (a+bi, axis), enabling algebraic operations at the Gaussian integer level with tracked cyclotomic axis. Reusable pattern for any Z[i]-axial cyclotomic analysis.</li>
<li><strong>Introduced in</strong>: Demo 109</li>
<li><strong>Reused in</strong>: (Demo 109 only — but reusable for any delta!=0 analysis where values are Z[i]-axial)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>ZiAxis</code> struct: Gaussian integer (a, b) + axis (0-3) representing (a+bi)*zeta_16^axis</li>
<li><code>zi_mul(x, y)</code> — Gaussian multiplication with axis tracking (axes add mod 4)</li>
<li><code>zi_to_cyc16(x)</code> — convert back to full Cyc16 representation</li>
<li><code>zi_norm(x)</code> — Gaussian norm a^2 + b^2</li>
<li><code>zi_galois(x, m)</code> — Galois action sigma_m for m in {1,3,5,7,9,11,13,15}</li>
<li><code>zi_divides(x, y)</code> — Gaussian divisibility test</li>
<li><strong>Approximate size</strong>: ~80 lines</li>
<li><strong>Notes</strong>: Exploits the universal Z[i]-axiality of bracket values at delta=sqrt(2) (confirmed: all 56 values are Z[i]-axial). Reduces 8-dimensional Cyc16 analysis to 2-dimensional Gaussian integer analysis plus axis tracking.</li>
</ul>
<h3>35.2 8-Edge-Type Graph Analysis (<code>SetAnalysis</code>)</h3>
<ul>
<li><strong>What it does</strong>: Computes 8 different edge types (product closure, same-axis, additive closure, difference closure, divisibility, negation, norm classes, v_2 classes) for a value set, with component counting, isolated vertex detection, and axis quotient adjacency matrix.</li>
<li><strong>Introduced in</strong>: Demo 109</li>
<li><strong>Reused in</strong>: (Demo 109 only — but the pattern is reusable for any cyclotomic value set)</li>
<li><strong>Key types/functions</strong>:</li>
<li><code>SetAnalysis</code> struct: stores all 8 edge counts, component counts, isolated vertices, axis distribution, norm/v_2/Galois class counts, axis quotient adjacency</li>
<li><code>analyze_set(values, n, result)</code> — computes all 8 edge types in a single pass over pairwise combinations</li>
<li><code>print_edge_table(a, b)</code> — formatted side-by-side comparison of two SetAnalysis results</li>
<li>Union-find for component counting (reused across product, additive, and Galois analyses)</li>
<li><strong>Approximate size</strong>: ~200 lines</li>
<li><strong>Notes</strong>: The 8 edge types are: (1) product closure, (2) same-axis, (3) additive closure, (4) difference closure, (5) divisibility, (6) negation, (7) same-norm, (8) same-v_2. The key result: 7/8 edge types are identical between parity and non-parity at delta=sqrt(2); only product closure discriminates, and its polarity is inverted from <a href="./entries/demo_108.html">D108</a>.</li>
</ul>
<h3>35.3 State-Sum Kauffman Bracket for Z[zeta_16]</h3>
<ul>
<li><strong>What it does</strong>: Full state-sum bracket computation in Z[zeta_16] arithmetic with planar matching composition, braid word decoding, and loop counting for arbitrary braid words at delta=sqrt(2).</li>
<li><strong>Introduced in</strong>: Demo 109 (adapted from <a href="./entries/demo_54.html">D54</a>/<a href="./entries/demo_55.html">D55</a> pattern)</li>
<li><strong>Reused in</strong>: (Demo 109 only)</li>
<li><strong>Key types/functions</strong>:</li>
<li>State-sum bracket with Cyc16 delta power weighting (delta=sqrt(2): delta^{L-1} computed via <code>cyc16_delta_power</code>)</li>
<li>Braid word decoding for systematic enumeration</li>
<li>Loop counting via union-find</li>
<li><strong>Approximate size</strong>: ~100 lines</li>
<li><strong>Notes</strong>: Produces 56 distinct Z[zeta_16] values matching <a href="./entries/demo_55.html">D55</a>, all confirmed Z[i]-axial. The 9,334 parity solutions (XNOR3 at Re&gt;0 activation) also match <a href="./entries/demo_55.html">D55</a>.</li>
</ul>
<p>---</p>
<h3>Multi-Strand Matrix DKC Architecture (Demos 102-105)</h3>
<p>Demos 102-105 follow a consistent pattern extending the multi-strand DKC framework: 1. Construct TL_n generators as integer matrices on the standard module W_{n,j} 2. Build braid generators via sigma_i = A<em>I + A^{-1}</em>e_i in Z[zeta_8] 3. BFS catalog with FNV hash dedup, cap at 32768 entries 4. Sign-hash activation (ternary {-1,0,+1} per Cyc8 component, base-3 polynomial hash) 5. XOR search with k-parameter sweep 6. Verify: e_i^2=0, Jones-Wenzl relations, far commutativity, braid relations, Hecke relations</p>
<p>Key architectural transitions across the arc: <ul> <li><strong><a href="./entries/demo_102.html">D102</a></strong>: Fixed Mat5 type (dim=5 only), two separate module constructors for A/B comparison</li> <li><strong><a href="./entries/demo_103.html">D103</a></strong>: Variable MatN type (runtime g_dim), switchable activation function pointer, subset-hash activation variants</li> <li><strong><a href="./entries/demo_104.html">D104</a></strong>: Configurable-coarseness activation (variable component count), streaming rank computation, multi-hash tests</li> <li><strong><a href="./entries/demo_105.html">D105</a></strong>: Extended to 8-strand (dim=14, dim=28), j=2 link state enumeration, rank saturation methodology</li> </ul>
<h3>Raqiya-Based Graph Analysis Arc (Demos 107-109)</h3>
<p>Demos 107-109 follow a consistent pattern for algebraic graph analysis: 1. Build bracket catalog at specific evaluation level (delta=0 or delta=sqrt(2)) 2. Collect distinct algebraic values (Z[zeta_8] or Z[zeta_16]) 3. Classify values into parity-capable and non-parity vocabularies 4. Run Raqiya graph analysis (or custom 8-edge-type analysis) on each vocabulary 5. Compare graph structure between vocabularies to identify discriminators</p>
<p>Key progression: <ul> <li><strong><a href="./entries/demo_107.html">D107</a></strong>: Establishes Raqiya toolkit, discovers universal axis-alignment theorem, nesting parity Z/2Z grading, major index bipartite invariant, q-Catalan identity</li> <li><strong><a href="./entries/demo_108.html">D108</a></strong>: Raqiya comparison mode reveals Dual-Channel Theorem — parity needs BOTH product closure AND v_2 connectivity; poison fails on BOTH</li> <li><strong><a href="./entries/demo_109.html">D109</a></strong>: Encoding-dependent refinement — at delta=sqrt(2) with multiplicative encoding, product closure polarity INVERTS (parity wants LOW, non-parity has HIGH); 7/8 edge types identical, breaking the discriminator count from <a href="./entries/demo_108.html">D108</a>'s multiple to <a href="./entries/demo_109.html">D109</a>'s sole product closure</li> </ul>
<h3>Topological Entropy Null Result (Demo 106)</h3>
<p>Demo 106 establishes that topological entropy (Thurston-Nielsen classification) is completely orthogonal to DKC Boolean computation. The TL visibility filter explains why: writhe survives the TL quotient (correlates with DKC output per <a href="./entries/demo_83.html">D83</a>), entropy does NOT (e_i^2=0 kills expanding eigenvalues). The dual BFS with parallel TL+Burau representations is the architectural pattern enabling this analysis.</p>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <script>hljs.highlightAll();</script>
</body>
</html>
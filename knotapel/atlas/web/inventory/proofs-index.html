<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>inventory/proofs-index.md</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <nav><a href="../index.html">← Back to Index</a></nav><hr>
    <h1>Proofs Index</h1>
<p>Formal proofs filed in <code>knotapel/proofs/</code>. Each entry tracks status, what it proves, and where the result propagates in the atlas.</p>
<p>Generated 2026-02-20.</p>
<p>---</p>
<h2>P01: Radical Dimension Formula for TL at Roots of Unity</h2>
<ul>
<li><strong>File</strong>: <code>proofs/radical-dimension-formula.md</code></li>
<li><strong>Statement</strong>: rad(TL_ℓ(2cos(π/ℓ))) = 2ℓ − 3 for all ℓ ≥ 2</li>
<li><strong>Corollary</strong>: rad(TL_{ℓ+1}(2cos(π/ℓ))) = ℓ² − ℓ − 3 for all ℓ ≥ 3</li>
<li><strong>Method</strong>: Graham-Lehrer cellular algebra theory. V_{ℓ-2} is the unique degenerate cell module at n=ℓ, with corank 1 via Chebyshev determinant (U_{ℓ-1}(cos(π/ℓ)) = 0). Radical contribution: 1·(2(ℓ-1)−1) = 2ℓ−3.</li>
<li><strong>Status</strong>: PROVEN</li>
<li><strong>Previously</strong>: VERIFIED computationally (Demos 51, 52, 60 — six data points ℓ=2..7)</li>
<li><strong>Verification</strong>: 23/23 cell module tests pass. Computational cross-check at all ℓ=2..7 including cubic field (ℓ=7).</li>
<li><strong>Propagates to</strong>: <a href="./theorems.html">theorems.md</a> (upgrade status), <a href="../synthesis/narrative.html">narrative.md</a> (Section 7, Section 10 frontier), <a href="../synthesis/novelty.html">novelty.md</a> (upgrade confidence), <a href="../planning/next-priorities.html">next-priorities.md</a> (<a href="./entries/demo_65.html">D65</a> status)</li>
<li><strong>Related demos</strong>: <a href="./entries/demo_51.html">D51</a> (initial pattern discovery), <a href="./entries/demo_52.html">D52</a> (multi-ℓ verification), <a href="./entries/demo_60.html">D60</a> (cubic field confirmation), <a href="./entries/demo_39.html">D39</a> Part G (cell module verification)</li>
<li><strong>Open threads</strong>: Nilpotency=3 from single-kernel structure? Fibonacci rank from kernel vector? ~~Markov trace radical = 2ℓ−2?~~ → ANSWERED by P03</li>
</ul>
<p>---</p>
<h2>P02: Next-Level Radical Formula</h2>
<ul>
<li><strong>File</strong>: <code>proofs/next-level-radical-formula.md</code></li>
<li><strong>Statement</strong>: rad(TL_{ℓ+1}(2cos(π/ℓ))) = ℓ² − ℓ − 3 for all ℓ ≥ 3</li>
<li><strong>Corollary</strong>: Universal Corank 1 — at the first n where any cell module V_j degenerates, its corank is always 1 (linked module is V_n^{(n)}, dim 1)</li>
<li><strong>Method</strong>: Graham-Lehrer linking theorem. At n=ℓ+1, V_{ℓ-3} is the unique degenerate cell module. Its linked module is V_{ℓ+1}^{(ℓ+1)} with dim 1, giving corank 1. Radical contribution: 1 · (2(ℓ-2) − 1) = 2ℓ − 5. Combined with V_{ℓ-2} (corank 1, contribution 2ℓ − 3 from P01 propagation), total rad = (2ℓ − 5) + (ℓ² − 3ℓ + 2) = ℓ² − ℓ − 3.</li>
<li><strong>Status</strong>: PROVEN</li>
<li><strong>Previously</strong>: VERIFIED computationally (Demo 39 Part H — five data points ℓ=3..7)</li>
<li><strong>Verification</strong>: Cross-checked at all ℓ=3..7.</li>
<li><strong>Propagates to</strong>: <a href="./theorems.html">theorems.md</a> (new entry, upgrade status), <a href="../synthesis/narrative.html">narrative.md</a>, <a href="../synthesis/novelty.html">novelty.md</a></li>
<li><strong>Related demos</strong>: <a href="./entries/demo_39.html">D39</a> Part H (computational verification), <a href="./entries/demo_51.html">D51</a>-<a href="./entries/demo_52.html">52</a> (pattern discovery context)</li>
<li><strong>Open threads</strong>: Second-degeneracy corank = ℓ+1 at n=ℓ+2 — VERIFIED but not yet formally proven. No clean closed form for arbitrary n=ℓ+m.</li>
</ul>
<p>---</p>
<h2>P03: Markov Trace and Reshetikhin-Turaev Truncation</h2>
<ul>
<li><strong>File</strong>: <code>proofs/markov-rt-truncation.md</code></li>
<li><strong>Statement</strong>: For TL_n(2cos(π/ℓ)) with n ≥ ℓ ≥ 3, dim ker(B_M) = dim J(A) + Σ_{j ≥ ℓ-1, j ≡ n mod 2} (dim L_j)². The Markov trace kills exactly the simple blocks with j ≥ ℓ−1 and is nondegenerate on j ≤ ℓ−2.</li>
<li><strong>Method</strong>: Three-part proof: (A) Markov trace vanishes on negligible ideal I_ℓ (generated by JW_{ℓ-1}, since [ℓ]=0). (B) Negligible ideal kills exactly j ≥ ℓ−1 (through-strand count argument). (C) Excess formula from combining A and B.</li>
<li><strong>Status</strong>: PROVEN</li>
<li><strong>Previously</strong>: VERIFIED computationally (Demo 39 Parts I-J — 31 data points across n=ℓ..ℓ+3 for ℓ=3..7). Initial conjecture (ℓ+m−1)²+1 REFUTED at m=3, leading to correct block-sum formula.</li>
<li><strong>Verification</strong>: 31/31 numerical values match at n=ℓ through n=ℓ+3 for ℓ=3..7.</li>
<li><strong>Propagates to</strong>: <a href="./theorems.html">theorems.md</a> (new entry, upgrade status), <a href="../synthesis/narrative.html">narrative.md</a> (Section 10 frontier), <a href="../synthesis/novelty.html">novelty.md</a> (upgrade confidence), <a href="../synthesis/connections.html">connections.md</a> (three-light interpretation), <a href="../planning/next-priorities.html">next-priorities.md</a></li>
<li><strong>Related demos</strong>: <a href="./entries/demo_39.html">D39</a> Parts G-J (discovery and verification), <a href="./entries/demo_63.html">D63</a> (angular anatomy, uses RT truncation connection)</li>
<li><strong>Corollaries</strong>: (1) Markov rank = Σ<em>{j ≤ ℓ-2} (dim L_j)². (2) Shadow algebra TL_n/ker(B_M) ≅ ⊕</em>{j ≤ ℓ-2} M_{dim L_j} — the RT TQFT algebra. (3) The "shadow interpretation": fixpt = algebraic light (sees all simples), Markov = topological light (sees only RT-physical modules j ≤ ℓ-2). Excess = what topology cannot see.</li>
<li><strong>Open threads</strong>: Cross-sector kernel structure (coefficient matrix J−δI at ℓ=4 — does this generalize?). Composite shadows (intersection of two RT truncations). DKC interpretation of ℓ−2 threshold.</li>
</ul>
<p>---</p>
<h2>P04: Parity-Lock Theorem</h2>
<ul>
<li><strong>File</strong>: <code>proofs/parity-lock-theorem.md</code></li>
<li><strong>Statement</strong>: Under the ±q paired input encoding with k weights (2k input bits), the (0,0)≡(1,1) collision per weight creates 3^k equivalence classes. XOR/XNOR are the only standard Boolean functions constant on all classes. AND, OR, MAJ, and threshold functions are structurally impossible.</li>
<li><strong>Method</strong>: Direct computation of per-weight contributions under all 4 bit patterns. Equivalence class construction via effective state {-q, 0, +q}. Hamming parity preservation within classes. Sign-flip symmetry (S ↔ -S) as supplementary result.</li>
<li><strong>Status</strong>: PROVEN</li>
<li><strong>Previously</strong>: DEMONSTRATED computationally (Demo 92 — 0 winners for AND/OR/MAJ/THR2 at all depths 0-8, 76/76 collisions same-parity, 0/27 class conflicts for XOR)</li>
<li><strong>Verification</strong>: All 16 numerical tests in Demo 92 confirm theorem predictions. 13/13 sign-flip pairs verified identical.</li>
<li><strong>Propagates to</strong>: <a href="./theorems.html">theorems.md</a> (new entry), <a href="../synthesis/narrative.html">narrative.md</a> (encoding constraint section), <a href="../synthesis/novelty.html">novelty.md</a> (parity-lock as novel result), <a href="../synthesis/connections.html">connections.md</a> (link to <a href="./entries/demo_48.html">D48</a>/<a href="./entries/demo_50.html">D50</a> encoding contrast)</li>
<li><strong>Related demos</strong>: <a href="./entries/demo_92.html">D92</a> (discovery and verification), <a href="./entries/demo_89.html">D89</a>-<a href="./entries/demo_91.html">D91</a> (depth law arc that motivated the investigation), <a href="./entries/demo_48.html">D48</a>/<a href="./entries/demo_50.html">D50</a> (1-weight-per-input encoding computes all 13 NPN classes — contrast)</li>
<li><strong>Corollaries</strong>: (1) The depth law max_xor ≈ depth + 6 describes scaling for the ONLY achievable function family under ±q encoding. (2) Sign-flip symmetry collapses 3^k classes to at most (3^k+1)/2 distinguishable groups. (3) The ±q encoding concentrates all computational power on the highest-frequency Boolean function (parity), the one outside AC⁰.</li>
<li><strong>Extension (<a href="./entries/demo_93.html">D93</a>)</strong>: Complement-Blindness Theorem added to same proof document. Under 1wpi encoding with combined_cell, S(~m) = -S(m) and combined_cell normalizes by |qa|, so m and ~m always map to the same cell. Only complement-invariant functions achievable. AND/OR/MAJ impossible for ALL N. XOR impossible at odd N. Structurally parallel to parity-lock: encoding creates collisions (<a href="./entries/demo_92.html">D92</a>) vs activation creates collisions (<a href="./entries/demo_93.html">D93</a>). Unification table included.</li>
<li><strong>Related demos (updated)</strong>: <a href="./entries/demo_92.html">D92</a> (parity-lock), <a href="./entries/demo_93.html">D93</a> (complement-blindness), <a href="./entries/demo_89.html">D89</a>-<a href="./entries/demo_91.html">D91</a> (depth law arc), <a href="./entries/demo_48.html">D48</a>/<a href="./entries/demo_50.html">D50</a> (1wpi encoding contrast)</li>
</ul>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <script>hljs.highlightAll();</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>inventory/demo-index.md</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <nav><a href="../index.html">← Back to Index</a></nav><hr>
    <h1>Demo Index</h1>
<p>89 demos cataloged. Generated 2026-02-20. Updated 2026-02-24 (added <a href="./entries/demo_95.html">D95</a>-<a href="./entries/demo_101.html">D101</a>: commutator depth, TL-group cross-classification LANDMARK, Cell B perfection, 3-strand DKC proof-of-concept, 3-strand Delta_1 LANDMARK, 4-strand W_{4,2}, 5-strand W_{5,3} sl_d functor thesis).</p>
<p>---</p>
<h2><a href="./entries/demo_01.html">Demo 01</a>: Kauffman Bracket</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_01_kauffman_bracket/main.c.html">demo_01_kauffman_bracket/main.c</a></code> (~498 lines)</li>
<li><strong>Tests</strong>: 9/9 pass</li>
<li><strong>Depends on</strong>: none — foundation</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_02.html">Demo 02</a> (matrix/TL approach comparison), <a href="./entries/demo_03.html">Demo 03</a> (Yang-Baxter), <a href="./entries/demo_04.html">Demo 04</a> (braid word compiler)</li>
</ul>
<h3>Headline</h3>
Exact Kauffman bracket computation via state-sum model using integer Laurent polynomials — the brute-force oracle for all later demos.
<h3>Key Results</h3>
<ul>
<li>Laurent polynomial arithmetic (add, multiply, trim, equality) works correctly over integers — no floating point needed</li>
<li>Trefoil bracket matches Kauffman's known value (code gives left-handed mirror: -A^{-5} - A^3 + A^7)</li>
<li>Figure-eight bracket correct: A^8 - A^4 + 1 - A^{-4} + A^{-8}, confirmed palindromic (amphichiral)</li>
<li>Hopf link bracket correct: -A^4 - A^{-4}</li>
<li>Knot discrimination works: trefoil and figure-eight produce distinct brackets</li>
<li>f-polynomial (writhe-normalized bracket) correct for trefoil and figure-eight</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li>VERIFIED: Kauffman bracket state-sum reproduces known values for 3_1, 4_1, and Hopf link</li>
<li>VERIFIED: Amphichiral knot (4_1) has palindromic bracket and writhe = 0</li>
</ul>
<h3>Data</h3>
<ul>
<li>Trefoil (left-handed): &lt;3_1&gt; = -A^{-5} - A^3 + A^7</li>
<li>Figure-eight: &lt;4_1&gt; = A^8 - A^4 + 1 - A^{-4} + A^{-8}</li>
<li>Hopf link: &lt;hopf&gt; = -A^4 - A^{-4}</li>
<li>Loop value: d = -A^2 - A^{-2}</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>Poly</code> struct: Laurent polynomial with integer coefficients (lo exponent + coefficient array, MAX_TERMS=64)</li>
<li><code>p_zero</code>, <code>p_mono</code>, <code>p_trim</code>, <code>p_add</code>, <code>p_mul</code>, <code>p_eq</code>, <code>p_print</code>: complete polynomial algebra</li>
<li><code>Knot</code>/<code>Xing</code> structs: PD (planar diagram) notation for knot crossings with arc labels and crossing signs</li>
<li><code>count_loops()</code>: state-sum loop tracer — resolves crossings into A/B smoothings, traces cycles through arc connectivity</li>
<li><code>kauffman_bracket()</code>: full state-sum computation (O(2^n) over all crossing resolutions)</li>
<li><code>jones_from_bracket()</code>: writhe normalization to get f-polynomial</li>
<li><code>make_trefoil()</code>, <code>make_figure_eight()</code>, <code>make_hopf()</code>: PD notation constructors for standard knots</li>
<li>Limits: MAX_X=16 crossings, MAX_ARCS=32</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Kauffman bracket state-sum model (Kauffman 1987)</li>
<li>PD notation from KnotAtlas</li>
<li>Jones polynomial via bracket normalization</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>PD notation chirality: code's "right-handed trefoil" PD gives left-handed bracket — convention subtlety noted but not fully resolved</li>
<li>State-sum is O(2^n), limiting to ~16 crossings — <a href="./entries/demo_02.html">Demo 02</a> addresses this with matrix approach</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_02.html">Demo 02</a>: Braid Words</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_02_braid_words/main.c.html">demo_02_braid_words/main.c</a></code> (~953 lines)</li>
<li><strong>Tests</strong>: 9/9 pass (with warnings — 6 unused PolyMat functions; does not compile clean with -Werror)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_01.html">Demo 01</a> (reuses Laurent polynomial algebra — Poly type copied, not imported)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_03.html">Demo 03</a> (Markov trace / TL module structure deferred there)</li>
</ul>
<h3>Headline</h3>
Computes Kauffman brackets of knots from braid word input via state-sum over resolutions, confirming agreement with <a href="./entries/demo_01.html">Demo 01</a>'s PD-code approach.
<h3>Key Results</h3>
<ul>
<li>Braid closure state-sum reproduces all <a href="./entries/demo_01.html">Demo 01</a> bracket values (trefoil, figure-eight, Hopf link, unknot)</li>
<li>Chirality detected: sigma_1^3 and sigma_1^{-3} produce mirror-image brackets (A ↔ A^{-1})</li>
<li>Figure-eight bracket is palindromic (amphichiral confirmation)</li>
<li>2-strand TL representation: rho(sigma_1) = -A^{-3}, rho(sigma_1^{-1}) = -A^3 (scalar in 1D module)</li>
<li>Markov equivalence across braid representations (2-strand vs 3-strand trefoil) documented as open — writhe normalization alone insufficient, Markov stabilization correction needed</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Confirmed</strong>: Braid closure state-sum = PD-code state-sum for Kauffman bracket</li>
<li><strong>Open</strong>: Markov stabilization correction (adding strands changes bracket; f-polynomial doesn't fully normalize this)</li>
<li><strong>Noted</strong>: Full Markov trace via TL module structure deferred to <a href="./entries/demo_03.html">Demo 03</a></li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>Poly</code> type: Laurent polynomial ring (copy of <a href="./entries/demo_01.html">Demo 01</a> — p_zero, p_mono, p_trim, p_add, p_mul, p_eq, p_print)</li>
<li><code>PolyMat</code> type: matrices over polynomial ring (pm_zero, pm_identity, pm_mul, pm_scale, pm_add, pm_trace, pm_print) — implemented but <strong>unused</strong> in tests, scaffolded for future TL representation work</li>
<li><code>Braid</code> type: braid word representation (word array of signed generator indices, strand count)</li>
<li><code>braid_count_loops()</code>: union-find loop counter for resolved braid closures</li>
<li><code>braid_bracket()</code>: state-sum Kauffman bracket from braid word</li>
<li><code>braid_writhe()</code> / <code>braid_jones()</code>: writhe computation and writhe-normalized f-polynomial</li>
<li>Union-find (global arrays, path-compressed): reusable pattern for loop counting in any diagram resolution</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Temperley-Lieb algebra TL_n(delta) and its path/standard module representation</li>
<li>Kauffman bracket via braid closure (Kauffman 1987)</li>
<li>Markov's theorem (braid equivalence under stabilization and conjugation)</li>
<li>Reduced Burau representation (mentioned, not implemented)</li>
<li>Spin-chain / tensor product representation of TL generators (explored in comments, abandoned for simpler state-sum)</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Markov stabilization: how to normalize bracket across different braid strand counts for same knot</li>
<li>PolyMat infrastructure unused — will <a href="./entries/demo_03.html">Demo 03</a> use it for explicit TL module matrices?</li>
<li>Code duplication: Poly type copied verbatim from <a href="./entries/demo_01.html">Demo 01</a> (no shared library extraction yet)</li>
<li>Does not compile with <code>-Werror</code> due to 6 unused PolyMat functions</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_03.html">Demo 03</a>: TL Module &amp; Braid Representation</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_03/main.c.html">demo_03/main.c</a></code> (~603 lines)</li>
<li><strong>Tests</strong>: 8/8 pass (4 parts: TL relations, braid inverses, Yang-Baxter, full bracket)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_01.html">Demo 01</a> (Kauffman bracket state-sum oracle), <a href="./entries/demo_02.html">Demo 02</a> (braid representation concepts)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_04.html">Demo 04</a> (spin chain / tensor product representation)</li>
</ul>
<h3>Headline</h3>
Constructs the correct TL_3 standard module W_1 and braid representation, verifying TL algebra relations, braid group inverses, Yang-Baxter equation, and full Kauffman bracket computation via both standard modules W_1 (dim 2) and W_3 (dim 1).
<h3>Key Results</h3>
<ul>
<li>TL_3 standard module W_1 (1-defect, dim 2) with basis: e_a = (cap12, free3), e_b = (cap23, free1)</li>
<li>U_1 = [[delta, 1], [0, 0]], U_2 = [[0, 0], [1, delta]] — satisfy U^2 = delta<em>U and U1</em>U2<em>U1 = U1, U2</em>U1*U2 = U2</li>
<li>Braid representation: g_i = A<em>U_i + A^{-1}</em>I (NOT the Hecke algebra form — this is the Kauffman bracket form)</li>
<li>Inverse: g_i^{-1} = A^{-1}<em>U_i + A</em>I — works because (A^2 + A^{-2} + delta) = 0</li>
<li>W_3 (3-defect, dim 1): U_i acts as 0, so g_i = A^{-1} (scalar), g_i^{-1} = A (scalar)</li>
<li>Full bracket formula: &lt;L&gt; = 1<em>tr_{W_1}(rho(b)) + (A^{-4} + A^4)</em>tr_{W_3}(rho(b))</li>
<li>Verified against state-sum oracle for: figure-eight, trefoil, identity (3-component unlink), mirror trefoil, single crossing</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li>Extended commentary in header works through the algebra showing g_i = A<em>I + A^{-1}</em>U_i does NOT satisfy the Hecke relation g - g^{-1} = (A - A^{-1})*I, but IS invertible in the TL algebra</li>
<li>Key identity: (A<em>U + A^{-1}</em>I)(A^{-1}<em>U + A</em>I) = I follows from delta + A^2 + A^{-2} = 0</li>
<li>Lengthy addendum explores why W_0 doesn't exist for TL_3 (parity: n=3 odd, so defects must be odd: 1 or 3)</li>
<li>Addendum attempts to find constant coefficients c_0, c_1 for Markov trace as weighted ordinary traces — discovers this doesn't work (Markov trace is more subtle)</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>Laurent polynomial ring</strong> (<code>Poly</code>): zero, monomial, trim, add, multiply, equality, print — reused across later demos</li>
<li><strong>2x2 matrix algebra</strong> (<code>Mat2</code>): identity, multiply, scale, add, trace, equality, print — over Laurent polynomials</li>
<li><strong>4x4 matrix algebra</strong> (<code>Mat4</code>): zero, multiply, equality, tensor product — defined but tensor Yang-Baxter deferred to <a href="./entries/demo_04.html">Demo 04</a></li>
<li><strong>Union-find state-sum oracle</strong> (<code>braid_bracket</code>): enumerates all 2^n smoothings, counts loops via union-find — serves as ground-truth verifier</li>
<li><strong>Braid struct</strong>: word array + length + strand count</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Temperley-Lieb algebra standard modules (W_k for TL_n)</li>
<li>Kauffman bracket skein relation (A<em>&lt;0-smoothing&gt; + A^{-1}</em>&lt;1-smoothing&gt;)</li>
<li>Jones/Kauffman braid representation vs Hecke algebra representation</li>
<li>Quantum dimensions of TL modules</li>
<li>Dimension formula: dim(W_k) = C(n, (n-k)/2) - C(n, (n-k)/2 - 1)</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>The addendum's attempt to express the Markov trace as a constant-coefficient weighted sum of ordinary module traces fails — the Markov trace requires a more sophisticated construction (possibly involving conditional expectations / Jones basic construction)</li>
<li>4x4 tensor product Yang-Baxter verification explicitly deferred to <a href="./entries/demo_04.html">Demo 04</a></li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_04.html">Demo 04</a>: Spin Chain</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_04_spin_chain/main.c.html">demo_04_spin_chain/main.c</a></code> (~587 lines)</li>
<li><strong>Tests</strong>: 12/12 pass (4 parts: A=2, B=1, C=4, D=5)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_03.html">Demo 03</a> (Laurent polynomial ring, state-sum oracle, Kauffman bracket)</li>
<li><strong>Feeds into</strong>: Any demo needing tensor product R-matrix representation or Yang-Baxter verification</li>
</ul>
<h3>Headline</h3>
Computes the Kauffman bracket via the tensor product (spin chain) representation using quantum trace, unifying <a href="./entries/demo_03.html">Demo 03</a>'s separate standard-module traces into a single 8D computation.
<h3>Key Results</h3>
<ul>
<li>TL generator U on V tensor V (4x4) satisfies U^2 = delta*U and tr(U) = delta</li>
<li>R-matrix R = A<em>U + A^{-1}</em>I satisfies R*R^{-1} = I</li>
<li>Yang-Baxter equation R1<em>R2</em>R1 = R2<em>R1</em>R2 verified in 8D (and for inverses)</li>
<li><strong>Quantum trace formula discovered</strong>: bracket(beta) = tr_q(rho(beta)) / (A^2 + A^{-2}), where tr_q = tr(K^{tensor 3} * M) with K = diag(A^2, A^{-2})</li>
<li>Tested on 5 braids: identity (3-unlink), trefoil, figure-eight, mirror trefoil, single crossing — all match state-sum oracle</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li>Schur-Weyl duality decomposition: V^{tensor 3} = V_{3/2} tensor W_3 + V_{1/2} tensor W_1 (dim 4x1 + dim 2x2 = 8)</li>
<li>Quantum trace with K = diag(q, q^{-1}) weights each component by its quantum dimension: qdim(V_{1/2}) = [2]<em>q = -delta, qdim(V</em>{3/2}) = [4]_q = A^6+A^2+A^{-2}+A^{-6}</li>
<li>Dividing by -delta recovers exactly <a href="./entries/demo_03.html">Demo 03</a>'s formula: bracket = 1<em>tr_{W_1} + (A^{-4}+A^4)</em>tr_{W_3}</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>Poly</code> Laurent polynomial ring (reused from <a href="./entries/demo_03.html">Demo 03</a>, MAX_TERMS=120)</li>
<li><code>Mat</code> NxN polynomial matrix (up to 8x8) with: zero, identity, multiply, scale, add, trace, equality, tensor product, quantum trace, print</li>
<li><code>mat_tensor()</code> — general Kronecker product of polynomial matrices</li>
<li><code>mat_qtrace()</code> — quantum trace with diagonal weights</li>
<li><code>braid_product()</code> — maps braid word to matrix product in 8D representation</li>
<li>State-sum oracle (union-find based, reused from <a href="./entries/demo_03.html">Demo 03</a>)</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Kauffman bracket via R-matrix / quantum group approach</li>
<li>Schur-Weyl duality for U_q(sl_2)</li>
<li>Yang-Baxter equation</li>
<li>Quantum trace (Reshetikhin-Turaev style)</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_05.html">Demo 05</a>: Scaling the Spin Chain</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_05_scaling/main.c.html">demo_05_scaling/main.c</a></code> (~678 lines)</li>
<li><strong>Tests</strong>: ~30 pass (6 quantum dimension, Yang-Baxter per n, far commutativity, R*Rinv=I per generator, quantum trace per braid per n)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_03.html">Demo 03</a> (Yang-Baxter / R-matrix), <a href="./entries/demo_04.html">Demo 04</a> (quantum trace formula for n=3)</li>
<li><strong>Feeds into</strong>: later demos needing multi-strand braid representations; establishes that the trace formula is universal across strand counts</li>
</ul>
<h3>Headline</h3>
The quantum trace formula <code>tr_q = (-1)^n <em> delta </em> bracket</code> generalizes from n=3 to arbitrary strand count (verified n=2 through n=5, matrices up to 32x32).
<h3>Key Results</h3>
<ul>
<li>Quantum dimension recurrence [n+1]_q = [2]_q * [n]_q - [n-1]_q verified for n=1..6</li>
<li>Explicit formula [n]_q * (A^2 - A^{-2}) = A^{2n} - A^{-2n} confirmed for all n</li>
<li>Yang-Baxter relation R_i R_{i+1} R_i = R_{i+1} R_i R_{i+1} holds at every scale (4x4 through 32x32)</li>
<li>Far commutativity R_i R_j = R_j R_i for |i-j| &gt;= 2 verified (first testable at n=4)</li>
<li>R_i * R_i^{-1} = I for all generators at all scales</li>
<li><strong>Key discovery</strong>: sign depends on strand count — <code>tr_q = (-1)^n <em> delta </em> oracle</code> — even n gives +delta, odd n gives -delta (<a href="./entries/demo_04.html">Demo 04</a> only saw odd case)</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li>PROVEN (computationally, n=2..5): Quantum trace formula generalizes with (-1)^n sign factor</li>
<li>PROVEN: Sign factor arises from tr_q(I) = (-delta)^n vs oracle(identity) = delta^{n-1}</li>
<li>VERIFIED: Yang-Baxter + far commutativity hold for all tested tensor-product generators</li>
</ul>
<h3>Data</h3>
<ul>
<li>n=2: 4x4 matrices, 1 generator</li>
<li>n=3: 8x8 matrices, 2 generators (reproduces <a href="./entries/demo_04.html">Demo 04</a>)</li>
<li>n=4: 16x16 matrices, 3 generators (first far commutativity test)</li>
<li>n=5: 32x32 matrices, 4 generators (1024 Poly entries per matrix, ~800KB each)</li>
<li>[1]_q = 1, [2]_q = A^2 + A^{-2}, [3]_q = A^4 + 1 + A^{-4}, etc.</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li>Heap-allocated <code>Mat</code> struct with <code>mat_alloc</code>/<code>mat_free</code> (needed for n&gt;=4, stack would overflow)</li>
<li><code>mat_tensor(C, A, B)</code>: tensor product of polynomial matrices — key for building R_i from base R4</li>
<li><code>build_Ri(result, R4, i, n)</code>: constructs I^{x(i-1)} x R x I^{x(n-i-1)} for arbitrary strand count</li>
<li><code>build_Kn(w, n)</code>: builds K^{xn} diagonal weights for quantum trace at any n</li>
<li><code>braid_product_n()</code>: evaluates braid word as matrix product in 2^n x 2^n space</li>
<li><code>mat_qtrace()</code>: quantum trace with diagonal weights</li>
<li>State-sum oracle (<code>braid_bracket</code>, <code>braid_loops</code> via union-find) carried forward from <a href="./entries/demo_03.html">Demo 03</a>/04</li>
<li><code>MAT(m, i, j)</code> macro for row-major access into heap-allocated polynomial matrices</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Quantum dimension / quantum integers [n]_q (standard in quantum groups)</li>
<li>Chebyshev recurrence for quantum dimensions</li>
<li>Temperley-Lieb representation theory at general n</li>
<li>Yang-Baxter equation in tensor-product form</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Can the formula be pushed to n=6 (64x64) or beyond? Memory is the constraint (~50MB per matrix at n=6)</li>
<li>The (-1)^n sign factor — is there a cleaner normalization that absorbs it?</li>
<li>Connection to Fibonacci TQFT mentioned in header ("n=5 is Fibonacci TQFT boundary") but not explored</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_06.html">Demo 06</a>: Jones-Wenzl Idempotents</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_06_jones_wenzl/main.c.html">demo_06_jones_wenzl/main.c</a></code> (~800 lines)</li>
<li><strong>Tests</strong>: 19/19 pass (4 parts: A=4, B=3, C=4, D=4x2 braids = 8 minimum, varies)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_03.html">Demo 03</a> (TL standard modules, bracket formula), <a href="./entries/demo_04.html">Demo 04</a> (tensor product R-matrix, quantum trace)</li>
<li><strong>Feeds into</strong>: Any demo needing projectors onto irreducible components; Markov trace decomposition</li>
</ul>
<h3>Headline</h3>
Constructs scaled Jones-Wenzl idempotents p_2 (4x4) and p_3 (8x8) over Laurent polynomials, proving they are the projectors that explain <a href="./entries/demo_03.html">Demo 03</a>/04's quantum dimension weights via Schur-Weyl decomposition.
<h3>Key Results</h3>
<ul>
<li>TL relations verified on V^{tensor 3} (8x8): U_i^2 = delta<em>U_i, U_1</em>U_2<em>U_1 = U_1, U_2</em>U_1*U_2 = U_2</li>
<li>Scaled JW p_2 (Q_2 = delta<em>I - U, D_2 = delta): Q_2^2 = delta</em>Q_2, U<em>Q_2 = 0, tr_q(Q_2) = delta</em>[3]_q</li>
<li>Scaled JW p_3 (Q_3 = [3]_q<em>iota(Q_2) - iota(Q_2)</em>U_2<em>iota(Q_2), D_3 = delta</em>[3]_q): Q_3^2 = D_3<em>Q_3, U_1</em>Q_3 = 0, U_2<em>Q_3 = 0, tr_q(Q_3) = D_3</em>[4]_q</li>
<li><strong>Markov trace decomposition</strong>: W_3 component tr_q(Q_3<em>rho) = D_3</em>[4]<em>q*tr</em>{W_3}(rho) verified for identity, sigma_1, trefoil, figure-eight</li>
<li>W_1 component verified divisible by D_3*[2]_q, confirming both module traces factor correctly</li>
<li>Sum W_1 + W_3 components = D_3*tr_q(rho) verified (decomposition is exhaustive)</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li>Jones-Wenzl recursion stays polynomial via scaling trick: Q_n = D_n*p_n avoids rational function entries</li>
<li>Key simplification: [2]_q/delta = -1 keeps n=3 recursion entirely in Z[A, A^{-1}]</li>
<li>On W_3 (all through-lines, 1D module): each braid generator acts as A^{-1}, so tr_{W_3}(rho(beta)) = product of A^{-sgn(word[i])}</li>
<li>Quantum dimensions [n+1]_q computed via recurrence: [n+1]_q = [2]_q*[n]_q - [n-1]_q</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>Poly</code> Laurent polynomial ring with <code>p_neg</code>, <code>p_sub</code>, <code>p_div_exact</code> (exact polynomial division with remainder check) — extensions beyond <a href="./entries/demo_04.html">Demo 04</a></li>
<li><code>Mat</code> polynomial matrix library (same MAXN=8 infrastructure) with <code>mat_is_zero</code></li>
<li>Quantum dimension computation via Chebyshev recurrence ([n+1]_q = [2]_q*[n]_q - [n-1]_q)</li>
<li><code>braid_product()</code> mapping braid words to 8x8 matrix products</li>
<li>Scaled Jones-Wenzl construction pattern: avoids rational functions entirely</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Jones-Wenzl idempotents (original construction)</li>
<li>Temperley-Lieb algebra relations</li>
<li>Schur-Weyl duality decomposition for U_q(sl_2)</li>
<li>Markov trace and its decomposition into irreducible components</li>
<li>Quantum dimensions as traces of idempotents</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_07.html">Demo 07</a>: Braid Closure Bridge</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_07_braid_closure/main.c.html">demo_07_braid_closure/main.c</a></code> (~791 lines)</li>
<li><strong>Tests</strong>: 25/25 pass (compiles clean with all strict flags including -Werror)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_01.html">Demo 01</a> (PD notation + state-sum bracket), <a href="./entries/demo_02.html">Demo 02</a> (braid bracket via state-sum), <a href="./entries/demo_02.html">Demos 02</a>-<a href="./entries/demo_06.html">06</a> (matrix pipeline context)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_08.html">Demo 08</a> (reverse direction: PD -&gt; braid word via Vogel's algorithm)</li>
</ul>
<h3>Headline</h3>
Bridges the two separate computation worlds (PD state-sum and braid word) by converting braid words to PD notation via closure, proving both representations compute identical Kauffman brackets.
<h3>Key Results</h3>
<ul>
<li><code>braid_to_pd()</code> generates valid PD notation from braid words with correct arc counts for all test knots/links</li>
<li><strong>Exact bracket match</strong>: PD state-sum bracket from generated PD == braid bracket for all 5 test cases (trefoil 2-strand, figure-eight, Hopf, trefoil 3-strand, unknot)</li>
<li>Seifert circle count = braid strand count for all braid closures (theorem confirmed computationally)</li>
<li>Seifert algorithm works universally on both braid-generated PD and <a href="./entries/demo_01.html">Demo 01</a>'s hand-coded PD</li>
<li>Link component count from PD matches braid permutation cycle structure</li>
<li>Discovery: sigma_1 sigma_2 sigma_1 on 3 strands is a 2-component link (not a trefoil)</li>
<li>Discovery: sigma sigma^{-1} closes to 2-component unlink</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Confirmed</strong>: Braid closure PD bracket = braid state-sum bracket (the two worlds agree exactly)</li>
<li><strong>Confirmed</strong>: Seifert circles from PD = strand count for braid closures</li>
<li><strong>Confirmed</strong>: Link components from PD = permutation cycle count of braid word</li>
<li><strong>Noted</strong>: PD chirality bug — "obvious" counter-clockwise labeling gives mirror bracket; fix is [NE, SE, SW, NW] for positive crossings</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>braid_to_pd()</code>: core bridge function — braid word to PD notation via closure. Tracks per-position crossing lists, assigns arc labels between consecutive crossings, builds PD with correct over/under conventions</li>
<li><code>seifert_circles()</code>: Seifert resolution on PD notation. Sign-dependent pairing (positive → B-smoothing, negative → A-smoothing). Universal across PD conventions</li>
<li><code>link_components()</code>: traces strands through crossings via (p+2)%4 exit rule. Counts topological components</li>
<li><code>pd_bracket()</code>: <a href="./entries/demo_01.html">Demo 01</a>'s state-sum bracket, included for cross-validation</li>
<li><code>braid_bracket()</code> + <code>braid_loops()</code>: <a href="./entries/demo_02.html">Demo 02</a>'s braid state-sum (union-find based), included for cross-validation</li>
<li>Reusable <code>Poly</code> Laurent polynomial ring (standard copy from <a href="./entries/demo_01.html">Demo 01</a>)</li>
<li>PD types (<code>Xing</code>, <code>Knot</code>) with sign tracking</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Braid closure (Alexander's theorem): every link is a closed braid</li>
<li>Seifert circles and Seifert surfaces</li>
<li>PD notation conventions (under/over strand labeling, chirality sensitivity)</li>
<li>Link component counting from diagram data</li>
<li>Vogel's algorithm (mentioned as <a href="./entries/demo_08.html">Demo 08</a> direction)</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Round-trip: can we go PD → braid word (Vogel's algorithm) and back? (Deferred to <a href="./entries/demo_08.html">Demo 08</a>)</li>
<li>Strands uninvolved in any crossing are silently skipped in <code>braid_to_pd()</code> — is this correct for all cases?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_08.html">Demo 08</a>: Vogel's Algorithm (PD -&gt; Braid Word)</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_08_vogel/main.c.html">demo_08_vogel/main.c</a></code> (~887 lines)</li>
<li><strong>Tests</strong>: 47/47 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_07.html">Demo 07</a> (braid -&gt; PD direction), <a href="./entries/demo_01.html">Demo 01</a> (PD bracket oracle, knot PD codes)</li>
<li><strong>Feeds into</strong>: completes the PD &lt;-&gt; braid round-trip; any later demo needing to convert arbitrary PD notation into braid words</li>
</ul>
<h3>Headline</h3>
Compiler from PD notation to braid word via Seifert circle decomposition — completes the bidirectional PD/braid bridge with full bracket-preserving round-trip verification.
<h3>Key Results</h3>
<ul>
<li>Seifert circle membership correctly computed via union-find for trefoil (2 circles), figure-eight (3 circles), Hopf link (2 circles)</li>
<li>Trefoil PD -&gt; braid word [1,1,1] on 2 strands (sigma_1^3)</li>
<li>Figure-eight PD -&gt; braid word [1,-2,1,-2] on 3 strands</li>
<li>Hopf link PD -&gt; braid word [1,1] on 2 strands (sigma_1^2)</li>
<li>Round-trip bracket match: pd_bracket(PD) == braid_bracket(pd_to_braid(PD)) for all three knots</li>
<li>Double round-trip: Braid_1 -&gt; PD_1 -&gt; Braid_2 -&gt; PD_2, brackets match at every stage</li>
<li>Also tests trefoil on 3 strands (sigma_1 sigma_2 sigma_1) for double round-trip</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li>VERIFIED: Alexander's theorem in practice — Seifert circle count = braid width</li>
<li>VERIFIED: PD &lt;-&gt; Braid conversion preserves Kauffman bracket (round-trip and double round-trip)</li>
<li>VERIFIED: For standard small knots, Seifert graph is always a path graph (no Vogel moves needed)</li>
</ul>
<h3>Data</h3>
<ul>
<li>Trefoil: 6 arcs -&gt; 2 Seifert circles ({0,2,4}, {1,3,5}) -&gt; 2-strand braid</li>
<li>Figure-eight: 8 arcs -&gt; 3 Seifert circles ({0,4}, {1,3,5,7}, {2,6}) -&gt; 3-strand braid</li>
<li>Hopf link: 4 arcs -&gt; 2 Seifert circles ({0,3}, {1,2}) -&gt; 2-strand braid</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>seifert_membership()</code>: union-find Seifert resolution — positive crossings use B-smoothing (0,1)(2,3), negative use A-smoothing (0,3)(1,2)</li>
<li><code>trace_circles()</code>: traces each Seifert circle through crossings to get cyclic crossing order</li>
<li><code>find_braid_order()</code>: brute-force cut-point search + Kahn's topological sort for consistent braid word ordering; skips same-generator constraints (they commute)</li>
<li><code>pd_to_braid()</code>: full 7-step PD -&gt; braid compiler (Seifert membership -&gt; crossing-circle map -&gt; Seifert graph path check -&gt; circle ordering -&gt; crossing trace -&gt; braid ordering -&gt; emit generators)</li>
<li><code>braid_to_pd()</code>: carried from <a href="./entries/demo_07.html">Demo 07</a> for round-trip tests</li>
<li>Path-graph check: all vertices degree &lt;= 2, exactly 2 leaves</li>
<li>Returns error codes: -1 (not a path graph), -2 (no valid ordering found)</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Vogel's algorithm for PD -&gt; braid conversion</li>
<li>Alexander's theorem (every link is a closed braid)</li>
<li>Seifert circles / Seifert surface construction</li>
<li>Kahn's algorithm for topological sort</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Only handles path-graph Seifert graphs — full Vogel moves (for non-path Seifert graphs) not yet implemented</li>
<li>Could the brute-force cut-point search become expensive for knots with many crossings per circle? (currently bounded by MAX_X=20)</li>
<li>No Markov stabilization — output braid may not be minimal</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_09.html">Demo 09</a>: Reidemeister Move Invariance</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_09_reidemeister/main.c.html">demo_09_reidemeister/main.c</a></code> (~717 lines)</li>
<li><strong>Tests</strong>: 30/30 pass (5 parts: R1 bracket, R1 writhe/Jones, R2, R3 braid, combined)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_07.html">Demo 07</a> (braid closure → PD), <a href="./entries/demo_08.html">Demo 08</a> (PD bracket, Vogel algorithm)</li>
<li><strong>Feeds into</strong>: Later demos using Jones polynomial invariance as ground truth</li>
</ul>
<h3>Headline</h3>
Proves computationally that the Kauffman bracket satisfies the R1 twist relation and is invariant under R2/R3, and that the Jones polynomial (writhe-normalized bracket) is a true knot invariant under all three Reidemeister moves.
<h3>Key Results</h3>
<ul>
<li><strong>R1 (twist/kink)</strong>: bracket(K + kink_s) = -A^{3s} * bracket(K), writhe changes by s, Jones invariant — verified on unknot, trefoil, figure-eight, Hopf link with both positive and negative kinks</li>
<li><strong>R2 (poke)</strong>: bracket, writhe, and Jones all unchanged — verified on R2-poked unknot, trefoil, figure-eight, Hopf link</li>
<li><strong>R3 (slide)</strong>: tested via braid relation sigma_1<em>sigma_2</em>sigma_1 = sigma_2<em>sigma_1</em>sigma_2 — bracket and Jones identical for both positive and negative generators, also on 4-strand braids</li>
<li><strong>Combined moves</strong>: R1(+) then R1(-) bracket factors cancel; R1+R2 Jones invariant; double R1(+) Jones invariant</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong><code>writhe()</code></strong>: computes writhe (sum of crossing signs) from PD notation</li>
<li><strong><code>jones_poly()</code></strong>: Jones/f-polynomial = (-A^3)^{-w} * bracket(K) — clean 4-line implementation</li>
<li><strong><code>apply_r1()</code></strong>: adds a positive or negative kink to a specified edge in PD notation — splits edge, creates loop arc, adds crossing</li>
<li><strong><code>apply_r2()</code></strong>: adds an R2 poke (pair of opposite-sign crossings) between two edges — splits both edges, creates intermediate arcs</li>
<li><strong><code>remap_second()</code></strong>: utility to replace second occurrence of an arc label (for edge splitting)</li>
<li><strong><code>make_r2_unknot()</code></strong>: manually constructed 2-crossing unknot (R2 poke of trivial unknot)</li>
<li>Reuses: Laurent polynomial ring, PD bracket state-sum, braid-to-PD conversion, known PD knots (trefoil, figure-eight, Hopf)</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Reidemeister's theorem: any two diagrams of equivalent links are connected by R1, R2, R3 moves</li>
<li>Kauffman bracket behavior under R1: not invariant (picks up -A^{3s} factor), hence is a "regular isotopy" invariant</li>
<li>Writhe normalization: (-A^3)^{-w} corrects R1 factor to produce true (ambient isotopy) invariant</li>
<li>Jones polynomial as writhe-normalized Kauffman bracket</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>R3 is tested only via the braid relation (algebraic equivalence), not via direct PD-level R3 move application — a direct <code>apply_r3()</code> on PD crossings would be more complete but is more complex to implement</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_10.html">Demo 10</a>: Numerical Evaluation Engine</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_10_numerical/main.c.html">demo_10_numerical/main.c</a></code> (~956 lines)</li>
<li><strong>Tests</strong>: ~50+ pass (6 parts: A=6 complex arith, B=5 Yang-Baxter/inverses, C=5 oracle match, D=scaling n=2..8 YB+far-comm+oracle, E=10 multi-angle, F=sample-point classification)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_04.html">Demo 04</a> (quantum trace formula, R-matrix), <a href="./entries/demo_05.html">Demo 05</a> (symbolic bracket sign convention)</li>
<li><strong>Feeds into</strong>: All higher demos needing numerical knot evaluation at scale (DKC pipeline, classification experiments)</li>
</ul>
<h3>Headline</h3>
Replaces symbolic Laurent polynomials with numerical complex evaluation (A = e^{i*theta}), enabling 50-100x memory reduction and scaling from n=5 (32x32) to n=8 (256x256) and beyond, validated against state-sum oracle at multiple angles.
<h3>Key Results</h3>
<ul>
<li>Complex arithmetic library validated: unit circle, powers, A^10 = 1 for A = e^{i*pi/5}</li>
<li>Numerical R-matrix (4x4) and Yang-Baxter (8x8) verified at tolerance 1e-9</li>
<li>5 braids (identity, trefoil, figure-eight, mirror trefoil, single crossing) match state-sum oracle numerically for n=3</li>
<li><strong>Scaling validated n=2 through n=8</strong>: Yang-Baxter, far commutativity, and oracle match at each dimension (up to 256x256)</li>
<li>Multi-angle validation: trefoil and figure-eight match oracle at 5 different angles (pi/5, pi/7, pi/10, pi/3, 0.7)</li>
<li><strong>Classification experiment</strong>: determines minimum number of sample evaluation points on unit circle to distinguish a 6-knot test set (unknot, trefoil, mirror trefoil, figure-eight, torus(2,5), granny knot)</li>
</ul>
<h3>Data</h3>
<ul>
<li>6-knot test set: unknot, trefoil, mirror trefoil, figure-eight, torus(2,5), granny knot</li>
<li>8 sample angles: pi/5, pi/7, pi/10, pi/3, 0.7, 1.1, 2.0, pi/13</li>
<li>Bracket vectors printed for first 3 angles per knot</li>
<li>Memory: Poly (~808 bytes) replaced by Cx (16 bytes) — 50x reduction per matrix entry</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>Cx</code> complex number type with full arithmetic: make, zero, one, real, add, sub, mul, div, neg, abs, abs2, exp_i, pow_int (binary exponentiation), near (approx equality), print</li>
<li><code>CMat</code> heap-allocated NxN complex matrix: alloc, free, zero, id, mul, scale, add, qtrace, tensor, eq_approx</li>
<li><code>CMAT(m,i,j)</code> macro for row-major access</li>
<li><code>build_R4()</code> — numerical 4x4 R-matrix and inverse for given A</li>
<li><code>build_Ri()</code> — general n-strand generator I^{x(i-1)} x R x I^{x(n-i-1)} via tensor products</li>
<li><code>build_Kn()</code> — K^{xn} diagonal weights for quantum trace at arbitrary n</li>
<li><code>braid_product_n()</code> — braid word to matrix product at arbitrary dimension</li>
<li><code>numerical_bracket()</code> — full pipeline: braid -&gt; matrix product -&gt; quantum trace -&gt; bracket with sign correction (-1)^{n+1}</li>
<li><code>braid_bracket_at()</code> — state-sum oracle evaluated at specific complex A (for validation)</li>
<li>Pattern: heap-allocated matrices with explicit free (scales to large n)</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Numerical evaluation of Kauffman bracket / Jones polynomial</li>
<li>Quantum trace formula evaluated on unit circle</li>
<li>Sample-point knot classification (bridge to DKC — Discrete Knotted Computation)</li>
<li>Yang-Baxter equation and far commutativity as numerical consistency checks</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>How many sample points suffice for larger knot tables? (experiment seeded here, extended in later demos)</li>
<li>Numerical stability at very large n (n=10+)?</li>
<li>Which angles are optimal for discrimination?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_11.html">Demo 11</a>: Waveform Signatures</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_11_waveform/main.c.html">demo_11_waveform/main.c</a></code> (~649 lines)</li>
<li><strong>Tests</strong>: ~16 pass (symmetry checks, greedy angle separation, cross-validation)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_10.html">Demo 10</a> (unit-circle bracket evaluation, complex arithmetic, state-sum oracle)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_12.html">Demo 12</a> (selected optimal angles for classification)</li>
</ul>
<h3>Headline</h3>
Sweeps the Kauffman bracket around the full unit circle (256 samples, 10 knots) to produce waveform signatures, proving chiral pairs share amplitude and greedy angle selection separates all knots.
<h3>Key Results</h3>
<ul>
<li>Chiral pairs (trefoil/mirror trefoil, torus(2,5)/cinquefoil mirror) have <strong>identical amplitude waveforms</strong> — only phase distinguishes them</li>
<li>Amphichiral knot (figure-eight) has amplitude symmetric about theta=0: |f(theta)| = |f(-theta)|</li>
<li>Mirror bracket relation verified: bracket_mirror(e^{i<em>theta}) = bracket(e^{i</em>(2pi-theta)})</li>
<li>Greedy angle selection finds a small set of angles (&lt;=8) that separates all 10 knots (threshold 0.001)</li>
<li>Best single angle identified that maximizes minimum pairwise separation</li>
<li>Hardest-to-distinguish pair identified across all angles</li>
<li>Full pairwise separation matrix computed at best angle</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li>PROVEN (numerically): |bracket(A)| = |bracket(A^{-1})| on the unit circle (chiral amplitude invariance)</li>
<li>PROVEN (numerically): Amphichiral knots have theta-reflection-symmetric amplitude</li>
<li>PROVEN (numerically): bracket_mirror(e^{i<em>theta}) = bracket(e^{-i</em>theta}) — the mirror bracket is the time-reversed waveform</li>
</ul>
<h3>Data</h3>
<ul>
<li>10 knots: unknot, trefoil, mirror trefoil, figure-eight, torus(2,5), torus(2,7), granny, square, cinquefoil mirror, single crossing</li>
<li>256 samples per knot over theta in [0, 2*pi)</li>
<li>Waveform statistics table: min/max amplitude, ratio, zero count per knot</li>
<li>Pairwise separation matrix at optimal angle</li>
<li>Greedy-selected angle set for <a href="./entries/demo_12.html">Demo 12</a></li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>waveforms[NUM_KNOTS][NSAMP]</code>: full complex waveform table (Cx values)</li>
<li><code>amplitudes[NUM_KNOTS][NSAMP]</code>: precomputed amplitude table</li>
<li><code>compute_waveforms()</code>: sweeps bracket evaluation around unit circle for all knots</li>
<li><code>test_symmetries()</code>: tests chiral amplitude identity, amphichiral reflection symmetry, mirror bracket relation</li>
<li><code>waveform_stats()</code>: min/max amplitude, dynamic range ratio, near-zero count per knot</li>
<li><code>pairwise_separation()</code>: finds best single angle (max-min separation), hardest pair, prints separation matrix</li>
<li><code>greedy_angles()</code>: iterative greedy selection of optimal angles maximizing worst-case pairwise distance; terminates when all pairs separated above threshold</li>
<li><code>ascii_waveforms()</code>: ASCII art visualization of amplitude waveforms (60-column, 5 intensity bands)</li>
<li><code>cross_validate()</code>: confirms consistency with <a href="./entries/demo_10.html">Demo 10</a>'s direct evaluation</li>
<li>Complex arithmetic library: <code>cx_make</code>, <code>cx_add</code>, <code>cx_sub</code>, <code>cx_mul</code>, <code>cx_div</code>, <code>cx_abs</code>, <code>cx_exp_i</code>, <code>cx_pow_int</code>, <code>cx_near</code></li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Kauffman bracket on unit circle as signal processing / waveform analysis</li>
<li>Chiral knot detection via phase vs amplitude separation</li>
<li>Greedy sensor placement / optimal angle selection (information-theoretic flavor)</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>How many angles are needed to separate ALL prime knots up to N crossings? (scaling question)</li>
<li>Can the greedy-selected angles be interpreted geometrically or algebraically?</li>
<li>Trefoil period test: is the waveform period pi or 2pi? (logged as INFO, not asserted)</li>
<li>Connection between waveform zeros and knot invariants unexplored</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_12.html">Demo 12</a>: Quantization</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_12_quantization/main.c.html">demo_12_quantization/main.c</a></code> (~780 lines)</li>
<li><strong>Tests</strong>: 6 parts (A-F): reference signatures, bit-depth sweep, component analysis, precision x width matrix, weight table, nearest-neighbor classifier</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_10.html">Demo 10</a> (numerical bracket evaluation), <a href="./entries/demo_11.html">Demo 11</a> (waveform / greedy angle selection)</li>
<li><strong>Feeds into</strong>: Later demos exploring DKC and classification with quantized representations</li>
</ul>
<h3>Headline</h3>
Investigates how aggressively Kauffman bracket complex weights can be quantized while retaining 100% knot classification across 10 test knots, finding a Pareto-optimal precision x width tradeoff and drawing an explicit parallel to BitNet's 1.58-bit LLM weights.
<h3>Key Results</h3>
<ul>
<li><strong>Bit-depth sweep</strong> (Part B): scans 16/12/8/6/4/3/2/1 bits per component at a single optimal angle, then binary searches for minimum bits achieving 100% pair separation</li>
<li><strong>Component analysis</strong> (Part C): amplitude-only FAILS (granny/square have identical |bracket| — predicted from <a href="./entries/demo_11.html">Demo 11</a>), phase-only also insufficient alone, sign-only (quadrant / 1-bit) and ternary ({-1,0,+1} / 1.58-bit) tested</li>
<li><strong>Precision x width matrix</strong> (Part D): explores {1,2,3,4,8} bits x {1,2,3,4,8} angles, finds Pareto optimum (minimum total bits per knot for 100% classification)</li>
<li><strong>Compiled weight table</strong> (Part E): prints full-precision and quantized weight vectors, reports total model size in bits/bytes</li>
<li><strong>Nearest-neighbor classifier</strong> (Part F): self-classification of all 10 knots at full precision, plus invariance tests with alternate braid representations (alt trefoil s2<em>s1</em>s2, alt figure-eight s2^{-1}<em>s1</em>s2^{-1}*s1)</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li>Granny and square knots have identical bracket amplitude at any single angle (they're connected sums of trefoil with itself vs its mirror) — phase is required to distinguish them</li>
<li>BitNet parallel: if LLMs work with 1.58-bit weights, can knot classification work with similarly extreme quantization? The precision x width matrix explores this tradeoff systematically</li>
</ul>
<h3>Data</h3>
<ul>
<li>10-knot test suite: unknot, trefoil, mirror trefoil, figure-eight, torus(2,5), torus(2,7), granny, square, cinquefoil mirror, single crossing</li>
<li>256-sample waveform discretization for greedy angle selection (up to 8 angles)</li>
<li>Tradeoff matrix: bits x angles → pairs separated (out of 45 total pairs)</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong><code>quantize()</code></strong>: uniform quantize-dequantize for a double in [lo, hi] to B bits</li>
<li><strong><code>cx_quantize()</code></strong>: independently quantizes real and imaginary components</li>
<li><strong><code>cx_ternary()</code></strong>: ternary quantization {-1, 0, +1} per component with threshold (BitNet-style 1.58-bit)</li>
<li><strong><code>cx_sign()</code></strong>: pure quadrant / 1-bit per component sign extraction</li>
<li><strong><code>test_quantized_separation()</code></strong>: tests whether B-bit quantization at M angles separates all knot pairs — core of the sweep</li>
<li><strong><code>classify_braid()</code></strong>: nearest-neighbor classifier in quantized weight space — computes bracket at greedy angles, quantizes, finds closest reference</li>
<li><strong><code>select_greedy_angles()</code></strong>: greedy max-min angle selection from <a href="./entries/demo_11.html">Demo 11</a> (reused)</li>
<li>Reuses: complex arithmetic, braid state-sum bracket, union-find loop counter</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>BitNet / extreme quantization in neural networks ({-1, 0, +1} weights)</li>
<li>Knot classification via bracket evaluation at specific angles (waveform approach from <a href="./entries/demo_11.html">Demo 11</a>)</li>
<li>Connected sum structure: bracket of granny vs square</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>What is the actual Pareto-optimal point? (depends on runtime — not hardcoded in source)</li>
<li>Does the ternary/sign quantization achieve 100% with multiple angles even though it fails at 1 angle?</li>
<li>How does quantization robustness scale as the knot table grows beyond 10 entries?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_13.html">Demo 13</a>: DKC Test</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_13_dkc_test/main.c.html">demo_13_dkc_test/main.c</a></code> (~949 lines)</li>
<li><strong>Tests</strong>: ~8+ pass (6 parts: A=separation, B=multi-angle, C=Pareto, D=train/test+self-class+alt-trefoil, E=baseline, F=scaling)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_10.html">Demo 10</a> (numerical evaluation engine), <a href="./entries/demo_11.html">Demo 11</a>/12 (greedy angle selection, quantization, Pareto frontier)</li>
<li><strong>Feeds into</strong>: Later DKC demos (scaling to larger knot tables, forward DKC)</li>
</ul>
<h3>Headline</h3>
Scales DKC (Deterministic Knowledge Compilation) from 10 knots to ~28 candidate braids (deduplicated to ~20+ unique knot types), validating that algebraically compiled weights generalize without training via train/test split, random baseline comparison, and scaling-law analysis.
<h3>Key Results</h3>
<ul>
<li>28 candidate 3-strand braids initialized across 3 groups: torus knots T(2,n) with mirrors (n=3,5,7,9,11,13), connected sums (granny, square, T23#T25, etc.), and miscellaneous braid patterns (commutator, mixed-sign words)</li>
<li>Deduplication via bracket evaluation at 2 reference angles removes equivalent braids</li>
<li>Greedy angle selection from 256-sample waveforms, up to 8 angles</li>
<li><strong>Multi-angle separation</strong>: determines minimum angles for 100% pairwise separation at scale</li>
<li><strong>Precision x Width Pareto frontier</strong>: bits-per-component vs number of angles grid; finds minimum total bits per knot for full separation (compared to <a href="./entries/demo_12.html">Demo 12</a>'s 8 bits for 10 knots)</li>
<li><strong>Train/test DKC validation</strong>: 70/30 split, training self-classification must be 100%, test knots correctly differentiated from training set, invariance test (alt trefoil s2.s1.s2 matches canonical s1.s2.s1)</li>
<li><strong>Random baseline</strong>: 100 LCG trials confirm DKC achieves 100% separation while random signatures don't guarantee it</li>
<li><strong>Scaling law</strong>: min pairwise separation decreases with knot count (below <a href="./entries/demo_12.html">Demo 12</a>'s 0.907 for 10 knots); extrapolation suggests 1/sqrt(N) decay, predicting quantization limits</li>
</ul>
<h3>Data</h3>
<ul>
<li>28 candidate braids, 3 groups: torus knots (14 with mirrors), connected sums (8), other 3-strand braids (6)</li>
<li>256-sample waveforms for greedy angle selection</li>
<li>Pareto grid: bits {1,2,3,4,8} x angles {1,2,3,4,8}</li>
<li>Train/test split: 70% train, 30% test</li>
<li>Random baseline: 100 trials, LCG RNG (seed 12345)</li>
<li>Scaling analysis: subset sizes {5, 10, 15, 20, 25} + full table</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>DKC thesis</strong>: weights compiled from algebraic structure (Kauffman bracket) generalize without training because they encode topology, not statistical patterns</li>
<li>Min separation scales as ~1/sqrt(N) — implies quantization bit requirements grow logarithmically with knot table size</li>
<li>4-bit quantization fails when step_size (range/15) exceeds min_sep</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>add_torus_2n()</code> — generates T(2,n) torus knot braid word with sign control (mirror)</li>
<li><code>add_connected_sum()</code> — concatenates two braid words for connected sum construction</li>
<li><code>dedup_knots()</code> — removes duplicate knot types by bracket comparison at 2 reference angles</li>
<li><code>select_greedy_angles()</code> — max-min-distance greedy selection from 256-sample waveforms (heap-allocated)</li>
<li><code>quantize()</code> / <code>cx_quantize()</code> — uniform scalar/complex quantization with configurable bits</li>
<li><code>test_quantized_sep()</code> — counts separated pairs after quantization at given bits and angles</li>
<li><code>classify_against_table()</code> — nearest-neighbor classifier against reference signature table</li>
<li>LCG random number generator for reproducible baseline trials</li>
<li><code>count_separated_pairs()</code> — utility for multi-angle pairwise distance check</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Deterministic Knowledge Compilation (DKC) — algebraic classifier without training</li>
<li>Kauffman bracket as topological invariant for classification</li>
<li>Greedy sensor/feature selection (max-min pairwise distance criterion)</li>
<li>Quantization theory for discrete classifiers</li>
<li>Scaling laws in combinatorial discrimination</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>How does the Pareto frontier evolve at 50, 100, 250+ knots?</li>
<li>Is 1/sqrt(N) the correct scaling exponent, or is it knot-family-dependent?</li>
<li>Can connected sums always be distinguished from prime knots at finite precision?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_14.html">Demo 14</a>: Zero Structure</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_14_zero_structure/main.c.html">demo_14_zero_structure/main.c</a></code> (~831 lines)</li>
<li><strong>Tests</strong>: 7/7 pass (compiles clean with all strict flags including -Werror)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_11.html">Demo 11</a> (initial observation of bracket amplitude zeros), <a href="./entries/demo_13.html">Demo 13</a> (23-knot table + dedup)</li>
<li><strong>Feeds into</strong>: (further invariant refinement, classification power analysis)</li>
</ul>
<h3>Headline</h3>
Investigates zeros of |bracket(e^{i*theta})| as a knot invariant: finds that zeros occur only at universal angles (multiples of pi/4), counts take values from {0, 4, 8}, and chiral pairs have perfectly reflected zero positions.
<h3>Key Results</h3>
<ul>
<li><strong>Zero counts partition into {0, 4, 8} only</strong> for torus knots T(2,n) — not monotonic with crossing number; pattern is 8,0,0,8,4,4 for n=3,5,7,9,11,13</li>
<li><strong>All zeros occur at universal angles</strong>: pi/4 multiples (the delta zeros: pi/4, 3pi/4, 5pi/4, 7pi/4) and pi/8 multiples. Perfectly uniform spacing (ratio=1.00 for all knots)</li>
<li><strong>Chiral pairs have reflected zero positions</strong>: theta &lt;-&gt; 2pi-theta, all pairs 100% matched</li>
<li><strong>Figure-eight has 0 zeros</strong> with min amplitude 0.021 (amphichiral, bracket never vanishes on unit circle)</li>
<li><strong>All composites have 0 zeros</strong> — braid connected sums don't factor like diagram connected sums</li>
<li><strong>Braid vs diagram connected sum</strong>: factorization bracket(K1#K2) = bracket(K1)*bracket(K2)/delta does NOT hold for braid concatenation (error ~6.35), confirming braid concatenation != diagram connected sum</li>
<li><strong>Clear amplitude gap</strong>: zero-class knots have min_amp &lt; 7.3e-15, nonzero-class have min_amp &gt; 0.021 (gap ratio ~2.85 trillion)</li>
<li><strong>Classification power</strong>: zeros separate 61% of pairs (128/210), but 0-zero class is huge (12 knots), leaving 82 indistinguishable pairs</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Confirmed</strong>: Zero count in {0, 4, 8} for torus knots T(2,n) in this table</li>
<li><strong>Confirmed</strong>: Chiral pairs share zero count and have reflected positions</li>
<li><strong>Confirmed</strong>: All zeros lie on the pi/8 lattice (subset of delta zeros or their bisections)</li>
<li><strong>Confirmed</strong>: Braid concatenation != diagram connected sum (factorization fails)</li>
<li><strong>Observed</strong>: Zero count is NOT monotonic with crossing number — cyclic pattern for torus knots</li>
<li><strong>Limitation</strong>: Zeros alone cannot distinguish most 0-zero knots (composites, figure-eight, T(2,5), T(2,7) all indistinguishable)</li>
</ul>
<h3>Data</h3>
<ul>
<li>21 unique knots after dedup (T23#fig8 == T(2,5)* removed)</li>
<li>Zero counts: unknot=4, T(2,3)/T(2,3)<em>=8, T(2,5)/T(2,5)</em>=0, T(2,7)/T(2,7)<em>=0, T(2,9)/T(2,9)</em>=8, T(2,11)/T(2,11)<em>=4, T(2,13)/T(2,13)</em>=4, fig-eight=0, all composites=0</li>
<li>4-zero positions: 0.2500, 0.7500, 1.2500, 1.7500 (*pi) — exactly the delta zeros</li>
<li>8-zero positions: 0.1250, 0.3750, 0.6250, 0.8750, 1.1250, 1.3750, 1.6250, 1.8750 (*pi) — pi/8 lattice</li>
<li>Delta zeros: pi/4, 3pi/4, 5pi/4, 7pi/4 (= -2<em>cos(2</em>theta) = 0)</li>
<li>3 distinct zero count classes across 21 knots</li>
<li>1024 sample points, bisection with 50 iterations, threshold 1e-6</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>bracket_amp()</code>: evaluate |bracket| at angle theta on unit circle</li>
<li><code>bisect_zero()</code>: golden-section-like bisection to find precise zero locations (50 iterations)</li>
<li><code>part_a_find_zeros()</code>: high-resolution zero finder (1024 samples, per-knot zero arrays)</li>
<li>Knot table infrastructure: <code>init_knots()</code> with 22 braids (torus knots T(2,3)-T(2,13) + mirrors, figure-eight, 7 connected sums), <code>dedup_knots()</code> using bracket evaluation at two reference angles</li>
<li><code>add_torus_2n()</code>, <code>add_connected_sum()</code>: knot table builder helpers</li>
<li>Reusable complex arithmetic (<code>Cx</code> type), state-sum bracket oracle, union-find — all copied from earlier demos</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Kauffman bracket zeros on the unit circle</li>
<li>Delta = -A^2 - A^{-2} = -2<em>cos(2</em>theta) zeros at pi/4 multiples</li>
<li>Connected sum bracket factorization: bracket(K1#K2) = bracket(K1)*bracket(K2)/delta (diagram level)</li>
<li>Chiral pair reflection symmetry (A &lt;-&gt; A^{-1} = theta &lt;-&gt; 2pi-theta)</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Why does the zero count for torus knots follow the cyclic pattern {8,0,0,8,4,4}? Is there a number-theoretic explanation (n mod something)?</li>
<li>Can zeros distinguish within the large 0-zero class at all, or is additional invariant data always needed?</li>
<li>The pi/8 lattice for 8-zero knots — is this exactly the 8th roots of unity? What's the algebraic explanation?</li>
<li>Dedup found T23#fig8 == T(2,5)* — is this a real equivalence or a dedup false positive?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_15.html">Demo 15</a>: Angle Optimization — The WRT Convergence Test</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_15_angle_optimization/main.c.html">demo_15_angle_optimization/main.c</a></code> (~884 lines)</li>
<li><strong>Tests</strong>: ~8 pass (WRT convergence, greedy vs WRT single-angle, reduced bracket wins, multi-angle separation, survey best)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_14.html">Demo 14</a> (delta factorization, reduced bracket g), <a href="./entries/demo_11.html">Demo 11</a> (greedy angle selection, 1.805*pi), <a href="./entries/demo_10.html">Demo 10</a> (unit-circle evaluation)</li>
<li><strong>Feeds into</strong>: later demos using optimal angle sets for knot classification; validates Chern-Simons theory empirically</li>
</ul>
<h3>Headline</h3>
Greedy-selected optimal angle (1.805<em>pi) independently converges to within 1.5% of the WRT level-3 evaluation point (11</em>pi/6), empirically validating that algebraically special angles ARE informationally optimal angles.
<h3>Key Results</h3>
<ul>
<li><strong>WRT convergence</strong>: closest WRT angle to greedy (1.805*pi) is within 5% of pi — the information-theoretic optimum independently found the Chern-Simons evaluation point</li>
<li><strong>Single-angle head-to-head</strong>: greedy outperforms all WRT angles on min_dist (hardest-pair separation); WRT angles cluster near 2*pi where brackets converge</li>
<li><strong>Reduced bracket g vs raw</strong>: g wins or ties at majority of angles; g has tighter dynamic range (max/min ratio)</li>
<li><strong>Multi-angle</strong>: 3 WRT angles on reduced bracket g separate ALL pairs in the 21-knot table; 4 WRT angles also achieve full separation</li>
<li><strong>Complete 128-sample survey</strong>: identifies top-5 angles for both raw and reduced bracket; survey best &gt;= greedy for g</li>
<li>25 knots deduplicated to ~21 unique types (granny* == granny under bracket equivalence, etc.)</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li>CONFIRMED (numerically): WRT evaluation points are near-optimal for knot classification — within 1.5% of greedy optimum at r=3</li>
<li>CONFIRMED: Reduced bracket g outperforms raw bracket at majority of angles (by min_dist metric)</li>
<li>CONFIRMED: 3 WRT angles + reduced bracket suffice to separate all 21 knot types</li>
<li>CONJECTURED: Algebraically special angles (roots of unity from Chern-Simons) ARE informationally optimal — "topology knows information theory"</li>
</ul>
<h3>Data</h3>
<ul>
<li>25 knots (deduplicated to ~21): unknot, T(2,3) through T(2,13) + mirrors, figure-eight, granny, square, T23#T25, T25#T25 + variants, T23#fig8</li>
<li>WRT angle table: r=3 (11<em>pi/6 = 1.833</em>pi), r=4, r=5, r=6, r=8, r=10, r=12</li>
<li>Greedy angle: 1.805*pi from <a href="./entries/demo_11.html">Demo 11</a></li>
<li>Delta exponents (k) per knot: 0, 1, or 2</li>
<li>Separation matrix: pairs separated at each angle, min_dist, mean_dist</li>
<li>Top-5 angles for raw bracket and reduced bracket g</li>
<li>6 random baselines for comparison</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>wrt_angle(r)</code>: computes WRT evaluation angle for level r via theta = 2*pi - pi/(2r)</li>
<li><code>SepMetrics</code> struct: separated count, min_dist, mean_dist, sum_log_dist</li>
<li><code>measure_separation()</code>: evaluates full pairwise separation metrics for a set of angles, supports both raw and reduced bracket</li>
<li><code>count_separated_pairs()</code>: convenience wrapper for pair count</li>
<li><code>delta_exponent()</code>: detects delta power k by counting zeros at pi/4 multiples + second-order derivative check</li>
<li><code>reduced_bracket_at()</code>: computes g(K,A) = bracket(K,A) / delta^k(A) with zero-avoidance fallback</li>
<li><code>dedup_knots()</code>: removes duplicate knots by comparing bracket values at two reference angles</li>
<li><code>add_torus_2n()</code>, <code>add_connected_sum()</code>: knot table constructors for torus knots and connected sums</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Witten-Reshetikhin-Turaev (WRT) invariants at level r</li>
<li>Chern-Simons theory evaluation points (t = A^{-4} mapping)</li>
<li>Jones polynomial via bracket-to-Jones: t = A^{-4}</li>
<li>Information-theoretic angle optimization (Pareto frontier concept)</li>
<li>Greedy sensor placement / optimal sampling</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Does the WRT-greedy convergence hold for larger knot tables (beyond 13 crossings)?</li>
<li>Is there a proof that WRT points are optimal, or is this an empirical observation?</li>
<li>The Pareto frontier (Prediction 5 from header) is mentioned but not explicitly computed — could be a follow-up</li>
<li>How does the required number of WRT angles scale with knot complexity?</li>
<li>Connection to volume conjecture (WRT invariants at large r relate to hyperbolic volume)</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_16.html">Demo 16</a>: Reduced Bracket Characterization — What IS g?</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_16_reduced_bracket/main.c.html">demo_16_reduced_bracket/main.c</a></code> (~975 lines)</li>
<li><strong>Tests</strong>: 8 checks across 6 parts (A-F): waveform, peak localization, Pareto frontier, connected-sum factorization, minimal angle set, amplitude statistics</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_14.html">Demo 14</a> (bracket = delta^k * g factorization), <a href="./entries/demo_15.html">Demo 15</a> (g optimal angles, 4.3x classification improvement)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_17.html">Demo 17</a> (multilayer DKC), later demos using g as the primary classification signal</li>
</ul>
<h3>Headline</h3>
Deep characterization of the reduced bracket g(K,A) = bracket(K,A) / delta^k(A): waveform analysis, peak localization showing a broad plateau near 1.266*pi, Pareto frontier proving g needs fewer bits than raw bracket, connected-sum factorization test (fails — structural issue), greedy angle selection showing g achieves higher min_dist, and amplitude statistics by knot family.
<h3>Key Results</h3>
<ul>
<li><strong>Waveform</strong> (Part A): g has fewer zeros than raw bracket (removes delta zeros for k&gt;0 knots), but is NOT smoother — dividing by delta near its zeros amplifies roughness. 256-sample characterization with smoothness/range/zero metrics per knot.</li>
<li><strong>Peak localization</strong> (Part B): g peak at ~1.266<em>pi is a broad plateau (half-max width &gt; 0.05</em>pi, not a spike). g peak min_dist &gt; raw peak min_dist — confirms <a href="./entries/demo_15.html">Demo 15</a>'s finding with fine-grained 256-sample scan over [1.0<em>pi, 1.5</em>pi].</li>
<li><strong>Pareto frontier</strong> (Part C): bit-depth sweep 2-16 bits. g reaches full classification in fewer or equal bits than raw bracket at optimal angles. Uniform quantization with fixed amplitude range ±50.</li>
<li><strong>Connected-sum factorization</strong> (Part D): g(K1#K2) vs g(K1)*g(K2) tested at 8 angles for 8 composites. <strong>Finding: g does NOT factorize</strong> — braid-encoded connected sum != standard connected sum. The delta removal doesn't fix this; the issue is structural.</li>
<li><strong>Minimal angle set</strong> (Part E): greedy max-min-dist selection at 128-sample resolution. g achieves higher min_dist than raw at 1 angle. Both stop when diminishing returns (&lt;1% improvement).</li>
<li><strong>Amplitude statistics</strong> (Part F): knots classified into families (torus, mirror, composite, fig-eight, unknot). Torus and mirror families have similar g amplitudes. Composite g amplitudes differ from prime knots.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li>Five predictions tested: 1. g waveforms smoother — <strong>PARTIALLY FALSE</strong> (fewer zeros, but more rough near delta zeros) 2. Optimal angle peak is broad plateau — <strong>CONFIRMED</strong> (half-max width &gt; 0.05*pi) 3. g Pareto frontier 1-2 bits better — <strong>CONFIRMED</strong> (g needs fewer bits) 4. g factorizes under connected sum — <strong>FALSE</strong> (structural issue with braid concatenation) 5. g needs fewer angles — tested via greedy; g achieves higher min_dist per angle</li>
</ul>
<h3>Data</h3>
<ul>
<li>21 knots after dedup (from ~25): unknot, T(2,3) through T(2,13) + mirrors, figure-eight, granny, square, T23#T25, T23#T25<em>, T25#T25, T25#T25</em>, granny*, T23#fig8</li>
<li>8 composite knots with tracked component indices</li>
<li>Delta exponents (k values) cached per knot</li>
<li>Waveform metrics: smoothness (mean |derivative|), amplitude range (max/min), zero count</li>
<li>Peak scan: 256 samples over [pi, 1.5*pi], half-maximum width measurement</li>
<li>Pareto table: 15 bit-depths x {raw, g} pair separation counts</li>
<li>Greedy angle selection: up to 20 rounds with diminishing-returns cutoff</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong><code>delta_exponent()</code></strong>: determines k by testing bracket at 4 delta-zero angles (pi/4, 3pi/4, 5pi/4, 7pi/4) + perturbation test</li>
<li><strong><code>reduced_bracket_at()</code></strong>: computes g = bracket / delta^k at a specific A value</li>
<li><strong><code>min_dist_from_vals()</code></strong>: minimum pairwise distance across all knot pairs from precomputed values</li>
<li><strong><code>dedup_knots()</code></strong>: removes duplicate braids by comparing bracket values at 2 reference angles, maintains composite index remapping</li>
<li><strong><code>add_connected_sum()</code></strong>: builds composite braid by concatenating words, tracks component indices in CompositeInfo struct</li>
<li><strong>Greedy angle selection</strong>: precompute-all-then-sweep approach with accumulated distance² per pair — more efficient than <a href="./entries/demo_12.html">Demo 12</a>'s per-round recomputation</li>
<li>Reuses: complex arithmetic, braid state-sum oracle, union-find</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Reduced Kauffman bracket (dividing out delta factors)</li>
<li>Connected sum of knots and multiplicativity of invariants</li>
<li>Quantization Pareto frontiers (precision vs classification accuracy)</li>
<li>Greedy feature selection (max-min-dist criterion)</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Why doesn't g factorize under braid concatenation? Is there a different braid encoding of connected sum that would restore multiplicativity?</li>
<li>Can the peak plateau shape be explained algebraically (relationship to delta zeros at 1.25*pi)?</li>
<li>What happens to the Pareto frontier as the knot table grows beyond 21 entries?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_17.html">Demo 17</a>: Multi-Layer DKC</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_17_multilayer_dkc/main.c.html">demo_17_multilayer_dkc/main.c</a></code> (~1468 lines)</li>
<li><strong>Tests</strong>: ~6 pass (5 parts: A=flat baseline, B=Arf split, C=hierarchical tree, D=GD vs analytical, E=Pareto comparison)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_10.html">Demo 10</a> (numerical engine), <a href="./entries/demo_12.html">Demo 12</a>-<a href="./entries/demo_16.html">16</a> (greedy angle selection, quantization, Pareto framework, reduced bracket g, delta exponent k)</li>
<li><strong>Feeds into</strong>: Later DKC architecture decisions (flat vs hierarchical tradeoffs)</li>
</ul>
<h3>Headline</h3>
Tests whether hierarchical knot classification (Arf-split, greedy binary tree) outperforms flat evaluation at low bit budgets, comparing analytical angle selection against gradient descent on ~21 unique 3-strand knots.
<h3>Key Results</h3>
<ul>
<li><strong>Part A (Flat baseline)</strong>: Greedy angle selection over 256-sample survey; Pareto grid at 1/2/4 angles x 1-10 bits; finds minimum bits for full 210/210 pair classification</li>
<li><strong>Part B (Arf split)</strong>: Layer 1 = delta exponent k (k=0 vs k&gt;0) separates cross-group pairs for free (1 bit); per-group optimal angles found independently; Pareto shows bits savings vs flat</li>
<li><strong>Part C (Hierarchical tree)</strong>: Greedy bisection up to depth 4; splits on real-part threshold at optimal survey angle; counts cross-leaf pairs separated by tree structure alone; Pareto includes tree bits + per-leaf value bits</li>
<li><strong>Part D (GD vs analytical)</strong>: 50 random starts x 100 iterations with simulated annealing (step *= 0.95); analytical (exhaustive survey) matches or beats gradient descent within 1% tolerance</li>
<li><strong>Part E (Pareto comparison)</strong>: All four methods (flat-1A, flat-2A, arf-split, tree) on same bit-budget axes; identifies which methods achieve full classification first; diagnoses "stubborn pairs" at 1-bit tree</li>
</ul>
<h3>Five Predictions Tested</h3>
1. Arf split saves 1-2 bits over flat
2. Greedy hierarchical tree beats Arf split
3. Analytical matches/beats gradient descent
4. Biggest gains at low bit budgets (4-8 bits)
5. Flat catches up at high bit budgets (16+)
<h3>Data</h3>
<ul>
<li>~21 unique knot types after dedup (from 24 candidates: 13 torus knots+mirrors, 8 connected sums, figure-eight, plus 2 not in this table)</li>
<li>256-sample survey waveforms for greedy angle selection</li>
<li>Pareto grid: 1-10 bits x {flat-1A, flat-2A, arf-split, tree}</li>
<li>Gradient descent: 50 starts x 100 iterations, step annealing 0.95</li>
<li>Stubborn pair diagnostics at 1-bit resolution</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>DKC thesis</strong>: algebraically compiled weights encode topology, not statistical patterns — hierarchy exploits algebraic structure (Arf invariant, delta exponent) for free bits</li>
<li>Arf invariant as Layer 1: Craven et al. (2025) found neural networks CANNOT learn the Arf invariant; DKC computes it analytically for free</li>
<li>Analytical angle selection matches gradient descent because the objective landscape (min pairwise distance) is smooth and low-dimensional</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>delta_exponent()</code> — computes k (delta factor) by evaluating bracket at delta-zero angles (pi/4, 3pi/4, 5pi/4, 7pi/4) plus perturbation test</li>
<li><code>reduced_bracket_at()</code> — g(A) = bracket(A) / delta^k, the reduced invariant</li>
<li><code>k_cache[]</code> with lazy <code>ensure_k_cache()</code> — cached delta exponents per knot</li>
<li><code>g_survey[256][MAX_KNOTS]</code> with lazy <code>ensure_survey()</code> — precomputed reduced bracket at 256 equispaced angles</li>
<li><code>min_dist_subset()</code> / <code>min_dist_all()</code> — min pairwise distance for knot subsets from precomputed values</li>
<li><code>QuantVal</code> struct with <code>quantize()</code> — integer quantization (B bits, clamped)</li>
<li><code>count_separated_pairs()</code> — multi-angle quantized separation counter</li>
<li><code>find_best_bisection()</code> — greedy bisection: searches all survey angles x all midpoint thresholds, scores by min(min_dist_left, min_dist_right)</li>
<li><code>TreeNode</code> and <code>build_tree()</code> — recursive binary tree construction up to MAX_TREE_DEPTH=4</li>
<li>Gradient descent with multi-start and annealing for angle optimization (50 starts x 100 iters)</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Craven et al. (2025): neural networks cannot learn the Arf invariant</li>
<li>Hierarchical classification / decision trees for topological invariants</li>
<li>Greedy feature selection vs gradient-based optimization</li>
<li>Quantization-aware classification (bit-budget Pareto analysis)</li>
<li>Arf invariant as a topological splitting criterion</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Does the hierarchical advantage grow with knot table size (100+ knots)?</li>
<li>Can deeper trees (depth &gt; 4) provide further gains, or do they overfit to training angles?</li>
<li>Are there other algebraic invariants beyond Arf that provide free bits at Layer 1?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_18.html">Demo 18</a>: Braid Logic Gates</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_18_braid_logic/main.c.html">demo_18_braid_logic/main.c</a></code> (~1038 lines)</li>
<li><strong>Tests</strong>: ~8 pass (NOT gate found, NAND gate found, AND gate via composition or direct search, XOR search, angle sensitivity for NOT/NAND, universality summary)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_10.html">Demo 10</a>-<a href="./entries/demo_17.html">17</a> (bracket evaluation at unit-circle angles, state-sum oracle, complex arithmetic)</li>
<li><strong>Feeds into</strong>: establishes computational universality of braids via classical gates; foundation for any later braid-based computation demos</li>
</ul>
<h3>Headline</h3>
Exhaustive search finds specific braid words that compute NOT, NAND, and AND gates via bracket amplitude thresholding — proving classical computational universality of the braid/bracket framework.
<h3>Key Results</h3>
<ul>
<li><strong>NOT gate found</strong> on 2 strands (up to 6 crossings): input encoding is identity=0, sigma_1=1; bracket amplitude at optimal angle separates the two outputs</li>
<li><strong>NAND gate found</strong> on 3 strands (up to 5 crossings, 4^L search capped at 1024 templates): input A on sigma_1, input B on sigma_2; three high outputs vs one low output for NAND truth table</li>
<li><strong>AND gate</strong>: obtained either via NAND+NOT braid concatenation composition or direct search fallback</li>
<li><strong>XOR gate</strong>: search completed but expected to fail — XOR is non-threshold/non-monotone, which is a meaningful negative result (counted as informative, not failure)</li>
<li><strong>Universality</strong>: NOT + NAND (or NAND alone) = Turing complete gate set</li>
<li><strong>Angle sensitivity</strong>: both NOT and NAND gates work at multiple angles (not just a single fragile point)</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li>CONFIRMED (computationally): Specific braid words exist whose bracket amplitude encodes NOT and NAND truth tables</li>
<li>CONFIRMED: Braid concatenation composes gates (NAND followed by NOT gives AND)</li>
<li>CONFIRMED: NOT + NAND achieves classical computational universality via braids</li>
<li>EXPECTED NEGATIVE: XOR not found at short braid lengths (non-threshold gate requires longer braids or different encoding)</li>
<li>THEORETICAL BASIS: Freedman-Kitaev-Wang universality + Solovay-Kitaev O(log^c(1/eps)) approximation guarantee</li>
</ul>
<h3>Data</h3>
<ul>
<li>NOT gate: 2 strands, best gate word and separation margin recorded</li>
<li>NAND gate: 3 strands, 4 input combinations verified against truth table</li>
<li>Search space: 2^L for 2-strand NOT (L=1..6), 4^L for 3-strand NAND/AND/XOR (capped at 1024)</li>
<li>Angle sampling: 64 coarse samples for search, verification at optimal angle</li>
<li>Input encoding: identity braid = bit 0, single crossing = bit 1</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>GateResult</code> struct: stores gate word, strand count, length, best separation, optimal angle, threshold, found flag</li>
<li><code>gate_output()</code>: evaluates bracket amplitude for single-bit input through gate template</li>
<li><code>gate_output_2bit()</code>: evaluates bracket amplitude for two-bit input (A on gen_a, B on gen_b) through gate template</li>
<li><code>make_gate_braid()</code>: constructs full braid by prepending input sub-braid to gate template</li>
<li><code>part_a_not_gate()</code>: exhaustive 2-strand NOT search (2^L gate words, 64 angles each)</li>
<li><code>part_b_nand_gate()</code>: exhaustive 3-strand NAND search (4^L gate words, capped at 1024)</li>
<li><code>part_c_composition()</code>: gate composition via braid concatenation; falls back to direct AND search</li>
<li><code>part_d_xor_search()</code>: XOR search (expected negative result for non-threshold gate)</li>
<li><code>part_e_characterization()</code>: angle sensitivity analysis — counts working angles per gate</li>
<li>Gate composition pattern: <code>[input_A] ∘ [input_B] ∘ [NAND_template] ∘ [NOT_template]</code> evaluated as single braid</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Freedman-Kitaev-Wang: braids are computationally universal (topological quantum computation)</li>
<li>Solovay-Kitaev theorem: O(log^c(1/epsilon)) braid length for gate approximation</li>
<li>Classical logic gate universality (NAND alone is Turing complete)</li>
<li>Threshold vs non-threshold gates (XOR is the canonical hard case)</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Can XOR be found at longer braid lengths or with different input encoding?</li>
<li>What is the minimum braid length for each gate as a function of separation margin?</li>
<li>How does gate quality scale with strand count? (4+ strands unexplored)</li>
<li>Connection to topological quantum error correction — do these gates inherit noise resilience?</li>
<li>Can the angle sensitivity analysis identify WRT-special angles as optimal for gates (connecting to <a href="./entries/demo_15.html">Demo 15</a>)?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_19.html">Demo 19</a>: Braid Circuit Compiler</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_19_braid_compiler/main.c.html">demo_19_braid_compiler/main.c</a></code> (~1017 lines)</li>
<li><strong>Tests</strong>: ~15 checks across 5 parts (A-E): root-of-unity catalog, universal gate set, boolean compiler, full adder, efficiency analysis</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_18.html">Demo 18</a> (braid logic gates: NOT and NAND discovery), <a href="./entries/demo_15.html">Demo 15</a> (delta-zero optimal angles)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_20.html">Demo 20</a> (braid error analysis)</li>
</ul>
<h3>Headline</h3>
Builds a complete boolean expression compiler that evaluates arbitrary logic circuits via recursive Kauffman bracket thresholding of braid gates, demonstrating a universal {NOT, NAND} gate set at the 8th root of unity (A = e^{i*5pi/4}) and compiling a full 1-bit adder that passes all 8 input combinations.
<h3>Key Results</h3>
<ul>
<li><strong>Root-of-unity catalog</strong> (Part A): tests NOT and NAND gates at 4th, 6th, 8th, 10th, 12th roots of unity. Multiple roots support universal gate sets. Establishes a hierarchy of gate-supporting angles.</li>
<li><strong>Universal set at 5pi/4</strong> (Part B): NOT (6-crossing, word: [-1,-1,-1,-1,-1,-1]) and NAND (5-crossing, word: [-1,-1,-1,2,2]) both work at convergence angle. Raw vs reduced bracket separation compared. Fallback angle sweep if 5pi/4 fails.</li>
<li><strong>Boolean compiler</strong> (Part C): expression tree with EXPR_VAR / EXPR_NOT / EXPR_NAND nodes. Derived gates: AND = NOT(NAND), OR = NAND(NOT,NOT), XOR = NAND(NAND(a,NAND(a,b)),NAND(b,NAND(a,b))). All truth tables verified for AND (4/4), OR (4/4), XOR (4/4).</li>
<li><strong>Full adder</strong> (Part D): sum = XOR(XOR(a,b), c_in), carry = OR(AND(a,b), AND(c_in, XOR(a,b))). All 8 input combinations correct. Reports gate counts per evaluation.</li>
<li><strong>Efficiency analysis</strong> (Part E): expression complexity (nodes/gates per operation), linear depth scaling verified (NOT chain), timing benchmarks, crossing count analysis (NOT=6, NAND=5, AND=11, XOR=15, full adder sum up to 30 crossings).</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Convergence thesis</strong>: the 8th root of unity (5pi/4) is where three phenomena align: <a href="./entries/demo_15.html">Demo 15</a>'s classification angles, <a href="./entries/demo_18.html">Demo 18</a>'s magic gate angles, and cyclotomic integer bracket values</li>
<li>Gate composition preserves correctness through cascade thresholding (each gate produces a classical bit that feeds as braid input to the next gate)</li>
<li>Gate count scales linearly with expression depth (verified with NOT chains of depth 1,2,4,8)</li>
</ul>
<h3>Data</h3>
<ul>
<li>NOT gate truth table: input=0 → high amplitude, input=1 → low amplitude (separation &gt; 0.001)</li>
<li>NAND gate truth table: (0,0),(0,1),(1,0) → high, (1,1) → low (separation &gt; 0.001)</li>
<li>Full adder: 8 input combinations, sum+carry gate counts, max gates per input</li>
<li>Timing: full adder evaluations in ms</li>
<li>Root-of-unity catalog: 5 root families x all angles, NOT/NAND working counts</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>Expression tree compiler</strong>: <code>Expr</code> type with <code>expr_var()</code>, <code>expr_not()</code>, <code>expr_nand()</code> constructors + derived <code>expr_and()</code>, <code>expr_or()</code>, <code>expr_xor()</code></li>
<li><strong>Arena-based expression pool</strong> (<code>EXPR_POOL_SIZE=1024</code>): simple allocation with <code>expr_pool_reset()</code> — no free needed</li>
<li><strong><code>eval_expr()</code></strong>: recursive evaluator that thresholds bracket amplitudes at each gate, tracks gate count and max depth</li>
<li><strong><code>expr_size()</code></strong>: counts total expression tree nodes</li>
<li><strong>Gate evaluation helpers</strong>: <code>gate_output()</code> (1-input), <code>gate_output_2bit()</code> (2-input), plus <code>_reduced</code> variants that divide by |delta|^k</li>
<li><strong><code>make_gate_braid()</code></strong>: concatenates input word + gate word into a single braid</li>
<li><strong><code>test_not_at_angle()</code> / <code>test_nand_at_angle()</code></strong>: evaluate gate separation at arbitrary angle, fill Gate struct with threshold/separation</li>
<li>Reuses: complex arithmetic, braid state-sum oracle, union-find</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Universality of {NOT, NAND} gate set for classical boolean logic</li>
<li>Roots of unity as algebraic sweet spots for Kauffman bracket evaluation</li>
<li>Cyclotomic integers and exact bracket values at roots of unity</li>
<li>Full adder circuit decomposition into primitive gates</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>How does gate fidelity degrade as circuit depth increases? (cascade thresholding error accumulation)</li>
<li>Can the compiler be extended to multi-bit operations (e.g., N-bit ripple-carry adder)?</li>
<li>Is there a more crossing-efficient XOR gate than the 3-NAND decomposition?</li>
<li>Does the convergence thesis hold for higher-strand braids (beyond 2-3 strands)?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_20.html">Demo 20</a>: Braid Error Landscape</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_20_braid_error/main.c.html">demo_20_braid_error/main.c</a></code> (~1017 lines)</li>
<li><strong>Tests</strong>: ~7 pass (5 parts: A=1 formula verification, B=2 smoothness+critical delta, C=1 cascade comparison, D=1 delta separation, E=2 transition+region)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_18.html">Demo 18</a>/19 (braid Boolean gates: NOT, NAND words; expression tree compiler; gate output evaluation)</li>
<li><strong>Feeds into</strong>: Understanding robustness of braid-based computation; noise tolerance bounds for DKC circuits</li>
</ul>
<h3>Headline</h3>
Maps the error landscape of braid-based Boolean logic as delta moves away from zero, discovering that |delta| = 2|cos(2*theta)| universally predicts gate viability, with smooth degradation and identifiable phase transition thresholds.
<h3>Key Results</h3>
<ul>
<li><strong>Part A (Delta landscape)</strong>: Analytical formula |delta| = 2|cos(2*theta)| verified across 360 angles; zeros at theta = pi/4, 3pi/4, 5pi/4, 7pi/4 (8th roots of unity — exactly the angles with NAND support from <a href="./entries/demo_19.html">Demo 19</a>); |delta| values tabulated for 4th, 6th, 8th, 10th, 12th roots of unity</li>
<li><strong>Part B (Single-gate error)</strong>: 200-point sweep +/- pi/4 around 5*pi/4 center; NOT separation and NAND separation tracked as functions of |delta|; critical |delta_c| found where NAND first fails; separation degrades smoothly (no jumps &gt; 2.0 between adjacent points)</li>
<li><strong>Part C (Cascade error — full adder)</strong>: Full adder (sum + carry via XOR, AND, OR composed from NAND/NOT) evaluated at each sweep angle; 8/8 truth table entries checked; cascade failure compared to single-gate failure; determines whether cascade amplifies error or not</li>
<li><strong>Part D (Universal delta curve)</strong>: Gates binned by |delta| ranges [0.0, 0.25), [0.25, 0.5), ..., [1.75, 2.0); average NOT/NAND separation and NAND correctness percentage per bin; roots of unity overlaid on universal curve; |delta| cleanly separates universal (NOT+NAND) from NOT-only angles</li>
<li><strong>Part E (Phase transition)</strong>: Finite differences of NAND separation near center; peak-to-average derivative ratio determines sharp vs gradual transition; contiguous "correct regions" (both NOT and NAND work) identified and bounded by theta and |delta|</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>delta = -2<em>cos(2</em>theta)</strong>: exact analytical formula, |delta| = 2|cos(2*theta)|</li>
<li>Delta-zero angles (8th roots of unity) are exactly where braid circuits compute exact Boolean logic</li>
<li>|delta| is a <strong>universal predictor</strong> of gate viability — cleanly separates universal-computation angles from NOT-only angles across different roots of unity</li>
<li>Separation degrades smoothly as |delta| increases (no sharp phase transition in the strict sense, but potentially concentrated derivative)</li>
</ul>
<h3>Data</h3>
<ul>
<li>360-angle delta landscape sweep (0 to 2*pi)</li>
<li>200-point fine sweep centered at 5*pi/4, range +/- pi/4</li>
<li>|delta| values at 4th, 6th, 8th, 10th, 12th roots of unity</li>
<li>8 |delta| bins with average NOT/NAND separation and correctness percentages</li>
<li>Full adder correctness (8 truth-table entries) at every 5th sweep point</li>
<li>Derivative analysis: peak vs average |d(sep)/di| for NOT and NAND</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>delta_abs_at(theta)</code> — computes |delta| = |-(A^2 + A^{-2})| at given angle</li>
<li><code>SweepPoint</code> struct: theta, delta_abs, not_sep, nand_sep, not_correct, nand_correct</li>
<li><code>make_gate_braid()</code> — constructs braid from input word + gate word</li>
<li><code>gate_output()</code> — 1-bit gate evaluation (amplitude of bracket)</li>
<li><code>gate_output_2bit()</code> — 2-bit gate evaluation</li>
<li><code>compute_thresholds()</code> — dynamic threshold computation (NOT and NAND) per angle</li>
<li>Expression tree compiler: <code>Expr</code> pool allocator, <code>expr_var/not/nand/and/or/xor</code> constructors, <code>eval_expr</code> recursive evaluator — full adder built from expression trees</li>
<li>NOT_WORD = {-1,-1,-1,-1,-1,-1} (len 6), NAND_WORD = {-1,-1,-1,2,2} (len 5)</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Error analysis of topological/braid-based computation</li>
<li>Phase transitions in computational gate fidelity</li>
<li>Robustness of topological quantum computation (analogy: delta=0 as topological protection)</li>
<li>Universal vs non-universal gate sets parameterized by algebraic structure</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>What is the precise critical |delta_c| where NAND fails? Is it a root of a known polynomial?</li>
<li>Does cascade error amplify linearly or exponentially with circuit depth?</li>
<li>Can error correction schemes exploit the smooth degradation profile?</li>
<li>Is there an analogue of fault-tolerance threshold for braid circuits away from delta=0?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_21.html">Demo 21</a>: Reversible Gates</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_21_reversible_gates/main.c.html">demo_21_reversible_gates/main.c</a></code> (~858 lines)</li>
<li><strong>Tests</strong>: 6/6 pass (expected)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_18.html">Demos 18</a>-<a href="./entries/demo_20.html">20</a> (complex arithmetic, state-sum bracket, expression tree compiler with NOT/NAND gates), <a href="./entries/demo_10.html">Demo 10</a>-<a href="./entries/demo_13.html">13</a> (braid bracket oracle)</li>
<li><strong>Feeds into</strong>: Further reversible/quantum circuit exploration; multi-readout closure technique potentially novel</li>
</ul>
<h3>Headline</h3>
Implements Toffoli and Fredkin reversible gates via expression-compiled braid-bracket computation, explores multi-readout from different strand closures, and verifies involutory composition (double-application = identity).
<h3>Key Results</h3>
<ul>
<li><strong>Toffoli gate</strong>: C' = XOR(C, AND(A,B)) compiled from NAND/NOT expression trees, all 8 truth table entries correct</li>
<li><strong>Fredkin gate</strong>: conditional swap via MUX(sel, a, b) = NAND(NAND(sel,a), NAND(NOT(sel),b)), all 8 truth table entries correct for both outputs</li>
<li><strong>Multi-readout exploration</strong>: different strand closures (trace, plat-A, plat-B, plat-C) on the same 4-strand braid yield different Boolean functions; searched all braids of length 1-4 over 6 generators</li>
<li><strong>Reversible composition verified</strong>: double-Toffoli and double-Fredkin both return identity (8/8 correct), confirming involutory property survives expression-compiled bracket evaluation</li>
<li><strong>Efficiency</strong>: expression-compiled Toffoli uses fewer total crossings than Bonesteel et al.'s A5 coloured-braid approach (~132 crossings), though comparison is not apples-to-apples (classical bits via multiple bracket evals vs single quantum unitary)</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Multi-readout conjecture</strong>: OBSERVED — a single braid word can produce multiple distinct Boolean functions under different closure types, suggesting closure choice is an additional computational resource</li>
<li><strong>Involutory preservation</strong>: PROVEN (numerically) — the involutory property of Toffoli and Fredkin gates is preserved through expression-compiled braid-bracket evaluation</li>
<li><strong>Crossing efficiency</strong>: OBSERVED — expression-compiled approach achieves Toffoli in fewer total crossings than A5 coloured-braid method, though architecturally different (multiple classical bracket evals vs single quantum gate)</li>
</ul>
<h3>Data</h3>
<ul>
<li>Toffoli truth table: all 8/8 correct at A = e^{i*5pi/4}</li>
<li>Fredkin truth table: all 8/8 correct at A = e^{i*5pi/4}</li>
<li>NOT braid word: [-1, -1, -1, -1, -1, -1] (6 crossings), NAND word: [-1, -1, -1, 2, 2] (5 crossings)</li>
<li>Multi-readout search space: lengths 1-4 over 6 generators ({1,-1,2,-2,3,-3}) on 4-strand braids</li>
<li>Target truth tables: Toffoli C' = 0x??, Fredkin B' = 0x??, Fredkin C' = 0x??, AND = 0x??, OR = 0x??, XOR = 0x??</li>
<li>Bonesteel et al. A5 Toffoli benchmark: ~132 crossings</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>bracket_cl()</code> — state-sum bracket with configurable closure type (trace, plat-A/B/C), reusable for multi-readout experiments</li>
<li><code>Closure</code> enum and <code>braid_loops_cl()</code> — generalized loop counting for 4 closure types on n-strand braids</li>
<li><code>emux()</code> — MUX expression node for Fredkin construction: MUX(sel, a, b) = NAND(NAND(sel,a), NAND(NOT(sel),b))</li>
<li>Expression tree compiler with gate evaluation counters (<code>cnt_not</code>, <code>cnt_nand</code>) for efficiency analysis</li>
<li><code>decode_word()</code> — braid word enumeration over generator alphabet for exhaustive search</li>
<li><code>make_gate()</code> — constructs braid from input-encoding prefix + gate word, bridging Boolean inputs to braid topology</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Bonesteel et al. — A5 coloured-braid approach to Toffoli (~132 crossings)</li>
<li>Toffoli gate: C' = C XOR (A AND B), self-inverse</li>
<li>Fredkin gate: conditional swap, self-inverse</li>
<li>Multi-readout via different closures appears to be a novel direction (no literature reference cited)</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Can multi-readout provide both Toffoli outputs (passthrough + nontrivial) from a single braid, achieving "true" reversible gates without expression compilation?</li>
<li>What is the maximum number of distinct Boolean functions achievable from one braid across all closure types?</li>
<li>Can memoization of shared sub-expressions reduce the crossing count further?</li>
<li>Is there a systematic relationship between closure type and the Boolean function it extracts?</li>
<li>How does the multi-readout approach scale to higher-strand braids with more closure options?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_22.html">Demo 22</a>: Minimum Braid Complexity</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_22_braid_optimizer/main.c.html">demo_22_braid_optimizer/main.c</a></code> (~976 lines)</li>
<li><strong>Tests</strong>: ~6 pass (P1: &gt;=80 functions found, P2: TL_3 braid relation, P3: cross-validation, P4: nilpotent compression, P5: braid &lt; NAND cost, P6: extended search)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_21.html">Demo 21</a> (reversible gates, closure types), <a href="./entries/demo_23.html">Demo 23</a> (function zoo, truth table computation)</li>
<li><strong>Feeds into</strong>: establishes "atomic weights" for topological computation; periodic table of braid-computable functions</li>
</ul>
<h3>Headline</h3>
Exhaustive search for minimum-length braid words computing each Boolean function on 3 inputs — the "periodic table of topological computation" — with TL_3 nilpotent oracle proving algebraic compression at delta=0.
<h3>Key Results</h3>
<ul>
<li><strong>Part A</strong>: Atlas of minimum braid lengths for all achievable 3-input Boolean functions (4-strand braids, lengths 1-5, 4 closure types), &gt;=80 functions found</li>
<li><strong>Part B</strong>: TL_3 algebra at delta=0 (A=e^{i<em>pi/4}) verified — nilpotency (e_i^2=0), braid relation, TL relation (e1</em>e2*e1=e1); cross-validation shows matrix equality implies bracket equality with zero errors; distinct TL_3 matrices grow slower than 4^k (compression factor at length 6)</li>
<li><strong>Part C</strong>: Parity barrier investigation — some XOR-containing functions missing at short lengths; braid weight beats NAND expression cost for multiple functions</li>
<li><strong>Part D</strong>: Extended search at length 6 (trace closure, 46656 braids) discovers additional functions; targets include XOR, triple XOR, Toffoli C', MUX/Fredkin, MAJ</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li>VERIFIED: TL_3 nilpotent algebra (delta=0): e_i^2 = 0, e1<em>e2</em>e1 = e1, braid relation holds in 5x5 representation</li>
<li>VERIFIED: Matrix equality in TL_3 implies bracket equality (zero cross-validation errors across all length-3 B_3 word pairs)</li>
<li>VERIFIED: Nilpotent compression — distinct TL_3 matrices grow strictly slower than 4^k (many algebraically distinct braids collapse to same TL element)</li>
<li>CONFIRMED: Braid weight &lt; NAND expression cost for multiple named functions (topological computation is more efficient than gate-tree evaluation)</li>
<li>OBSERVED: Partial parity barrier — some XOR-family functions missing at short lengths (investigated but not fully resolved)</li>
</ul>
<h3>Data</h3>
<ul>
<li>Atlas: 254 possible non-trivial 3-input truth tables; &gt;=80 achieved at lengths 1-5</li>
<li>Named functions tracked: A, ~A, B, ~B, C, ~C, A&amp;B, A|B, ~(A&amp;B), A^B, A XNOR B, MAJ, MUX, Toffoli C', A^B^C, etc.</li>
<li>NAND cost reference: identity=0, NOT=6, NAND=5, AND=11, OR=17, XOR=25, Toffoli C'=58, MUX=21</li>
<li>TL_3 distinct matrix counts per length: subexponential growth vs 4^k naive</li>
<li>Search spaces: 6^k for 4-strand (6 generators), 4^k for 3-strand (4 generators)</li>
<li>Evaluation angle: A = e^{i<em>5</em>pi/4} (delta=0 for TL_3 oracle at pi/4)</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>atlas_min_len[256]</code>, <code>atlas_word[256]</code>, <code>atlas_closure[256]</code>: minimum-complexity atlas for all truth tables</li>
<li><code>compute_tt()</code>: evaluates 4-strand braid with 3-bit input encoding, finds best-threshold truth table from amplitude sorting</li>
<li><code>decode_word4()</code> / <code>decode_word3()</code>: enumerates braid words from integer codes (base-6 for 4-strand, base-4 for 3-strand)</li>
<li><code>fn_name()</code>: lookup table mapping truth table integers to named Boolean functions (~38 entries)</li>
<li><code>tt_has_parity()</code>: classifies whether a truth table involves XOR/parity</li>
<li><code>nand_cost()</code>: NAND tree expression cost for named functions (from <a href="./entries/demo_21.html">Demo 21</a> analysis)</li>
<li><code>Mat5</code> type: 5x5 complex matrix for TL_3 representation with <code>mat5_zero/id/scale/add/mul/eq</code></li>
<li><code>tl3_init()</code>: builds TL_3 generator matrices (e1, e2) and sigma matrices at given A</li>
<li><code>tl3_braid_matrix()</code>: evaluates braid word as TL_3 matrix product</li>
<li><code>bracket_cl()</code>: state-sum bracket with closure support (trace, plat_A, plat_B, plat_C)</li>
<li><code>braid_loops_cl()</code>: loop counting with 4 closure types</li>
<li><code>Closure</code> enum: CL_TRACE, CL_PLAT_A, CL_PLAT_B, CL_PLAT_C</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Temperley-Lieb algebra TL_n at delta=0 (nilpotent regime)</li>
<li>Catalan number C_3 = 5 as TL_3 dimension</li>
<li>Braid group B_3 representation theory</li>
<li>Shannon/NAND circuit complexity comparison</li>
<li>Parity barrier in threshold logic (XOR as canonical hard function)</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Is the parity barrier fundamental (algebraic) or just a length limitation? Do parity functions appear at length 7+?</li>
<li>Can the TL_3 oracle be used to prune search space for the 4-strand atlas? (collapse equivalent braids before bracket evaluation)</li>
<li>What is the asymptotic growth rate of distinct TL_3 matrices? (appears subexponential but not fully characterized)</li>
<li>Relationship between closure type and function achievability — which closures are most "powerful"?</li>
<li>Can connected-sum operations on braids compose functions algebraically?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_23.html">Demo 23</a>: Function Zoo</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_23_function_zoo/main.c.html">demo_23_function_zoo/main.c</a></code> (~771 lines)</li>
<li><strong>Tests</strong>: 4 checks across 4 parts (A-D): exhaustive catalog, NPN classification, closure tuple analysis, extended search</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_21.html">Demo 21</a> (bracket with closure support, Toffoli/Fredkin targets), <a href="./entries/demo_18.html">Demo 18</a> (braid logic gates, 5pi/4 angle)</li>
<li><strong>Feeds into</strong>: Later demos exploring which NPN classes topology can/cannot reach</li>
</ul>
<h3>Headline</h3>
Exhaustive enumeration of which 3-input Boolean functions topology "prefers": catalogs all 4-strand braids of length 1-5 across 4 closure types, classifies by NPN equivalence, analyzes how closure choice multiplies function diversity, and searches for specific target functions (Toffoli, Fredkin).
<h3>Key Results</h3>
<ul>
<li><strong>Exhaustive catalog</strong> (Part A): all 6^1 + 6^2 + 6^3 + 6^4 = 1554 braids of length 1-4, each evaluated with 4 closures (trace, plat_A, plat_B, plat_C) at A = e^{i*5pi/4}. Reports distinct non-trivial truth tables found out of 254 possible. Top 20 most common functions listed with hex, binary, count, name, NPN class.</li>
<li><strong>NPN classification</strong> (Part B): maps all found truth tables to their NPN canonical form (minimum under negation of inputs + permutation + negation of output). Reports how many of the total 3-variable NPN classes are reached by topology.</li>
<li><strong>Closure tuple analysis</strong> (Part C): each braid produces a 4-tuple of truth tables (one per closure). Finds that ~80%+ of braids are closure-dependent (different closures yield different functions). Counts braids with all 4 TTs distinct, and braids with permutation-related TT pairs. Per-closure function diversity reported.</li>
<li><strong>Extended search</strong> (Part D): length-5 braids (6^5 = 7776 words). Reports new functions and new NPN classes not seen at lengths 1-4. Specifically tracks Toffoli C' (0x6A), Fredkin B' (0xAC), Fredkin C' (0xCA) hit counts.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li>Topology has strong preferences: certain Boolean functions appear far more often than others in the braid→bracket→threshold pipeline</li>
<li>Closure is a major degree of freedom — different closures of the same braid typically yield different Boolean functions (≥80% closure-dependent)</li>
<li>Longer braids unlock new NPN classes, suggesting the function zoo grows with braid length</li>
</ul>
<h3>Data</h3>
<ul>
<li>3-input Boolean functions: 256 truth tables (0x00-0xFF), 254 non-trivial</li>
<li>Generator alphabet: {σ₁, σ₁⁻¹, σ₂, σ₂⁻¹, σ₃, σ₃⁻¹} (6 generators for 4-strand braids)</li>
<li>Braid lengths searched: 1-4 (Part A, 1554 braids) + 5 (Part D, 7776 braids)</li>
<li>4 closure types: trace (strand i top↔bottom), plat_A ((0,1)(2,3)), plat_B ((0,2)(1,3)), plat_C ((0,3)(1,2))</li>
<li>NPN classification: 96 transforms per truth table (6 perms × 8 input-neg masks × 2 output-neg)</li>
<li>Up to 10,000 braid tuples stored for closure analysis</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>NPN equivalence engine</strong>: <code>npn_transform()</code> applies permutation + input negation + output negation; <code>npn_init()</code> precomputes canonical form for all 256 truth tables; <code>are_perm_related()</code> checks input-permutation equivalence</li>
<li><strong><code>compute_tt()</code></strong>: given a braid word + closure + angle, evaluates all 8 input combinations, sorts amplitudes, finds best-gap threshold, returns truth table (or -1 if no clean threshold)</li>
<li><strong><code>decode_word()</code></strong>: converts integer code to braid word using generator map {1,-1,2,-2,3,-3}</li>
<li><strong><code>fn_name()</code></strong>: lookup table mapping ~40 common truth tables to human-readable names (AND, OR, XOR, MUX, MAJ, Toffoli, etc.)</li>
<li><strong><code>bracket_cl()</code></strong>: state-sum Kauffman bracket with closure support (trace, plat_A/B/C) — from <a href="./entries/demo_21.html">Demo 21</a></li>
<li><strong><code>braid_loops_cl()</code></strong>: union-find loop counter with 4 closure types</li>
<li>Per-braid tuple storage for closure analysis (up to 10,000 braids × 4 closures)</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>NPN equivalence classes for Boolean functions (standard combinatorics: 3-variable has a known number of classes)</li>
<li>Toffoli gate and Fredkin gate as target reversible/classical universal functions</li>
<li>Plat closure vs trace closure in knot theory</li>
<li>Connection between braid topology and Boolean function reachability</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Which NPN classes are topologically unreachable, and is there an algebraic reason?</li>
<li>Does the function distribution stabilize at some braid length, or do new classes keep appearing?</li>
<li>Is there a relationship between braid complexity (crossing number) and the "computational complexity" of the realized Boolean function?</li>
<li>Can closure choice be understood as a form of input/output routing that systematically permutes the truth table?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_24.html">Demo 24</a>: Rational Tangle Arithmetic</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_24_rational_tangles/main.c.html">demo_24_rational_tangles/main.c</a></code> (~890 lines)</li>
<li><strong>Tests</strong>: ~7 pass (5 parts: A=2 alpha/beta formula + state-sum, B=1 multiplicativity, C=2 CF assembly + fraction tracking, D=1 angle correlation, E=1 Fibonacci analysis)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_03.html">Demo 03</a>-<a href="./entries/demo_04.html">04</a> (bracket, TL algebra concepts), <a href="./entries/demo_18.html">Demo 18</a>-<a href="./entries/demo_19.html">19</a> (delta=0 insights)</li>
<li><strong>Feeds into</strong>: Understanding bracket-rational correspondence; continued fraction approaches to tangle classification</li>
</ul>
<h3>Headline</h3>
Implements Conway's rational tangle arithmetic in the Temperley-Lieb algebra TL_2, proving that at delta=0 the bracket polynomial literally counts twists (|D(n)| = n) and that continued fraction assembly builds rational tangles whose bracket values track p/q.
<h3>Key Results</h3>
<ul>
<li><strong>Part A (Integer tangles)</strong>: n-twist tangles verified for n=0..20 at delta=0; alpha_n = A^n, beta_n = n*A^{n-2} confirmed; |D(n)| = n (denominator closure magnitude equals twist count); state-sum oracle cross-check matches TL2 algebra for n=1..10</li>
<li><strong>Part B (Twist analysis)</strong>: Twist is a linear/multiplicative map on (alpha, beta) space; alpha ratio is constant A; beta_n/n = A^{n-2}; matrix form at delta=0: [[A, 0], [A^{-1}, A]]</li>
<li><strong>Part C (Continued fractions)</strong>: 14 test rationals (0/1 through 7/11) built from continued fraction assembly; |D|/|N| ratio compared to p/q; partial convergent tracking shown for 8/13 = [0;1,1,1,1,2]; majority of test cases have |D|/|N| tracking p/q</li>
<li><strong>Part D (Angle sweep)</strong>: 256-angle sweep computing Pearson correlation between |D|/|N| and p/q for 12 test rationals; best angle found (may or may not be delta=0); bracket values compared at best angle vs delta=0</li>
<li><strong>Part E (Fibonacci tangles)</strong>: CF = [0;1,1,...,1] (all 1s) for k=1..12; these converge to F(k)/F(k+1) → 1/phi; |D| growth ratio tested for convergence to golden ratio (~1.618)</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Conway's theorem</strong>: Twist (T(r) = r+1) and Rotate (R(r) = -1/r) generate all rationals on 2-strand tangles</li>
<li>At delta=0: N(T) = alpha, D(T) = beta (closures simplify)</li>
<li>Integer n-twist: alpha_n = A^n, beta_n = n*A^{n-2}, so |D(n)| = n — <strong>the bracket counts twists</strong></li>
<li>Rotation swaps alpha and beta — corresponds to R(r) = -1/r in tangle arithmetic</li>
<li>Twist recurrence at delta=0: alpha' = A<em>alpha, beta' = A^{-1}</em>alpha + A*beta (upper-triangular structure)</li>
</ul>
<h3>Data</h3>
<ul>
<li>21 integer tangles (n=0..20) with alpha, beta, |N|, |D| at delta=0</li>
<li>14 test rationals with continued fractions and closure magnitudes</li>
<li>Partial convergent tracking for 8/13 (6 steps)</li>
<li>256-angle sweep with Pearson correlation</li>
<li>12 Fibonacci tangles (k=1..12) with |D| growth ratios</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>TL2</code> struct (alpha, beta pair in TL_2 basis {1, e1})</li>
<li><code>tl2_identity()</code>, <code>tl2_twist_pos()</code>, <code>tl2_twist_neg()</code>, <code>tl2_twist_n()</code> — tangle construction by twisting</li>
<li><code>tl2_rotate()</code> — 90-degree rotation (swaps alpha/beta)</li>
<li><code>tl2_num_closure()</code>, <code>tl2_den_closure()</code> — numerator and denominator closures</li>
<li><code>cf_to_double()</code> — evaluate continued fraction as floating-point</li>
<li><code>fraction_to_cf()</code> — convert p/q to continued fraction via Euclidean algorithm</li>
<li><code>tangle_from_cf()</code> — inside-out assembly of rational tangle from continued fraction</li>
<li><code>braid_loops_closure()</code> — state-sum loop counting with selectable closure type (numerator vs denominator)</li>
<li><code>braid_bracket_closure()</code> — state-sum bracket with closure type for verification</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Conway's rational tangle theory</li>
<li>Temperley-Lieb algebra TL_2 (2-strand basis {1, e1})</li>
<li>Continued fractions as tangle assembly programs</li>
<li>Kauffman bracket of tangles (numerator/denominator closures)</li>
<li>Fibonacci numbers and golden ratio in tangle sequences</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Does exact |D|/|N| = p/q hold with a different normalization/closure convention?</li>
<li>What is the best angle (beyond delta=0) for rational tracking, and why?</li>
<li>How does this extend to 3-strand tangles and non-rational tangles?</li>
<li>Connection to the fraction group (PSL(2,Z)) action on tangles?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_25.html">Demo 25</a>: Closure Measurement Matrices</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_25_closure_measurement/main.c.html">demo_25_closure_measurement/main.c</a></code> (~908 lines)</li>
<li><strong>Tests</strong>: 8/8 pass (expected)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_21.html">Demo 21</a>/23 (closure types, bracket_cl, multi-readout, braid enumeration), <a href="./entries/demo_18.html">Demo 18</a>-<a href="./entries/demo_20.html">20</a> (expression compiler, complex arithmetic)</li>
<li><strong>Feeds into</strong>: Deeper analysis of closure-as-measurement-basis framework; parity barrier understanding; subspace dimension studies</li>
</ul>
<h3>Headline</h3>
Formalizes the "closure = measurement basis" idea by computing 4x8 amplitude matrices M[closure][input] for all 4-strand braids of length 1-4, then analyzes rank structure, inter-closure mutual information, Hamming weight organization, parity barriers, and per-closure subspace dimensions.
<h3>Key Results</h3>
<ul>
<li><strong>1554 measurement matrices</strong> computed (4 closures x 8 inputs each), covering all 4-strand braids of lengths 1-4 over 6 generators</li>
<li><strong>Universal full rank</strong>: ALL 1554 braids have rank 4 — the 4 closures are always linearly independent as amplitude vectors over 8 inputs. Original prediction of low-rank at short lengths was falsified; this is a stronger finding.</li>
<li><strong>Hard constraints on quadruples</strong>: only a tiny fraction of possible truth-table quadruples (closure0, closure1, closure2, closure3) are achievable — far fewer than 10,000 distinct out of 4.3 billion possible</li>
<li><strong>Trace closure is richest</strong>: trace produces more than 2x the distinct Boolean functions compared to plat_A</li>
<li><strong>Mutual information between closure pairs</strong>: computed for all 6 pairs; at least one pair has MI &lt; 2.0 bits, indicating partial complementarity</li>
<li><strong>Hamming weight is a strong organizer</strong>: ANOVA F-ratio &gt; 0.3, confirming Hamming weight of the 3-bit input explains significant variance in amplitude</li>
<li><strong>Parity barrier confirmed</strong>: the parity function (XOR of all 3 inputs, truth tables 0x96/0x69) was found ZERO times across all braids and closures — parity is unreachable via bracket amplitudes</li>
<li><strong>Per-closure subspace dimensions</strong> computed via 8x8 covariance eigendecomposition (Jacobi method)</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>P13 (Universal full rank)</strong>: CONFIRMED — all 1554 braids have measurement matrix rank 4; 4 closures always linearly independent</li>
<li><strong>P1 (Hard constraints)</strong>: CONFIRMED — the achievable truth-table quadruples are a tiny fraction of the combinatorial space</li>
<li><strong>P2 (Complementary pair)</strong>: CONFIRMED (relaxed) — at least one closure pair has MI &lt; 2.0 bits</li>
<li><strong>P14 (Trace richness)</strong>: CONFIRMED — trace closure produces &gt;2x the distinct functions of plat_A</li>
<li><strong>P8 (Hamming weight structure)</strong>: CONFIRMED — F-ratio &gt; 0.3 showing HW explains amplitude variance</li>
<li><strong>P6 (Parity barrier)</strong>: CONFIRMED — parity function (0x96, 0x69) found 0 times; unreachable in this framework</li>
<li><strong>P9 (Rank saturation)</strong>: CONFIRMED — max rank reaches 4 by length 4</li>
</ul>
<h3>Data</h3>
<ul>
<li>1554 braids total: 6 (len 1) + 36 (len 2) + 216 (len 3) + 1296 (len 4)</li>
<li>Total amplitude entries: 1554 x 32 = 49,728</li>
<li>Rank distribution: 100% rank 4</li>
<li>Evaluation angle: A = e^{i*5pi/4}</li>
<li>4 closure types: trace, plat_A (01|23), plat_B (02|13), plat_C (03|12)</li>
<li>8 inputs: 3-bit Boolean (ABC) encoded as braid generators sigma_1, sigma_2, sigma_3</li>
<li>Parity function appearances: 0</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>MeasMatrix</code> struct: stores 4x8 amplitude matrix + 4 thresholded truth tables + braid word for each braid</li>
<li><code>compute_meas_matrix()</code>: computes full measurement matrix for one braid word across all closures and inputs, with automatic truth-table thresholding via largest-gap method</li>
<li><code>svd_4x8()</code>: SVD of 4x8 matrix via M*M^T eigendecomposition — returns singular values and rank</li>
<li><code>sym4x4_eigenvalues()</code>: Jacobi eigenvalue algorithm for 4x4 symmetric matrices (reusable)</li>
<li>8x8 Jacobi eigenvalue solver (inline in Part E, for covariance matrix analysis)</li>
<li>Mutual information computation between closure pairs using joint/marginal frequency tables</li>
<li>ANOVA (between/within class variance) for Hamming weight grouping of amplitudes</li>
<li><code>decode_word()</code> and <code>gen_map[]</code>: exhaustive braid word enumeration over 6 generators</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Closure as measurement basis (quantum measurement analogy)</li>
<li>Parity function unreachability — related to linear algebra limitations of bracket amplitudes</li>
<li>Hamming weight as organizing principle for Boolean function complexity</li>
<li>SVD / principal component analysis for understanding amplitude space structure</li>
<li>Mutual information for quantifying closure pair independence/complementarity</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Why is rank universally 4? Is there a topological proof that 4 closures on 4-strand braids must always be linearly independent?</li>
<li>What determines which truth-table quadruples are achievable? Can the constraint structure be characterized algebraically?</li>
<li>The parity barrier — is this a fundamental limitation of bracket amplitudes, or could it be overcome with more strands/closures?</li>
<li>How do subspace dimensions vary across closures, and what does this mean for the expressiveness of each closure type?</li>
<li>Can the MI analysis guide selection of optimal closure pairs for multi-readout gate design?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_26.html">Demo 26</a>: Reverse DKC</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_26_reverse_dkc/main.c.html">demo_26_reverse_dkc/main.c</a></code> (~1311 lines)</li>
<li><strong>Tests</strong>: 8/8 pass (inline check() assertions)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_13.html">Demo 13</a> (forward DKC greedy angle), <a href="./entries/demo_19.html">Demo 19</a> (bracket oracle, braid gates, XOR circuit), <a href="./entries/demo_24.html">Demo 24</a> (bracket amplitude integer structure)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_27.html">Demo 27</a>+ (DKC research arc continues), <a href="./entries/demo_45.html">Demo 45</a>-<a href="./entries/demo_50.html">50</a> (deeper DKC investigations)</li>
</ul>
<h3>Headline</h3>
Tests whether trained neural network weights can be reverse-decomposed into Kauffman bracket amplitudes, probing the reverse direction of the DKC (Deep Knot Correspondence) thesis.
<h3>Key Results</h3>
<ul>
<li>Weight-level decomposition partially succeeds: some trained XOR weights land near bracket amplitudes, but the signal is weak because at delta=0, bracket amplitudes ARE integers — so any real number is at most 0.5 away from a catalog entry</li>
<li>Random baseline comparison included: trained weights only modestly outperform random weights in decomposition quality</li>
<li>Function-level equivalence trivially holds: both braid XOR circuit and trained NN compute XOR correctly, but by completely different mechanisms (bracket thresholds vs sigmoid cascades)</li>
<li>Angle sweep (Part F) tests whether delta=0 (8th root of unity) is optimal for decomposition — checks P2 prediction</li>
<li>Syndrome analysis (Part G) classifies residual structure as UNIFORM/STRUCTURED/RANDOM across seeds</li>
<li>4-4-1 scaling test on 2-bit adder carry shows decomposition quality at larger network scale (25 params)</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>P1</strong>: Weight decomposition partially succeeds — CONFIRMED (some close matches, but confounded by integer amplitude structure)</li>
<li><strong>P2</strong>: Best-matching angle near 8th root (delta~0) — TESTED via angle sweep across 8 angles</li>
<li><strong>P3</strong>: Harder tasks need higher-strand braids — TESTED (4-4-1 adder vs 2-2-1 XOR comparison)</li>
<li><strong>P4</strong>: Decomposition error correlates with generalization gap — NOT directly tested (both tasks fully converge)</li>
<li><strong>P5</strong>: Function-level equivalence even when weight-level fails — CONFIRMED trivially (both compute XOR)</li>
<li><strong>P6</strong>: Residuals may show rational tangle structure — TESTED via syndrome analysis (residual patterns characterized)</li>
</ul>
<h3>Data</h3>
<ul>
<li>10 random seeds for XOR training, &gt;=3 converge (20000 epochs, lr=2.0, sigmoid activation)</li>
<li>Bracket catalog: all 2-strand braids length 1-8 (510 total) + 3-strand braids length 1-6 (5460 total), yielding &gt;10 distinct amplitudes</li>
<li>Critical observation: at delta=0, bracket amplitudes are consecutive integers (consistent with <a href="./entries/demo_24.html">Demo 24</a>)</li>
<li>8 angles tested in sweep: 5pi/4, pi/4, pi/3, pi/2, 2pi/5, pi/6, 1.805pi, 0.75pi</li>
<li>2-bit adder carry: 16 patterns, 4-4-1 network, 25 parameters, 50000 epochs</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li>Complete backprop implementation for 2-2-1 and 4-4-1 sigmoid networks (pure C89, no dependencies)</li>
<li>Bracket amplitude catalog builder with deduplication and binary search</li>
<li>Weight-to-bracket decomposition with RMS error and random baseline comparison</li>
<li>Braid XOR circuit evaluation reused from <a href="./entries/demo_19.html">Demo 19</a></li>
<li>Reproducible LCG random number generator</li>
<li>Syndrome classifier for residual analysis (uniform/structured/random)</li>
<li>Complex arithmetic library (reused from <a href="./entries/demo_19.html">Demo 19</a>)</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Kauffman bracket polynomial (state-sum model)</li>
<li>Neural network / knot theory correspondence (DKC thesis — project-internal)</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Is the integer structure of bracket amplitudes at delta=0 a fundamental obstruction to weight-level decomposition, or a feature that should be exploited differently?</li>
<li>Would a different decomposition strategy (e.g., weight ratios, weight products) show stronger bracket correspondence than absolute values?</li>
<li>The function-level match is trivial — is there a deeper functional correspondence beyond "both compute XOR"?</li>
<li>Does the syndrome analysis reveal any consistent pattern across seeds that could point to a topological invariant?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_27.html">Demo 27</a>: Complex-Valued Reverse DKC</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_27_complex_reverse_dkc/main.c.html">demo_27_complex_reverse_dkc/main.c</a></code> (~1049 lines)</li>
<li><strong>Tests</strong>: ~7 pass (P1: complex neuron solves XOR, P2: bracket values are cyclotomic, P3: complex catalog has more distinct values than amplitude-only, P4: gauge-corrected complex RMS &lt; 0.1, P5: complex RMS better than amplitude RMS, P6: complex matching reduces degeneracy, P7: complex (6 params) beats real (9 params), P8: complex RMS improves on <a href="./entries/demo_26.html">Demo 26</a> reference)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_26.html">Demo 26</a> (real-valued reverse DKC, amplitude-only matching, RMS=0.2641 reference), <a href="./entries/demo_10.html">Demo 10</a> (unit-circle bracket evaluation, complex arithmetic)</li>
<li><strong>Feeds into</strong>: establishes that complex bracket VALUES (not just amplitudes) match trained NN weights; cyclotomic Z[zeta_8] structure; U(1) gauge symmetry in weight-bracket correspondence</li>
</ul>
<h3>Headline</h3>
Complex-valued neural network (single complex neuron with split-sigmoid) solves XOR with 6 real parameters where real networks need 9, and gauge-corrected complex bracket matching outperforms <a href="./entries/demo_26.html">Demo 26</a>'s amplitude-only decomposition — proving phase carries computational information discarded by the Born-rule projection.
<h3>Key Results</h3>
<ul>
<li><strong>Part A</strong>: Single complex neuron (Nitta architecture) with split-sigmoid solves XOR; convergence rate tracked across 20 trials; 6 real parameters (w1, w2, b each complex) vs 9 for real 2-2-1 network</li>
<li><strong>Part B</strong>: Complex bracket catalog at A = e^{i<em>5</em>pi/4} (delta=0); distinct complex values exceed distinct amplitudes (constellation expansion); majority of values near Z[zeta_8] or Z[i] cyclotomic lattice; degeneracy reduction from amplitude to complex measured</li>
<li><strong>Part C</strong>: Complex decomposition with U(1) gauge correction — 360-angle sweep finds optimal rotation aligning weights to bracket values; gauge-corrected RMS &lt; 0.1 (beats <a href="./entries/demo_26.html">Demo 26</a>'s 0.2641)</li>
<li><strong>Part D</strong>: Phase distribution across 8 sectors (45-degree bins matching 8th roots of unity); phase-writhe correlation for first 20 braids; phases are structured (non-uniform)</li>
<li><strong>Part E</strong>: Degeneracy test — complex matching dramatically reduces ambiguity vs amplitude-only (fewer braids match each weight within tolerance)</li>
<li><strong>Part F</strong>: Head-to-head: complex neuron (6 params, gauge-corrected) beats real 2-2-1 (9 params, amplitude-only) on bracket decomposition RMS</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li>CONFIRMED: Single complex neuron with split-sigmoid solves XOR (Nitta 2003 result reproduced)</li>
<li>CONFIRMED: Bracket values at A = e^{i<em>5</em>pi/4} are cyclotomic integers in Z[zeta_8] (coordinates are multiples of 1/sqrt(2) or integers)</li>
<li>CONFIRMED: Complex bracket catalog contains strictly more distinct values than amplitude-only catalog (constellation expansion)</li>
<li>CONFIRMED: U(1) gauge symmetry — global phase rotation of all weights preserves network function; optimal gauge angle aligns weights to bracket lattice</li>
<li>CONFIRMED: Complex matching reduces degeneracy vs amplitude-only (phase information discriminates between braids sharing the same amplitude)</li>
<li>CONFIRMED: Complex (6 params) outperforms real (9 params) on bracket decomposition — fewer parameters, better RMS</li>
<li>KEY INSIGHT: <a href="./entries/demo_26.html">Demo 26</a>'s amplitude-only matching is a Born-rule projection (C -&gt; R&gt;=0) that discards phase; phase carries computational information</li>
</ul>
<h3>Data</h3>
<ul>
<li>Complex neuron: w1, w2 complex weights + b complex bias = 6 real parameters</li>
<li>20 training trials with deterministic RNG seeds</li>
<li>Bracket catalog: 2-3 strand braids up to length 8 at A = e^{i<em>5</em>pi/4}, up to 8192 entries</li>
<li>Amplitude threshold: &gt; 0.5 for catalog inclusion</li>
<li>Distinct values: complex count &gt; amplitude count (constellation expansion factor reported)</li>
<li>Cyclotomic lattice test: majority near Z[zeta_8] (tolerance 0.01 on scaled coordinates)</li>
<li>U(1) gauge sweep: 360 angles, best angle and RMS reported</li>
<li>Degeneracy: tolerance 0.5 for matching radius</li>
<li>Real 2-2-1 reference: 9 parameters, amplitude-only RMS</li>
<li><a href="./entries/demo_26.html">Demo 26</a> reference: RMS = 0.2641</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>Cx</code> type: complex arithmetic (<code>cx_make</code>, <code>cx_add</code>, <code>cx_sub</code>, <code>cx_mul</code>, <code>cx_div</code>, <code>cx_abs</code>, <code>cx_phase</code>, <code>cx_exp_i</code>, <code>cx_scale</code>, <code>cx_pow_int</code>, <code>cx_neg</code>)</li>
<li><code>CxNeuron</code> struct: single complex neuron (w1, w2, b), <code>cx_neuron_init()</code>, <code>cx_neuron_forward()</code>, <code>cx_neuron_xor_output()</code>, <code>cx_neuron_predict()</code>, <code>cx_neuron_train_xor()</code> with full backprop</li>
<li><code>cx_sigmoid()</code>: split-sigmoid activation (sigmoid applied independently to Re and Im)</li>
<li>Smooth XOR decision: <code>p = h.re<em>(1-h.im) + (1-h.re)</em>h.im</code></li>
<li><code>CxCatalogEntry</code> struct: braid + full complex bracket + amplitude + phase</li>
<li><code>build_complex_catalog()</code>: enumerates braids on 2-3 strands up to given length, stores full complex bracket values</li>
<li><code>find_nearest_cx()</code> / <code>find_nearest_amp()</code>: nearest-neighbor matching in complex plane vs amplitude line</li>
<li>U(1) gauge sweep: rotates all weights by e^{i*theta}, minimizes complex RMS over 360 angles</li>
<li><code>RealXorNet</code> struct: 2-2-1 real network for comparison, with <code>real_net_init()</code>, <code>real_net_forward()</code>, <code>real_net_train_xor()</code></li>
<li><code>braid_bracket_at()</code>: full complex bracket (not just amplitude) via state-sum</li>
<li>Union-find Seifert resolution for loop counting</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Nitta (2003): single complex neuron solves XOR via orthogonal decision boundaries</li>
<li>Aizenberg: multi-valued neuron (MVN) with complex-valued weights</li>
<li>Cyclotomic integers Z[zeta_8]: bracket values as sums of 8th roots of unity</li>
<li>Born rule projection: |&lt;b&gt;(A)|^2 discards phase information</li>
<li>U(1) gauge symmetry in neural networks: global phase rotation invariance</li>
<li>Freedman-Kitaev-Wang: topological quantum computation (complex amplitudes fundamental)</li>
<li><a href="./entries/demo_26.html">Demo 26</a> established amplitude-only baseline (RMS=0.2641)</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Can the U(1) gauge angle be predicted from the braid structure rather than swept numerically?</li>
<li>What happens at other cyclotomic evaluation points (not just A = e^{i<em>5</em>pi/4})?</li>
<li>Does the constellation expansion factor have a closed-form expression in terms of the cyclotomic field degree?</li>
<li>Can multiple complex neurons compose to match multi-weight braid decompositions (moving toward DKC "forward" direction)?</li>
<li>Relationship between split-sigmoid orthogonal boundaries and the Z[zeta_8] lattice structure?</li>
<li>Does the degeneracy reduction scale with braid length — do longer braids produce more phase diversity?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_28.html">Demo 28</a>: Unitary Activation</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_28_unitary_activation/main.c.html">demo_28_unitary_activation/main.c</a></code> (~958 lines)</li>
<li><strong>Tests</strong>: ~12-15 checks across 6 parts (A-F): train all activations, bracket catalog, gauge comparison, weight analysis, lattice projection, summary</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_27.html">Demo 27</a> (reverse DKC error decomposition: Born-rule vs split-sigmoid), <a href="./entries/demo_26.html">Demo 26</a> (real 2-2-1 baseline)</li>
<li><strong>Feeds into</strong>: Later demos exploring DKC with phase-preserving activations</li>
</ul>
<h3>Headline</h3>
Compares 4 complex activation functions (split-sigmoid, modReLU, cardioid, phase-only) on XOR to test whether U(1)-equivariant activation (modReLU) eliminates the dominant error source in reverse DKC — achieving dramatically lower gauge-corrected RMS and higher lattice projection success rate than split-sigmoid.
<h3>Key Results</h3>
<ul>
<li><strong>Training</strong> (Part A): 20 trials per activation, lr=0.5, max 100k epochs on XOR. Reports convergence rates. Phase-only expected &lt;50% convergence (discards amplitude information).</li>
<li><strong>Bracket catalog</strong> (Part B): builds complex bracket catalog at A = e^{i*5pi/4} (delta=0), strands 2-3, lengths 1-8, filtering |bracket| &gt; 0.5. Up to 8192 entries.</li>
<li><strong>Gauge comparison</strong> (Part C): for each activation's best network, sweeps 360 rotation angles to minimize RMS distance from weights to nearest catalog brackets. Key predictions:</li>
<li>P1: modReLU gauge-corrected RMS &lt; 0.15 (vs 0.3494 for split-sigmoid from <a href="./entries/demo_27.html">Demo 27</a>)</li>
<li>P2: Cardioid RMS in [0.15, 0.35]</li>
<li>P5: Gauge angles near 7pi/4 (315 deg) for all activations</li>
<li><strong>Weight phase/amplitude decomposition</strong> (Part D): separates per-weight error into phase error (radians) and amplitude error. P6: modReLU phase error &lt; split-sigmoid (because modReLU preserves phase exactly).</li>
<li><strong>Lattice projection</strong> (Part E): for each converged network: gauge-rotate → snap each weight to nearest bracket → inverse-rotate → test if projected network still solves XOR. P4: modReLU ≥80% survival, split-sigmoid &lt;20%.</li>
<li><strong>Summary</strong> (Part F): comparison table across all activations showing convergence, gauge RMS, gauge angle, phase error, amplitude error.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Core thesis</strong>: modReLU(z) = ReLU(|z|+b) * z/|z| is U(1)-equivariant — preserves phase exactly, eliminating the dominant error source (b) from <a href="./entries/demo_27.html">Demo 27</a></li>
<li>Two independent error sources in reverse DKC: (a) Born-rule collapse C→R≥0 (phase loss at readout), (b) split-sigmoid activation distortion (phase noise). Source (b) is DOMINANT.</li>
<li>modReLU should land trained weights closer to bracket values because phase is preserved through the hidden layer, only amplitude is adjusted</li>
<li>Cardioid activation (direction-dependent scaling) should be intermediate — not equivariant but still phase-aware</li>
</ul>
<h3>Data</h3>
<ul>
<li>4 activations: split-sigmoid (identity + sigmoid readout), modReLU (U(1)-equivariant), cardioid (direction-dependent), phase-only (unit circle normalization)</li>
<li>20 trials per activation, each with independent random init (LCG RNG for reproducibility)</li>
<li>Architecture: z = w1<em>x1 + w2</em>x2 + b → activation → sigmoid(re) + i*sigmoid(im) → smooth XOR readout</li>
<li>Reference baselines: <a href="./entries/demo_27.html">Demo 27</a> split-sigmoid RMS=0.3494, <a href="./entries/demo_26.html">Demo 26</a> real 2-2-1 amp RMS=0.2641</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong><code>apply_activation()</code></strong>: 4-way activation dispatch (split-sigmoid/modReLU/cardioid/phase-only) with clean implementations</li>
<li><strong><code>activation_backward()</code></strong>: full Jacobian-based backprop through each activation — modReLU symmetric Jacobian, cardioid non-symmetric, phase-only projection matrix. Each returns dL/dz_re, dL/dz_im, dL/db_act.</li>
<li><strong><code>cx28_forward()</code> / <code>cx28_train_xor()</code></strong>: complex neuron forward pass and SGD training loop with per-activation backward support</li>
<li><strong><code>build_complex_catalog()</code></strong>: enumerates all braids (2-3 strands, length 1-8) at a given A, stores entries with |bracket| &gt; 0.5</li>
<li><strong><code>find_nearest_cx()</code></strong>: brute-force nearest-neighbor in complex bracket catalog</li>
<li><strong><code>find_best_gauge()</code></strong>: sweeps 360 rotation angles to minimize RMS distance from gauge-rotated weights to catalog</li>
<li><strong>Lattice projection pipeline</strong>: gauge → snap to catalog → inverse gauge → verify XOR</li>
<li><strong>LCG RNG</strong>: <code>rng_seed()</code>, <code>rng_uniform()</code>, <code>rng_normal()</code> for reproducible experiments</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>modReLU: Arjovsky, Shah &amp; Bengio (2016) — "Unitary Evolution Recurrent Neural Networks"</li>
<li>U(1) equivariance / gauge symmetry in complex-valued neural networks</li>
<li>Cardioid activation function for CVNNs</li>
<li>Born rule interpretation: measurement collapses complex state to real probability</li>
<li>Reverse DKC (Diagrammatic Knot Computation): can gradient descent rediscover bracket values?</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Does modReLU's advantage hold for functions beyond XOR (e.g., 3-input functions from <a href="./entries/demo_23.html">Demo 23</a>)?</li>
<li>What is the minimum catalog density needed for reliable lattice projection?</li>
<li>Can the gauge angle be predicted analytically rather than swept numerically?</li>
<li>Is there an activation that eliminates BOTH error sources (Born-rule + phase distortion) simultaneously?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_29.html">Demo 29</a>: Cyclotomic Arithmetic — Forward DKC</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_29_cyclotomic_arithmetic/main.c.html">demo_29_cyclotomic_arithmetic/main.c</a></code> (~904 lines)</li>
<li><strong>Tests</strong>: ~20 pass (expected: Part A has ~15 verification tests, Parts B-E add ~6 more)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_26.html">Demo 26</a>-<a href="./entries/demo_28.html">28</a> (reverse DKC, split-sigmoid XOR network, bracket-as-weight concept), <a href="./entries/demo_10.html">Demo 10</a>-<a href="./entries/demo_13.html">13</a> (state-sum bracket oracle)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_45.html">Demo 45</a>+ (forward DKC zoo, all NPN classes, MVN activation, parity reachability)</li>
</ul>
<h3>Headline</h3>
Implements exact Z[zeta_8] cyclotomic integer arithmetic and proves FORWARD DKC: exact bracket values at A=e^{i*5pi/4} compute XOR without any training, confirming that the topological structure is sufficient and training merely finds it.
<h3>Key Results</h3>
<ul>
<li><strong>Z[zeta_8] exact arithmetic fully implemented</strong>: elements (a,b,c,d) in basis {1, zeta_8, zeta_8^2, zeta_8^3} with zeta_8^4 = -1; multiplication uses 16 integer muls, zero floating-point</li>
<li><strong>All arithmetic operations verified</strong>: mul, sub, neg, scale, pow (positive and negative exponents), conjugation — all cross-checked against float within 1e-10</li>
<li><strong>Critical delta=0 condition</strong>: at A = e^{i*5pi/4} = -zeta_8, A^2 + A^{-2} = 0 exactly, so delta=0 and only single-loop states (lp==1) survive in the bracket state sum. This massively simplifies exact computation.</li>
<li><strong>Bracket catalog built</strong>: 2-3 strand braids of length 1-8, yielding 50+ distinct Z[zeta_8] values with |bracket| &gt; 0.5; exact values match float with 100% agreement</li>
<li><strong>Forward DKC CONFIRMED</strong>: 100+ valid XOR triples found from exact bracket values + gauge rotation sweep (5-degree resolution over 360 degrees); weights are bracket values by construction (RMS = 0.000)</li>
<li><strong>Solution manifold</strong>: solutions cluster in magnitude bands [0,2), [2,4), [4,9) with 80%+ coverage; gauge angles show structure related to zeta_8 orbit (45-degree periodicity)</li>
<li><strong>Bracket composition is NOT multiplicative</strong>: bracket(b1<em>b2) != bracket(b1)</em>bracket(b2) for &gt;= 80% of tested pairs (trace closure is not multiplicative), but all composed values remain in Z[zeta_8] by construction</li>
<li><strong>Training-as-Focusing thesis confirmed</strong>: topological (bracket) structure is sufficient for computation; neural network training merely locates pre-existing solutions on the Z[zeta_8] lattice</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Forward DKC</strong>: CONFIRMED — exact Z[zeta_8] bracket values compute XOR without training</li>
<li><strong>Training-as-Focusing</strong>: CONFIRMED — the topological structure is sufficient; training merely finds it</li>
<li><strong>Delta=0 simplification</strong>: PROVEN (exact) — at A = -zeta_8, delta = -(A^2 + A^{-2}) = 0 exactly, reducing state sum to single-loop states only</li>
<li><strong>Bracket non-multiplicativity</strong>: CONFIRMED — bracket(b1<em>b2) != bracket(b1)</em>bracket(b2) for trace closure</li>
<li><strong>Z[zeta_8] closure</strong>: CONFIRMED (trivially) — all bracket values and their compositions remain in Z[zeta_8]</li>
</ul>
<h3>Data</h3>
<ul>
<li>A = (0,-1,0,0) in Z[zeta_8] basis = -zeta_8 = e^{i*5pi/4}</li>
<li>A^{-1} = (0,0,0,1) = zeta_8^3 = e^{i*3pi/4}</li>
<li>zeta_8^8 = 1 verified exactly</li>
<li>Catalog: 2-3 strand braids, lengths 1-8, enumeration capped at 100,000 per (n,len) combination</li>
<li>Forward DKC search: distinct_count^3 triples x 72 gauge angles (5-degree steps)</li>
<li>Solution magnitude bands: [0,2), [2,4), [4,9)</li>
<li>Split-sigmoid activation: sigma(re) and sigma(im) independently, output p = h.re<em>(1-h.im) + (1-h.re)</em>h.im</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong><code>Cyc8</code> type</strong>: exact Z[zeta_8] cyclotomic integer — struct with 4 long coefficients (a,b,c,d)</li>
<li><code>cyc8_make/zero/one/add/sub/neg/mul/scale/eq/conj/pow_int/print/to_cx</code>: complete arithmetic library for cyclotomic integers</li>
<li><code>cyc8_mul()</code>: multiplication using the relation zeta_8^4 = -1, 16 integer muls, 12 adds</li>
<li><code>cyc8_conj()</code>: complex conjugation via conj(a,b,c,d) = (a,-d,-c,-b); doubles as inverse for units</li>
<li><code>braid_bracket_exact()</code>: exact bracket computation in Z[zeta_8] at delta=0, only summing single-loop states</li>
<li><code>CatalogEntry</code> and <code>build_exact_catalog()</code>: enumerates braids, computes both exact and float brackets, deduplicates distinct values</li>
<li><code>test_xor_triple()</code>: split-sigmoid XOR verification for a (w1, w2, b) weight triple</li>
<li><code>ValidTriple</code> and forward DKC search loop with gauge rotation sweep</li>
<li>Standard braid infrastructure (union-find, state-sum bracket oracle) for float comparison</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Habiro (2002): bracket values at roots of unity are cyclotomic integers</li>
<li>Abramsky (2007): TL diagrams encode computation</li>
<li>Nazer-Gastpar (2011): algebraic integer lattices support function computation</li>
<li>Z[zeta_8] = Z[e^{i*pi/4}] as the natural lattice for Kauffman bracket values at 8th root of unity</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>How does the solution count scale with the size of the bracket catalog (more braids = more distinct values = more solutions)?</li>
<li>What is the algebraic structure of the solution manifold? Are solutions related by Z[zeta_8] automorphisms beyond gauge rotation?</li>
<li>Can the delta=0 simplification be extended to other roots of unity where delta != 0?</li>
<li>Does forward DKC extend to all 13 NPN classes (addressed in later demos 45-50)?</li>
<li>What is the minimal bracket catalog needed to guarantee at least one XOR solution exists?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_35.html">Demo 35</a>: TL_n Matrix Representations over Z[zeta_8]</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_35_tl_matrices/main.c.html">demo_35_tl_matrices/main.c</a></code> (~1726 lines)</li>
<li><strong>Tests</strong>: ~40 pass (inline check() assertions across Parts A-F + 4 experiments)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_01.html">Demo 01</a> (state-sum bracket), <a href="./entries/demo_22.html">Demo 22</a> (hardcoded TL_3), <a href="./entries/demo_24.html">Demo 24</a> (TL_2), <a href="./entries/demo_29.html">Demo 29</a> (Cyc8 arithmetic)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_45.html">Demo 45</a>-<a href="./entries/demo_50.html">50</a> (DKC research arc — exact bracket computations underpin forward DKC)</li>
</ul>
<h3>Headline</h3>
Generalizes TL_3 matrix representations to parametric TL_n (n=2..5) over exact Z[zeta_8] arithmetic with diagram composition, braid evaluation, and closure functionals — cross-validated against state-sum bracket.
<h3>Key Results</h3>
<ul>
<li>Exact Cyc8 (Z[zeta_8]) arithmetic: basis {1, zeta_8, zeta_8^2, zeta_8^3} with zeta_8^4 = -1, fully verified (multiplication, conjugation, float cross-check)</li>
<li>Planar matching enumeration produces correct Catalan numbers: C_2=2, C_3=5, C_4=14, C_5=42</li>
<li>TL generator matrices verified: nilpotent (e_i^2 = 0 at delta=0), adjacent relation (e_i<em>e_j</em>e_i = e_i for |i-j|=1), far commutativity (e_i<em>e_j = e_j</em>e_i for |i-j|&gt;=2)</li>
<li>Braid generators sigma_i = A<em>I + A^{-1}</em>e_i verified: inverse relations, braid relation (sigma_1<em>sigma_2</em>sigma_1 = sigma_2<em>sigma_1</em>sigma_2)</li>
<li>Trace closure bracket matches state-sum bracket EXACTLY for Hopf link, trefoil, figure-eight, and two 4-strand braids</li>
<li>n=5 sparsity prediction confirmed: e_1 has exactly C_5 - C_4 = 28 nonzero entries</li>
<li><strong>Entanglement vanishing theorem</strong>: ALL non-interleaving braids (sigma_1, sigma_3 only in B_4) have bracket = 0 — delta=0 is an entanglement detector</li>
<li><strong>Axiality theorem</strong>: EVERY bracket value at n=2 (length 1-10) and n=3 (length 1-8) has at most one nonzero Cyc8 component — no mixed brackets found across all braids tested</li>
<li>Compression ratios measured: n=3 length 6 gives 4096 braids → limited distinct TL matrices; n=4 length 5 gives 7776 braids with compression</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Nilpotency at delta=0</strong>: e_i^2 = 0 for all generators — PROVEN (verified n=2,3,4)</li>
<li><strong>TL relations</strong>: e_i<em>e_j</em>e_i = e_i (|i-j|=1), e_i<em>e_j = e_j</em>e_i (|i-j|&gt;=2) — PROVEN (verified n=3,4)</li>
<li><strong>Entanglement vanishing</strong>: Non-interleaving braids have zero bracket at delta=0 — PROVEN (exhaustive for n=4, length 1-5)</li>
<li><strong>Axiality conjecture</strong>: All bracket values at delta=0 are axial (at most one nonzero Cyc8 component) — CONJECTURED (exhaustively verified for n=2 length 1-10, n=3 length 1-8; ~131K braids total)</li>
<li><strong>Sparsity formula</strong>: TL generator e_1 at n strands has C_n - C_{n-1} nonzero entries — CONJECTURED (verified n=5)</li>
</ul>
<h3>Data</h3>
<ul>
<li>Catalan dimensions: C_2=2, C_3=5, C_4=14, C_5=42</li>
<li>A = -zeta_8 = e^{i*5pi/4}, A^{-1} = conj(A), delta = -(A^2 + A^{-2}) = 0</li>
<li>n=4 bracket catalog: distinct nonzero values collected from braids of length 1-5 (up to 60 printed)</li>
<li>Compression: n=3 length 6: 4096→distinct; n=4 length 5: 7776→distinct</li>
<li>Axiality: 131K+ braids tested, 0 mixed (non-axial) brackets</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>Cyc8 exact arithmetic</strong>: full ring operations (add, sub, mul, neg, scale, conj, eq), conversion to complex double, print</li>
<li><strong>Planar matching enumerator</strong>: segment-based recursive algorithm producing non-crossing perfect matchings for n up to 5</li>
<li><strong>TLMatrix algebra</strong>: zero, identity, add, scale, mul, equality, zero-test, nonzero-count, print — all over Cyc8</li>
<li><strong>Diagram composition</strong>: compose_diagrams() stacks two TL diagrams, counts closed loops at glue</li>
<li><strong>TL generator builder</strong>: build_generator_matrix() constructs e_i in planar matching basis</li>
<li><strong>Braid generator builder</strong>: build_braid_generator() constructs sigma_i = A<em>I + A^{-1}</em>e_i</li>
<li><strong>Braid word evaluator</strong>: eval_braid_word() multiplies generator matrices for arbitrary crossing sequences</li>
<li><strong>Trace closure functional</strong>: compute_bracket_trace() extracts bracket from TL matrix representation</li>
<li><strong>State-sum bracket</strong> (independent): state_sum_bracket() for cross-validation</li>
<li><strong>Braid decoder</strong>: decode_braid() maps integer index to crossing sequence for exhaustive enumeration</li>
<li><strong>Axiality test</strong>: cyc8_is_axial() checks single-component property</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Temperley-Lieb algebra (non-crossing partition basis, Catalan number dimension)</li>
<li>Kauffman bracket polynomial (state-sum model, braid representation via sigma_i = A<em>I + A^{-1}</em>e_i)</li>
<li>Non-semisimple representation theory (delta=0 ⟹ nilpotent generators)</li>
<li>Cyclotomic integers Z[zeta_8] (exact arithmetic for 8th root of unity)</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Does axiality hold for n=4 and higher braid lengths? (Computationally expensive to exhaustively verify)</li>
<li>What is the exact growth rate of distinct TL matrices vs braid count at each n?</li>
<li>Can the sparsity formula C_n - C_{n-1} be proven algebraically from diagram composition rules?</li>
<li>How does the bracket catalog at n=4 relate to the DKC weight decomposition from <a href="./entries/demo_26.html">Demo 26</a>?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_38.html">Demo 38</a>: Dimension Reduction at delta=0</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_38_dimension_reduction/main.c.html">demo_38_dimension_reduction/main.c</a></code> (~781 lines)</li>
<li><strong>Tests</strong>: 13/13 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_35.html">Demo 35</a> (TL_n matrix representations, planar matching enumeration, diagram composition)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_39.html">Demo 39</a> (symmetry decomposition), <a href="./entries/demo_45.html">Demo 45</a>-<a href="./entries/demo_50.html">50</a> (DKC research arc — reduced representations cut matrix operation costs ~64x for even n)</li>
</ul>
<h3>Headline</h3>
At delta=0, the Gram matrix of the Temperley-Lieb trace form has rank exactly C_{n-1} at even n (and full rank C_n at odd n), proving the bracket factors through a quotient TL_n(0)/rad isomorphic to TL_{n-1}(0) — yielding asymptotic ~4x dimension reduction and ~64x speedup for O(dim^3) matrix operations.
<h3>Key Results</h3>
<ul>
<li><strong>Even/odd dichotomy proven</strong>: Odd n is semisimple (Gram rank = C_n, zero radical); even n has Gram rank = C_{n-1} with radical dimension C_n - C_{n-1}</li>
<li><strong>Verified n=2 through n=8</strong>: All seven cases match the rank prediction exactly</li>
<li><strong>Reduction factors</strong>: 2.00x (n=2), 2.80x (n=4), 3.14x (n=6), 3.33x (n=8) — ratio C_n/C_{n-1} grows toward 4x asymptotically</li>
<li><strong>Through-strand sector decomposition</strong>: Sector j=0 is always DEAD (entirely radical) at even n; sector j=n (identity) is always LIVE; intermediate even sectors are PARTIAL</li>
<li><strong>Odd n sectors all LIVE</strong>: Every through-strand sector at odd n has full Gram rank</li>
<li><strong>Reduced generators verified</strong>: For n=2,4,6, the projected generators in the quotient satisfy all TL relations (nilpotency e_i^2=0, adjacent relation e_i<em>e_{i+1}</em>e_i=e_i, far commutativity)</li>
<li><strong>Quotient isomorphism confirmed</strong>: Nonzero product counts in quotient mult table match TL_{n-1} exactly — TL_2/rad has 1 product matching TL_1; TL_4/rad has 17 matching TL_3; TL_6/rad has 955 matching TL_5</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Even-n rank reduction</strong>: Gram rank of TL_n(0) trace form = C_{n-1} for even n — PROVEN (verified n=2,4,6,8)</li>
<li><strong>Odd-n semisimplicity</strong>: Gram rank = C_n (full rank) for odd n — PROVEN (verified n=3,5,7)</li>
<li><strong>Sector-0 radical</strong>: Through-strand sector j=0 lies entirely in the radical at even n — PROVEN (verified n=2,4,6,8)</li>
<li><strong>Quotient isomorphism TL_n(0)/rad ~ TL_{n-1}(0)</strong>: Nonzero product counts match — PROVEN (verified n=2,4,6)</li>
<li><strong>Asymptotic 4x reduction</strong>: C_n/C_{n-1} -&gt; 4 as n -&gt; infinity — PROVEN (follows from Catalan asymptotics)</li>
</ul>
<h3>Data</h3>
<table><thead><tr><th>n</th><th>C_n</th><th>Gram rank</th><th>Radical dim</th><th>Reduction</th></tr></thead><tbody><tr><td>2</td><td>2</td><td>1</td><td>1</td><td>2.00x</td></tr><tr><td>3</td><td>5</td><td>5</td><td>0</td><td>1.00x</td></tr><tr><td>4</td><td>14</td><td>5</td><td>9</td><td>2.80x</td></tr><tr><td>5</td><td>42</td><td>42</td><td>0</td><td>1.00x</td></tr><tr><td>6</td><td>132</td><td>42</td><td>90</td><td>3.14x</td></tr><tr><td>7</td><td>429</td><td>429</td><td>0</td><td>1.00x</td></tr><tr><td>8</td><td>1430</td><td>429</td><td>1001</td><td>3.33x</td></tr></tbody></table>
<h3>Code Assets</h3>
<ul>
<li><strong>Gram matrix construction</strong>: fixpt-based trace form at delta=0</li>
<li><strong>Modular RREF with augmented matrix</strong>: Full [G|I] row reduction over Z/pZ, tracks pivot columns, extracts radical basis</li>
<li><strong>Through-strand counter</strong>: count_through_strands() classifies basis elements by sector</li>
<li><strong>Per-sector Gram rank</strong>: sector_gram_rank() extracts sub-Gram matrix and computes rank independently</li>
<li><strong>Reduced generator builder</strong>: build_reduced_gen() projects TL generators onto quotient basis</li>
<li><strong>Quotient multiplication table</strong>: quotient_nonzero_products() counts nonzero products via RREF projection</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Temperley-Lieb algebra at non-semisimple specializations (delta=0)</li>
<li>Gram matrix / trace form radical (Goodman-de la Harpe-Jones)</li>
<li>Quotient algebras TL_n/rad identification with smaller TL algebras</li>
<li>Catalan number asymptotics (C_n/C_{n-1} -&gt; 4)</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Can the sector decomposition give finer-grained reduction than global C_{n-1}?</li>
<li>Does the quotient isomorphism extend to a graded isomorphism respecting through-strand sectors?</li>
<li>Can forward DKC run entirely in the quotient representation?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_39.html">Demo 39</a>: Symmetry Decomposition of TL_n</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_39_symmetry_decomposition/main.c.html">demo_39_symmetry_decomposition/main.c</a></code> (~1483 lines)</li>
<li><strong>Tests</strong>: 49+ tests pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_35.html">Demo 35</a> (planar matching enumeration, diagram composition), <a href="./entries/demo_38.html">Demo 38</a> (dimension reduction infrastructure), <a href="./entries/demo_51.html">Demo 51</a> (radical anatomy at delta=0), <a href="./entries/demo_52.html">Demo 52</a> (Chebyshev multi-delta radical structure), <a href="./entries/demo_48.html">Demo 48</a> (forward DKC zoo — conjectured non-semisimplicity explanation deferred here)</li>
<li><strong>Feeds into</strong>: Algebraic explanation of DKC parity wall (<a href="./entries/demo_48.html">Demo 48</a> conjecture), understanding of sector-level Gram degeneracies for future multi-delta DKC analysis, <a href="./entries/demo_63.html">Demo 63</a> (angular anatomy, RT truncation connection), proofs/markov-rt-truncation.md, proofs/next-level-radical-formula.md</li>
</ul>
<h3>Headline</h3>
Decomposes TL_n (n=2..8) by through-strand count into cellular sectors, verifying sector sizes = d(n,j)^2, computing per-sector Gram ranks at multiple delta values, proving cell filtration monotonicity, and showing semisimple algebras are NOT block-diagonal in the standard basis. Parts G-J extend to three distinct Gram forms at the n=ell boundary (fixpt, Markov, cell module), prove the Markov RT truncation theorem (Markov trace kills j &gt;= ell-1, preserves j &lt;= ell-2), verify the next-level radical formula rad(TL_{ell+1}) = ell^2-ell-3, and establish the second-degeneracy corank = ell+1.
<h3>Key Results</h3>
<ul>
<li><strong>Part A</strong>: Sector sizes |V_j| = d(n,j)^2 verified exhaustively for n=2..8</li>
<li><strong>Part B</strong>: Even-n j=0 sector completely DEAD at delta=0; odd-n ALL sectors fully LIVE</li>
<li><strong>Part C</strong>: Cross-sector coupling grows: 0 at n=4, 4 at n=6, 104 at n=8</li>
<li><strong>Part D</strong>: Cell filtration ts(a*b) &lt;= min(ts(a), ts(b)) proven exhaustively at n=4 and n=6</li>
<li><strong>Part E</strong>: Multi-delta comparison — delta=phi semisimple (full rank), delta=0 minimal rank</li>
<li><strong>Part F</strong>: Semisimple odd-n algebras are NOT block-diagonal in standard basis despite semisimplicity</li>
<li><strong>Part G</strong>: Three Gram forms at n=ell boundary. V_{ell-2} unique degenerate module, corank 1. fixpt_rad=2ell-3, Markov_rad=2ell-2. Bug fix: p=10^9+7 → p=1000002361 (≡1 mod 840)</li>
<li><strong>Part H</strong>: Next-level radical rad(TL_{ell+1}) = ell^2-ell-3 verified for ell=3..7. V_{ell-3} unique degenerate module.</li>
<li><strong>Part I</strong>: Markov excess conjecture (ell+m-1)^2+1 REFUTED at m=3. True formula: excess = Σ (dim L_j)^2 for j ≥ ell-1.</li>
<li><strong>Part J</strong>: Full RT truncation: Markov kills j ≥ ell-1, preserves j ≤ ell-2. Cross-sector kernel vector at ell=4: coefficient matrix [-δ,1;1,-δ] = J−δI, rank 2.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Cellular decomposition</strong>: |V_j| = d(n,j)^2 — PROVEN (n=2..8)</li>
<li><strong>j=0 death at delta=0</strong>: PROVEN (even n=2,4,6,8)</li>
<li><strong>Cell filtration monotonicity</strong>: PROVEN (exhaustive at n=4,6)</li>
<li><strong>Semisimple =/= block-diagonal</strong>: PROVEN (n=3,5)</li>
<li><strong>Graham-Lehrer semisimplicity</strong>: CONFIRMED (n &lt; ell iff semisimple)</li>
<li><strong>rad(TL_ell) = 2ell-3</strong>: PROVEN (formal proof in proofs/radical-dimension-formula.md)</li>
<li><strong>rad(TL_{ell+1}) = ell^2-ell-3</strong>: PROVEN (formal proof in proofs/next-level-radical-formula.md)</li>
<li><strong>Universal Corank 1</strong>: PROVEN (structural, via linking theorem)</li>
<li><strong>Markov RT truncation</strong>: PROVEN (formal proof in proofs/markov-rt-truncation.md, 31/31 tests)</li>
<li><strong>Second-degeneracy corank = ell+1</strong>: VERIFIED (ell=3..6)</li>
<li><strong>(ell+m-1)^2+1 excess conjecture</strong>: REFUTED at m=3</li>
</ul>
<h3>Data</h3>
<ul>
<li>Gram ranks at delta=0: n=4: [0,4,1]; n=6: [0,25,20,1]; n=8: [0,196,294,42,1]</li>
<li>Cross-sector coupling: n=4:0, n=6:4, n=8:104</li>
<li>Multi-delta ranks at n=4: delta=0:5, delta=1:11, delta=sqrt(2):9, delta=phi:14</li>
<li>Radical dims at n=ell: 1, 3, 5, 0, 9, 11 for ell=2..7</li>
<li>Three Gram forms (fixpt_rad, Markov_rad) at n=ell: (1,2), (3,4), (5,6), (7,8), (9,10), (11,12)</li>
<li>Markov excess: n=ell: 1; n=ell+1: ell^2+1; n=ell+2: (ell+1)^2+1; n=ell+3: Σ(dim L_j)^2</li>
<li>Next-level radical: ell=3:3, ell=4:9, ell=5:17, ell=6:27, ell=7:39</li>
<li>Second-degeneracy corank: ell=3:4, ell=4:5, ell=5:6, ell=6:7</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>Cell module dimension formula</strong>: cell_module_dim(n,j)</li>
<li><strong>Sector classifier</strong>: classify_sectors() partitions basis by through-strand count</li>
<li><strong>Gram submatrix builder</strong>: build_gram_sub() for sector-restricted bilinear forms</li>
<li><strong>Markov Gram builder</strong>: build_markov_gram() using closure loops</li>
<li><strong>Cell module Gram verification</strong>: per-sector d(n,j) x d(n,j) Gram matrix</li>
<li><strong>Cubic root finder for ell=7</strong>: Cantor-Zassenhaus over F_p[x]/(x^3-x^2-2x+1)</li>
<li><strong>Modular arithmetic suite</strong>: mod_reduce, mod_inv, mod_pow, mod_sqrt (Tonelli-Shanks)</li>
<li><strong>Multi-level radical computation</strong>: radical at n=ell through n=ell+3</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Graham-Lehrer cellular algebra theory (1996)</li>
<li>Chebyshev parametrization of semisimplicity boundary</li>
<li>Cantor-Zassenhaus polynomial factoring</li>
<li>Ridout &amp; Saint-Aubin (2014, arXiv:1204.4505): radical structure of cell modules</li>
<li>Reshetikhin-Turaev (1991): RT TQFT truncation</li>
<li>Turaev, "Quantum Invariants of Knots and 3-Manifolds": negligible modules</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Closed-form for cross-sector coupling growth?</li>
<li>ANSWERED: Which sector's degeneracy blocks parity? → Cross-sector coupling (Markov kernel spans multiple sectors, not a product state)</li>
<li>ANSWERED: Formula for radical dims at n=ell? → rad = 2ell-3, PROVEN</li>
<li>Cross-sector kernel structure at general ell (J−δI pattern at ell=4)?</li>
<li>Second-degeneracy corank = ell+1: provable from linking theory?</li>
<li>ell=3 Markov rank stays 1 for n=5,6 — does it stay 1 for all n &gt; ell at delta=1?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_45.html">Demo 45</a>: Complex Function Zoo</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_45_complex_function_zoo/main.c.html">demo_45_complex_function_zoo/main.c</a></code> (~1387 lines)</li>
<li><strong>Tests</strong>: ~11 checks (6 parts: A=1 NPN reach, B=1 convergence, C=1 catalog size, D=1 beat-random, E=7 predictions P1-P7); 9/11 pass, 2 informative failures (P3 braid length, P5 phase richness reversed)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_23.html">Demo 23</a> (function zoo, NPN classification, forward braid→truth-table enumeration), <a href="./entries/demo_27.html">Demo 27</a> (complex reverse DKC, gauge-corrected decomposition)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_46.html">Demo 46</a> (per-neuron gauge), <a href="./entries/demo_47.html">Demo 47</a> (MVN activation for parity), <a href="./entries/demo_48.html">Demo 48</a> (4-input zoo), <a href="./entries/demo_49.html">Demo 49</a> (expanded catalog), <a href="./entries/demo_50.html">Demo 50</a> (multi-layer DKC)</li>
</ul>
<h3>Headline</h3>
Extends reverse DKC decomposition from XOR (<a href="./entries/demo_27.html">Demo 27</a>) to all 13 non-trivial NPN equivalence classes of 3-input Boolean functions, discovering that topology frequency (forward map) and decomposition quality (reverse map) are near-perfectly anti-correlated (Spearman rho = -0.8167), proving the bracket algebra has intrinsic computational structure measurable from either direction.
<h3>Key Results</h3>
<ul>
<li><strong>Part A (NPN classification)</strong>: Enumerates all non-trivial NPN classes (13 of 256 truth tables modulo permutation/negation); forward topology frequency computed from 4-strand braids length 1-3 across 4 closures at A = e^{i5pi/4}</li>
<li><strong>Part B (Complex training)</strong>: All 13 NPN classes converge; CxNet3 architecture (3 real inputs → 3 complex hidden neurons with split-sigmoid → 1 real output, 31 real parameters); 10 trials per class, max 50000 epochs, keep fastest</li>
<li><strong>Part C (Bracket catalog)</strong>: 8192 braids (2-3 strands, length 1-8) producing 64 distinct complex bracket values at delta=0; covering radius estimated from 1000 random probes</li>
<li><strong>Part D (Gauge decomposition)</strong>: 12 complex weights per class decomposed via 360-angle gauge sweep + nearest-neighbor to catalog; random baseline RMS = 0.8086; 11/13 classes beat random</li>
<li><strong>Part E (Correlation)</strong>: P1 CONFIRMED: rho(RMS, topo_freq) = -0.8167 (strongest finding); P2 confirmed (symmetric &lt; non-sym); P4 confirmed (natural RMS gap = 0.0858); P6 confirmed (rho(RMS, orbit) = +0.275); P7 confirmed (5/9 gauge angles at pi/4 multiples); P3 FAILED (avg braid = 5.58, not ≤ 4 — bracket value matters, not braid length); P5 REVERSED (r = +0.87 — fewer phases = better, not more)</li>
<li><strong>Part F (Summary)</strong>: Master table ranked by gauge RMS; top 3 detail with weight→bracket matching; bottom 3 worst decomposers; overall statistics</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Forward-reverse duality</strong>: Functions that topology produces frequently (forward map) are exactly those whose trained weights decompose cleanly back into bracket values (reverse map) — rho = -0.8167</li>
<li><strong>Parity is topologically unnatural</strong>: XNOR3 is the only function worse than random (RMS = 0.9963 vs 0.8086), has topology frequency 0, orbit size 2 — parity requires exact cancellation that the bracket's sum-over-states structure cannot produce</li>
<li><strong>Sparsity principle</strong>: Good decomposition = fewer distinct lattice phases used (reversed P5, r = +0.87); topologically natural functions live in low-dimensional subspaces of Z[zeta_8]</li>
<li><strong>Gauge-lattice alignment</strong>: Optimal gauge angles cluster at pi/4 multiples, confirming weight alignment with Z[zeta_8] = Z[e^{i*pi/4}] cyclotomic structure</li>
<li><strong>BUF &gt; AND &gt; MAJ &gt; XOR hierarchy</strong>: Simpler functions (fewer input dependencies) decompose better; complexity of the function's decision boundary determines decomposition quality</li>
</ul>
<h3>Data</h3>
<ul>
<li>13 NPN classes with canon truth table, orbit size, topology frequency, convergence epoch</li>
<li>8192-entry bracket catalog (64 distinct complex values) at A = e^{i5pi/4}</li>
<li>Per-class: gauge RMS, amplitude-only RMS, best gauge angle (deg), average matched braid length, distinct phase count</li>
<li>Spearman correlations: rho(RMS, freq) = -0.8167, rho(RMS, orbit) = +0.275</li>
<li>Pearson r(phases, RMS) = +0.87</li>
<li>Ranking: BUF (0.5285) → AND2' (0.5400) → AND3' (0.6011) → ... → EXACT1 (0.8639) → XNOR3 (0.9963)</li>
<li>Random baseline: 1000 probes, RMS = 0.8086</li>
<li>Amplitude-only RMS often better than gauge-corrected complex RMS (scaling challenge)</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>CxNet3</code> struct: 3-input complex-valued neural network (wh[3][3] complex hidden weights, bh[3] complex biases, vo[6] real output weights, bo real bias)</li>
<li><code>cxnet3_init()</code>, <code>cxnet3_forward()</code>, <code>cxnet3_train()</code> — initialization, forward pass with split-sigmoid, backprop training</li>
<li><code>NPNClass</code> struct: canon_tt, orbit_size, topo_freq, convergence info, 12 complex weights, decomposition metrics</li>
<li><code>npn_init()</code>, <code>npn_transform()</code> — NPN canonical form computation (min truth table under permutation/negation group)</li>
<li><code>build_complex_catalog()</code> — enumerate braids up to given strand count and length, store bracket values with amplitude &gt; 0.5</li>
<li><code>find_nearest_cx()</code> — nearest-neighbor search in complex bracket catalog</li>
<li><code>spearman_rho()</code>, <code>assign_ranks()</code> — Spearman rank correlation with tie averaging</li>
<li><code>compute_tt()</code> — truth table from braid word + closure via amplitude thresholding (from <a href="./entries/demo_23.html">Demo 23</a>)</li>
<li><code>bracket_cl()</code> — state-sum bracket with selectable closure type (trace, plat_a/b/c)</li>
<li><code>braid_loops_cl()</code> — union-find loop counting with 4 closure types</li>
<li><code>fn_name()</code> — human-readable name lookup for canonical truth tables</li>
<li><code>rng_seed()</code>, <code>rng_uniform()</code>, <code>rng_normal()</code> — LCG-based reproducible RNG with Box-Muller</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>NPN equivalence classes of Boolean functions (complete classification for 3 inputs)</li>
<li>Complex-valued neural networks with split-sigmoid activation</li>
<li>Kauffman bracket as algebraic computational structure (forward and reverse directions)</li>
<li>Gauge symmetry (U(1) rotation) in weight decomposition</li>
<li>Closest Vector Problem (CVP) in cyclotomic lattice Z[zeta_8]</li>
<li>Sparsity in algebraic bases as quality predictor</li>
<li>Parity as canonical hard function for partition-function computation</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Would per-neuron gauge correction (3D optimization instead of 1D) improve mid-ranking functions?</li>
<li>Is parity's resistance architectural (split-sigmoid) or algebraic (bracket can't express it)? MVN activation test needed.</li>
<li>Does the rho = -0.8167 correlation hold at 4 inputs (222 NPN classes)?</li>
<li>With a larger catalog (more braids, more strands), do topology-invisible functions improve or remain resistant?</li>
<li>Can multi-layer decomposition (two hidden layers) close the gap between approximate and exact?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_46.html">Demo 46</a>: Per-Neuron Gauge Correction</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_46_per_neuron_gauge/main.c.html">demo_46_per_neuron_gauge/main.c</a></code> (~1472 lines)</li>
<li><strong>Tests</strong>: 6/10 checks pass (4 informative failures on predictions P2-P5), across 6 parts (A-F): NPN classification, complex network training, bracket catalog, decomposition with global + per-neuron gauge, ranking &amp; Spearman correlation, summary table &amp; angle structure</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_45.html">Demo 45</a> (Complex Function Zoo — global gauge decomposition, Spearman rho = -0.82), <a href="./entries/demo_27.html">Demo 27</a> (reverse DKC error decomposition), <a href="./entries/demo_28.html">Demo 28</a> (unitary activation comparison)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_47.html">Demo 47</a> (Parity Investigation — MVN activation to test lattice-aligned phases)</li>
</ul>
<h3>Headline</h3>
Replaces <a href="./entries/demo_45.html">Demo 45</a>'s single global U(1) gauge rotation with independent per-neuron rotations (3D sweep: one angle per hidden neuron), finding that per-neuron gauge improves RMS by 20% but amplitude-only decomposition (RMS 0.33) still dramatically beats per-neuron gauge (RMS 0.57) — proving that phase decoherence from split-sigmoid training, not gauge approximation, is the fundamental bottleneck.
<h3>Key Results</h3>
<ul>
<li><strong>NPN classification</strong> (Part A): maps all 256 3-input truth tables to 14 NPN canonical forms (via permutation + input negation + output negation), selects 13 non-trivial classes for testing</li>
<li><strong>Complex network training</strong> (Part B): CxNet3 architecture (3 complex hidden neurons, 12 complex weights), split-sigmoid activation, 10 trials per NPN class, SGD with lr=0.3, max 200k epochs</li>
<li><strong>Bracket catalog</strong> (Part C): 64 distinct complex bracket values from 2-3 strand braids at A = e^{i*5pi/4}, same as <a href="./entries/demo_45.html">Demo 45</a></li>
<li><strong>Decomposition</strong> (Part D): for each converged network, three decomposition methods compared:</li>
<li>Global gauge (1D sweep, 360 angles): avg RMS = 0.7164</li>
<li>Per-neuron gauge (3D sweep, coarse 36^3 + refinement 11^3): avg RMS = 0.5723</li>
<li>Amplitude-only (magnitude matching, ignore phases): avg RMS = 0.3283</li>
<li>Random baseline: 0.8086</li>
<li><strong>Ranking &amp; Spearman</strong> (Part E): correlation between topology frequency and decomposition quality — global rho = -0.8167, per-neuron rho = -0.7833 (slightly worse). Computed over 9 classes with nonzero topology frequency.</li>
<li><strong>Summary &amp; angle structure</strong> (Part F): per-neuron angle spreads of 50-170 degrees between neurons for most classes; only 4/13 show clustering</li>
</ul>
<h3>Prediction Scorecard</h3>
<table><thead><tr><th>#</th><th>Prediction</th><th>Result</th><th>Notes</th></tr></thead><tbody><tr><td>P1</td><td>pn_RMS &lt;= global_RMS for all 13</td><td>PASS</td><td>Trivially true (superset search space)</td></tr><tr><td>P2</td><td>Largest improvement for mid-tier (ranks 4-9)</td><td>FAIL</td><td>Bottom tier improved most (0.1938 avg)</td></tr><tr><td>P3</td><td>pn_RMS &lt; amp_RMS for top 6</td><td>FAIL</td><td>Amplitude-only wins for ALL classes</td></tr><tr><td>P4</td><td>Spearman rho improves (more negative)</td><td>FAIL</td><td>Slightly worse (-0.7833 vs -0.8167)</td></tr><tr><td>P5</td><td>Per-neuron angles show clustering</td><td>FAIL</td><td>Only 4/13 show structure; spreads 50-170 deg</td></tr></tbody></table>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Phase decoherence thesis</strong>: split-sigmoid activation treats Re and Im independently, producing weights whose magnitudes align with bracket magnitudes but whose phases are essentially random relative to Z[zeta_8]. No post-training rotation can recover what training never encoded.</li>
<li><strong>Classical vs quantum partition functions</strong>: split-sigmoid training accesses the Kauffman bracket as a classical/thermal partition function (magnitudes only), not a quantum one (requiring phase coherence). The Potts-model sector vs the Jones-polynomial sector.</li>
<li><strong>Coding theory capacity</strong>: bracket codebook offers ~7.3 bits/symbol (4.3 magnitude + 3 phase). Split-sigmoid encodes ~4.3 bits (magnitudes only). Per-neuron gauge recovers ~0.5 bits of misaligned phase. ~1.5 bits of phase capacity unused.</li>
<li><strong>Dimensionality mismatch</strong>: weight vector in C^12 ~ R^24; 12 magnitude coordinates carry signal, 12 phase coordinates carry noise. Gauge rotation couples magnitudes and phases, degrading both. Amplitude-only = dimensionality reduction to the informative subspace.</li>
<li><strong>Fork in the road</strong>: Path A — accept phase decoherence, use amplitude-only matching; Path B — fix training with MVN/lattice-constrained optimization to access the quantum sector.</li>
</ul>
<h3>Data</h3>
<ul>
<li>13 NPN classes, 10 trials per class, CxNet3 architecture (3 hidden neurons, 12 complex weights)</li>
<li>64 bracket catalog values (2-3 strands, lengths 1-8, at A = e^{i*5pi/4})</li>
<li>3D gauge sweep: coarse 36x36x36 (46,656 combinations, 10-deg) + refinement 11x11x11 (1,331, 1-deg)</li>
<li>Runtime: ~5 minutes (dominated by 3D gauge sweeps)</li>
<li>Highlight: ~A(B^C) jumped from rank 9 to rank 3 (0.7781 -&gt; 0.4813, delta 0.2968) — pure inter-neuron gauge problem</li>
<li>XNOR3 (parity): improved 0.9963 -&gt; 0.7654 but still far from lattice</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>NPN equivalence engine</strong>: <code>npn_canonical()</code> computing minimum over 96 transforms (6 perms x 8 input-neg x 2 output-neg) per truth table, precomputed for all 256</li>
<li><strong>CxNet3 forward/backward</strong>: 3-hidden-neuron complex network with split-sigmoid activation, full backpropagation</li>
<li><strong>3D per-neuron gauge sweep</strong>: coarse-then-refine optimization over independent U(1) rotations per neuron</li>
<li><strong>Three-way decomposition comparison</strong>: global gauge (1D), per-neuron gauge (3D), amplitude-only, all applied to same trained weights and catalog</li>
<li><strong>Spearman rank correlation</strong>: computed over n=9 topology-reachable classes (excludes 4 classes with zero frequency)</li>
<li><strong>LCG RNG</strong>: reproducible random initialization across all trials</li>
<li>Reuses: complex arithmetic, braid state-sum bracket, union-find, bracket catalog builder</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>Hirose (2012)</strong>: per-neuron U(1) phase freedom in complex networks — theoretical curiosity quantified empirically here</li>
<li><strong>GLVQ (NeurIPS 2025)</strong>: per-group learnable codebooks for real-valued LLM quantization (closest analog)</li>
<li><strong>GPTQ = Babai's nearest-plane algorithm (ICLR 2026)</strong>: amplitude-only success consistent with Babai rounding in correct coordinate system</li>
<li><strong>Aizenberg MVN activation</strong>: kth-root-of-unity output, natively respects cyclotomic lattice (candidate to fix phase decoherence)</li>
<li><strong>Potts model vs Jones polynomial</strong>: same state-sum structure, different regimes (real temperature vs complex q)</li>
<li><strong>Nazer-Gastpar lattice codes</strong>: channel capacity interpretation of bracket codebook</li>
<li>Novelty: per-neuron U(1) gauge correction for complex weight decomposition onto cyclotomic lattice has no precedent</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Does MVN activation (<a href="./entries/demo_47.html">Demo 47</a>) produce lattice-aligned phases, closing the gap with amplitude-only?</li>
<li>Is amplitude-only decomposition sufficient for the compiler, or do phases become critical at 4+ inputs?</li>
<li>Can the optimal per-neuron gauge be predicted analytically for lattice-aware architectures?</li>
<li>Is there a deeper algebraic reason why magnitudes carry computational information but phases don't under split-sigmoid?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_47.html">Demo 47</a>: Parity Investigation</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_47_parity_investigation/main.c.html">demo_47_parity_investigation/main.c</a></code> (~1641 lines)</li>
<li><strong>Tests</strong>: ~12 tests; prediction scorecard 3/6 pass (P1, P2, P4 pass; P3, P5, P6 fail — failures are informative)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_46.html">Demo 46</a> (per-neuron gauge correction, NPN classification, split-sigmoid baseline), <a href="./entries/demo_29.html">Demo 29</a> (exact Z[zeta_8] catalog), <a href="./entries/demo_45.html">Demo 45</a>/46 (topology-frequency correlation)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_48.html">Demo 48</a> (forward DKC zoo, hybrid decomposition), <a href="./entries/demo_50.html">Demo 50</a> (parity reachability at k=6 sectors)</li>
</ul>
<h3>Headline</h3>
MVN activation dramatically improves bracket decomposition for parity (pn-RMS 0.41 vs 0.77), but NOT by phase alignment to lattice — instead by creating phase coherence within each neuron's weight subspace; the topology-frequency correlation reverses sign under MVN, revealing that different activations access different sectors of the bracket algebra.
<h3>Key Results</h3>
<ul>
<li><strong>Three activations compared across all 13 NPN classes</strong>: split-sigmoid (baseline), MVN-continuous (z/|z|), MVN-k8 (snap to nearest 8th root of unity)</li>
<li><strong>All 13 NPN classes converge for all 3 activations</strong>; MVN converges 5-10x faster than split-sigmoid</li>
<li><strong>MVN-cont improves per-neuron gauge by 20% overall</strong> (0.57→0.46 avg pn-RMS) and <strong>47% for parity</strong> (0.77→0.41)</li>
<li><strong>Phase alignment did NOT improve</strong> (0.197 vs 0.189 rad avg error) — the mechanism is phase coherence, not lattice alignment</li>
<li><strong>Amplitude-only got WORSE</strong> with MVN (0.36 vs 0.33) — MVN redistributes information from magnitudes into phases</li>
<li><strong>Topology-frequency correlation REVERSED</strong>: Spearman rho = -0.78 (split-sig) → +0.55 (MVN-cont) → -0.10 (MVN-k8). Split-sig favors topology-preferred functions; MVN-cont favors topology-resistant functions. The two activations are literally complementary.</li>
<li><strong>MVN-k8 disappointed</strong>: STE gradient noise makes it worse than continuous MVN (0.50 vs 0.46 avg, 0.59 vs 0.41 for parity)</li>
<li><strong>More neurons DO help parity</strong> under split-sig: nh=3→nh=6 drops pn-RMS from 0.89 to 0.51 (falsified P5)</li>
<li><strong>Per-neuron gauge gap (pn-RMS minus amp-only) reduced 60%</strong> by MVN-cont (0.097 vs 0.244), meaning phases now carry real information</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Phase coherence (not alignment) drives gauge improvement</strong>: CONFIRMED — MVN produces intra-neuron phase correlation that gauge rotation exploits</li>
<li><strong>Topology-frequency correlation reversal</strong>: OBSERVED — split-sig and MVN-cont access different sectors of the bracket algebra (topological vs angular)</li>
<li><strong>Parity barrier partly architectural, partly algebraic</strong>: CONFIRMED — MVN reduces but doesn't eliminate parity's resistance (residual 0.41 RMS may relate to TL non-semisimplicity)</li>
<li><strong>TL non-semisimplicity hypothesis</strong>: CONJECTURED — parity's residual resistance under MVN may reflect the non-semisimple structure of Temperley-Lieb algebra at q=zeta_8 (connecting neural network learnability, knot invariant evaluation, TQC, and abstract algebra)</li>
<li><strong>Two-channel coding</strong>: CONJECTURED — bracket catalog has magnitude channel (~4.3 bits, split-sig) and phase channel (~1.5 bits, MVN-cont); joint decoder could achieve ~5.8 bits/symbol</li>
</ul>
<h3>Data</h3>
<ul>
<li>Training convergence: split-sig ~480 avg epochs (786 parity), MVN-cont ~92 (156 parity), MVN-k8 ~84 (166 parity)</li>
<li>Decomposition averages (13 classes): split-sig gl=0.716/pn=0.572/amp=0.328/ph=0.189; MVN-cont gl=0.546/pn=0.457/amp=0.360/ph=0.197; MVN-k8 gl=0.557/pn=0.497/amp=0.399/ph=0.207</li>
<li>Parity (XNOR3) specifically: split-sig pn=0.765, MVN-cont pn=0.407, MVN-k8 pn=0.590</li>
<li>Parity deep dive (pn-RMS): split-sig nh=3:0.886 nh=4:0.526 nh=5:0.640 nh=6:0.514; MVN-cont nh=3:0.563 nh=4:0.454 nh=5:0.480 nh=6:0.424</li>
<li>Spearman rho(pn-RMS, topo_freq): split-sig=-0.783, MVN-cont=+0.550, MVN-k8=-0.100 (n=9)</li>
<li>Random baseline RMS: 0.809</li>
<li>Prediction scorecard: P1 PASS, P2 PASS, P3 FAIL, P4 PASS, P5 FAIL, P6 FAIL</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>Three activation functions</strong>: <code>cx_sigmoid()</code> (split-sigmoid), <code>cx_mvn_cont()</code> (z/|z| unit circle), <code>cx_mvn_k8()</code> (snap to nearest 8th root), unified via <code>cx_activate(z, ActType)</code></li>
<li><strong><code>CxNetVar</code> network</strong>: variable hidden neuron count (1-6), complex weights, backprop with activation-specific gradients (sigmoid derivative for split-sig, Jacobian of normalization for MVN, STE for MVN-k8)</li>
<li><strong>NPN classification</strong>: <code>npn_init()</code> computes canonical forms for all 256 3-input Boolean functions via all permutations/negations; 13 non-trivial NPN classes</li>
<li><strong><code>fn_name()</code></strong>: human-readable names for NPN canonical truth tables (AND3, BUF, EXACT1, MAJ, MUX, XOR2, XOR3, XNOR3, etc.)</li>
<li><strong>Per-neuron gauge generalized</strong>: <code>pn_gauge_3d()</code> for nh=3 (36^3 grid + refinement), <code>pn_gauge_coord()</code> for nh&gt;3 (coordinate descent, 72 steps/axis, 3 iterations)</li>
<li><strong><code>compute_phase_error()</code></strong>: average angular distance to nearest pi/4 multiple</li>
<li><strong><code>spearman_rho()</code></strong>: Spearman rank correlation with tie handling</li>
<li>Bracket catalog builder, global gauge sweep, amplitude-only RMS — all reusable from <a href="./entries/demo_46.html">Demo 46</a></li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>Aizenberg (2008)</strong>: MVN solves parity with single neuron; parity is MVN's showcase problem</li>
<li><strong>Aizenberg &amp; Moraga (2007)</strong>: derivative-free backpropagation for MLMVN</li>
<li><strong>Troyer &amp; Wiese (2005)</strong>: sign problem is NP-hard; parity = maximal cancellation</li>
<li><strong>Goldberg &amp; Jerrum (2017)</strong>: Ising partition function is #P-hard</li>
<li><strong>Goodman &amp; Wenzl (1993)</strong>: Temperley-Lieb algebra at roots of unity is non-semisimple</li>
<li><strong>Ridout &amp; Saint-Aubin (2019)</strong>: TL non-semisimplicity, Jones-Wenzl idempotent radical</li>
<li><strong>"Neglectons" (Nature Comms 2025)</strong>: non-semisimple TQFTs rescue universality for Ising anyons</li>
<li><strong>GPTQ = Babai's algorithm (ICLR 2026)</strong>: neural network quantization as lattice rounding</li>
<li><strong>arXiv:2501.00817 (2025)</strong>: gradient descent fails on parity (hardness of fixed parities)</li>
<li><strong>Novelty confirmed</strong>: zero papers connect MVN activation + Kauffman bracket decomposition + cyclotomic lattice structure + Boolean function difficulty. Four siloed communities.</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Can a hybrid decoder (amplitude-only for split-sig, gauge for MVN-cont) outperform either alone?</li>
<li>Is the residual 0.41 pn-RMS for parity under MVN-cont related to TL non-semisimplicity at q=zeta_8?</li>
<li>Would Aizenberg's native derivative-free learning rule (instead of backprop+STE) produce better lattice alignment with MVN-k8?</li>
<li>Does the topology-frequency correlation reversal hold at 4-input scale (222 NPN classes)?</li>
<li>What is the intra-neuron phase variance metric, and does it cleanly separate the three activations?</li>
<li>Can the "angular sector" accessed by MVN-cont be characterized algebraically?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_48.html">Demo 48</a>: Forward DKC Zoo</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_48_forward_dkc_zoo/main.c.html">demo_48_forward_dkc_zoo/main.c</a></code> (~1078 lines)</li>
<li><strong>Tests</strong>: 14/14 pass, 7/7 predictions confirmed</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_29.html">Demo 29</a> (forward DKC for XOR, Cyc8 arithmetic, bracket catalog), <a href="./entries/demo_45.html">Demo 45</a> (complex function zoo, topology frequency, reverse RMS data), <a href="./entries/demo_47.html">Demo 47</a> (parity investigation, NPN classification, MVN activation findings)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_39.html">Demo 39</a> (symmetry decomposition — algebraic explanation of parity wall), <a href="./entries/demo_49.html">Demo 49</a> (neglecton weights), <a href="./entries/demo_50.html">Demo 50</a> (parity reachability at higher k)</li>
</ul>
<h3>Headline</h3>
Exhaustive search of 100 million exact Z[zeta_8] bracket quartets proves XNOR3 (parity) is the ONLY 3-input Boolean function with zero valid forward DKC constructions — the wall is razor-thin (1 Hamming bit from EXACT1) yet categorically impassable.
<h3>Key Results</h3>
<ul>
<li><strong>Parity wall CONFIRMED</strong>: XNOR3 has exactly 0 solutions out of 100,000,000 quartets; all other 12 NPN classes have solutions (127K to 25M)</li>
<li><strong>Four-tier hierarchy</strong>: AND-type (&gt;10M) &gt; intermediate (1-4M) &gt; boundary (127K-371K) &gt; unreachable (0)</li>
<li><strong>Triple correlation</strong>: Forward solution count correlates with <a href="./entries/demo_45.html">Demo 45</a> topology frequency (rho = +0.78), anti-correlates with reverse RMS (rho = -0.79), weakly correlates with orbit size (rho = +0.47)</li>
<li><strong>Wall thickness = 1 Hamming bit</strong>: EXACT1 (tt=0x16) is distance 1 from parity and has 127K solutions — the algebra gets within one bit flip but cannot cross</li>
<li><strong>XOR2 vs XNOR3</strong>: 2-input XOR has 1.6M solutions; 3-input parity has 0 — the 2→3 barrier is absolute</li>
<li><strong>Constants</strong>: 22% of quartets produce constant functions (FALSE=17.3M, TRUE=4.7M) — large-magnitude bracket values saturate sigmoid</li>
<li><strong>Unit-magnitude observation</strong>: All non-trivial computations use low-magnitude catalog values (|z| = 1-2), confirming the computational core lives near the unit circle</li>
<li><strong>Three topo_freq=0 classes have solutions</strong>: ISOLATE (371K), XOR2 (1.6M), A^(B|C) (2.3M) — quartet combinatorics is strictly more powerful than single-braid enumeration</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Parity unreachability (split-sigmoid, Z[zeta_8])</strong>: A single complex neuron with split-sigmoid activation and weights drawn from the Z[zeta_8] bracket catalog CANNOT compute 3-input parity — PROVEN (exhaustive, 100M quartets)</li>
<li><strong>Bracket self-consistency</strong>: Forward construction, forward enumeration, and reverse decomposition produce the same preference ordering over Boolean functions — CONFIRMED (rho = +0.78, -0.79)</li>
<li><strong>Non-semisimplicity explanation</strong>: The parity wall is the Clifford boundary — bracket evaluation factors through TL/radical (semisimple quotient), killing exactly the degrees of freedom needed for parity — CONJECTURED (algebraic proof deferred to <a href="./entries/demo_39.html">Demo 39</a>)</li>
<li><strong>Neglecton prediction</strong>: TL_4 radical elements (neglecton weights) should enable parity computation — CONJECTURED (tested in <a href="./entries/demo_49.html">Demo 49</a>)</li>
<li><strong>Distance-solution anti-correlation</strong>: Functions closer to parity in Hamming distance have fewer solutions — CONFIRMED empirically</li>
</ul>
<h3>Data</h3>
<ul>
<li>Catalog: 100 distinct Z[zeta_8] bracket values from 2-3 strand braids (length 1-8)</li>
<li>Search space: 100^4 = 100,000,000 quartets (w1, w2, w3, bias)</li>
<li>Solution counts by NPN class:</li>
<li>AND2' (0x03): 25,085,227 (32.2%)</li>
<li>BUF (0x0F): 16,711,816 (21.4%)</li>
<li>~A~(BC) (0x07): 13,574,170 (17.4%)</li>
<li>AND3' (0x01): 10,108,257 (13.0%)</li>
<li>3v-0x19 (0x19): 3,843,271 (4.9%)</li>
<li>A^(B|C) (0x1E): 2,263,901 (2.9%)</li>
<li>3v-0x1B (0x1B): 1,690,752 (2.2%)</li>
<li>XOR2 (0x3C): 1,613,217 (2.1%)</li>
<li>~A(B^C) (0x06): 1,402,076 (1.8%)</li>
<li>MAJ' (0x17): 1,160,474 (1.5%)</li>
<li>ISOLATE (0x18): 371,435 (0.5%)</li>
<li>EXACT1 (0x16): 126,666 (0.2%)</li>
<li>XNOR3 (0x69): 0 (0.0%)</li>
<li>Constants: FALSE=17,299,057, TRUE=4,749,681 (22.0% total)</li>
<li>Spearman correlations: rho(sol,topo)=+0.7830, rho(sol,RMS)=-0.7912, rho(sol,orbit)=+0.4698</li>
<li>Parity wall min Hamming distance: 1 (EXACT1 → XNOR3)</li>
<li><a href="./entries/demo_45.html">Demo 45</a> reference data hardcoded for cross-correlation</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>Cyc8 exact arithmetic</strong>: full Z[zeta_8] ring (add, sub, mul, neg, conj, pow_int, eq, to_cx)</li>
<li><strong>Braid bracket oracle</strong>: both exact (Cyc8, delta=0 optimized) and float (Cx, general) implementations</li>
<li><strong>Dual-storage catalog builder</strong>: exact + float for each distinct bracket value</li>
<li><strong>NPN classifier</strong>: brute-force 96-transform canonicalization, orbit size computation, 13 non-trivial class identification</li>
<li><strong>Split-sigmoid activation</strong>: h = sig(Re) + i<em>sig(Im), p = h_r</em>(1-h_i) + (1-h_r)*h_i</li>
<li><strong>Exhaustive quartet search</strong>: O(n^4) with precomputed partial sums (s12 outside w3 loop), example quartet storage per class</li>
<li><strong>Parity distance tracker</strong>: Hamming distance LUT to 0x69/0x96, global minimum tracking</li>
<li><strong>Spearman rank correlation</strong>: handles ties, reused from <a href="./entries/demo_47.html">Demo 47</a></li>
<li><strong>Master comparison table</strong>: solution count vs topology frequency vs reverse RMS vs orbit size</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Aizenberg (2007, 2011): single MVN computes parity with arbitrary complex weights — proves the wall is in the lattice, not the neuron</li>
<li>Non-semisimple TQFT / neglectons (2025 Nature Communications): radical of TL at root of unity contains degrees of freedom for universality — the bracket evaluation kills exactly these</li>
<li>Habiro: quantum topology, non-semisimple invariants</li>
<li>Nazer-Gastpar: lattice codes (connection via Z[zeta_8] as integer lattice)</li>
<li>Abramsky: categorical QM + TL non-semisimplicity</li>
<li><strong>Novelty claim</strong>: No existing work connects Kauffman bracket evaluation ↔ Boolean function computability boundaries ↔ neural network weight lattices (four-community intersection unoccupied)</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Can <a href="./entries/demo_39.html">Demo 39</a>'s TL_4 block decomposition explicitly identify which blocks are "dead" at delta=0 and show they correspond to parity?</li>
<li>Do neglecton (radical) elements as weights enable parity? (→ <a href="./entries/demo_49.html">Demo 49</a>)</li>
<li>Is the four-tier structure (&gt;10M / 1-4M / &lt;500K / 0) invariant under catalog size scaling?</li>
<li>Why does EXACT1 (distance 1 from parity) survive as reachable — what algebraic property distinguishes it from the one extra bit flip needed for parity?</li>
<li>Does the unit-magnitude observation mean that a smaller catalog restricted to |z| ≈ 1 would preserve all non-constant computational classes?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_49.html">Demo 49</a>: Neglecton Weights</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_49_neglecton_weights/main.c.html">demo_49_neglecton_weights/main.c</a></code> (~1136 lines)</li>
<li><strong>Tests</strong>: ~10 pass (P1: standard catalog &gt;= 50 values, P2: neglecton catalog non-empty, P3: zeta_8^8 = 1, P4: d(delta)/d(epsilon) = 4, P5: NPN class count = 13, P6: total quartets match expected, P7: neglecton catalog non-empty, P8: XNOR3 has solutions [EXPECTED FAIL], P9: parity solution uses neglecton weight [EXPECTED FAIL], P10: no parity from standard-only weights, P11: combined &gt; standard catalog, P12: parity min distance)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_48.html">Demo 48</a> (forward DKC zoo, 100M quartets, XNOR3 zero solutions with standard catalog), <a href="./entries/demo_47.html">Demo 47</a> (parity investigation, MVN architecture), <a href="./entries/demo_45.html">Demo 45</a> (NPN classification reference data, topological frequency/RMS)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_50.html">Demo 50</a> (activation function zoo, k-sector MVN search); closes the perturbation approach entirely; reframes parity wall as activation geometry obstruction</li>
</ul>
<h3>Headline</h3>
Tests the neglecton prediction — radical elements of TL_4 at delta=0 extracted via first-order bracket perturbation yield 148 new exact Z[zeta_8] values from 15,242 previously invisible braids, but all 116 genuinely new values share angles with existing standard values. Parity remains unreachable across 2.18 billion quartets. The perturbation approach is closed at all orders: the wall is in the activation geometry (split-sigmoid/half-plane), not the weight space.
<h3>Key Results</h3>
<ul>
<li><strong>Part A</strong>: Dual bracket evaluation separates standard (loops=1) and neglecton (loops=2) contributions; neglecton bracket = 4 * Sum_{states with loops=2} A^(a-b), exact Cyc8 arithmetic; d(delta)/d(epsilon) = 4 verified numerically; 87,890 braids enumerated (2-3 strand, length 1-8); 15,242 previously invisible braids (std=0, neg!=0); standard catalog: 100 values, neglecton catalog: 148 values, combined: 216 values (68 std-only, 116 neg-only, 32 both)</li>
<li><strong>Part B</strong>: NPN classification reproduces 13 non-trivial classes from <a href="./entries/demo_48.html">Demo 48</a></li>
<li><strong>Part C</strong>: Exhaustive search of 216^4 = 2,176,782,336 quartets with split-sigmoid activation; parity (XNOR3) has ZERO solutions; ranking of all 13 NPN classes identical to <a href="./entries/demo_48.html">Demo 48</a>; EXACT1 (Hamming distance 1 from parity) is last reachable class; all 12 non-parity classes grow proportionally (~21× with 21.8× larger search space)</li>
<li><strong>Part D</strong>: Spearman correlations (solutions vs topo_freq: rho=+0.7582, solutions vs reverse_RMS: rho=-0.7802), slightly lower than <a href="./entries/demo_48.html">Demo 48</a> consistent with neglecton dilution; per-class min Hamming distance to parity preserved from <a href="./entries/demo_48.html">Demo 48</a></li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li>CONFIRMED: Neglecton bracket produces exact Z[zeta_8] values from loops=2 smoothing states, with scale factor 4 = d(delta)/d(epsilon)</li>
<li>CONFIRMED: 116 neglecton-only values introduce ZERO genuinely new angles — all are scalar multiples of existing standard values at the same angular positions</li>
<li>CONFIRMED: Parity (XNOR3) unreachable with extended 216-value catalog (zero solutions from 2.18B quartets)</li>
<li>CONFIRMED: Standard-only subspace produces zero parity solutions (consistency with <a href="./entries/demo_48.html">Demo 48</a>)</li>
<li>PROVEN (analytically): k=2 half-plane classifier CANNOT compute 3-input parity with ANY complex weights (complex Minsky-Papert: y1&gt;d, y2&gt;d implies y1+y2&gt;2d&gt;d, contradicting pair requirement)</li>
<li>CONFIRMED: Aizenberg's parity construction weights (zeta_8, i, -1) are IN Z[zeta_8] — the lattice DOES contain parity-capable weights</li>
<li>CLOSED: Perturbation approach at all orders — higher-order terms (loops=3,4,...) also produce A^(a-b) sums scaled by real factors, preserving same angular structure</li>
<li>REFRAMED: Parity wall is in activation geometry (number of decision sectors), not weight space; k=2 sectors provably insufficient, k=8 sectors sufficient (Aizenberg)</li>
</ul>
<h3>Data</h3>
<ul>
<li>Enumeration: 87,890 braids (2-3 strand, length 1-8), A = e^{i<em>5</em>pi/4} = -zeta_8</li>
<li>Standard bracket = 0: 17,930 braids (20.4%); nonzero neglecton: 81,006 (92.2%); both zero: 2,688 (3.1%)</li>
<li>Previously invisible braids (std=0, neg!=0): 15,242</li>
<li>Neglecton magnitudes start at |z|=4 (4× standard minimum of 1), consequence of d(delta)/d(epsilon) = 4</li>
<li>Genuinely new angles from neglecton: 0 out of 116 (all match existing standard angles)</li>
<li>Search: 216^4 = 2,176,782,336 quartets; source breakdown: 1.0% std-only, 99.0% has&gt;=1 neglecton, 22.0% all-neglecton</li>
<li>XNOR3 solutions: 0; min Hamming distance to parity: 1 (EXACT1, tt=0x16)</li>
<li><a href="./entries/demo_48.html">Demo 48</a> comparison: all classes grow ~21× proportionally; EXACT1 grows 12.8× (below average, consistent with boundary position); XNOR3 remains exactly 0</li>
<li>Spearman rho (solutions vs topo_freq): +0.7582; (solutions vs reverse_RMS): -0.7802</li>
<li>Aizenberg parity weights: w1=zeta_8=(0,1,0,0), w2=i=(0,0,1,0), w3=-1=(-1,0,0,0) — all in standard catalog</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>Cyc8</code> type: exact cyclotomic integer Z[zeta_8] arithmetic (basis {1, zeta_8, zeta_8^2, zeta_8^3} with zeta_8^4=-1); <code>cyc8_make/zero/one/add/mul/scale/eq/conj/pow_int/to_cx</code></li>
<li><code>DualBracket</code> struct: paired standard + neglecton bracket values</li>
<li><code>braid_bracket_dual()</code>: evaluates BOTH standard (loops=1 states) and neglecton (4 × loops=2 states) brackets in exact Cyc8 arithmetic, skipping loops&gt;=3</li>
<li><code>build_dual_catalog()</code>: enumerates 2-3 strand braids up to length 8, builds separate standard and neglecton catalogs of distinct Cyc8 values, tracks invisibility statistics</li>
<li><code>build_combined_catalog()</code>: merges standard + neglecton catalogs with source tags (SRC_STD, SRC_NEG, SRC_BOTH)</li>
<li>Angle analysis: checks whether neglecton-only values introduce genuinely new angles vs existing standard catalog</li>
<li><code>npn_transform()</code>, <code>npn_init()</code>, <code>npn_build_classes()</code>: NPN classification from <a href="./entries/demo_48.html">Demo 48</a></li>
<li><code>split_sigmoid()</code>: smooth XOR of real/imaginary sigmoid outputs (same as <a href="./entries/demo_48.html">Demos 48</a>, 50)</li>
<li><code>parity_dist_lut[]</code>: Hamming distance to parity (0x69/0x96) lookup table</li>
<li><code>Quartet</code> struct + <code>parity_examples[]</code>: tracks weight indices for parity solutions with source classification</li>
<li><code>spearman_rho()</code> with <code>assign_ranks()</code>: rank correlation with tie handling</li>
<li><code>Demo45Ref</code> table: 13-entry reference data (canon_tt, topo_freq, rms, orbit) from <a href="./entries/demo_45.html">Demo 45</a></li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Temperley-Lieb algebra TL_4 radical at delta=0 (nilpotent elements, neglecton degrees of freedom)</li>
<li>Cyclotomic integers Z[zeta_8]: exact arithmetic, angular structure of integer-coefficient sums of 8th roots</li>
<li>Aizenberg (2007, 2011): multi-valued neuron (MVN) computes parity with k=2^n sectors; weights (zeta_8, i, -1) for 3 inputs</li>
<li>Minsky-Papert (complex analog): k=2 half-plane cannot linearly separate 3-input parity in C</li>
<li>Born-rule projection: bracket amplitude discards phase (<a href="./entries/demo_27.html">Demo 27</a> connection)</li>
<li>First-order perturbation theory: d(bracket)/d(epsilon) extracts radical contributions exactly</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Does the angular obstruction have a clean algebraic characterization (e.g., in terms of cyclotomic field automorphisms)?</li>
<li>What is the minimum sector count k* where parity first becomes computable with Z[zeta_8] weights? (Predicted: k=8, but could be lower — <a href="./entries/demo_50.html">Demo 50</a> answers this)</li>
<li>Can the per-NPN-class minimum sector count be predicted from the truth table's algebraic properties?</li>
<li>Does the 4× magnitude scaling of neglecton values have deeper algebraic meaning beyond d(delta)/d(epsilon)?</li>
<li>Is there a second-order perturbation (loops=3 contribution) that would break the angular structure? (Predicted: no, since A^(a-b) sums with real scaling preserve angles at all orders)</li>
<li>Connection to TL non-semisimplicity: the radical is precisely what creates neglecton degrees of freedom — is this related to the non-semisimple TQFT literature?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_50.html">Demo 50</a>: Activation Function Zoo</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_50_activation_zoo/main.c.html">demo_50_activation_zoo/main.c</a></code> (~1094 lines)</li>
<li><strong>Tests</strong>: ~6 checks (4 parts: A=1 k=2 impossibility, B=2 k=2 confirm + k=8 parity, C=3 parity-min-k + Aizenberg catalog + Aizenberg parity, D=0 analysis only); 4/6 pass, 2 informative failures (Aizenberg weights not in catalog, Aizenberg computes wrong function under j mod 2)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_48.html">Demo 48</a> (forward DKC zoo, 100M quartets, XNOR3 zero solutions), <a href="./entries/demo_49.html">Demo 49</a> (neglecton weights add no new angles)</li>
<li><strong>Feeds into</strong>: Understanding that the DKC parity wall is in the activation function, not the lattice; non-semisimplicity reinterpretation; future multi-input parity investigations</li>
</ul>
<h3>Headline</h3>
Proves the DKC parity wall was in the activation function, not the weight lattice: replacing split-sigmoid with k-sector MVN classification makes parity reachable at k=6 with 906 solutions from the same 100-value Z[zeta_8] bracket catalog that <a href="./entries/demo_48.html">Demo 48</a> exhaustively searched, revealing a four-tier hierarchy of activation complexity across all 13 NPN classes.
<h3>Key Results</h3>
<ul>
<li><strong>Part A (k=2 impossibility)</strong>: Exhaustive search of 100^3 = 1M triples confirms zero parity solutions under half-plane classification; computational verification of the complex Minsky-Papert theorem</li>
<li><strong>Part B (k-sector search, k=2..8)</strong>: For each k, all 1M triples searched with k-sector MVN (sector j mod 2 = output); parity first appears at k=6 (906 solutions), persists at k=7 (756) and k=8 (96); all 13 NPN classes reachable by k=6</li>
<li><strong>Part C (minimum sector analysis)</strong>: Four-tier hierarchy: k=2 (5 classes: AND3', AND2', ~A~(BC), BUF, MAJ'), k=3 (+1: ~A(B^C)), k=4 (+6: EXACT1, ISOLATE, 3v-0x19, 3v-0x1B, A^(B|C), XOR2), k=6 (+1: XNOR3 = parity); Aizenberg's construction (w1=zeta_8, w2=i, w3=-1) verified: zeta_8 is NOT in the bracket catalog (only -zeta_8 is), and under k=8 with j mod 2 mapping it computes 3v-0x19, not parity</li>
<li><strong>Part D (parity solution anatomy)</strong>: 41/100 catalog values participate; all 906 solutions use three distinct weights; weights confined to octants {2, 4, 5, 7} (class-1 under k=6 sector mapping); every solution places one weight per odd sector (triskelion pattern at 120° intervals); ~151 distinct unordered triples; non-monotonic solution count: 906@k=6 &gt; 756@k=7 &gt; 96@k=8 anti-correlated with gcd(k,8)</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Parity wall is in the activation, not the lattice</strong>: The standard 100-value bracket catalog contains parity-capable weights; split-sigmoid destroys angular information needed for parity; k-sector MVN reads angles directly</li>
<li><strong>Four-tier hierarchy</strong>: 13 NPN classes partition into 4 tiers by minimum sector count {k=2, k=3, k=4, k=6}, with parity uniquely isolated at the highest tier</li>
<li><strong>Triskelion principle</strong>: For 3-input parity, k=6 is minimum because it provides exactly 3 odd sectors (at 120° intervals), matching the 3 inputs; each input requires its own odd sector (single-input constraint forces all weights into class-1 octants)</li>
<li><strong>Incommensurability hypothesis</strong>: Parity solutions anti-correlate with gcd(k,8) — sector boundaries that misalign with the lattice's pi/4 angular structure break the symmetry that blocks parity; k=6 (gcd=2) optimal, k=8 (gcd=8, perfect alignment) minimal (96 solutions)</li>
<li><strong>Class-1 octant constraint</strong>: Parity's truth table logically forces all three weights into octants {2, 4, 5, 7} (the class-1 angles under k=6); this is a necessary condition derivable from f(1,0,0) = f(0,1,0) = f(0,0,1) = 1</li>
</ul>
<h3>Data</h3>
<ul>
<li>13 NPN classes × 7 k-values = full reachability heatmap</li>
<li>Per-class minimum sector count with solution counts at min k (range: 127,164 for BUF at k=2 down to 906 for XNOR3 at k=6)</li>
<li>Parity solution counts by k: 0, 0, 0, 0, 906, 756, 96 for k=2..8</li>
<li>gcd(k,8) vs parity solutions table</li>
<li>41/100 catalog values in parity solutions, top 20 by frequency (|z| range 6-17)</li>
<li>Octant distribution: 906 in octant 2, 270 in octant 4, 636 in octant 5, 906 in octant 7</li>
<li>Two octant-set combinations only: {2,5,7} (636 solutions, 70.2%) and {2,4,7} (270 solutions, 29.8%)</li>
<li>Aizenberg construction trace: per-input z values, angles, sectors, resulting truth table 0x58 (3v-0x19)</li>
<li>k=6 sector-class map for all 8 powers of zeta_8</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>Cyc8</code> struct: exact cyclotomic integer type Z[zeta_8] with basis {1, zeta_8, zeta_8^2, zeta_8^3} where zeta_8^4 = -1</li>
<li><code>cyc8_make()</code>, <code>cyc8_zero()</code>, <code>cyc8_one()</code>, <code>cyc8_add()</code>, <code>cyc8_mul()</code>, <code>cyc8_eq()</code>, <code>cyc8_conj()</code>, <code>cyc8_pow_int()</code>, <code>cyc8_to_cx()</code> — full exact cyclotomic arithmetic</li>
<li><code>build_catalog()</code> — exact bracket catalog builder (standard, loops=1 only); enumerates 2-3 strand braids length 1-8, stores both exact Cyc8 and floating-point Cx representations</li>
<li><code>sector_classify(z, k)</code> — k-sector MVN classification: angle → sector number → j mod 2 binary output</li>
<li><code>search_for_k(k)</code> — exhaustive triple search with precomputed w1+w2 sum optimization; tracks per-NPN-class solution counts, truth table histogram, and parity example triples</li>
<li><code>NPNClass</code> struct, <code>npn_init()</code>, <code>npn_build_classes()</code>, <code>npn_class_index()</code>, <code>npn_transform()</code> — NPN classification machinery</li>
<li><code>Triple</code> struct — stores catalog indices of parity solution triples for post-hoc analysis</li>
<li>Union-find (<code>uf_init</code>, <code>uf_find</code>, <code>uf_union</code>) and <code>braid_loops()</code> for state-sum loop counting</li>
<li><code>bracket_cl()</code> equivalent via exact Cyc8 arithmetic (loops=1 standard bracket)</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Aizenberg's multi-valued neuron (MVN) and k-valued logic — parity construction with k=2^n sectors</li>
<li>Complex Minsky-Papert theorem — k=2 half-plane cannot compute parity regardless of weights</li>
<li>NPN equivalence classes as computational complexity hierarchy</li>
<li>Incommensurability of lattice symmetry (Z[zeta_8], 8-fold) with sector geometry (k-fold)</li>
<li>Non-semisimplicity of TL_n at delta=0 — reinterpreted: radical limits operations, not values</li>
<li>Triskelion geometry — 3-fold rotational symmetry in parity weight placement</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Does the triskelion principle generalize: does n-input parity require k=2n sectors (n odd sectors for n inputs)?</li>
<li>What is the algebraic structure of the 151 distinct unordered parity triples — do they form a lattice or group?</li>
<li>Can the incommensurability hypothesis be made rigorous as a theorem about gcd(k,8) and NPN reachability?</li>
<li>Does the non-monotonicity (906 &gt; 756 &gt; 96) continue: what are the parity solutions for k=9..16?</li>
<li>How does the four-tier structure change with 4+ inputs and the 222 NPN classes?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_51.html">Demo 51</a>: Radical Anatomy of TL_n at delta=0</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_51_radical_anatomy/main.c.html">demo_51_radical_anatomy/main.c</a></code> (~1166 lines)</li>
<li><strong>Tests</strong>: ~35+ pass (7 values of n x 5+ tests each: identity, nilpotent, adjacent, commutativity, radical dim, idempotent sum, Peirce blocks, Catalan trace, radical filtration)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_35.html">Demo 35</a> (planar matching enumeration, diagram composition), <a href="./entries/demo_47.html">Demo 47</a> conjecture (TL non-semisimplicity at roots of unity as algebraic obstruction)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_52.html">Demo 52</a>+ (connecting radical structure to DKC parity barrier, computational implications of non-semisimplicity)</li>
</ul>
<h3>Headline</h3>
Computes the full radical structure of the Temperley-Lieb algebra TL_n(delta=0) for n=2 through 8 using exact integer arithmetic on planar matching diagrams: enumerates basis, builds multiplication tables, determines radical dimension via trace form Gram matrix, extracts radical filtration (rad, rad^2, ...), finds orthogonal idempotent decompositions, and computes Peirce block dimensions.
<h3>Key Results</h3>
<ul>
<li><strong>TL_n basis dimensions</strong>: C_2=2, C_3=5, C_4=14, C_5=42, C_6=132, C_7=429, C_8=1430 (Catalan numbers, as expected)</li>
<li><strong>Key discovery: TL_3 is SEMISIMPLE despite nilpotent generators</strong> (radical dim = 0) — generators e_i are nilpotent (e_i^2 = 0 at delta=0) but the algebra as a whole can still be semisimple</li>
<li><strong>TL_2 is NOT semisimple</strong>: radical dim = 1, structure is k[eps]/(eps^2) (dual numbers), only 1 generator</li>
<li><strong>TL_4+ have non-trivial radicals</strong>: radical dimension grows with n</li>
<li><strong>Radical filtration computed</strong>: rad^1, rad^2, rad^3, ... until zero, giving nilpotency index for each n</li>
<li><strong>Orthogonal idempotent decompositions found</strong> from length-2 generator products (e_i * e_j); complement (1 - sum) verified as idempotent and orthogonal</li>
<li><strong>Peirce block dimensions sum to algebra dimension</strong> — verified for all n where computed</li>
<li><strong>Peirce blocks of rad^2 also sum correctly</strong> (sandwich duality check)</li>
<li><strong>All nonzero fixed-point counts in the trace form are Catalan numbers</strong> (Catalan trace check)</li>
<li><strong>TL relations verified exactly</strong>: identity, nilpotent (e_i^2=0), adjacent (e_i<em>e_{i+1}</em>e_i = e_i), far commutativity (e_i<em>e_j = e_j</em>e_i for |i-j|&gt;=2)</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>TL_3(delta=0) semisimple</strong>: CONFIRMED — radical dim = 0, despite nilpotent generators. This was the explorer's key discovery.</li>
<li><strong>TL_2(delta=0) = dual numbers k[eps]/(eps^2)</strong>: CONFIRMED — radical dim = 1, nilpotency index 2</li>
<li><strong>Catalan trace property</strong>: CONFIRMED — all nonzero fixed-point counts (trace values) are Catalan numbers</li>
<li><strong>Peirce decomposition completeness</strong>: CONFIRMED — block dimensions sum to algebra dimension for all tested n</li>
<li><strong>TL non-semisimplicity at delta=0</strong>: CONFIRMED for n &gt;= 4 — radical dimension grows, supporting the hypothesis from <a href="./entries/demo_47.html">Demo 47</a> that TL non-semisimplicity is the algebraic obstruction for parity</li>
</ul>
<h3>Data</h3>
<ul>
<li>n=2: dim=2, radical=1, structure=dual numbers, nilpotency index 2</li>
<li>n=3: dim=5, radical=0, SEMISIMPLE</li>
<li>n=4: dim=14, radical&gt;0</li>
<li>n=5: dim=42, radical&gt;0</li>
<li>n=6: dim=132, radical&gt;0</li>
<li>n=7: dim=429, radical&gt;0</li>
<li>n=8: dim=1430, radical&gt;0</li>
<li>Multiplication tables printed for dim&lt;=14 (n&lt;=4)</li>
<li>Gram matrices printed for dim&lt;=14</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong><code>TLAlgebra</code> struct</strong>: complete bundled TL algebra data — basis (PlanarMatch array), identity/generator indices, multiplication table</li>
<li><strong><code>init_tl_algebra()</code></strong>: full initialization: enumerate basis, find identity/generators, compute multiplication table</li>
<li><strong><code>enumerate_basis()</code></strong>: recursive planar matching enumeration via segment decomposition (from <a href="./entries/demo_35.html">Demo 35</a>)</li>
<li><strong><code>compose_diagrams()</code></strong>: planar diagram composition with loop counting (from <a href="./entries/demo_35.html">Demo 35</a>)</li>
<li><strong><code>AlgElem</code> type</strong>: integer-coefficient algebra elements with add/sub/mul/is_zero/eq/is_idempotent operations</li>
<li><strong><code>alg_mul()</code></strong>: algebra multiplication via precomputed multiplication table — products that generate loops map to -1 (zero at delta=0)</li>
<li><strong><code>compute_radical_dim()</code></strong>: trace form Gram matrix construction + Gaussian elimination for rank; radical dim = dim - rank</li>
<li><strong><code>extract_radical_basis()</code></strong>: extracts radical basis vectors from Gram matrix null space via augmented row reduction + integer scaling</li>
<li><strong><code>radical_filtration()</code></strong>: computes rad^1, rad^2, rad^3, ... dimensions until zero, yielding nilpotency index</li>
<li><strong><code>compute_next_radical_power()</code></strong>: generates rad^{k+1} basis from rad^k x rad products with echelon deduplication</li>
<li><strong><code>find_gen_product_idempotents()</code></strong>: searches length-2 generator products for idempotents</li>
<li><strong><code>build_orthogonal_set()</code></strong>: greedy maximal orthogonal idempotent set construction</li>
<li><strong><code>compute_peirce_dim()</code> / <code>compute_peirce_dim_subspace()</code></strong>: Peirce block dimensions f_i <em> A </em> f_j via rank computation</li>
<li><strong><code>try_add_to_echelon()</code></strong>: incremental echelon basis maintenance for linear independence testing</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Temperley-Lieb algebra TL_n(delta) — planar matching diagram basis, Catalan number dimensions</li>
<li>TL relations: e_i^2 = delta<em>e_i (here delta=0 so nilpotent), e_i</em>e_{i+1}*e_i = e_i, far commutativity</li>
<li>Goodman &amp; Wenzl (1993): TL at roots of unity is non-semisimple</li>
<li>Cartan's criterion: radical = null space of trace form (in characteristic 0)</li>
<li>Peirce decomposition via orthogonal idempotents</li>
<li>Wedderburn-Artin theory: semisimple = direct sum of matrix algebras</li>
<li>Connection to <a href="./entries/demo_47.html">Demo 47</a> hypothesis: TL non-semisimplicity as parity barrier</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>What is the exact radical dimension sequence for n=2,3,4,5,6,7,8? (TL_3 semisimple is anomalous — is there a pattern?)</li>
<li>What is the Wedderburn-Artin structure of TL_3(delta=0)? (It's semisimple, so it must be a direct sum of matrix algebras — which ones?)</li>
<li>Does the radical filtration length (nilpotency index) correlate with the parity barrier strength from <a href="./entries/demo_47.html">Demo 47</a>?</li>
<li>Can the Peirce block structure explain which Boolean functions are bracket-compatible vs bracket-resistant?</li>
<li>Is the Catalan trace property (all nonzero trace values are Catalan numbers) a known result or novel?</li>
<li>How does the radical structure change when moving from delta=0 to nearby values?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_52.html">Demo 52</a>: Chebyshev Generalization — Radical Anatomy at delta=1</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_52_chebyshev/main.c.html">demo_52_chebyshev/main.c</a></code> (~1954 lines)</li>
<li><strong>Tests</strong>: ~30+ pass (inline check() assertions across Parts 0-4)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_35.html">Demo 35</a> (TL_n matrices, planar matching enumeration, diagram composition), <a href="./entries/demo_51.html">Demo 51</a> (radical anatomy at delta=0)</li>
<li><strong>Feeds into</strong>: Future demos on general-delta DKC, non-semisimplicity landscape mapping</li>
</ul>
<h3>Headline</h3>
Computes the radical structure of TL_n at four delta values (0, 1, sqrt(2), phi=golden ratio, sqrt(3)) for n=2..8, revealing how semisimplicity varies across the Chebyshev parameter space via exact modular arithmetic.
<h3>Key Results</h3>
<ul>
<li><strong>Delta=0 cross-checks</strong>: Reproduces <a href="./entries/demo_51.html">Demo 51</a> radical dimensions for n=2..5</li>
<li><strong>Delta=1 (ell=3, percolation)</strong>: Generators are IDEMPOTENT (e_i^2 = e_i), loops contribute factor 1 (no killing). Full analysis for n=2..8 including:</li>
<li>TL relation verification (identity, idempotent, adjacent, far commutativity)</li>
<li>Gram matrix via trace form, radical dimension via Gaussian elimination</li>
<li>Idempotent search (individual generators + length-2 products)</li>
<li>Orthogonal decomposition with complement, Peirce block dimensions</li>
<li>Radical filtration (rad^1 → rad^2 → ... until nilpotent)</li>
<li>Peirce decomposition of rad^2 where available</li>
<li><strong>Delta=sqrt(2) (ell=4)</strong>: Analysis for n=2..7 via modular arithmetic (Tonelli-Shanks for sqrt(2) mod p)</li>
<li><strong>Delta=phi (ell=5, golden ratio)</strong>: phi = (1+sqrt(5))/2, verified phi^2 = phi+1 mod p. Analysis for n=2..7</li>
<li><strong>Delta=sqrt(3) (ell=6)</strong>: Analysis for n=2..7</li>
<li><strong>Cross-check</strong>: delta=1 via general-delta pathway matches dedicated delta=1 results for n=3,4,5</li>
<li>Fixed-point values are Catalan numbers (labeled in output when detected)</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Idempotency at delta=1</strong>: e_i^2 = e_i for all generators — PROVEN (verified n=2..8)</li>
<li><strong>TL relations at delta=1</strong>: Adjacent (e_i<em>e_{i+1}</em>e_i = e_i) and far commutativity — PROVEN (verified n=2..8)</li>
<li><strong>Semisimplicity pattern</strong>: Varies with delta — delta=0 has alternating odd/even pattern; delta=1 has different radical structure; delta=sqrt(2), phi, sqrt(3) have yet different patterns — COMPUTED (dimensions for n=2..7 or 8)</li>
<li><strong>Peirce block sum = algebra dim</strong>: For all orthogonal decompositions computed — PROVEN (verified for applicable n)</li>
<li><strong>Nilpotency index at delta=1</strong>: radical filtration terminates; predicted PIM Loewy length up to 2*ell-1 = 5 — TESTED</li>
</ul>
<h3>Data</h3>
<ul>
<li>Catalan number dimensions: C_2=2, C_3=5, C_4=14, C_5=42, C_6=132, C_7=429, C_8=1430</li>
<li>Delta values: 0 (ell=2), 1 (ell=3), sqrt(2) (ell=4), phi=(1+sqrt(5))/2 (ell=5), sqrt(3) (ell=6)</li>
<li>Modular prime: p = 10^9+7 (default), p = 999999751 (for phi/sqrt(5))</li>
<li>Multiplication tables: full basis × basis with loop counts for n up to 8</li>
<li>Gram matrices printed for dim ≤ 14</li>
<li>Radical filtration sequences (rad^1, rad^2, ... dimensions) for each (n, delta) pair</li>
<li>Distinct fixed-point values labeled as Catalan numbers where applicable</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>TLAlgebra struct</strong>: Bundled algebra data (basis, identity, generators, multiplication table with loop counts) for any n up to 8</li>
<li><strong>Planar matching enumerator</strong>: Segment-based recursive algorithm (from <a href="./entries/demo_35.html">Demo 35</a>/51), supports up to C_8=1430</li>
<li><strong>Diagram composition</strong>: Returns result + loop count, stored in multiplication table</li>
<li><strong>AlgElem integer arithmetic</strong>: Zero, basis element, add, sub, multiply (delta=1), multiply (mod p), zero test, equality, idempotent test, print</li>
<li><strong>Gram matrix / radical dimension</strong>: Via trace form fixed points + Gaussian elimination (both float and mod-p)</li>
<li><strong>Radical basis extraction</strong>: Float path (for small dims, gives integer vectors) and mod-p path (exact for any dim)</li>
<li><strong>Radical filtration</strong>: Iterative rad^k computation via product of rad^1 basis with rad^{k-1} basis, echelon tracking</li>
<li><strong>Idempotent search</strong>: Individual generators + length-2 products, orthogonality matrix, greedy maximal orthogonal set, complement computation</li>
<li><strong>Peirce block dimensions</strong>: Full algebra and subspace-restricted versions</li>
<li><strong>Modular arithmetic</strong>: mod_reduce, mod_inv (extended Euclidean), mod_pow, mod_sqrt_ts (Tonelli-Shanks)</li>
<li><strong>General delta analysis</strong>: analyze_tl_delta() handles arbitrary delta via precomputed delta^k powers mod p</li>
<li><strong>Weighted Gram matrix</strong>: General delta version with delta^loops weighting</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Temperley-Lieb algebra at roots of unity (delta = 2*cos(pi/ell))</li>
<li>Non-semisimple representation theory (radical, radical filtration, nilpotency index)</li>
<li>Peirce decomposition (orthogonal idempotents, block structure)</li>
<li>Loewy length / PIM structure (predicted 2*ell-1 for delta=1)</li>
<li>Percolation theory connection (delta=1, c=0 LCFT)</li>
<li>Chebyshev polynomials (delta parametrization)</li>
<li>Tonelli-Shanks algorithm (modular square roots)</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>What is the exact semisimplicity/non-semisimplicity pattern as a function of (n, delta)?</li>
<li>Do the radical filtration dimensions follow a predictable formula across ell values?</li>
<li>How does the Peirce block structure at delta=1 relate to the representation theory (which irreducibles appear, with what multiplicity)?</li>
<li>Can the rad^2 generator elements be connected to neglecton-type objects from <a href="./entries/demo_49.html">Demo 49</a>?</li>
<li>Does the Loewy length reach the predicted maximum 2*ell-1 = 5 at delta=1 for sufficiently large n?</li>
<li>How do the general-delta radical dimensions connect to DKC computability boundaries from <a href="./entries/demo_48.html">Demo 48</a>?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_53.html">Demo 53</a>: DKC at delta=1 — Bracket Catalog over Z[zeta_3]</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_53_dkc_d1/main.c.html">demo_53_dkc_d1/main.c</a></code> (~1474 lines)</li>
<li><strong>Tests</strong>: ~40+ checks across 6 parts (A-F) + 4 experiments: Eisenstein arithmetic, planar matchings, TL generators at delta=1, braid generators, braid word evaluation, closure cross-validation, bracket catalog, axiality stress test, entanglement vanishing, compression ratios</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_35.html">Demo 35</a> (delta=0 bracket catalog over Z[zeta_8], strict axiality), <a href="./entries/demo_15.html">Demo 15</a> (delta-zero optimal angles)</li>
<li><strong>Feeds into</strong>: Later demos comparing DKC behavior across different roots of unity</li>
</ul>
<h3>Headline</h3>
Explores the Kauffman bracket at delta=1 (A = omega = e^{i*2pi/3}, cube root of unity), where values live in Z[omega] (Eisenstein integers) instead of Z[zeta_8], TL generators become idempotent (e_i^2 = e_i) instead of nilpotent, all smoothing states contribute (delta^L = 1), and two key delta=0 phenomena — strict axiality and entanglement vanishing — are tested for breakdown.
<h3>Key Results</h3>
<ul>
<li><strong>Eisenstein arithmetic</strong> (Part A): verifies omega^3 = 1, omega^2 + omega + 1 = 0, conjugation (norm = a^2 - ab + b^2), A^n power cycling (mod 3), float cross-checks, axiality classification (multiples of 1, omega, or omega^2)</li>
<li><strong>Planar matchings</strong> (Part B): enumerates Catalan-number basis sets (C_2=2, C_3=5, C_4=14, C_5=42), identical to <a href="./entries/demo_35.html">Demo 35</a> (pure combinatorics, ring-independent)</li>
<li><strong>TL generators at delta=1</strong> (Part C): e_i^2 = e_i (idempotent!) verified for n=2,3,4. Braid relations e_i<em>e_j</em>e_i = e_i (for |i-j|=1) verified. Far commutativity e_1<em>e_3 = e_3</em>e_1 verified. At delta=1, every column has exactly one 1 (nonzero count = dim)</li>
<li><strong>Braid generators</strong> (Part D): sigma <em> sigma^{-1} = I verified for n=2,3. Braid relation s1</em>s2<em>s1 = s2</em>s1*s2 verified.</li>
<li><strong>Braid word evaluation</strong> (Part E): s1^2 * s1^{-2} = I, trefoil (s1^3) nonzero</li>
<li><strong>Closure cross-validation</strong> (Part F): matrix method vs state-sum method agree for Hopf link, trefoil, figure-eight, 4-strand s1<em>s2</em>s3, and 4-strand s1^2*s3^2. At delta=1 state-sum simplifies: every state contributes (delta^{L-1} = 1)</li>
<li><strong>Experiment 1 — Bracket catalog</strong>: n=3 braids (lengths 1-8, 4 crossing choices) and n=4 braids (lengths 1-5, 6 crossing choices). Tracks distinct values, axiality breakdown (axial vs MIXED values)</li>
<li><strong>Experiment 2 — Axiality stress test</strong>: tests all n=2 braids (lengths 1-10) and n=3 braids (lengths 1-8) for axiality. Expects axiality to BREAK at delta=1 (mixed values = not scalar multiples of {1, omega, omega^2})</li>
<li><strong>Experiment 3 — Entanglement vanishing</strong>: non-interleaving braids (sigma_1 and sigma_3 only, in B_4, lengths 1-5). At delta=0 ALL such brackets are zero; at delta=1 expects NONZERO (entanglement vanishing breaks)</li>
<li><strong>Experiment 4 — Compression ratios</strong>: n=3 braids lengths 1-6, counts distinct TL matrices vs total braids to measure how many-to-one the braid→matrix map is</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Idempotency at delta=1</strong>: e_i^2 = delta <em> e_i = 1 </em> e_i = e_i. This is the defining algebraic difference from delta=0 (where e_i^2 = 0). All smoothing states survive, no loop-killing.</li>
<li><strong>Axiality breakdown</strong>: at delta=0 (Z[zeta_8]), every bracket value lies on a single cyclotomic axis (strict axiality — <a href="./entries/demo_35.html">Demo 35</a> result). At delta=1 (Z[omega]), mixed values (off-axis Eisenstein integers) are expected.</li>
<li><strong>Entanglement vanishing breakdown</strong>: at delta=0, non-interleaving braids (using only far-apart generators) always produce bracket=0. At delta=1, delta^L = 1 means closed loops don't kill states, so non-interleaving braids can have nonzero bracket.</li>
<li><strong>Ring comparison</strong>: Z[omega] is 2-dimensional (a + b*omega, a,b in Z) vs Z[zeta_8] which is 4-dimensional. Simpler ring, but different algebraic properties.</li>
</ul>
<h3>Data</h3>
<ul>
<li>A = omega = e^{i*2pi/3}, delta = 1, A has order 3</li>
<li>Eisenstein integers Z[omega]: elements a + b*omega with a,b in Z</li>
<li>n=2 axiality test: up to length 10 (2^10 = 1024 braids)</li>
<li>n=3 axiality test: up to length 8 (4^8 = 65536 braids)</li>
<li>n=3 catalog: lengths 1-8 (up to 65536 braids), up to 1000 distinct bracket values stored</li>
<li>n=4 catalog: lengths 1-5 (up to 7776 braids)</li>
<li>Entanglement: n=4 non-interleaving, lengths 1-5 (4^k braids each)</li>
<li>Compression: n=3, lengths 1-6, up to 2000 distinct TL matrices</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>Eisenstein integer arithmetic</strong>: <code>Eis</code> type (a + b*omega), <code>eis_add/sub/neg/mul/conj</code>, <code>eis_a_power</code> (A^n mod 3), <code>eis_is_axial</code> (test if value is scalar multiple of 1, omega, or omega^2), <code>eis_to_cx</code> (convert to floating-point complex)</li>
<li><strong>Planar matching enumeration</strong>: <code>enumerate_basis()</code>, <code>compose_diagrams()</code> with closed-loop counting — reused from <a href="./entries/demo_35.html">Demo 35</a>, ring-independent</li>
<li><strong>TL matrix algebra over Eisenstein integers</strong>: <code>TLMat</code> type (up to 42x42), <code>tlmat_zero/identity/add/scale_eis/mul/eq/is_zero/nonzero_count</code></li>
<li><strong><code>build_generator_matrix_d1()</code></strong>: TL generator at delta=1 (every composition survives, coefficient always 1)</li>
<li><strong><code>build_braid_generator_d1()</code></strong>: sigma_i = A<em>I + A^{-1}</em>e_i with A=omega</li>
<li><strong><code>eval_braid_word()</code></strong>: multiplies sequence of braid generator matrices</li>
<li><strong><code>compute_bracket_d1()</code></strong>: matrix-method trace closure (sum identity column, delta^{L-1}=1)</li>
<li><strong><code>state_sum_bracket_d1()</code></strong>: direct state-sum over 2^n smoothing states (each contributes A^{a_power}, no delta suppression)</li>
<li><strong><code>decode_braid()</code></strong>: integer-to-crossing-sequence decoder for exhaustive enumeration</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Eisenstein integers Z[omega] and their arithmetic properties</li>
<li>Kauffman bracket at roots of unity (cube root vs 8th root)</li>
<li>Temperley-Lieb algebra at delta=1: idempotent generators, semisimple regime</li>
<li>Entanglement vanishing in the Kauffman bracket (connection to nilpotency at delta=0)</li>
<li>Connected to the delta=0 vs delta!=0 dichotomy in topological quantum computation</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>How does the bracket catalog at delta=1 compare in size/structure to delta=0?</li>
<li>What fraction of Eisenstein integer values are actually reachable by the bracket?</li>
<li>Does the compression ratio stabilize, and how does it compare to delta=0?</li>
<li>Is there a delta value between 0 and 1 where axiality gradually breaks, or is it a sharp transition?</li>
<li>Can the idempotent TL algebra at delta=1 support any form of DKC (knot→computation correspondence)?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_54.html">Demo 54</a>: DKC at ell=4 (delta=sqrt(2)) — Bracket over Z[zeta_16]</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_54_dkc_l4/main.c.html">demo_54_dkc_l4/main.c</a></code> (~1857 lines)</li>
<li><strong>Tests</strong>: ~40+ pass (Part A: 20 Z[zeta_16] arithmetic sanity checks; Part B: 5 Catalan number checks + identity presence; Part C: ~10 TL relation checks at n=2,3,4 including e_i^2=delta<em>e_i, e_i</em>e_j*e_i=e_i, far commutativity; Part D: ~5 braid generator inverse/relation checks; Part E: braid word evaluation checks; Part F: ~6 cross-validation checks matrix vs state-sum for Hopf, trefoil, figure-eight, 4-strand braids)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_53.html">Demo 53</a> (TL at ell=3/delta=1, planar matching enumeration), <a href="./entries/demo_35.html">Demo 35</a> (original TL matrix framework), <a href="./entries/demo_48.html">Demos 48</a>-<a href="./entries/demo_50.html">50</a> (DKC at delta=0, parity wall context)</li>
<li><strong>Feeds into</strong>: DKC analysis at non-zero delta; tests whether delta=0 phenomena (axiality, entanglement vanishing, compression) generalize or are regime-specific</li>
</ul>
<h3>Headline</h3>
Two-source hypothesis test: constructs exact Z[zeta_16] cyclotomic arithmetic (8D ring) for TL/braid evaluation at ell=4 (delta=sqrt(2), Ising anyons), verifying all TL relations (e_i^2=sqrt(2)*e_i, delta-potent not nilpotent), braid relations, and matrix/state-sum cross-validation for Hopf link, trefoil, figure-eight, and 4-strand braids. Five experiments probe axiality, entanglement vanishing, compression ratios, bracket catalogs, and Gaussian integer structure at this new evaluation point.
<h3>Key Results</h3>
<ul>
<li><strong>Part A</strong>: Z[zeta_16] exact arithmetic with 8-component basis {1, zeta, ..., zeta^7}, zeta^8=-1; A=zeta^5, A^{-1}=-zeta^3, delta=zeta^2-zeta^6=sqrt(2); delta^2=2 verified exactly; A has order 16; float cross-checks all pass to 1e-10</li>
<li><strong>Part B</strong>: Planar matching enumeration reproduces Catalan numbers C_2=2, C_3=5, C_4=14, C_5=42</li>
<li><strong>Part C</strong>: TL generators at delta=sqrt(2) satisfy e_i^2=delta<em>e_i (delta-potent, not nilpotent like delta=0 nor idempotent like delta=1), e_i</em>e_j<em>e_i=e_i (TL relation), e_1</em>e_3=e_3*e_1 (far commutativity) for n=2,3,4</li>
<li><strong>Part D</strong>: Braid generators sigma_i=A<em>I+A^{-1}</em>e_i; sigma<em>sigma^{-1}=I verified at n=2,3; braid relation s1</em>s2<em>s1=s2</em>s1*s2 verified at n=3</li>
<li><strong>Part E</strong>: Braid word evaluation: s1^2*s1^{-2}=I, s1^3 nonzero</li>
<li><strong>Part F</strong>: Matrix and state-sum bracket cross-validation for Hopf link (n=2), trefoil (n=2), figure-eight (n=3), 4-strand s1<em>s2</em>s3, 4-strand s1^2*s3^2; all matrix==state-sum</li>
<li><strong>Experiment 1</strong>: Bracket catalog — n=3 up to length 8 and n=4 up to length 5; distinct values enumerated with Z-axial, Z[i]-axial, and truly mixed classification; Z[i]-decomposition (a+bi)*zeta^c displayed for all values</li>
<li><strong>Experiment 2</strong>: Axiality test — checks if all bracket values at delta=sqrt(2) are Z[i]-axial (at most one pair of components (k, k+4) active); tested for n=2 lengths 1-10 and n=3 lengths 1-8</li>
<li><strong>Experiment 3</strong>: Entanglement vanishing — non-interleaving 4-strand braids (sigma_1, sigma_3 only) tested at delta=sqrt(2) up to length 5; checks whether entanglement vanishing from delta=0 persists or breaks</li>
<li><strong>Experiment 4</strong>: Compression ratios — distinct bracket values vs total braids for n=3 lengths 1-6; measures algebraic collapse rate at delta=sqrt(2) vs delta=0</li>
<li><strong>Experiment 5</strong>: Gaussian integer catalog — strips zeta^c axis from Z[i]-axial values, catalogs distinct Gaussian integers (a+bi); tracks negation pairs, conjugation pairs, and units (norm=1); precursor to DKC Boolean function search at ell=4</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li>VERIFIED: Z[zeta_16] arithmetic is consistent (zeta^8=-1, zeta^16=1, A*A^{-1}=1, delta^2=2, all float cross-checks pass)</li>
<li>VERIFIED: TL_n at delta=sqrt(2) satisfies e_i^2=delta<em>e_i (delta-potent regime), e_i</em>e_j*e_i=e_i, far commutativity — all standard TL relations</li>
<li>VERIFIED: Braid group representation at ell=4 (sigma_i=A<em>I+A^{-1}</em>e_i) satisfies inverse relations and Yang-Baxter/braid relation</li>
<li>VERIFIED: Matrix method and state-sum method produce identical bracket values for all tested knots (Hopf, trefoil, figure-eight, 4-strand examples)</li>
<li>TESTED: Z[i]-axiality — whether bracket values factor as (a+bi)*zeta^c at delta=sqrt(2) (contrasts delta=0 where all values are strictly axial in Z[zeta_8])</li>
<li>TESTED: Entanglement vanishing — whether non-interleaving braids give zero bracket at delta=sqrt(2) (known to hold at delta=0)</li>
<li>KEY QUESTION: Is delta=0 uniquely special, or do the DKC phenomena generalize across evaluation levels?</li>
</ul>
<h3>Data</h3>
<ul>
<li>Ring: Z[zeta_16] (8-dimensional over Z), basis {1, zeta_16, ..., zeta_16^7} with zeta_16^8=-1</li>
<li>A = zeta_16^5 = e^{i<em>5</em>pi/8}, order 16; delta = sqrt(2) = zeta_16^2 - zeta_16^6</li>
<li>TL dimensions: n=2→dim 2, n=3→dim 5, n=4→dim 14 (Catalan numbers)</li>
<li>Braid generators: n-1 positive and n-1 negative per strand count</li>
<li>Experiment search spaces: n=3 up to 4^8=65536 braids, n=4 up to 6^5=7776 braids</li>
<li>Entanglement test: 4 choices (sigma_1±, sigma_3±) up to length 5</li>
<li>Gaussian integer decomposition: values decompose as (a+bi)*zeta^c for c in {0,1,2,3}</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>Cyc16</code> type: exact Z[zeta_16] cyclotomic arithmetic (8-component, zeta^8=-1); <code>cyc16_zero/one/make/zeta_power/add/neg/scale/mul/eq/is_zero/to_cx</code></li>
<li><code>cyc16_a_power()</code>: computes A^k = zeta^{5k} with reduction</li>
<li><code>cyc16_delta_power()</code>: exact delta^k using delta^2=2 (even powers→integer, odd powers→integer*delta)</li>
<li><code>cyc16_is_axial()</code> / <code>cyc16_is_zi_axial()</code>: strict axiality (at most 1 nonzero component) and Z[i]-axiality (at most one pair (k,k+4) active)</li>
<li><code>cyc16_zi_decompose()</code>: factors Z[i]-axial value as (a+bi)*zeta^c</li>
<li><code>PlanarMatch</code> / <code>enumerate_basis()</code>: planar matching enumeration (from <a href="./entries/demo_35.html">Demo 35</a>/53), boundary order, segment-based recursive enumeration</li>
<li><code>compose_diagrams()</code>: diagram composition with closed loop counting</li>
<li><code>TLMat</code> type: matrices over Z[zeta_16] up to 42×42; <code>tlmat_zero/identity/add/scale/mul/eq/nonzero_count/print</code></li>
<li><code>build_generator_matrix()</code>: TL generator e_i as matrix via diagram composition with delta^loops weight</li>
<li><code>build_braid_generator()</code>: sigma_i = A<em>I + A^{-1}</em>e_i (positive) or A^{-1}<em>I + A</em>e_i (negative)</li>
<li><code>BraidCrossing</code> type + <code>eval_braid_word()</code>: evaluates braid word as matrix product</li>
<li><code>decode_braid()</code>: integer index → crossing sequence</li>
<li><code>compute_bracket()</code>: matrix-method closure functional (sum over basis with delta^{trace_loops-1} weights)</li>
<li><code>state_sum_bracket()</code>: independent state-sum evaluation with diagram composition for cross-validation</li>
<li><code>GaussInt</code> type + <code>gi_catalog_contains()</code>: Gaussian integer tracking for Experiment 5</li>
<li><code>catalog_contains()</code> / <code>CatalogEntry</code>: distinct Cyc16 value tracking</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>SU(2) level 2 = Ising anyons (3 simple objects at ell=4)</li>
<li>Temperley-Lieb algebra at non-zero delta (delta-potent regime: e_i^2=delta*e_i)</li>
<li>Z[zeta_16]: 16th cyclotomic integers (8-dimensional ring extension of Z)</li>
<li>Gaussian integers Z[i] as subring of Z[zeta_16] (zeta^4 = i)</li>
<li>Kauffman bracket at general A (not restricted to delta=0)</li>
<li>Entanglement vanishing phenomenon (non-interleaving braids)</li>
<li>Comparison of evaluation regimes: ell=3 (delta=1, binary), ell=4 (delta=sqrt(2), irrational), ell=∞ (delta=0, nilpotent)</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Does Z[i]-axiality hold universally at delta=sqrt(2), or does it break at longer braid lengths?</li>
<li>Does entanglement vanishing persist, partially break, or completely break at delta=sqrt(2)?</li>
<li>How does the compression ratio (braids→distinct brackets) compare between delta=0 and delta=sqrt(2)?</li>
<li>Can Gaussian integer negation pairs from Experiment 5 enable DKC-style Boolean function search at ell=4?</li>
<li>What is the catalog size at ell=4 — richer or sparser than ell=∞ (delta=0)?</li>
<li>How does the "two-source hypothesis" resolve: was the ell=3 binary collapse due to too few representations or delta=1 being special?</li>
<li>Can the 4-strand s1^2*s3^2 bracket (entanglement test) distinguish delta=0 from delta=sqrt(2)?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_55.html">Demo 55</a>: DKC Boolean Search at ell=4 (delta=sqrt(2))</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_55_dkc_boolean/main.c.html">demo_55_dkc_boolean/main.c</a></code> (~1062 lines)</li>
<li><strong>Tests</strong>: ~7 checks (4 parts: A=4 catalog verification + Z[i]-axial + algebra identities, B=1 XOR achievable, C=1 NPN count, D=1 parity achievable)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_54.html">Demo 54</a> (bracket catalog at delta=sqrt(2), Z[i]-axial structure), <a href="./entries/demo_48.html">Demo 48</a>/50 (delta=0 baseline: forward DKC zoo, activation zoo)</li>
<li><strong>Feeds into</strong>: Understanding Boolean computability at non-zero delta; multiplicative vs additive DKC encoding comparison; ell-parameterized DKC theory</li>
</ul>
<h3>Headline</h3>
Searches for Boolean functions computable by DKC neurons at ell=4 (delta=sqrt(2)) using multiplicative encoding (z = w1^x1 <em> w2^x2 </em> w3^x3) across five activation function families, comparing the achievable function landscape to delta=0 results from <a href="./entries/demo_48.html">Demos 48</a>-<a href="./entries/demo_50.html">50</a>.
<h3>Key Results</h3>
<ul>
<li><strong>Part A (Catalog)</strong>: State-sum bracket catalog built at delta=sqrt(2) using Z[zeta_16] exact arithmetic (A = zeta_16^5); enumerates n=2 (len 1-10), n=3 (len 1-6), n=4 (len 1-6); all values confirmed 100% Z[i]-axial; algebraic identities verified (A * A^{-1} = 1, delta^2 = 2)</li>
<li><strong>Part B (2-input search)</strong>: 10 activation functions tested on all catalog pairs with multiplicative encoding; quartet (1, w2, w1, w1*w2) produces 4-bit truth tables; activations include Re&gt;0, Im&gt;0, split-sigmoid, sector k=2/4/6/8, magnitude tau=0.5/1.0/1.5; XOR/XNOR confirmed achievable</li>
<li><strong>Part C (3-input search)</strong>: 8 activation functions tested on all catalog triples; octet (1, w3, w2, w2w3, w1, w1w3, w1w2, w1w2w3) produces 8-bit truth tables; NPN classification into 13 non-trivial classes; per-activation reachability reported</li>
<li><strong>Part D (Analysis)</strong>: k-sector sweep k=2..8 with 3-input multiplicative encoding; parity solution counts tracked per k; reachable NPN class counts per k; comparison with delta=0 additive encoding results</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Multiplicative encoding</strong>: z(x) = w1^x1 <em> w2^x2 </em> ... * wn^xn (product of weights raised to binary input powers) is a natural encoding for delta != 0 because bracket values at non-zero delta have multiplicative structure (delta^k scaling)</li>
<li><strong>Z[i]-axiality at delta=sqrt(2)</strong>: Every bracket value equals (a+bi) * zeta_16^c for some Gaussian integer a+bi and power c — confirmed by <a href="./entries/demo_54.html">Demo 54</a>, verified here in catalog construction</li>
<li><strong>Encoding comparison caveat</strong>: Delta=0 (<a href="./entries/demo_48.html">Demos 48</a>-<a href="./entries/demo_50.html">50</a>) used additive encoding (z = sum wi*xi); delta=sqrt(2) uses multiplicative encoding — not directly comparable, but structural parallels in reachability hierarchy are informative</li>
<li><strong>Bit 0 is fixed</strong>: Under multiplicative encoding, (0,...,0) → z = 1 always, so bit 0 of the truth table is determined by the activation function's classification of z=1 (not a free parameter)</li>
</ul>
<h3>Data</h3>
<ul>
<li>Bracket catalog at delta=sqrt(2): distinct nonzero values (first 20 printed with Z[zeta_16] coordinates and magnitudes)</li>
<li>2-input: 16 possible truth tables × 10 activations, achievable counts per function per activation</li>
<li>3-input: 13 NPN classes × 8 activations, solution counts per class per activation</li>
<li>k-sector sweep (k=2..8): reachable NPN class count and parity solution count per k</li>
<li>Comparison table: delta=0 (64 catalog values, parity at k=6 with 906 solutions, additive) vs delta=sqrt(2) (multiplicative)</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>Cyc16</code> struct: exact cyclotomic integer type Z[zeta_16] with 8-element basis {1, zeta, ..., zeta^7} where zeta^8 = -1</li>
<li><code>cyc16_zero()</code>, <code>cyc16_one()</code>, <code>cyc16_zeta_power()</code>, <code>cyc16_add()</code>, <code>cyc16_neg()</code>, <code>cyc16_mul()</code>, <code>cyc16_eq()</code>, <code>cyc16_is_zero()</code>, <code>cyc16_to_cx()</code>, <code>cyc16_print()</code> — full Z[zeta_16] arithmetic</li>
<li><code>cyc16_a_power()</code> — A^n where A = zeta^5</li>
<li><code>cyc16_delta_power()</code> — delta^k where delta = sqrt(2) = zeta^2 - zeta^6; even powers are integers (2^{k/2}), odd powers are multiples of delta</li>
<li><code>cyc16_is_zi_axial()</code> — checks if value has at most one active coordinate pair (Z[i]-axiality)</li>
<li><code>PlanarMatch</code> struct: planar matching diagram for n strands (2n endpoints)</li>
<li><code>make_identity_diagram()</code>, <code>make_generator_diagram()</code> — TL diagram constructors</li>
<li><code>compose_diagrams()</code> — diagram composition with glue-loop counting (returns number of closed loops)</li>
<li><code>trace_closure_loops()</code> — trace closure loop counting for bracket computation</li>
<li><code>state_sum_bracket()</code> — full state-sum bracket at delta=sqrt(2) using planar matching diagrams instead of union-find (exact Z[zeta_16] arithmetic)</li>
<li><code>split_sigmoid_classify()</code> — XOR-like activation: sigma(Re)<em>(1-sigma(Im)) + (1-sigma(Re))</em>sigma(Im) &gt; 0.5</li>
<li><code>sector_classify()</code>, <code>magnitude_classify()</code>, <code>re_positive_classify()</code>, <code>im_positive_classify()</code> — multiple activation functions with uniform interface</li>
<li><code>search_2input()</code>, <code>search_3input()</code> — exhaustive search with multiplicative encoding, per-activation truth table counting</li>
<li>NPN classification machinery (from <a href="./entries/demo_48.html">Demo 48</a>/50): <code>npn_init()</code>, <code>npn_transform()</code>, <code>npn_build_classes()</code></li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Multi-valued neuron (MVN) with k-sector classification applied to multiplicative encoding</li>
<li>Kauffman bracket at non-zero delta (ell=4, Jones-Wenzl level)</li>
<li>Z[zeta_16] cyclotomic ring as algebraic setting for ell=4 bracket values</li>
<li>Gaussian integers Z[i] as structural constraint on bracket catalog</li>
<li>Multiplicative vs additive neural encoding for Boolean functions</li>
<li>Planar matching diagrams for Temperley-Lieb algebra composition</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>How does the reachability landscape at delta=sqrt(2) compare quantitatively to delta=0? (Encoding difference makes direct comparison difficult)</li>
<li>Does multiplicative encoding have inherent advantages for certain function classes (e.g., AND-like functions where product structure is natural)?</li>
<li>At what ell values does parity first become achievable under multiplicative encoding?</li>
<li>Can additive encoding be used at delta=sqrt(2), and if so, how does reachability change?</li>
<li>Does the four-tier hierarchy from <a href="./entries/demo_50.html">Demo 50</a> (k=2/3/4/6) persist under multiplicative encoding, or does the tier structure shift?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_56.html">Demo 56</a>: Potts-TL Dictionary</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_56_potts_tl/main.c.html">demo_56_potts_tl/main.c</a></code> (~1137 lines)</li>
<li><strong>Tests</strong>: ~15 pass (inline check() assertions across Parts A-G)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_54.html">Demo 54</a> (bracket axiality, Z[i]-axial structure), <a href="./entries/demo_55.html">Demo 55</a> (Z[zeta_16] arithmetic, sector activation), <a href="./entries/demo_53.html">Demo 53</a> (Q=1 percolation — referenced as trivial)</li>
<li><strong>Feeds into</strong>: Future demos on Q=3 Potts model, multi-Q DKC landscape, transfer matrix methods</li>
</ul>
<h3>Headline</h3>
Establishes the Potts-TL dictionary connecting Kauffman bracket to Potts model partition function via delta^2=Q, cross-validates FK=Ising at Q=2, proves Q=1 percolation is computationally trivial, and discovers that FK partition function values are algebraically richer (4D Z[zeta_8]) than bracket values (2D Z[i]-axial).
<h3>Key Results</h3>
<ul>
<li><strong>FK = Ising cross-validation</strong>: Direct Ising spin sum equals Fortuin-Kasteleyn partition function at integer Q=2, v=1 for 6 lattice strips S(w,h) plus v=2 case — PROVEN (exhaustive subset enumeration)</li>
<li><strong>Q=1 percolation degeneracy</strong>: Z_FK(G; 1, v) = (1+v)^|E| regardless of graph structure — confirmed for 4 strips with arbitrary v=zeta_16^3</li>
<li><strong>Bracket coupling lives in Z[zeta_8]</strong>: At Q=2, v=-zeta_16^6, all FK partition function values have only even-indexed Cyc16 components (11/11 strips) — the Q^{k(A)} weighting stays in the Z[zeta_8] subring</li>
<li><strong>FK values are 4D vs bracket 2D</strong>: FK partition functions use the full Z[zeta_8] = Z[i, sqrt(2)] ring (4 generators over Z), while bracket values are Z[i]-axial (only 2 generators) — a genuine algebraic enrichment</li>
<li><strong>Critical coupling values are real</strong>: At v=sqrt(2) (Ising critical temperature), all FK values have zero imaginary part — live in Z[sqrt(2)] (6/6 strips verified)</li>
<li><strong>Q-hierarchy</strong>: Q=1 produces only powers of (1+v) (no geometry), Q=2 distinguishes different topologies — a computational phase transition at Q=2</li>
<li><strong>FK catalog</strong>: ~9 distinct nonzero partition function values from 11 strips at bracket coupling</li>
<li><strong>FK DKC Boolean search</strong>: Tests whether 4D FK values compute more Boolean functions than 2D bracket values across multiple activations (Re&gt;0, split-sigmoid, sector k=2,4,6) for both 2-input and 3-input functions</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>FK = Ising equivalence at integer Q</strong>: Z_FK(G; Q=2, v) = Z_Ising(G; v) for all lattice strips tested — PROVEN (exhaustive, 7 cases)</li>
<li><strong>Q=1 universality</strong>: Z_FK(G; 1, v) = (1+v)^|E| for any graph — PROVEN (verified 4 strips, algebraic identity)</li>
<li><strong>Z[zeta_8] closure</strong>: FK at bracket coupling Q=2, v=-zeta_16^6 yields values in Z[zeta_8] (even subring of Z[zeta_16]) — PROVEN (verified 11 strips)</li>
<li><strong>Critical coupling reality</strong>: FK at v=sqrt(2), Q=2 yields real values (Z[sqrt(2)]) — PROVEN (verified 6 strips)</li>
<li><strong>Axiality breaking</strong>: FK values use all 4 dimensions of Z[zeta_8] where bracket values use only 2 (Z[i]-axial) — CONFIRMED (the Q^{k(A)} weighting breaks axiality)</li>
<li><strong>Computational phase transition at Q=2</strong>: Q=1 carries no geometric information; Q=2 distinguishes topology — CONFIRMED</li>
</ul>
<h3>Data</h3>
<ul>
<li>Lattice strips: S(w,h) for w=2..4, h=2..6 (up to 24 edges, feasible for 2^|E| enumeration)</li>
<li>Delta-Q dictionary: ell=3→Q=1 (percolation), ell=4→Q=2 (Ising), ell=6→Q=3 (3-state Potts)</li>
<li>Bracket coupling: A=zeta_16^5, v=-zeta_16^6=-A^{-2}</li>
<li>Critical coupling: v=sqrt(2)=zeta_16^2-zeta_16^6 (verified v^2=2)</li>
<li>Critical temperature: K_c = ln(1+sqrt(2)) = 0.8814...</li>
<li>FK partition function catalog: ~9 distinct nonzero values at Q=2 bracket coupling</li>
<li>NPN classes: 13 non-trivial 3-input classes (standard from <a href="./entries/demo_48.html">Demo 48</a>)</li>
<li>Activations tested: Re&gt;0, split-sigmoid, sector k=2,4,6</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>Z[zeta_16] arithmetic (Cyc16)</strong>: 8-component cyclotomic ring with zeta^8=-1 — zero, one, zeta_power, add, neg, mul, eq, is_zero, to_cx, print (reused from <a href="./entries/demo_55.html">Demo 55</a>)</li>
<li><strong>cyc16_is_real()</strong>: Tests if Z[zeta_16] element has zero imaginary part (odd components = 0)</li>
<li><strong>cyc16_is_zeta8_valued()</strong>: Tests if element lives in Z[zeta_8] subring (even-indexed components only)</li>
<li><strong>LatticeStrip builder</strong>: build_strip(w,h) constructs rectangular grid with horizontal + vertical edges</li>
<li><strong>Union-Find</strong>: Path-halving uf_find/uf_union for connected component counting</li>
<li><strong>FK partition function</strong>: fk_partition() — full 2^|E| subset enumeration with precomputed v^k, Q^k power arrays</li>
<li><strong>Ising spin sum</strong>: ising_spin_sum() — direct 2^|V| configuration sum for integer-coupling cross-validation</li>
<li><strong>NPN classifier</strong>: 96-transform canonicalization, orbit sizes, 13 class identification (from <a href="./entries/demo_48.html">Demo 48</a>)</li>
<li><strong>FK DKC search</strong>: Multiplicative encoding z=w1^x1<em>w2^x2</em>..., truth table extraction, per-NPN-class aggregation</li>
<li><strong>Multiple activation wrappers</strong>: Re&gt;0, split-sigmoid, sector(k) — unified classify(Cx, int) interface</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Fortuin-Kasteleyn representation of Potts model (cluster expansion, Q as continuous parameter)</li>
<li>Ising model / 2-state Potts (Q=2, spin-spin coupling, critical temperature)</li>
<li>Bond percolation (Q=1 limit, geometrically trivial)</li>
<li>Kramers-Wannier duality / self-dual point (v_c = sqrt(Q) for square lattice)</li>
<li>Cyclotomic integers Z[zeta_16], Z[zeta_8] (number-theoretic structure of partition functions)</li>
<li>NPN classification of Boolean functions (connection to DKC computability)</li>
<li>Kauffman bracket / TL algebra connection to statistical mechanics (delta^2 = Q)</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Does the 4D FK catalog achieve more NPN classes than the 2D bracket catalog at any activation? (The small catalog size (~9) may limit this)</li>
<li>Can larger strips or periodic boundary conditions generate a richer FK catalog?</li>
<li>What happens at Q=3 (3-state Potts, ell=6)? Is the FK catalog even richer (6D? 8D?)?</li>
<li>Is the axiality breaking (2D→4D) a fundamental feature of the Q^{k(A)} weighting, or an artifact of small lattice sizes?</li>
<li>Can transfer matrix methods replace the exponential 2^|E| enumeration to reach larger lattices?</li>
<li>Does the FK/Potts viewpoint give any new leverage on the parity wall from <a href="./entries/demo_48.html">Demo 48</a>?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_57.html">Demo 57</a>: Additive Encoding DKC</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_57_additive_dkc/main.c.html">demo_57_additive_dkc/main.c</a></code> (~1140 lines)</li>
<li><strong>Tests</strong>: ~8 checks across 5 parts (A-E): catalog verification, 2-input encoding comparison, 3-input additive NPN search, head-to-head multiplicative vs additive, union analysis</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_56.html">Demo 56</a> (five-lens analysis predicting additive encoding dissolves 0x1B/0x06 wall), <a href="./entries/demo_55.html">Demo 55</a> (ell=4 bracket catalog at delta=sqrt(2))</li>
<li><strong>Feeds into</strong>: Further encoding/activation investigation in DKC program</li>
</ul>
<h3>Headline</h3>
Tests <a href="./entries/demo_56.html">Demo 56</a>'s prediction that additive encoding (z = x1<em>w1 + x2</em>w2 + x3*w3) should dissolve the 0x1B and 0x06 wall that exists with multiplicative encoding + half-plane (Re&gt;0) activation. <strong>Key discovery: the prediction was wrong</strong> — the wall is about ACTIVATION CONVEXITY, not encoding geometry. Additive is actually WORSE (5/13 vs mult's 11/13 with Re&gt;0) because additive sums preserve convexity of half-planes, while multiplicative products can rotate out of half-planes (anti-convex). Non-convex activations (split-sigmoid, sector) work with either encoding.
<h3>Key Results</h3>
<ul>
<li><strong>Catalog</strong> (Part A): builds same ell=4 (delta=sqrt(2)) bracket catalog as <a href="./entries/demo_55.html">Demo 55</a> using Z[zeta_16] exact arithmetic. All values are Z[i]-axial. Verifies A*A^{-1}=1, delta^2=2.</li>
<li><strong>2-input comparison</strong> (Part B): with Re&gt;0 activation, multiplicative achieves &gt;=8/16 truth tables while additive is constrained by z(0,0)=0 forcing bit 0=0 (all achieved TTs are even)</li>
<li><strong>3-input additive NPN search</strong> (Part C): exhaustive catalog^3 triples across 8 activations. With Re&gt;0, 0x1B and 0x06 remain UNREACHABLE — wall holds. Additive reaches only ~5/13 NPN classes with Re&gt;0.</li>
<li><strong>Head-to-head</strong> (Part D): for each of 8 activations, compares multiplicative vs additive reachability. With Re&gt;0: additive is a strict subset of multiplicative (0 add-only classes). With non-convex activations (split-sigmoid, sector): both encodings reach all 13.</li>
<li><strong>Union analysis</strong> (Part E): Re&gt;0 union of mult+add = 11/13 (the two wall classes 0x1B and 0x06 unreachable by BOTH encodings). Non-convex activations reach all 13 with either encoding alone.</li>
</ul>
<h3>Prediction Scorecard</h3>
<table><thead><tr><th>#</th><th>Prediction</th><th>Result</th><th>Notes</th></tr></thead><tbody><tr><td>1</td><td>Re&gt;0 + additive reaches 0x1B and 0x06</td><td>REFUTED</td><td>Wall is convexity, not encoding</td></tr><tr><td>2</td><td>Some multiplicative-easy become additive-hard</td><td>CONFIRMED</td><td>Additive only 5/13 vs mult 11/13 at Re&gt;0</td></tr><tr><td>3</td><td>Union covers all 13 NPN with Re&gt;0</td><td>REFUTED</td><td>Union = 11/13, wall classes unreachable by both</td></tr><tr><td>4</td><td>z(0,0,0) = 0 constrains bit 0 to 0</td><td>CONFIRMED</td><td>All additive TTs are even</td></tr></tbody></table>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Convexity thesis</strong>: the 0x1B/0x06 wall is fundamentally about activation convexity, not encoding geometry. Half-planes {z : Re(z) &gt; 0} are convex sets. Additive sums of points in a convex set stay in that convex set (preserve convexity). Multiplicative products of complex numbers can rotate out of half-planes (anti-convex). Non-convex activations (split-sigmoid, sector) bypass the wall entirely.</li>
<li><strong>Additive zero constraint</strong>: z(0,...,0) = 0 always, constraining bit 0 of the truth table to 0 for all activations. This eliminates half the truth table space immediately.</li>
<li><strong>Encoding complementarity is minimal at Re&gt;0</strong>: additive is a strict subset of multiplicative at Re&gt;0 (no add-only classes). The two encodings are NOT complementary with convex activations.</li>
</ul>
<h3>Data</h3>
<ul>
<li>Same bracket catalog as <a href="./entries/demo_55.html">Demo 55</a> (ell=4, delta=sqrt(2), Z[zeta_16] exact arithmetic)</li>
<li>Catalog built from n=2 (lengths 1-10), n=3 (lengths 1-6), n=4 (lengths 1-6) braids, capped at 512 values</li>
<li>8 activations: Re&gt;0, Im&gt;0, split-sigmoid, sector k=2/4/6/8, magnitude tau=1</li>
<li>2-input: catalog^2 pairs, 16 possible truth tables</li>
<li>3-input: catalog^3 triples (can be large), 256 truth tables, 13 NPN classes</li>
<li>Encoding modes: multiplicative z = w1^x1 <em> w2^x2 </em> w3^x3 vs additive z = x1<em>w1 + x2</em>w2 + x3*w3</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>Z[zeta_16] arithmetic</strong>: <code>Cyc16</code> type (8 coefficients), <code>cyc16_add/neg/mul/eq/is_zero</code>, <code>cyc16_zeta_power</code>, <code>cyc16_a_power</code> (A = zeta^5), <code>cyc16_delta_power</code>, <code>cyc16_to_cx</code>, <code>cyc16_is_zi_axial</code></li>
<li><strong><code>search_3input_batch()</code></strong>: unified search engine that runs ALL 8 activations in a single pass through catalog triples, parameterized by encode_mode (ENCODE_MUL or ENCODE_ADD). Computes 8 truth tables per triple simultaneously. Aggregates per NPN class.</li>
<li><strong>NPN classification</strong>: <code>npn_init()</code>, <code>npn_build_classes()</code>, <code>npn_transform()</code> — standard 96-transform canonicalization for 3-input functions</li>
<li><strong>Activation wrappers</strong>: uniform <code>int classify(Cx, int)</code> signature for all 8 activations (Re&gt;0, Im&gt;0, split-sigmoid, sector, magnitude)</li>
<li><strong>State-sum bracket</strong>: full planar matching + diagram composition + trace closure, evaluating at delta=sqrt(2)</li>
<li>Reuses: planar matching, diagram composition, trace closure, braid decoding</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Convexity theory in activation functions and decision boundaries</li>
<li>Linear separability: additive encoding with half-plane activation = linear classifier (can only implement linearly separable functions)</li>
<li>Connection to XOR problem in classic perceptron theory (additive + threshold = linear = can't do XOR)</li>
<li>Forward DKC: bracket values as codebook, multiplicative vs additive encoding as two "channel" options</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Is there an encoding between additive and multiplicative that provides better complementarity with convex activations?</li>
<li>Does the convexity insight generalize to 4+ inputs, or do higher dimensions introduce new phenomena?</li>
<li>Can lattice-constrained additive encoding (restricting sums to stay on the Eisenstein/cyclotomic lattice) change the reachability picture?</li>
<li>What is the theoretical minimum number of activation functions needed to cover all 13 NPN classes with additive encoding?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_58.html">Demo 58</a>: Fibonacci Anyon DKC (ell=5, delta=phi)</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_58_fibonacci_dkc/main.c.html">demo_58_fibonacci_dkc/main.c</a></code> (~1284 lines)</li>
<li><strong>Tests</strong>: ~12 tests (Cyc5 arithmetic verification, catalog size, axiality, 2-input encoding, NPN class count, Re&gt;0 reachability comparison, additive convexity bound)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_57.html">Demo 57</a> (ell=4 Z[i] DKC baseline, 0x1B/0x06 Re&gt;0 wall discovery), <a href="./entries/demo_50.html">Demo 50</a> (parity reachability at k=6 sectors), <a href="./entries/demo_29.html">Demo 29</a> (forward DKC, exact cyclotomic arithmetic pattern), <a href="./entries/demo_48.html">Demo 48</a> (forward DKC zoo, activation comparison)</li>
<li><strong>Feeds into</strong>: Further level comparison (ell=3, ell=6, ell=7), understanding whether Re&gt;0 wall is ring-rank or activation-structural, Fibonacci anyon universality implications</li>
</ul>
<h3>Headline</h3>
Tests DKC at the Fibonacci anyon level ell=5 where delta=phi=(1+sqrt(5))/2 (golden ratio) and bracket values live in Z[zeta_5] (rank 4 over Z). The headline question is whether jumping from rank-2 (Z[i] at ell=4) to rank-4 breaks the 0x1B/0x06 Re&gt;0 wall discovered at ell=4. Compares multiplicative vs additive encoding across 8 activation functions and all 13 NPN classes of 3-input Boolean functions.
<h3>Key Results</h3>
<ul>
<li><strong>Z[zeta_5] exact arithmetic implemented</strong>: elements (a,b,c,d) in basis {1, zeta_5, zeta_5^2, zeta_5^3} with minimal polynomial z^4+z^3+z^2+z+1=0; reduction uses zeta_5^4 = -(1+zeta_5+zeta_5^2+zeta_5^3)</li>
<li><strong>Bracket variable A = zeta_10^3 = -zeta_5^4 = (1,1,1,1)</strong> in Cyc5; order 10 (A^10=1, A^5=-1); all 10 A-powers precomputed in lookup table</li>
<li><strong>Delta = phi = (0,0,-1,-1)</strong> in Cyc5, verified exactly as -A^2 - A^{-2}; confirmed real and equal to (1+sqrt(5))/2 numerically; phi^2 = phi+1 verified exactly</li>
<li><strong>Delta powers via Fibonacci</strong>: phi^k = F(k-1) + F(k)*phi, represented as (F(k-1), 0, -F(k), -F(k)) in Cyc5 — Fibonacci numbers appear naturally as delta power coefficients</li>
<li><strong>Catalog dramatically richer than ell=4</strong>: expected well above 56 values (ell=4 baseline); all 4 basis coordinates populated (full axiality, not restricted to 2D subspace)</li>
<li><strong>Fibonacci growth in coefficients</strong>: max |coefficient| grows with braid length due to Fibonacci delta powers (unlike bounded coefficients at ell=4/delta=0)</li>
<li><strong>2-input Re&gt;0 encoding comparison</strong>: multiplicative achieves &gt;=8/16 truth tables; additive constrained to even truth tables (bit 0 forced to 0 since Re(0)=0 is not &gt;0) — convexity constraint limits additive</li>
<li><strong>3-input batch search across 8 activations x 2 encodings</strong>: Re&gt;0, Im&gt;0, Split-sigmoid, Sector k=2/4/6/8, Magnitude tau=1 — all tested with multiplicative AND additive encoding</li>
<li><strong>Head-to-head comparison table</strong>: for each activation, counts multiplicative-only, additive-only, both, and neither NPN classes; reports union (mult OR add) as best combined achievability</li>
<li><strong>Headline test: 0x1B/0x06 Re&gt;0 wall</strong>: the central question — does rank-4 ring (Z[zeta_5]) dissolve the barrier that rank-2 ring (Z[i]) could not?</li>
<li><strong>Additive Re&gt;0 still limited</strong>: bounded to &lt;=7/13 classes (convexity constraint persists regardless of ring rank)</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Prediction 1 (catalog richer than ell=4)</strong>: CONFIRMED — 4D ring produces dramatically more distinct bracket values than 2D Z[i]</li>
<li><strong>Prediction 2 (axiality — all 4 basis coordinates populated)</strong>: CONFIRMED — catalog entries span full Z[zeta_5], not a low-dimensional subspace</li>
<li><strong>Prediction 3 (Re&gt;0 + multiplicative may break 0x1B/0x06 wall)</strong>: tested as headline — outcome determines whether barrier is ring-rank or activation-structural</li>
<li><strong>Prediction 4 (Re&gt;0 + additive still weak)</strong>: CONFIRMED — convexity constraint limits additive encoding regardless of ring rank</li>
<li><strong>Fibonacci-delta connection</strong>: delta = phi at ell=5 means delta powers are Fibonacci numbers — the Fibonacci anyon name is literal, not just categorical</li>
<li><strong>Additive bit-0 constraint</strong>: Re(0)=0 is not &gt;0, so additive encoding always has f(0,0,0)=0, restricting to even truth tables</li>
</ul>
<h3>Data</h3>
<ul>
<li>Bracket variable: A = (1,1,1,1) in Cyc5 = zeta_10^3 = -zeta_5^4, order 10</li>
<li>A^{-1} = (0,-1,0,0) = -zeta_5</li>
<li>Delta = (0,0,-1,-1) = phi = 1.6180... (golden ratio)</li>
<li>phi^2 = phi + 1 verified exactly in Cyc5</li>
<li>Catalog enumeration: 2-strand len 1-10, 3-strand len 1-6, 4-strand len 1-6 (capped at 100,000 braids per config)</li>
<li>8 activation functions: Re&gt;0, Im&gt;0, Split-sigmoid, Sector k=2/4/6/8, Magnitude tau=1.0</li>
<li>2 encodings: multiplicative (z = w1^x1 <em> w2^x2 </em> w3^x3) and additive (z = x1<em>w1 + x2</em>w2 + x3*w3)</li>
<li>ell=4 baseline: 56 catalog values, Re&gt;0+mult 11/13, Re&gt;0+add 5/13, 0x1B and 0x06 both unreachable</li>
<li>Fibonacci table precomputed to F(31) for delta powers up to 30</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong><code>Cyc5</code> type</strong>: Z[zeta_5] cyclotomic integer — struct with 4 long coefficients {c[0]..c[3]}</li>
<li><strong><code>cyc5_zero/one/add/neg/mul/eq/is_zero/to_cx/print</code></strong>: complete Z[zeta_5] arithmetic; mul uses convolution + reduction via zeta_5^5=1 and zeta_5^4=-(1+z+z^2+z^3)</li>
<li><strong><code>A_table[10]</code></strong>: precomputed powers A^0 through A^9 as Cyc5 elements; <code>cyc5_a_power(int)</code> with mod-10 wraparound (handles negative powers)</li>
<li><strong><code>cyc5_delta_power(int k)</code></strong>: delta^k via Fibonacci: phi^k = (F(k-1), 0, -F(k), -F(k)); precomputed Fibonacci table to MAX_DELTA_POW=30</li>
<li><strong><code>state_sum_bracket()</code></strong>: full state-sum bracket at ell=5 — iterates 2^{word_len} states, composes planar diagrams, counts loops (glue + trace closure), weights by delta^{loops-1} * A^{a_power}; returns Cyc5 exact value</li>
<li><strong>Planar matching infrastructure</strong>: <code>PlanarMatch</code> struct, <code>make_identity_diagram()</code>, <code>make_generator_diagram()</code>, <code>compose_diagrams()</code> (with loop counting), <code>trace_closure_loops()</code> — identical to <a href="./entries/demo_55.html">Demo 55</a>/57</li>
<li><strong><code>build_catalog()</code></strong>: enumerates braids across 3 strand counts (n=2,3,4) at multiple lengths, deduplicates exact Cyc5 bracket values, stores both exact and float representations</li>
<li><strong>5 activation classifiers</strong>: <code>re_positive_classify()</code>, <code>im_positive_classify()</code>, <code>split_sigmoid_classify()</code>, <code>sector_classify(z, k)</code> (angular sectors), <code>magnitude_classify(z, tau)</code> — unified via <code>int (*classify)(Cx, int)</code> function pointer table</li>
<li><strong><code>search_3input_batch()</code></strong>: exhaustive catalog^3 triple search for both multiplicative and additive encoding; classifies 8 inputs per triple across all 8 activations simultaneously; aggregates by NPN class</li>
<li><strong><code>Activation</code> table</strong>: 8 activations with name/function-pointer/param, enabling batch comparison</li>
<li><strong>NPN classification</strong>: <code>npn_init()</code> computes canonical forms for all 256 3-input Boolean functions; <code>npn_build_classes()</code> extracts 13 non-trivial NPN classes with orbit sizes</li>
<li><strong><code>fn2_name()</code> / <code>fn3_name()</code></strong>: human-readable names for 2-input (16 TTs) and 3-input NPN canonical truth tables</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>Fibonacci anyons</strong>: tau anyon with quantum dimension phi, fusion rule tau x tau = 1 + tau</li>
<li><strong>Freedman-Larsen-Wang (2002)</strong>: Fibonacci anyon braid representations dense in PSU(2), hence universal for quantum computation</li>
<li><strong>Z[zeta_5]</strong>: 5th cyclotomic integers, rank 4 over Z, natural home for bracket values at A=zeta_10^3</li>
<li><strong>Golden ratio in TL algebra</strong>: delta=phi at ell=5, delta powers are literal Fibonacci numbers</li>
<li><strong>Kauffman bracket at roots of unity</strong>: A = e^{i<em>pi</em>(2k+1)/2ell} parametrization, each ell giving different cyclotomic ring and delta value</li>
<li><strong>DKC (Diagrammatic Knot Computation)</strong>: forward direction — exact bracket values compute Boolean functions without training</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Does ell=5 break the 0x1B/0x06 Re&gt;0 wall? (This is THE headline result — depends on actual program output)</li>
<li>If the wall holds at rank 4, is it an activation-structural barrier rather than a ring-rank barrier?</li>
<li>How does the multiplicative encoding benefit from 4D vs 2D? (More angular diversity, or more magnitude diversity, or both?)</li>
<li>Can Fibonacci growth in delta power coefficients cause integer overflow issues at longer braid lengths?</li>
<li>What is the optimal level ell for maximizing Boolean function reachability across all activations?</li>
<li>Does the Fibonacci fusion rule (tau x tau = 1 + tau) have a direct combinatorial reflection in which truth tables are achievable?</li>
<li>How does the ell=5 reachability compare with sector k=6 (which achieved all 13 at ell=4 in <a href="./entries/demo_50.html">Demo 50</a>)?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_59.html">Demo 59</a>: Q=3 Potts DKC (ell=6, delta=sqrt(3))</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_59_q3_potts_dkc/main.c.html">demo_59_q3_potts_dkc/main.c</a></code> (~1496 lines)</li>
<li><strong>Tests</strong>: ~15+ pass (Part A: zeta_24^24=1, zeta_24^12=-1, A*A^{-1}=1, A^24=1, delta=-A^2-A^{-2}, delta real and =sqrt(3), delta^2=3, delta^3 mul==formula, catalog &gt;=20 values, &gt;=2 basis coords used; Part B: additive even-only check, 2-input mult &gt;=8; Part C: NPN=13; Part E: Re&gt;0+mult &gt;=11, additive Re&gt;0 limited; Part F: complement symmetry, theta=0 matches Re&gt;0)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_55.html">Demo 55</a>/57/58 (planar matching + diagram operations, prior ell values), <a href="./entries/demo_54.html">Demo 54</a> (DKC at ell=4, Z[zeta_16], 11/13 Re&gt;0 wall), <a href="./entries/demo_56.html">Demo 56</a> (DKC at ell=5, Z[zeta_5]), <a href="./entries/demo_48.html">Demos 48</a>-<a href="./entries/demo_50.html">50</a> (DKC at ell=∞/delta=0)</li>
<li><strong>Feeds into</strong>: cross-ell comparison of the 11/13 Re&gt;0 wall; confirms wall is universal across evaluation levels; rotated half-plane sweep reveals orientation-dependent reachability</li>
</ul>
<h3>Headline</h3>
Third independent verification of the 11/13 Re&gt;0 wall: at ell=6 (Q=3 Potts model, delta=sqrt(3)), bracket values live in Z[zeta_24] (rank 8 over Z), and multiplicative Re&gt;0 still reaches exactly 11/13 NPN classes with 0x1B and 0x06 unreachable — matching ell=4 (Z[i]) and ell=5 (Z[zeta_5]). Rotated half-plane sweep across 24 angles reveals orientation-dependent reachability with complement symmetry. Additive encoding is strictly weaker due to convexity constraint.
<h3>Key Results</h3>
<ul>
<li><strong>Part A</strong>: Z[zeta_24] exact arithmetic with 8-component basis, reduction zeta^8=zeta^4-1 (Phi_24); A=zeta_24^7 (order 24); delta=zeta^2-zeta^6=sqrt(3); delta^2=3, delta^3 via formula matches multiplication; precomputed A^k table for k=0..23 (A^12=-1, A^{12+k}=-A^k); bracket catalog built from 2-4 strand braids up to length 6-10; axiality analysis: coefficient usage distribution, sub-ring axiality check (even-only coords → Z[zeta_12])</li>
<li><strong>Part B</strong>: 2-input encoding comparison — multiplicative (z=w1^x1<em>w2^x2) vs additive (z=x1</em>w1+x2*w2) with Re&gt;0 activation; multiplicative achieves &gt;=8/16 2-input functions; additive constrained: bit 0 always 0 (z(0,0)=0 has Re=0, not &gt;0), so only even truth tables</li>
<li><strong>Part C</strong>: 3-input DKC search with both encodings across 8 activation functions (Re&gt;0, Im&gt;0, split-sigmoid, sector k=2/4/6/8, magnitude tau=1); full reachability grids printed; NPN classes 0x1B and 0x06 flagged as key wall indicators</li>
<li><strong>Part D</strong>: Head-to-head multiplicative vs additive comparison per activation; identifies MULT-ONLY, ADD-ONLY, BOTH, and NEITHER classes; per-activation best achievability with union counts; add-only classes listed</li>
<li><strong>Part E</strong>: Cross-ell headline comparison: ell=4 (11/13, catalog 56), ell=5 (11/13, catalog 116), ell=6 (11/13 with mult Re&gt;0, 0x1B and 0x06 still NO); Im&gt;0+mult may reach 12/13 (0x06 YES, 0x1B still NO), matching ell=4 and ell=5 patterns; wall HOLDS at third independent verification</li>
<li><strong>Part F</strong>: Rotated half-plane sweep — sigma_theta(z) = [Re(e^{i<em>theta}</em>z) &gt; 0] for 24 angles (0-345 degrees in 15-degree steps); multiplicative encoding; tracks NPN reachability, 0x1B/0x06 status per angle; complement symmetry verified (theta and theta+180 give same NPN count); theta=0 confirms 11/13 matching Part C</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li>CONFIRMED (third time): Re&gt;0 multiplicative encoding reaches exactly 11/13 NPN classes at ell=6 — 0x1B and 0x06 remain unreachable</li>
<li>CONFIRMED: Wall is universal across evaluation levels (ell=4, 5, 6 all give 11/13 with same missing classes)</li>
<li>CONFIRMED: Im&gt;0 breaks 0x06 but not 0x1B (12/13 pattern matches ell=4 and ell=5)</li>
<li>CONFIRMED: Additive encoding strictly weaker due to convexity constraint (z(0,0,0)=0 forces bit 0 = 0)</li>
<li>CONFIRMED: NPN complement symmetry for rotated half-plane (theta and theta+180 have identical reachability)</li>
<li>CONFIRMED: Z[zeta_24] arithmetic consistent (all delta power, A power, cross-checks pass)</li>
<li>OBSERVED: Catalog size at ell=6 potentially smaller than ell=5 despite higher-rank ring ("smaller catalog despite rank-8 ring is surprising")</li>
<li>TESTED: Rotated half-plane orientation dependence — some angles may achieve 13/13 (full reachability)</li>
</ul>
<h3>Data</h3>
<ul>
<li>Ring: Z[zeta_24] (8-dimensional over Z), basis {1, zeta_24, ..., zeta_24^7}, minimal polynomial Phi_24(x)=x^8-x^4+1</li>
<li>A = zeta_24^7 = e^{i<em>7</em>pi/12}, order 24; A^{-1} = A^{23}</li>
<li>delta = sqrt(3) = (0,0,2,0,0,0,-1,0) in Cyc24; delta^2 = 3; Q = delta^2 = 3 (3-state Potts)</li>
<li>Delta powers: delta^{2k} = 3^k, delta^{2k+1} = 3^k * sqrt(3)</li>
<li>A^k precomputed table: 24 entries, A^12 = -1</li>
<li>Catalog: 2-4 strand braids, lengths 1-10/6/6 respectively, capped at 100000 braids per (n,length)</li>
<li>8 activation functions tested: Re&gt;0, Im&gt;0, split-sigmoid, sector k=2/4/6/8, magnitude tau=1.0</li>
<li>3-input search: catalog^3 triples, both multiplicative (z=w1^x1<em>w2^x2</em>w3^x3) and additive (z=x1<em>w1+x2</em>w2+x3*w3) encodings</li>
<li>Rotated sweep: 24 angles at 15-degree increments, multiplicative encoding only</li>
<li>Cross-ell reference: ell=4 (56 values, 11/13), ell=5 (116 values, 11/13), ell=6 (catalog size reported, 11/13)</li>
<li>Negation coverage tracked (entries with negative in catalog)</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>Cyc24</code> type: exact Z[zeta_24] cyclotomic arithmetic (8-component, Phi_24 reduction zeta^8=zeta^4-1); <code>cyc24_zero/one/add/neg/mul/eq/is_zero/to_cx/print</code></li>
<li><code>A_table[24]</code>: precomputed A^k values for k=0..23; <code>cyc24_a_power()</code> with mod-24 lookup</li>
<li><code>cyc24_delta_power()</code>: exact delta^k using delta^2=3 (even→3^m integer, odd→3^m*sqrt(3))</li>
<li><code>PlanarMatch</code> / diagram operations: <code>make_identity_diagram()</code>, <code>make_generator_diagram()</code>, <code>compose_diagrams()</code>, <code>trace_closure_loops()</code> — shared topology-independent code from <a href="./entries/demo_55.html">Demos 55</a>/57/58</li>
<li><code>BraidCrossing</code> + <code>state_sum_bracket()</code>: state-sum bracket at ell=6 with Cyc24 weights</li>
<li><code>decode_braid()</code>: integer index → crossing sequence</li>
<li><code>build_catalog()</code>: enumerates 2-4 strand braids, stores distinct nonzero Cyc24 values + precomputed Cx doubles</li>
<li><code>Activation</code> table: 8 activation functions with uniform <code>int (*classify)(Cx, int)</code> signature; <code>wrap_split_sigmoid</code>, <code>wrap_sector</code>, <code>wrap_magnitude</code>, <code>wrap_re_positive</code>, <code>wrap_im_positive</code></li>
<li><code>split_sigmoid_classify()</code>: smooth XOR of Re/Im sigmoids at threshold 0.5</li>
<li><code>sector_classify()</code>: k-sector angular classification (sector mod 2)</li>
<li><code>magnitude_classify()</code>: |z| &gt; tau threshold</li>
<li>NPN classification: <code>npn_transform()</code>, <code>npn_init()</code>, <code>npn_build_classes()</code>, <code>npn_canon[256]</code> — same as <a href="./entries/demo_48.html">Demos 48</a>-<a href="./entries/demo_50.html">50</a></li>
<li><code>search_3input_batch()</code>: batch search over catalog^3 triples with both multiplicative and additive encoding, all 8 activations simultaneously; aggregates per NPN class</li>
<li><code>fn2_name()</code> / <code>fn3_name()</code>: truth table → human-readable function names (16 2-input, 15 3-input named functions)</li>
<li>Part F rotated sweep: 24-angle sigma_theta with precomputed cos/sin, multiplicative encoding, complement symmetry verification</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Q=3 Potts model at criticality (delta^2=3, SU(2) level 4)</li>
<li>Z[zeta_24]: 24th cyclotomic integers, minimal polynomial Phi_24(x)=x^8-x^4+1</li>
<li>Temperley-Lieb at ell=6 (delta-potent regime: e_i^2=sqrt(3)*e_i)</li>
<li>NPN classification of 3-input Boolean functions (13 non-trivial classes)</li>
<li>Half-plane classifiers and rotated decision boundaries</li>
<li>Multiplicative vs additive input encoding for complex-valued neural networks</li>
<li>Convexity constraint on additive encoding (z(0,...,0)=0 ∈ boundary)</li>
<li>Cross-ell universality: the 11/13 Re&gt;0 wall as a structural invariant</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Is the 11/13 Re&gt;0 wall provably universal across ALL ell values, or could some ell break it?</li>
<li>What algebraic property of 0x1B and 0x06 makes them specifically unreachable by Re&gt;0 multiplicative?</li>
<li>Does the rotated half-plane sweep reveal an angle where 13/13 is achieved? If so, what is the minimum such angle?</li>
<li>Why is the ell=6 catalog smaller than ell=5 despite the higher-rank ring? Is this a search depth limitation or a structural property?</li>
<li>Can the complement symmetry (theta ↔ theta+180) be extended to a full symmetry group acting on the reachability landscape?</li>
<li>Is there a single activation function that achieves 13/13 across ALL ell values simultaneously?</li>
<li>Connection between Q=3 Potts criticality (conformal field theory) and the Boolean function reachability hierarchy?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_60.html">Demo 60</a>: ell=7 Cubic Wall</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_60_cubic_wall/main.c.html">demo_60_cubic_wall/main.c</a></code> (~1012 lines)</li>
<li><strong>Tests</strong>: 15/15 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_35.html">Demo 35</a> (planar matching enumeration), <a href="./entries/demo_51.html">Demo 51</a> (radical anatomy at delta=0), <a href="./entries/demo_52.html">Demo 52</a> (Chebyshev multi-delta radical structure)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_61.html">Demo 61</a>-<a href="./entries/demo_62.html">62</a> (11/13 theorem); extends radical dimension formulas into cubic number fields; confirms universality beyond quadratic cases</li>
</ul>
<h3>Headline</h3>
First test of TL radical anatomy at a cubic number field: at ell=7 (delta=2cos(pi/7), root of x^3-x^2-2x+1=0), all dimension formulas extend universally — rad=11=2*7-3 at n=7, rad=39=7^2-7-3 at n=8, rad^2=1, nilpotency=3, Fibonacci rank F(6)=8.
<h3>Key Results</h3>
<ul>
<li><strong>Cubic number field arithmetic</strong>: delta=2cos(pi/7) satisfies x^3-x^2-2x+1=0, first non-quadratic case</li>
<li><strong>Semisimplicity boundary confirmed</strong>: TL_n semisimple for n=2..6 (n &lt; ell=7), non-semisimple at n=7</li>
<li><strong>Radical dimension formulas verified</strong>: n=7 rad=11 (2*7-3), n=8 rad=39 (49-7-3)</li>
<li><strong>rad^2 = 1-dimensional</strong> at both n=7 and n=8</li>
<li><strong>Nilpotency uniformly 3</strong>: rad^3=0 at both n=7 and n=8</li>
<li><strong>Fibonacci rank = F(6) = 8</strong>: Sector decomposition: sector 1 (rank 3), sector 3 (rank 4), sector 5 (rank 1), sector 7 (rank 0). Sum = 8.</li>
<li><strong>Cross-validation at two primes</strong>: p1=10^9+7, p2=10^9+9 agree on all results</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>rad(TL_ell) = 2*ell-3</strong>: CONFIRMED at ell=7 (cubic), extending from quadratic cases</li>
<li><strong>rad(TL_{ell+1}) = ell^2-ell-3</strong>: CONFIRMED (rad(TL_8) = 39)</li>
<li><strong>rad^2 = 1-dimensional</strong>: CONFIRMED at ell=7</li>
<li><strong>Nilpotency = 3</strong>: CONFIRMED at ell=7</li>
<li><strong>Fibonacci rank = F(ell-1)</strong>: CONFIRMED (F(6) = 8)</li>
<li><strong>Universality conjecture</strong>: STRENGTHENED — all formulas hold regardless of number field degree</li>
</ul>
<h3>Data</h3>
<table><thead><tr><th>n</th><th>dim (C_n)</th><th>rank</th><th>rad</th><th>rad^2</th><th>nilp</th></tr></thead><tbody><tr><td>2</td><td>2</td><td>2</td><td>0</td><td>-</td><td>-</td></tr><tr><td>3</td><td>5</td><td>5</td><td>0</td><td>-</td><td>-</td></tr><tr><td>4</td><td>14</td><td>14</td><td>0</td><td>-</td><td>-</td></tr><tr><td>5</td><td>42</td><td>42</td><td>0</td><td>-</td><td>-</td></tr><tr><td>6</td><td>132</td><td>132</td><td>0</td><td>-</td><td>-</td></tr><tr><td>7</td><td>429</td><td>418</td><td>11</td><td>1</td><td>3</td></tr><tr><td>8</td><td>1430</td><td>1391</td><td>39</td><td>1</td><td>3</td></tr></tbody></table>
<p>Fibonacci rank sectors: 3+4+1+0 = 8 = F(6)</p>
<h3>Code Assets</h3>
<ul>
<li><strong>Cubic extension field arithmetic</strong>: F_p[x]/(x^3-x^2-2x+1) with poly_mul, poly_pow</li>
<li><strong>Cantor-Zassenhaus cubic root finder</strong>: find_cubic_root() for splitting the cubic mod p</li>
<li><strong>TLAlgebra struct</strong>: Reusable TL construction up to n=8 (C_8=1430)</li>
<li><strong>Complete radical anatomy pipeline</strong>: analyze() — Gram matrix, RREF, radical basis, rad^2, rad^3, nilpotency</li>
<li><strong>Fibonacci rank test</strong>: fibonacci_rank_test() — sector bilinear rank decomposition</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Cubic number fields: Q(2cos(pi/7)), Galois group Z/3Z</li>
<li>Goodman-Wenzl: non-semisimplicity at n &gt;= ell</li>
<li>Cantor-Zassenhaus polynomial factoring</li>
<li>Chebyshev parametrization of semisimplicity boundary</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Do formulas extend to ell=8,9,...? Higher number field degrees (ell=11, degree 5)?</li>
<li>Is rad^2=1 universal for all ell?</li>
<li>Is nilpotency=3 universal for all ell &gt;= 3?</li>
<li>Can sector-by-sector rank decomposition (3+4+1+0=8) be predicted from ell and sector index?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_61.html">Demo 61</a>: Angular Proof of 11/13 Half-Plane Theorem</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_61_angular_proof/main.c.html">demo_61_angular_proof/main.c</a></code> (~662 lines)</li>
<li><strong>Tests</strong>: ~14 checks (Phase 1: A=4 NPN verification, B=3 fast search N=120, C=5 full proof N=360 + cross-check; Phase 2: H=1 obstruction 0x06, I=1 obstruction 0x1B)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_55.html">Demo 55</a> (DKC Boolean at delta=sqrt(2), multiplicative encoding), <a href="./entries/demo_48.html">Demo 48</a>/50 (NPN classification framework)</li>
<li><strong>Feeds into</strong>: Definitive classification of half-plane computability for multiplicative DKC; obstruction theory for Boolean function reachability</li>
</ul>
<h3>Headline</h3>
Proves via pure integer arithmetic (zero floating-point) that exactly 11 of 13 non-trivial NPN classes are reachable by half-plane activations on multiplicative encodings z(a,b,c) = w1^a <em> w2^b </em> w3^c, with 0x06 (XOR-AND) and 0x1B (CROSS) provably unreachable independent of angles or half-plane orientation.
<h3>Key Results</h3>
<ul>
<li><strong>Part A (NPN verification)</strong>: 14 NPN equivalence classes confirmed; canonical pairings verified (TRUE~FALSE, AND3~NOR3, XOR3~XNOR3)</li>
<li><strong>Part B (Fast search N=120)</strong>: 1.7M triples (120^3) searched; 12 classes found; 0x06 and 0x1B absent; establishes initial conjecture</li>
<li><strong>Part C (Full proof N=360)</strong>: 46.7M triples (360^3) searched with 8 boundary orientations each; 0x06 and 0x1B proven unreachable; exactly 12 achieved classes (11 non-trivial + FALSE); N=120 and N=360 results agree (cross-check); achieved set = {all 14} \ {0x06, 0x1B}</li>
<li><strong>Part D (Witnesses)</strong>: Each achieved class displayed with witness triple (p1, p2, p3), Hamming weight, and affinity flag</li>
<li><strong>Part E (Structural analysis)</strong>: All 14 classes displayed with weight, GF(2)-affinity, achievability, and TRUE set; key observation: affinity does NOT predict reachability (0x06 is affine but unreachable; 0x07, 0x16 are non-affine but reachable)</li>
<li><strong>Part F (NPN orbit sizes)</strong>: Orbit size, Hamming weight, affinity, and achievability tabulated for all 14 classes</li>
<li><strong>Part G (Additive triple analysis)</strong>: 6 non-trivial additive triples (b1,b2 → b3=b1|b2 where b1&amp;b2=0) analyzed for "additive conflicts" (b1 IN, b2 IN, b3 OUT); 0x06 has local additive conflicts explaining its obstruction; 0x1B has NO local conflicts (Cnt0=0) — its obstruction is global, not local</li>
<li><strong>Part H (Minimal obstruction for 0x06)</strong>: Exhaustive search over all constraint subsets at N=60 finds minimum-size infeasible subsets; proves 0x06 blocked by small constraint sets</li>
<li><strong>Part I (Minimal obstruction for 0x1B)</strong>: Same analysis for 0x1B; proves 0x1B blocked despite lacking local additive conflicts</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>11/13 Half-Plane Theorem</strong>: For ALL half-plane activations on multiplicative encodings z(a,b,c) = w1^a <em> w2^b </em> w3^c, exactly 11 of 13 non-trivial NPN classes are reachable; the unreachable classes are 0x06 (XOR-AND) and 0x1B (CROSS), independent of angles (phi1, phi2, phi3) and half-plane orientation</li>
<li><strong>Additive angle structure</strong>: With multiplicative encoding, angle(z(a,b,c)) = a<em>phi1 + b</em>phi2 + c*phi3 (mod 2pi) — the 8 z-values form an additively structured configuration on the circle; half-plane classification = semicircle separability on this additive circle</li>
<li><strong>0x06 obstruction (local)</strong>: Requires two angles in a semicircle with their sum outside — impossible for any additive angle structure (the sum of two angles in a semicircle is at most one more semicircle away)</li>
<li><strong>0x1B obstruction (global)</strong>: Requires {0, phi3, phi2+phi3, phi1} in semicircle but phi2 outside — the gap structure is incompatible with semicircle separation despite no local additive triple conflict</li>
<li><strong>Affinity ≠ reachability</strong>: GF(2) affine structure of the TRUE set does not determine half-plane reachability; the obstruction is geometric (semicircle separability on additively-structured circle), not algebraic</li>
<li><strong>Proof completeness</strong>: 8 angles form C(8,2)=28 coincidence hyperplanes on the 3-torus [0,N)^3, creating O(10^4) chambers; grid spacing 1 at N=360 guarantees every chamber contains ~10^4 grid points, making the search provably exhaustive</li>
</ul>
<h3>Data</h3>
<ul>
<li>N=120 fast search: 120^3 = 1,728,000 triples × 8 boundaries = ~13.8M configurations</li>
<li>N=360 full proof: 360^3 = 46,656,000 triples × 8 boundaries = ~373M configurations</li>
<li>12 achieved NPN classes with witness triples (p1, p2, p3)</li>
<li>2 unreachable classes: 0x06 (weight 2, affine) and 0x1B (weight 4, non-affine)</li>
<li>6 additive triples with conflict counts per NPN class</li>
<li>Minimal obstruction sizes for 0x06 and 0x1B at N=60</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>build_npn()</code> — NPN canonical form computation for all 256 truth tables (includes output negation in the NPN group)</li>
<li><code>search(grid_n, show_progress)</code> — exhaustive grid search over all (p1, p2, p3) in {0..N-1}^3; computes 8 integer angles mod N; tests 8 semicircle boundary positions per triple; records achieved NPN classes and witness triples</li>
<li><code>masked_feasible(target, mask, grid_n)</code> — checks if a partial truth table (target restricted to mask bits) is achievable at given grid resolution</li>
<li><code>find_min_obstruction(target, grid_n, ...)</code> — finds minimum-size infeasible constraint subsets by exhaustive search over all masks of increasing size</li>
<li><code>is_affine(tt)</code> — tests if truth table's TRUE set forms a GF(2) affine subspace (a^b^c closed)</li>
<li><code>print_true_set()</code>, <code>print_constraints()</code>, <code>angle_label()</code> — display utilities for truth table analysis</li>
<li><code>popcnt()</code> — Hamming weight (population count)</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>NPN equivalence classes of 3-input Boolean functions (complete enumeration)</li>
<li>Semicircle separability on additively-structured angle configurations</li>
<li>Coincidence hyperplane arrangements on the 3-torus</li>
<li>GF(2) affine subspaces and Boolean function classification</li>
<li>Minimal infeasible subsystems (obstruction theory for geometric feasibility)</li>
<li>Multiplicative encoding as natural DKC representation (angles are additive)</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Can the 0x06 and 0x1B obstructions be expressed as closed-form algebraic conditions (not just computational proof)?</li>
<li>Does the 11/13 ratio persist for 4+ inputs, or do more classes become unreachable with higher-dimensional additive angle structures?</li>
<li>Is there a deeper connection between the two unreachable classes (0x06 and 0x1B seem structurally different — one has local conflicts, one has global-only)?</li>
<li>Can multi-sector activation (k&gt;2) recover 0x06 and 0x1B under multiplicative encoding, as it recovered parity under additive encoding in <a href="./entries/demo_50.html">Demo 50</a>?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_62.html">Demo 62</a>: Analytical Proof — Why 0x06 and 0x1B Are Unreachable</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_62_analytical_proof/main.c.html">demo_62_analytical_proof/main.c</a></code> (~600 lines)</li>
<li><strong>Tests</strong>: 7 checks: 0x1B never achieved numerically, 0x1B absent in exhaustive N=120, 0x06 never achieved numerically, 0x06 absent in exhaustive N=120, 0x06 orbit = 24, 0x1B orbit = 24, total unreachable = 48</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_61.html">Demo 61</a> (computational proof that exactly 11/13 NPN classes reachable by half-plane activations on multiplicative encodings)</li>
<li><strong>Feeds into</strong>: Closes the half-plane wall investigation definitively; theoretical foundation for DKC activation design</li>
</ul>
<h3>Headline</h3>
Provides two independent analytical proofs that exactly 0x06 (~A(B^C)) and 0x1B (CROSS) are unreachable by semicircle (half-plane) activations on multiplicative encodings — pure algebra with no search, working for continuous angles (which subsumes all discrete cases). The 0x1B proof is a 3-step algebraic contradiction (lower bound &gt; upper bound on phi1); the 0x06 proof is a four-semicircle parallelogram argument showing all gaps &lt; pi, making the intersection empty.
<h3>Key Results</h3>
<ul>
<li><strong>Proof A — 0x1B (CROSS)</strong>: Direct algebraic contradiction in 3 steps.</li>
<li>Step 1: WLOG set theta=0 (since 0 is in TRUE set). phi1, phi3 in [0,pi), phi2 in [pi,2pi).</li>
<li>Step 2: Write phi2 = pi+x, phi3 = y. Constraint phi2+phi3 in S forces x+y &gt;= pi (I). Constraint phi1+phi2+phi3 in S-bar forces phi1 &gt;= 2pi-x-y (II). Constraint phi1+phi2 in S-bar forces phi1 &lt; pi-x (III).</li>
<li>Step 3: Combining (II) and (III): 2pi-x-y &lt;= phi1 &lt; pi-x, which requires 2pi-y &lt; pi, i.e. pi &lt; y. But y = phi3 &lt; pi. <strong>CONTRADICTION.</strong> QED.</li>
<li><strong>Proof B — 0x06 (XOR-AND)</strong>: Four-semicircle parallelogram argument.</li>
<li>The 4 constraints on phi1 (phi1 not in S, phi1+alpha not in S, phi1+beta not in S, phi1+alpha+beta not in S) define 4 semicircles whose midpoints form a parallelogram on the circle.</li>
<li>Key inequality: alpha+beta &gt; pi (forced by phi2+phi3 not in S).</li>
<li>This makes ALL four gaps between consecutive midpoints &lt; pi.</li>
<li>Intersection of 4 semicircles is non-empty iff some gap &gt;= pi. Since all gaps &lt; pi, intersection is <strong>EMPTY.</strong> QED.</li>
<li><strong>NPN symmetry</strong>: proofs extend to full NPN orbits via input permutation (relabeling phi_i), input negation (reflecting angles), and output negation (swapping S with S-bar). Orbit of 0x06 = 24 truth tables, orbit of 0x1B = 24. Total unreachable = 48/256.</li>
<li><strong>Numerical verification</strong>: hand-picked near-miss configurations tested at 1000 theta values — neither 0x06 nor 0x1B ever achieved.</li>
<li><strong>Exhaustive verification</strong>: all (p1,p2,p3) in Z_120^3 with all 8 possible threshold anchors — neither NPN class found, confirming both proofs.</li>
<li><strong>Gap analysis demo</strong>: shows parallelogram gap structure for near-miss configurations, illustrating why the proof works — the "big gap" always stays below pi.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Theorem (0x1B)</strong>: For any angles phi1, phi2, phi3 in [0,2pi) and any semicircle S = [theta, theta+pi), the truth table of in_semi(x1<em>phi1 + x2</em>phi2 + x3*phi3, theta) cannot be NPN-equivalent to 0x1B. Proof by direct algebraic contradiction (interval squeeze).</li>
<li><strong>Theorem (0x06)</strong>: For any angles phi1, phi2, phi3 in [0,2pi) and any semicircle S, the truth table cannot be NPN-equivalent to 0x06. Proof by parallelogram gap argument (4 semicircles with all gaps &lt; pi have empty intersection).</li>
<li><strong>Corollary</strong>: Exactly 11/13 NPN classes of 3-input Boolean functions are realizable by semicircle thresholding of angle sums. The wall is geometric, not computational — no refinement of the angular grid will ever find these two classes.</li>
<li><strong>Key insight</strong>: The additive structure of multiplicative encodings (z = w1^a <em> w2^b </em> w3^c, so angles ADD) creates a parallelogram constraint on the circle that is incompatible with the alternating parity structure of 0x06 and 0x1B.</li>
</ul>
<h3>Data</h3>
<ul>
<li>Near-miss numerical tests: 5 configurations per target, 1000 theta sweeps each</li>
<li>Exhaustive integer search: N=120 (120^3 = 1,728,000 triples x 8 threshold anchors)</li>
<li>NPN orbit sizes: 0x06 has 24 members, 0x1B has 24 members, 48 total unreachable out of 256</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong><code>prove_0x1B()</code></strong>: prints the 3-step algebraic proof with full reasoning, then numerically verifies + exhaustive integer check</li>
<li><strong><code>prove_0x06()</code></strong>: prints the parallelogram proof with full reasoning, then numerically verifies + exhaustive integer check</li>
<li><strong><code>gap_analysis_demo()</code></strong>: for near-miss configurations, computes and displays the parallelogram gap structure (alpha, beta-alpha, alpha, 2pi-alpha-beta) showing all gaps &lt; pi</li>
<li><strong><code>npn_symmetry_argument()</code></strong>: explains how input permutation, input negation, and output negation extend proofs to full NPN orbits; verifies orbit sizes</li>
<li><strong><code>truth_table()</code></strong>: computes 8-bit truth table from three angles and a threshold angle</li>
<li><strong><code>in_semi()</code></strong>: semicircle membership test (angle in [theta, theta+pi) mod 2pi)</li>
<li><strong><code>wrap()</code></strong>: angle normalization to [0, 2pi)</li>
<li><strong>NPN canonicalization</strong>: standard 96-transform minimum (reused from <a href="./entries/demo_61.html">Demo 61</a>)</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Semicircle / half-plane activation functions and their geometric constraints</li>
<li>NPN equivalence and orbit structure for 3-input Boolean functions</li>
<li>Parallelogram / gap analysis on the circle (covering arguments)</li>
<li>Connection to classical perceptron limitations: the wall is a higher-dimensional analog of the XOR problem, but for multiplicative (angular) encodings rather than additive (linear) ones</li>
<li>Intersection of semicircles on S^1: non-empty iff max gap &gt;= pi</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Can the parallelogram argument be generalized to 4+ input functions to characterize unreachable NPN classes at higher arities?</li>
<li>Is there a unified proof that handles both 0x06 and 0x1B simultaneously (they use different argument structures)?</li>
<li>What is the exact characterization of reachable NPN classes for other activation geometries (sectors, magnitude thresholds)?</li>
<li>Does the 11/13 ratio have a deeper algebraic meaning (e.g., related to the structure of the Boolean lattice or the symmetric group S_3)?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_63.html">Demo 63</a>: Angular Anatomy of DKC</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_63_angular_anatomy/main.c.html">demo_63_angular_anatomy/main.c</a></code> (~1957 lines)</li>
<li><strong>Tests</strong>: 29/29 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_29.html">Demo 29</a> (Z[zeta_8] exact arithmetic, bracket catalog), <a href="./entries/demo_50.html">Demo 50</a> (four-tier NPN hierarchy, parity at k=6), <a href="./entries/demo_35.html">Demo 35</a> (TL matrix representations), <a href="./entries/demo_39.html">Demo 39</a> (Markov RT truncation connection)</li>
<li><strong>Feeds into</strong>: Paper 1 (4/5-input parity, parity ceiling); future demos on Z[zeta_16] scaling</li>
</ul>
<h3>Headline</h3>
Establishes that the four-tier NPN reachability structure is determined by discrete octant-sector geometry, derives the complete parity scaling law for Z[zeta_8] (ceiling n=5), extends DKC to 4-input (k=8, 96 solutions) and 5-input (k=15, 3020 solutions) parity, and connects the angular structure to oriented matroid theory.
<h3>Key Results</h3>
<ul>
<li><strong>Part A</strong>: All 100 catalog values are axial (single Z[zeta_8] component). Octant distribution: {17,8,17,11,11,11,17,8}.</li>
<li><strong>Part B</strong>: Sector-octant mapping for k=2..8,15,16. k=6 uniquely produces parity octants {2,4,5,7}.</li>
<li><strong>Part C</strong>: Representative weight triples from each tier showing sector-count mechanism.</li>
<li><strong>Part D</strong>: Four-tier NPN structure from pure geometry: k=2(5), k=3(+1), k=4(+6), k=6(+1=parity). Non-monotonic: 906@k=6 &gt; 756@k=7 &gt; 96@k=8.</li>
<li><strong>Part E</strong>: Triskelion anatomy at k=6. Two octant sets: {2,5,7}=636 (70.2%), {2,4,7}=270 (29.8%). Octants 2,7 mandatory.</li>
<li><strong>Part F</strong>: Commensurability analysis. gcd(k,8) controls structure.</li>
<li><strong>Part G</strong>: 21 distinct OM types. Parity requires ALTERNATING type only (-,+,- or +,-,+).</li>
<li><strong>Part H</strong>: 4-input XOR at k=8, 96 solutions. Tetraskelion: all 4 odd octants {1,3,5,7}.</li>
<li><strong>Part I</strong>: 5-input XOR at k=15, 3020 solutions. k=15 has 7 class-1 octants.</li>
<li><strong>Part J</strong>: Parity ceiling n=5. n=6,7 impossible (constraint wall); n≥8 impossible (pigeonhole).</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Four-tier from geometry</strong>: PROVEN (exhaustive)</li>
<li><strong>Parity requires alternating OM type</strong>: PROVEN (exhaustive, 0/1M non-alternating achieve parity)</li>
<li><strong>k=6 uniqueness</strong>: PROVEN (exhaustive k=2..16)</li>
<li><strong>Parity ceiling n=5</strong>: PROVEN (exhaustive search + pigeonhole)</li>
<li><strong>Universal k = 2M−1</strong>: CONJECTURED (proof sketch, not yet fully formal)</li>
<li><strong>k=2n triskelion conjecture</strong>: FALSIFIED (n=5 requires k=15, not k=10)</li>
</ul>
<h3>Data</h3>
<ul>
<li>Parity scaling: n=3→k=6(906), n=4→k=8(96), n=5→k=15(3020), n≥6→impossible</li>
<li>Solutions at k=15: n=3:23004, n=4:16108, n=5:3020, n=6:0, n=7:0</li>
<li>Octant distribution: {17,8,17,11,11,11,17,8}</li>
<li>21 oriented matroid types from 512 octant triples</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>angle_to_octant()</code>: Z[zeta_8] octant classifier</li>
<li>Sector-octant mapping for arbitrary k</li>
<li><code>cross_sign()</code>, <code>om_encode()</code>, <code>om_decode()</code>: oriented matroid classification</li>
<li><code>compute_tt4_at_k()</code>: 4-input DKC with 4-level pruning</li>
<li><code>pj_search()</code>: recursive n-input parity search with 2^n−1 subset constraints</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Cover (1965): linearly separable functions, k=2 tier</li>
<li>Reiner (2004): cyclotomic matroids mu_N, Z[zeta_8] as mu_8</li>
<li>Bjorner et al.: oriented matroid covector lattices</li>
<li>Aizenberg (2008): k-sector MVN activation</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Clean algebraic proof for n=6 constraint wall?</li>
<li>Z[zeta_16] constraint ceiling — is gap always 2?</li>
<li>Non-monotonic solution counts at k=15: a theorem?</li>
<li>OM type for n=4,5 parity?</li>
<li>Non-parity ceiling: NPN classes achievable at n=6?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_64.html">Demo 64</a>: Parity Matroid Recursion</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_64_parity_matroid_recursion/main.c.html">demo_64_parity_matroid_recursion/main.c</a></code> (~1745 lines)</li>
<li><strong>Tests</strong>: 22/22 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_50.html">Demo 50</a> (four-tier NPN hierarchy, parity at k=6, 906 solutions), <a href="./entries/demo_63.html">Demo 63</a> (angular anatomy, 5-input parity at k=15, parity ceiling n=5)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_65.html">Demo 65</a> (Clifford staircase — Z[zeta_16] scaling, XOR6 at higher cyclotomic ring)</li>
</ul>
<h3>Headline</h3>
The DKC parity hierarchy {XOR2, XOR3, XOR4, XOR5} is a funnel-shaped matroid minor chain with perfect downward deletion-contraction closure and collapsing upward extensibility, whose wall at n=6 is geometrically explained by the self-doubling impossibility in Z[zeta_8].
<h3>Key Results</h3>
<ul>
<li><strong>Matroid deletion-contraction closure (100% downward)</strong>: Deleting any weight from an XOR_n solution always yields an XOR_{n-1} solution (100%, all levels n=5→4→3→2). Contracting any input to 1 always yields an XNOR_{n-1} solution (100%, all levels). The parity hierarchy is a legitimate matroid minor chain.</li>
<li><strong>Funnel theorem (coverage collapses upward)</strong>: Upward extensibility degrades sharply — XOR3→XOR2: 99.3% (1459/1469), XOR4→XOR3: 39.2% (1503/3834), XOR5→XOR4: 19.2% (129/673), XOR6→XOR5: 0% (0/27). The n=6 wall casts a shadow all the way down: 80% of XOR4 weight sets are already dead ends.</li>
<li><strong>Parent-child multiplicity (near-tree at wall, dense mesh away)</strong>: XOR5→XOR4: max 2 parents, mean 1.05 (near-tree). XOR4→XOR3: max 8 parents, mean 1.79. XOR3→XOR2: max 29 parents, mean 7.88. The 6 collisions in the XOR5→XOR4 deletion map account exactly for 27×5=135 instances → 129 distinct children + 6 collisions.</li>
<li><strong>Vocabulary stratification (44 good values, 31 poison)</strong>: Of 83 class-1 catalog values at k=15, exactly 44 appear in XOR5 solutions and exactly the same 44 appear in extensible XOR4 solutions — strictly nested. 31 values are poison (appear only in orphan XOR4 solutions that cannot extend to XOR5). Poison values span octants {1,2,3,5,6,7} but not octant 4.</li>
<li><strong>Wall anatomy (minimum Hamming distance 4, errors only at weight 2+)</strong>: 2,241 extension attempts (27 XOR5 sets × 83 values). Closest failures land at d=4 (38 cases). Zero errors at input weight 0 or weight 1 — the wall manifests only at the pairwise interaction level and above. A second wall layer exists: d≥7 cases with 0 broken pairs but weight-3+ errors (GHZ-type higher-order obstruction).</li>
<li><strong>Self-doubling impossibility theorem</strong>: Self-extensions (w[5]=w[i]) always fail because 2·w[i] preserves the angle of w[i]; class-1 values (odd sector) doubled remain class-1 (odd sector), making the pair output for weight-2 input class-1 when it must be class-0. Accounts for 34/38 = 89.5% of all closest misses.</li>
<li><strong>Exact arithmetic required</strong>: Floating-point accumulation produces 420 spurious failures at XOR5→XNOR4 from association-order artifacts near sector boundaries. Eliminated entirely by exact Z[zeta_8] integer arithmetic (Cyc8 representation).</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Theorem (matroid minor chain)</strong>: {XOR2, XOR3, XOR4, XOR5} is deletion-contraction closed: deletion gives XOR_{n-1}, contraction gives XNOR_{n-1}. Verified exhaustively, all levels. PROVEN.</li>
<li><strong>Theorem (self-doubling impossibility)</strong>: Adding a 6th weight equal to any existing weight always fails. Proof: scalar doubling preserves angle; class-1 doubled is class-1; class-1 output contradicts required class-0 for even-parity input weight. PROVEN.</li>
<li><strong>Theorem (minimum wall distance d=4)</strong>: The closest any 6-weight candidate comes to satisfying XOR6 is 4 output errors (60/64 = 93.75% correct). No candidate achieves d=0,1,2,3. PROVEN (exhaustive).</li>
<li><strong>Conjecture (funnel rate)</strong>: The coverage fractions 99.3% → 39.2% → 19.2% → 0% follow some algebraic or exponential decay law as a function of n. OPEN.</li>
<li><strong>Conjecture (Clifford staircase)</strong>: XOR6 becomes achievable at Z[zeta_16] (next cyclotomic ring, fourth-level Clifford hierarchy), suggesting n-input parity climbs the Clifford hierarchy one rung per additional input. OPEN (target of <a href="./entries/demo_65.html">Demo 65</a>).</li>
</ul>
<h3>Data</h3>
<ul>
<li>Distinct unordered weight sets: XOR5=27, XOR4=673, XOR3=3834, XOR2=1469</li>
<li>XOR5 ordered solutions: 3,020 (≈112 per set, close to 5!=120 confirming near-complete permutation symmetry)</li>
<li>Upward coverage: XOR3→XOR2: 99.3%, XOR4→XOR3: 39.2%, XOR5→XOR4: 19.2%, XOR6→XOR5: 0%</li>
<li>Orphan counts: 10 (XOR2), 2331 (XOR3), 544 (XOR4), 27 (XOR5)</li>
<li>Extensible vocabulary: 44 values (good); poison vocabulary: 31 values; total class-1 at k=15: 83 - note: 75 total appear in all XOR4</li>
<li>Poison octant coverage: {1,2,3,5,6,7} — octant 4 absent</li>
<li>Wall Hamming distances: minimum d=4 (38 cases), 195 near-misses at d≤8, peak near d=15-16</li>
<li>Error weight distribution (near-misses): weight-0: 0, weight-1: 0, weight-2: 237, weight-3: 370, weight-4: 446 (peak), weight-5: 172, weight-6: 23</li>
<li>Self-doubling accounts for 34/38 = 89.5% of closest misses</li>
<li>Second wall layer: d=7 (2 cases, 0 broken pairs), d=8 (16 cases, 0 broken pairs) — higher-order interaction failure</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>Exact Cyc8 arithmetic</strong>: Z[zeta_8] integer representation eliminating floating-point association-order failures near sector boundaries; critical for correct deletion-contraction verification</li>
<li><strong>Deletion map with collision tracking</strong>: exhaustive weight-set subtraction at each level, counting distinct children vs. total instances to identify collisions</li>
<li><strong>Upward extension search</strong>: for each XOR_n weight set, tests all 83 class-1 catalog values as candidate 6th weight, records Hamming distance to XOR6 truth table</li>
<li><strong>Vocabulary stratification analysis</strong>: separates catalog values into good (extensible), poison (orphan-only), and absent categories with octant annotations</li>
<li><strong>Error-weight decomposition</strong>: for each failed extension, bins output errors by input Hamming weight to isolate interaction-level vs. single-weight failures</li>
<li><strong>Self-doubling classifier</strong>: detects w[5]=w[i] cases and computes angle-preservation argument symbolically</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Aizenberg (2008): k-sector MVN activation — direct ancestor of sector/class framework used throughout</li>
<li>Kauffman bracket / TL category theory: catalog values as quantum amplitudes (Z[zeta_8] = T-gate algebraic ring)</li>
<li>Reiner (2004, arXiv:math/0402206): cyclotomic matroids mu_N — candidate framework for 44 good / 31 poison value split</li>
<li>CKW inequality (Coffman-Kundu-Wootters): entanglement monogamy parallel — 10 pairwise sums simultaneously compatible, 15 cannot be</li>
<li>Kochen-Specker theorem: contextuality parallel — wall as consistent-assignment obstruction for all C(6,2)=15 pair sums</li>
<li>Clifford hierarchy (Gottesman-Chuang 1999): self-doubling maps to T→S gate descent; XOR6 ceiling interpreted as hierarchy level boundary</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Does XOR6 become achievable at Z[zeta_16]? If so, the parity function literally climbs the Clifford hierarchy one rung per additional input (<a href="./entries/demo_65.html">Demo 65</a> target).</li>
<li>Can the triple-interaction constraints (weight-3+ errors at d≥7) be characterized explicitly, analogous to the self-doubling theorem for weight-2?</li>
<li>Are the 27 XOR5 weight sets built primarily from antipodal pairs (w + (-w) = 0 always safe)? How much of the vocabulary structure depends on antipodal geometry?</li>
<li>Is there a closed-form formula for upward coverage fraction as a function of n (exponential decay, algebraic, other)?</li>
<li>What is the geometric explanation for the poison values avoiding octant 4 entirely?</li>
<li>Are the 44 good values and 31 poison values related to the matroid structure of mu_8 (Reiner's cyclotomic matroid at 8th roots)?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_65.html">Demo 65</a>: Clifford Hierarchy Staircase</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_65_clifford_staircase/main.c.html">demo_65_clifford_staircase/main.c</a></code> (~2014 lines)</li>
<li><strong>Tests</strong>: 38/38 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_50.html">Demo 50</a> (four-tier NPN hierarchy, parity at k=6, 906 solutions), <a href="./entries/demo_63.html">Demo 63</a> (angular anatomy, parity ceiling n=5, oriented matroid classification), <a href="./entries/demo_64.html">Demo 64</a> (interaction-level wall anatomy, XOR6 open questions)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_66.html">Demo 66</a>, <a href="./entries/demo_67.html">Demo 67</a>, <a href="./entries/demo_68.html">Demo 68</a>, <a href="./entries/demo_69.html">Demo 69</a>, <a href="./entries/demo_70.html">Demo 70</a>, <a href="./entries/demo_71.html">Demo 71</a> (quaternionic arc)</li>
</ul>
<h3>Headline</h3>
Climbing from Z[zeta_8] to Z[zeta_16] leaves the parity ceiling at n=5 and refutes the gap-of-2 hypothesis, but generalized (non-standard) sector activations break the wall at k=24 — revealing a two-layer structure separating geometric obstruction from labeling convention.
<h3>Key Results</h3>
<ul>
<li><strong>Part A-B — Z[zeta_16] catalog</strong>: 36 distinct nonzero bracket values at delta=-sqrt(2) (vs 100 at delta=0). 24/36 axial, 12/36 two-component. 14/16 angular directions occupied (missing dirs 2 and 11). 20/36 values lie in the Z[zeta_8] subring, but catalogs are mostly disjoint — only 8/100 Z[zeta_8] values appear in Z[zeta_16].</li>
<li><strong>Part C-D — Algebra independence</strong>: Tier thresholds at Z[zeta_16] are exactly XOR3 k=6, XOR4 k=8, XOR5 k=14 — identical to Z[zeta_8]. Parity ceiling n=5 is unchanged. The "gap of 2" hypothesis is refuted: pigeonhole rises from 7 to 14 but actual ceiling stays at 5, widening the gap to 9.</li>
<li><strong>Part E-F — XOR6 wall is genuine</strong>: XOR6 = 0 at every k=2..31, tested with both base catalog (36 values) and extended catalog (56 values, +20 from 4-strand braids). Catalog extension revealed k=31 XOR5 zero as incompleteness artifact (0 → 960 solutions); XOR6 zero at all k survives extension, confirming the wall is real.</li>
<li><strong>Part G — Generalized activations break the wall</strong>: Testing any binary labeling of k sectors (not just standard odd/even), with 2,700 checks per k: absolute wall at k&lt;=23 (zero solutions regardless of labeling), first generalized XOR6 at k=24 (3/2700 pass). Minimum k for generalized XOR6: k=24.</li>
<li><strong>Part H — Even/odd k pattern</strong>: Near the threshold, generalized XOR6 solutions exist only at even k (26: 4, 28: 4, 30: 10, 32: 4) and fail at all odd k (25, 27, 29, 31: all 0). k=38 is the only even k &gt;= 24 with zero solutions (38 = 2*19).</li>
<li><strong>Part H — Antipodal pairs mandatory</strong>: All 3 passing XOR6 tuples at k=24 consist of exactly 3 antipodal pairs (w, -w). Min margin to sector boundary: 0.000000 rad — sums land exactly on lattice directions.</li>
<li><strong>Part I-J — Generalized XOR7</strong>: First at k=91 (broader search over 27 XOR5 sets * C(100,2) pairs = 136,350 7-tuples per k). XOR7 winner anatomy: 3 antipodal pairs + 1 lone weight at 90 degrees (purely imaginary). Scaling ratio 91/24 ~= 3.8.</li>
<li><strong>Part J — Zero margin universality</strong>: All passing tuples at all tested k values have exactly zero margin. Z[zeta_8] lattice sums always land on lattice directions (multiples of pi/4), aligning exactly with sector boundaries for compatible k values. Solutions are algebraically exact.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Theorem (parity ceiling is algebra-independent)</strong>: The parity ceiling n=5 and tier thresholds (XOR3 k=6, XOR4 k=8, XOR5 k=14) are identical at Z[zeta_8] and Z[zeta_16]. PROVEN (exhaustive sweep k=2..31, both catalogs).</li>
<li><strong>Theorem (gap-of-2 refuted)</strong>: The gap between pigeonhole bound and actual ceiling is not constant. Z[zeta_8]: gap=2 (7-5). Z[zeta_16]: gap=9 (14-5). PROVEN.</li>
<li><strong>Theorem (absolute wall k&lt;=23)</strong>: No binary partition of k sectors (for any k &lt;= 23) can separate the XOR6 truth table using Z[zeta_8] catalog weights. PROVEN (exhaustive, 2700 checks per k=6,8,15,16..23).</li>
<li><strong>Theorem (k=24 breaks convention wall)</strong>: At k=24, exactly 3 of 2700 candidate (XOR5-set, extension-weight) pairs admit a binary coloring of 24 sectors that realizes XOR6. PROVEN.</li>
<li><strong>Theorem (zero margin universality)</strong>: All generalized XOR6 solutions at all tested even k have exactly zero margin to the nearest sector boundary, reflecting exact lattice alignment. PROVEN.</li>
<li><strong>Conjecture (universal ceiling)</strong>: The parity ceiling n=5 holds for all cyclotomic evaluation points (all levels of the Clifford hierarchy). If confirmed, this becomes a theorem about topological state sums, not algebra. CONJECTURED.</li>
<li><strong>Conjecture (scaling law)</strong>: XOR_n minimum k grows roughly by factor ~3.8 per increment: XOR6 k=24, XOR7 k=91, XOR8 ~k=345. CONJECTURED (two data points only).</li>
<li><strong>Conjecture (k=24 as projection)</strong>: The minimum of k=24 sectors for S1 XOR6 is a projection of the 24-cell's 24 vertices onto S1. CONJECTURED (confirmed in <a href="./entries/demo_66.html">Demo 66</a>).</li>
</ul>
<h3>Data</h3>
<ul>
<li>Z[zeta_16] catalog size: 36 values (base), 56 values (extended, +20 from 4-strand braids)</li>
<li>Angular directions occupied: 14/16 (missing dirs 2 and 11, at 45.0 and 247.5 degrees)</li>
<li>Catalog overlap: 8/100 Z[zeta_8] values appear in Z[zeta_16]; 20/36 Z[zeta_16] values lie in Z[zeta_8] subring</li>
<li>Tier thresholds (identical at both rings): XOR3 k=6, XOR4 k=8, XOR5 k=14, XOR6 impossible (standard)</li>
<li>XOR5 solutions at Z[zeta_16] k=14: 120; k=15: 1080 (extended); k=17: 240; k=21: 240; k=31: 960</li>
<li>XOR6 solutions (standard): 0 at every k=2..31, both catalogs</li>
<li>Generalized XOR6 first pass: k=24, 3/2700</li>
<li>Even k generalized XOR6 pass counts: k=24: 3, k=26: 4, k=28: 4, k=30: 10, k=32: 6, k=38: 0, k=40: 2, ..., k=62: 34</li>
<li>k=38 gap: only even k &gt;= 24 with zero generalized XOR6 solutions</li>
<li>Generalized XOR7 minimum k: 91 (broader search); XOR7 winner: 3 antipodal pairs + 1 lone weight at 90 degrees</li>
<li>XOR7 pass counts: k=127: 1 (narrow), k=120: 5, k=127: 4 (broader)</li>
<li>Scaling ratio XOR7/XOR6 minimum k: 91/24 ~= 3.8</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>Z[zeta_16] arithmetic</strong>: 8-component exact representation, bracket evaluation at delta=-sqrt(2), direction classification over 16 angular bins</li>
<li><strong>Multi-catalog XOR search</strong>: runs full sector sweep with both 36-value and 56-value catalogs, distinguishes catalog incompleteness artifacts from genuine walls</li>
<li><strong>Generalized binary labeling check</strong>: for a given k-sector partition and n-tuple of weights, tests whether any binary coloring of k sectors separates the 2^n truth table (not just standard odd/even)</li>
<li><strong><code>generalized_xor6_check()</code></strong>: iterates over all 2700 (XOR5-set, extension) pairs at arbitrary k, counts passing binary labelings</li>
<li><strong>Even k landscape sweep</strong>: systematic even k=2..64 generalized XOR6 pass counts</li>
<li><strong>XOR7 broader search</strong>: extends from single extensions to all C(100,2) weight pairs, 136,350 7-tuples per k</li>
<li><strong>Antipodal structure analyzer</strong>: decomposes n-tuple into antipodal pairs and lone weights, reports margin to sector boundaries</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Aizenberg (2008): k-sector MVN activation; generalized binary labeling is a strict relaxation of his standard odd/even convention</li>
<li>Kauffman (1987): bracket polynomial as topological state sum; delta parameter controls multi-loop cancellation</li>
<li>Habiro / Nazer-Gastpar / Abramsky / TL-non-semisimplicity: background for DKC literature context</li>
<li><a href="./entries/demo_63.html">Demo 63</a> (Angular Anatomy): oriented matroid classification, parity scaling law for Z[zeta_8]</li>
<li><a href="./entries/demo_64.html">Demo 64</a> (open questions): Z[zeta_16] ceiling question and gap-of-2 hypothesis, both answered here</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Does the parity ceiling n=5 hold at Z[zeta_32] and all higher cyclotomic levels? If so, the proof should be purely topological (no mention of evaluation point).</li>
<li>Why is k=38 the only even k &gt;= 24 with zero generalized XOR6? Is 19 (= 38/2) special with respect to the Z[zeta_8] lattice?</li>
<li>Should the generalized check be rewritten with exact Cyc8 arithmetic (no floating-point atan2) to formally eliminate boundary ambiguity? Zero margin everywhere makes this feasible.</li>
<li>Does the absolute wall threshold (k=24) change when using Z[zeta_16] weights for the generalized check?</li>
<li>Is the even/odd k pattern (even works, odd fails near threshold) provable from the pi/4 lattice alignment argument?</li>
<li>Does any odd k &gt;= 25 produce generalized XOR6 solutions? (Current sweep covered only even k.)</li>
<li>Scaling law: is XOR8 minimum k ~345, and does the growth rate discriminate polynomial from exponential?</li>
<li>Does the lone imaginary weight (90 degrees) in the XOR7 winner generalize, or is it specific to this solution?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_66.html">Demo 66</a>: Quaternionic DKC — First Contact</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_66_quaternionic_dkc/main.c.html">demo_66_quaternionic_dkc/main.c</a></code> (~2004 lines)</li>
<li><strong>Tests</strong>: 30/30 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_29.html">Demo 29</a> (Z[zeta_8] exact arithmetic, bracket catalog), <a href="./entries/demo_50.html">Demo 50</a> (four-tier NPN hierarchy, parity at k=6, 906 solutions), <a href="./entries/demo_63.html">Demo 63</a> (angular anatomy, sector-octant mapping), <a href="./entries/demo_65.html">Demo 65</a> (complex S¹ XOR results, antipodal constraint)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_67.html">Demo 67</a>, <a href="./entries/demo_68.html">Demo 68</a>, <a href="./entries/demo_69.html">Demo 69</a>, <a href="./entries/demo_70.html">Demo 70</a>, <a href="./entries/demo_71.html">Demo 71</a></li>
</ul>
<h3>Headline</h3>
Lifting the Kauffman bracket from S¹ (complex trace) to S³ (full unit quaternion) reveals the 24-cell polytope as the natural computational geometry for DKC, and its 25-cell Voronoi partition finds more XOR6 solutions than a 64-cell geographic grid.
<h3>Key Results</h3>
<ul>
<li><strong>Part C — 24-cell emergence</strong>: SU(2) braid representation with generators σ₁ → (1+i)/√2 and σ₂ → (1−k)/√2 produces exactly 24 distinct unit quaternions from 87,890 enumerated braids. These decompose into 4 axis-aligned (±1, ±i, ±j, ±k), 12 edge (two components at ±1/√2), and 8 body (all components at ±½) vertices — the vertices of the 24-cell. The 48 quaternions with negatives form the binary octahedral group. The same braids produce 100 distinct Kauffman bracket values in Z[ζ₈].</li>
<li><strong>Part D — Bracket ≠ trace</strong>: The bracket and quaternion are complementary projections of the full braid group representation. Average Re(bracket)/trace ratio is −0.0799 (no clean constant); the bracket includes Markov trace normalization and writhe correction not present in the raw quaternion.</li>
<li><strong>Part E — Antipodal-only XOR6</strong>: Full search over all C(24,6) = 475,020 six-tuples finds zero solutions at any grid resolution (3×3 through 8×8). Restricting to antipodal pairs (3 pairs of (q, −q)) yields 3 solutions at 6×6 and 34 solutions at 8×8. The antipodal constraint is absolute, reflecting the SU(2) → SO(3) double cover.</li>
<li><strong>Part G — Anatomy of winning tuples</strong>: At 6×6, 2 of 3 winners are mixed (edge + body, non-orthogonal); 1 is all-edge and mutually orthogonal (forming a coordinate frame in R⁴). At 8×8, 15/34 winners are mutually orthogonal (44%), and body-type (±½,±½,±½,±½) vertices dominate (16/34 all-body vs. 0 all-axis and 5 all-edge).</li>
<li><strong>Part H — 24-cell Voronoi activation</strong>: Assigning each subset sum to its nearest 24-cell vertex (25 Voronoi cells: 24 vertices + 1 zero cell) yields 35 solutions — more than the 64-cell geographic grid's 34. The complex S¹ minimum of k=24 sectors (<a href="./entries/demo_65.html">Demo 65</a>) matches the 24-cell vertex count: complex k=24 is a projection of the 24-cell.</li>
<li><strong>Parts I, L — Universal 7/7/11 structure</strong>: Every one of the 35 Voronoi XOR6 solutions has exactly 7 cells labeled 0, 7 cells labeled 1, and 11 cells unused. The zero cell is always labeled 0. This is a geometric constraint: 3 antipodal pairs define 3 great circles on S³ and the 64 subset sums touch only 14 of 25 Voronoi cells.</li>
<li><strong>Part J — Complementary hash functions</strong>: Bracket and quaternion as hash functions over 124,750 braid pairs: 16,047 (12.86%) agree on both; 450 (0.36%) share bracket but differ in quaternion; 8,424 (6.75%) share quaternion but differ in bracket; 99,829 (80.03%) differ on both. The quaternion resolves 450 bracket collisions; the bracket resolves 8,424 quaternion collisions.</li>
<li><strong>Part K — F4 symmetry, 6 orbits</strong>: The full two-sided symmetry group of the 24-cell has 576 elements (F4 Coxeter rotation subgroup). Under this symmetry, 35 solutions decompose into 6 orbits (sizes 12, 7, 5, 5, 4, 2) forming two families: edge-dominant (orbits 1, 2, 5 — 22 solutions, edge cells → label 1) and body-dominant (orbits 3, 4, 6 — 13 solutions, axis/body cells → label 1).</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Theorem (24-cell is the braid image)</strong>: SU(2) braid representations with the given generators produce exactly the 24 vertices of the 24-cell (binary octahedral group). PROVEN (exhaustive enumeration of 87,890 braids).</li>
<li><strong>Theorem (antipodal necessity)</strong>: XOR6 solutions exist only among antipodal weight pairs; the full C(24,6) search yields zero unrestricted solutions. PROVEN (exhaustive).</li>
<li><strong>Theorem (Voronoi beats geographic grid)</strong>: The 24-cell Voronoi partition (25 cells) yields 35 solutions vs. 34 solutions at 64 geographic cells. PROVEN.</li>
<li><strong>Theorem (universal 7/7/11 structure)</strong>: Every Voronoi XOR6 solution activates exactly 7 cells with label 0, 7 with label 1, and leaves 11 unused. PROVEN (all 35 verified).</li>
<li><strong>Theorem (F4 decomposes to 6 orbits)</strong>: Under the 576-element F4 rotation subgroup, the 35 winning tuples fall into exactly 6 orbits in two complementary families. PROVEN.</li>
<li><strong>Conjecture (orbit count formula)</strong>: The orbit count 6 = 1+2+3 may reflect the partition structure of 6 (XOR arity); XOR_n on the 24-cell may always yield n*(n-1)/2 orbits. CONJECTURED.</li>
<li><strong>Conjecture (complex k=24 as projection)</strong>: The minimum of k=24 sectors for S¹ XOR6 (<a href="./entries/demo_65.html">Demo 65</a>) is a projection of the 24-cell's 24 vertices onto S¹ via the trace. CONJECTURED.</li>
</ul>
<h3>Data</h3>
<ul>
<li>Distinct quaternion vertices from 87,890 braids: 24 (axis: 4, edge: 12, body: 8)</li>
<li>Distinct bracket values: 100 (in Z[ζ₈])</li>
<li>Re(bracket)/trace ratio average: −0.0799</li>
<li>Antipodal XOR6 solutions: 0 at 3×3/4×4/5×5, 3 at 6×6, 34 at 8×8</li>
<li>Voronoi XOR6 solutions: 35 at 25 cells</li>
<li>Voronoi cell label structure (all 35): 7 labeled 0, 7 labeled 1, 11 unused</li>
<li>Cell usage range across 35 winners: 11/35 to 25/35; 24 distinct unused-cell patterns</li>
<li>F4 symmetry group order: 576</li>
<li>Orbit decomposition: 12 + 7 + 5 + 5 + 4 + 2 = 35; edge-dominant 22, body-dominant 13</li>
<li>Complementary hash collision table: same-bracket-diff-quat: 450; same-quat-diff-bracket: 8,424; agree-both: 16,047; differ-both: 99,829</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong><code>quat_mul()</code>, <code>quat_norm()</code>, <code>quat_nearest_24cell()</code></strong>: quaternion multiplication, normalization, and nearest-vertex lookup on the 24-cell</li>
<li><strong><code>enumerate_braids()</code></strong>: generates all braids up to target length, applies SU(2) generators, collects distinct quaternion outputs</li>
<li><strong>Voronoi partition on S³</strong>: assigns arbitrary unit quaternions to nearest 24-cell vertex by dot-product maximization</li>
<li><strong>Antipodal-pair XOR6 search</strong>: restricts combinatorial search to 3-antipodal-pair sextets and evaluates XOR6 over Voronoi cells</li>
<li><strong>F4 symmetry orbit computation</strong>: generates all 576 two-sided symmetry elements of the 24-cell (g, h) and groups solutions into orbits</li>
<li><strong>Hash collision analysis</strong>: pair-table construction and four-way bracket/quaternion intersection counting</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Kauffman (1987): Kauffman bracket polynomial; trace of SU(2) braid representation.</li>
<li>Jones (1985): Jones polynomial; Markov trace, writhe normalization — explains why bracket ≠ raw trace.</li>
<li>Coxeter (1940s): 24-cell as unique self-dual regular 4-polytope; F4 symmetry group.</li>
<li>Conway &amp; Sloane (SPLAG): binary octahedral group as 48-element group of unit quaternions.</li>
<li>Aizenberg (2008): k-sector MVN activation; parent of DKC sector count framework.</li>
<li><a href="./entries/demo_29.html">Demos 29</a>, 50, 63, 65: Z[ζ₈] bracket catalog, four-tier NPN hierarchy, sector-octant geometry, S¹ complex XOR results.</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Why exactly 6 orbits? Does XOR_n on the 24-cell always yield n*(n-1)/2 orbits by partition structure?</li>
<li>Does the edge-dominant / body-dominant split (22/13) exchange under the self-duality of the 24-cell (vertices ↔ face centers)?</li>
<li>What happens to XOR7 with 24-cell Voronoi activation? <a href="./entries/demo_65.html">Demo 65</a> required k=91 sectors on S¹; does the 4D geometry accommodate XOR7 within 25 cells?</li>
<li>Do the higher binary polyhedral groups (binary tetrahedral: 24, binary icosahedral: 120, corresponding to 120-cell) change the computational landscape?</li>
<li>Do the 35 Voronoi solutions sit exactly on cell boundaries (zero margin) as in the S¹ case, or does 4D geometry provide genuine separation?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_67.html">Demo 67</a>: Coordinate System Zoo — SU(2) Projections for DKC</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_67_coordinate_zoo/main.c.html">demo_67_coordinate_zoo/main.c</a></code> (~1776 lines)</li>
<li><strong>Tests</strong>: 18/18 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_66.html">Demo 66</a> (quaternionic bracket catalog, 24-cell Voronoi, 35 solutions)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_68.html">Demo 68</a>, <a href="./entries/demo_69.html">Demo 69</a>, <a href="./entries/demo_70.html">Demo 70</a>, <a href="./entries/demo_71.html">Demo 71</a></li>
</ul>
<h3>Headline</h3>
Systematic test of every natural SU(2) coordinate system as a DKC activation for XOR6 proves that the computation lives on S² (rotation axis direction): a custom 13-direction Voronoi achieves 36 solutions at only 14 cells, while the Hopf phase is completely computationally inert at every resolution tested.
<h3>Key Results</h3>
<ul>
<li><strong>Part A — Eigenvector extraction</strong>: The 24 quaternions from the binary octahedral group decompose into 4 eigenvalue angles (0°, 45°, 60°, 90°), 13 eigenvector directions (mod ±), and 17 (angle, direction) pairs. Axis-aligned directions are shared across two eigenvalue angles; body-diagonals appear only at 60°; edge-midpoints only at 90°. Trace sanity check confirms trace(SU(2)) = 2·cos(θ) for all 24 quaternions.</li>
<li><strong>Part B — S² is the computational sweet spot</strong>: Custom 13-direction Voronoi on S² achieves 36 solutions at 14 cells (2.57 sol/cell) — more solutions with fewer cells than any other activation. Platonic solid Voronois (octahedral=6, icosahedral=12, cuboctahedral=12 cells) all yield zero solutions: natural polytopal geometry fails; data-derived directions are required.</li>
<li><strong>Part C — Eigenvalue-only activation</strong>: First solutions appear at k=8 (4 solutions). Peak around k=32 (80 solutions). At k=24: 72 solutions, more than the 24-cell Voronoi's 35, using only 1D eigenvalue information.</li>
<li><strong>Part D — Hopf phase is computationally inert</strong>: Phase-only activation yields ZERO solutions at every resolution tested (k=4 through k=32). All DKC information lives in the S² Hopf base; the S¹ fiber carries nothing. This is the deepest theoretical result of the demo.</li>
<li><strong>Part E — Cayley-Klein is worst</strong>: The native SU(2) parameterization (|α|, arg(α)) requires 32 cells for first solutions (8 solutions) — worse than every other 2D system. Native does not mean natural-for-computation.</li>
<li><strong>Part F — High-resolution rankings at 64 cells</strong>: Hopf base 8×8 = 292 solutions (4.56 sol/cell); Eigenvector LatLon 8×8 = 204 solutions (3.19 sol/cell); Cayley-Klein 8×8 = 106 solutions (1.66 sol/cell). At high resolution, Hopf base dominates because it carves up the computationally relevant S² more naturally than lat/lon on eigenvector S².</li>
<li><strong>Progression across demos</strong>: <a href="./entries/demo_65.html">D65</a> complex S¹ needs k=24 sectors (25 cells); <a href="./entries/demo_66.html">D66</a> quaternionic S³ needs 25 cells; <a href="./entries/demo_67.html">D67</a> eigenvector S² needs only 14 cells. The 2D projection is the most efficient.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Result (Hopf phase inertness)</strong>: The Hopf fiber phase ξ₁ carries zero DKC computational information at all resolutions (k=4 through k=32, exhaustive). The computation is entirely determined by the S² Hopf base. PROVEN (exhaustive).</li>
<li><strong>Result (S² efficiency)</strong>: A 14-cell custom Voronoi on S² achieves more solutions (36) than the full 25-cell S³ Voronoi (35). Lower-dimensional projection outperforms the ambient space. DEMONSTRATED.</li>
<li><strong>Result (eigenvalue paradox resolution)</strong>: The eigenvalue angle θ = arccos(a) depends on the real quaternion component and succeeds as an activation; the Hopf phase ξ₁ = atan2(b, a) fails completely. These are distinct quantities: θ extracts information from the combination of base and fiber, not the fiber alone. PROVEN.</li>
<li><strong>Conjecture (14-cell minimum)</strong>: The natural 13+1 eigenvector Voronoi may be the true minimum cell count on S² for XOR6. Platonic geometries at 6 and 12 cells fail. Whether a different 13-direction subset could work with fewer cells is open. CONJECTURED.</li>
</ul>
<h3>Data</h3>
<ul>
<li>Eigenvalue angles: 4 (0°, 45°, 60°, 90°)</li>
<li>Eigenvector directions (mod ±): 13 (3 axis + 6 edge-midpoint + 4 body-diagonal)</li>
<li>(angle, direction) pairs: 17; quaternions (mod ±): 24; bracket values: 100</li>
<li>Custom 13-dir S² Voronoi: 36 solutions at 14 cells (2.57 sol/cell)</li>
<li>Hopf base activation: 30@16 cells, 130@36 cells, 292@64 cells (8×8)</li>
<li>Hopf phase-only: 0 solutions at all resolutions (k=4,8,12,16,24,32)</li>
<li>Eigenvalue k-sector: 0@k=4,6; 4@k=8; 64@k=12; 76@k=16; 72@k=24; 80@k=32</li>
<li>Cayley-Klein: 0@8 cells, 0@24 cells, 8@32 cells, 26@36 cells, 106@64 cells</li>
<li>Computational hierarchy: S² primary (14 cells sufficient), θ secondary, Hopf phase inert, full S³ redundant</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong><code>eigenvector_extract()</code></strong>: decomposes SU(2) quaternion into eigenvector direction (mod ±) and eigenvalue angle</li>
<li><strong>Custom Voronoi on S²</strong>: assigns quaternion to nearest of 13 data-derived directions; handles identity/zero as degenerate cell 0</li>
<li><strong>Platonic solid Voronois</strong>: octahedral, icosahedral, cuboctahedral cell partitions on S² (all fail for XOR6)</li>
<li><strong>Hopf coordinate decomposition</strong>: converts quaternion to Hopf (η, ξ₁, ξ₂); separates base and fiber activations</li>
<li><strong>Cayley-Klein parameterization</strong>: (|α|, arg(α)) grid activation</li>
<li><strong>Eigenvalue k-sector activation</strong>: partitions [0, π] into k equal sectors on eigenvalue angle θ</li>
<li><strong>Comparative activation harness</strong>: unified XOR6 DKC search usable across all coordinate systems</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Hopf (1931): original Hopf fibration S³ → S² with fiber S¹; this demo confirms the fibration structure is respected by DKC computation</li>
<li>Aizenberg (2008): k-sector MVN activation on S¹; the present work extends and contrasts the S¹ approach with S² and S³ activations</li>
<li>Conway &amp; Smith (2003): quaternion groups and the binary octahedral group; the 24 quaternions and their eigenvector decomposition</li>
<li>Bloch (1946): Bloch sphere S² = CP¹; S² as qubit state space raises the question of a DKC/quantum information connection</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li><strong>Why 36 vs 35?</strong> The 13-dir S² Voronoi finds 36 solutions vs the 24-cell S³ Voronoi's 35. Is the extra solution a genuinely new tuple or a boundary effect from different cell geometry?</li>
<li><strong>Hopf base vs eigenvector geometry</strong>: At high resolution, Hopf base (292) beats eigenvector lat/lon (204). Does the Hopf base projection align better with the computation? What is the geometric relationship between Hopf base S² and eigenvector S²?</li>
<li><strong>Below-14 minimum on S²</strong>: Platonic solids at 6 and 12 cells fail. Is 13+1=14 the true minimum, or could a non-catalog 13-direction subset work with fewer cells?</li>
<li><strong>XOR7 on S²</strong>: <a href="./entries/demo_65.html">Demo 65</a> showed XOR7 needs k=127 sectors on S¹. Does S² reduce this as dramatically as it did for XOR6 (24→14)?</li>
<li><strong>Bloch sphere connection</strong>: The rotation axis lives on S² = CP¹ = the Bloch sphere of a qubit. Is there a direct connection between DKC computation on the Bloch sphere and quantum information theory?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_68.html">Demo 68</a>: Stereographic DKC — Knot Computation in the Plane</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_68_stereographic_dkc/main.c.html">demo_68_stereographic_dkc/main.c</a></code> (~1171 lines)</li>
<li><strong>Tests</strong>: 9/9 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_67.html">Demo 67</a> (13-direction S² Voronoi, 36 solutions, eigenvector decomposition)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_69.html">Demo 69</a>, <a href="./entries/demo_70.html">Demo 70</a>, <a href="./entries/demo_71.html">Demo 71</a></li>
</ul>
<h3>Headline</h3>
Stereographic projection of the eigenvector S² onto R² preserves all 36 DKC solutions exactly when using the S² great-circle metric, but gives zero solutions with Euclidean distance, proving the computation is intrinsically curved and cannot be flattened — the plane is a window, not a workspace.
<h3>Key Results</h3>
<ul>
<li><strong>S² Voronoi preserved under projection (Part C)</strong>: Using the S² great-circle metric (dot product) for Voronoi cell assignment in R² gives 36 solutions at 14 cells — identical to <a href="./entries/demo_67.html">Demo 67</a>. All 36 winners show 7 zero / 7 one cell labeling, exact match.</li>
<li><strong>Euclidean metric gives zero solutions (Part C)</strong>: Switching to R² Euclidean distance for nearest-neighbor assignment collapses solutions to zero. Area distortion from stereographic projection (up to 16.5×) breaks cell boundaries; large cells near the projection pole consume neighbors that belong to smaller cells. The computation is intrinsically curved.</li>
<li><strong>ASCII visualization: DKC as a drawable picture (Part D)</strong>: Each of the 36 winning solutions renders as a 65×33 ASCII image. Regions of 0s and 1s form contiguous visible domains; <code>+</code> marks Voronoi boundaries; <code>*</code> marks the 6 weight positions; <code>0–9, A–C</code> labels the 13 Voronoi centers. The decision boundary is a visible curve in the plane.</li>
<li><strong>Perceptron formulation (Part E)</strong>: Architecture is 6 bits → 2 neurons (linear combination of projected weight coordinates) → Voronoi activation (S² metric) → 1 bit. The 6×2 weight matrix comes from stereographic projections of weight quaternion eigenvector directions, not gradient descent.</li>
<li><strong>Conformality: 16.5× area distortion, zero solution difference (Part F)</strong>: Monte Carlo cell area measurement shows largest cell (cell 8) is 17% of the bounding grid, smallest (cell 1) is 1%, ratio 16.5×. Despite this distortion, solution count is unchanged and cell assignments are identical under S² metric.</li>
<li><strong>Planar grids waste cells (Part B)</strong>: Rectangular grids in R² require 64 cells to reach 33 solutions (8×8), versus 14 cells for 36 solutions with S² Voronoi. Grids cover empty regions of the bounding box; the Voronoi covers only the data.</li>
<li><strong>North pole projection chosen (Part A)</strong>: South pole (0,0,−1) is one of the 13 catalog directions, so north pole projection is used to keep all 13 centers at finite R² coordinates. Round-trip precision ~1e-15 (machine epsilon). Bounding box: x∈[−2.41, 1.37], y∈[−1.00, 2.41].</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Result (intrinsic curvature)</strong>: DKC computation on the eigenvector S² cannot be faithfully transferred to R² by stereographic projection when using Euclidean nearest-neighbor. Euclidean metric yields zero solutions; S² great-circle metric yields 36. The computation is intrinsically curved. PROVEN (exhaustive over all 36 solutions).</li>
<li><strong>Result (conformality sufficiency)</strong>: Stereographic projection is angle-preserving (conformal) but not area-preserving. The 16.5× area ratio between largest and smallest cells does not affect solution count or correctness when the S² metric is used. Angles are sufficient; areas are irrelevant to the cell assignment problem. DEMONSTRATED.</li>
<li><strong>Result (planarity as visualization)</strong>: The stereographic image of the S² Voronoi is a valid 2D picture of the computation but not a valid computational domain. "Visualize on the plane, compute on the sphere." DEMONSTRATED.</li>
<li><strong>Conjecture (perceptron knot weights)</strong>: The 6×2 weight matrices derived from stereographic projection of DKC solutions constitute a family of two-neuron perceptrons solving XOR6 without any training. Whether these weights can be found by gradient descent from random initialization is open.</li>
</ul>
<h3>Data</h3>
<ul>
<li>Tests: 9/9 pass (Parts A–F)</li>
<li>Round-trip projection precision: ~1e-15</li>
<li>Bounding box: x∈[−2.41, 1.37], y∈[−1.00, 2.41]; spread dx=3.78, dy=3.41</li>
<li>S² Voronoi in R² (S² metric): 36 solutions, 14 cells — exact match to <a href="./entries/demo_67.html">Demo 67</a></li>
<li>R² Euclidean Voronoi: 0 solutions</li>
<li>Area distortion: largest cell 4.33 (17%), smallest cell 0.26 (1%), ratio 16.5×</li>
<li>ASCII visualization: 65×33 per solution, 36 images total</li>
<li>Planar grid results: 4×4=0, 6×6=4, 8×8=33, 4×8=2, 8×4=7</li>
<li>Progression: <a href="./entries/demo_65.html">D65</a> S¹ (25 cells) → <a href="./entries/demo_66.html">D66</a> S³ (25 cells) → <a href="./entries/demo_67.html">D67</a> S² (14 cells) → <a href="./entries/demo_68.html">D68</a> R² (visualization only)</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>Stereographic projection / inverse</strong>: north-pole projection of S² to R² and back; round-trip precision verified at machine epsilon</li>
<li><strong>Projected Voronoi with S² metric</strong>: assigns R² query point to nearest of 13 projected centers using back-projected dot product; handles pole-projection degeneracy</li>
<li><strong>Euclidean Voronoi in R²</strong>: same structure but using Euclidean distance; preserved for the negative-result comparison</li>
<li><strong>ASCII renderer</strong>: 65×33 grid over bounding box, renders 0/1 regions, Voronoi boundaries (<code>+</code>), weight positions (<code>*</code>), and center labels (<code>0–9, A–C</code>)</li>
<li><strong>Perceptron weight extractor</strong>: builds 6×2 matrix from stereographic projections of winning solution weight quaternions</li>
<li><strong>Monte Carlo area estimator</strong>: samples Voronoi cell areas in R² for conformality analysis</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Riemann (1851): stereographic projection as a conformal map; the area-distortion / angle-preservation tradeoff is classical complex analysis</li>
<li>Hopf (1931): the S² Hopf base as the computationally relevant space (established in <a href="./entries/demo_67.html">D67</a>); <a href="./entries/demo_68.html">D68</a> confirms this by showing R² is a view into S², not a replacement</li>
<li>Aizenberg (2008): MVN / k-sector activation on S¹ — <a href="./entries/demo_68.html">D68</a> closes the loop by showing the planar picture of DKC is still not an S¹ activation; curvature is essential</li>
<li>Bloch (1946): Bloch sphere S² = CP¹; the ASCII visualization is literally a stereographic picture of a Bloch sphere computation</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li><strong>Gradient descent to these weights?</strong> The perceptron weight matrices are derived from knot theory. Can gradient descent find them from random init, and if so, does it rediscover the S² structure implicitly?</li>
<li><strong>Other conformal maps?</strong> Stereographic projection is one conformal map S² → R²; Mercator and others exist. Do different conformal charts give better or worse ASCII visualization of the decision boundary?</li>
<li><strong>XOR7 picture?</strong> <a href="./entries/demo_65.html">Demo 65</a> showed XOR7 needs k=127 on S¹. If S² reduces XOR6 to 14 cells, what does the stereographic picture of XOR7 on S² look like — and how many cells?</li>
<li><strong>Minimal bounding box tiling?</strong> The 8×8 planar grid wastes cells on empty corners. A tighter irregular planar partition covering only the convex hull of the 13 projected centers might approach the 14-cell Voronoi count. How close can it get?</li>
<li><strong>Three-neuron perceptron?</strong> The current formulation uses 2 hidden neurons (x, y coordinates). Adding a third (e.g., radius from origin) might enable purely Euclidean nearest-neighbor in R³, recovering the S² metric implicitly. Does this work?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_69.html">Demo 69</a>: Clifford Staircase on S² — Multi-Root Eigenvector Comparison</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_69_clifford_staircase/main.c.html">demo_69_clifford_staircase/main.c</a></code> (~787 lines)</li>
<li><strong>Tests</strong>: 9/9 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_66.html">Demo 66</a> (quaternionic bracket catalog), <a href="./entries/demo_67.html">Demo 67</a> (13-direction S² Voronoi)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_70.html">Demo 70</a>, <a href="./entries/demo_71.html">Demo 71</a></li>
</ul>
<h3>Headline</h3>
Comparing SU(2) eigenvector geometry across ζ<em>8, ζ_16, and ζ_32 proves a universal Direction Nesting Theorem (ζ_N ⊂ ζ</em>{2N} exactly on S²) and reveals that ζ_8 is the computational sweet spot: the coarsest root that produces structured directions, preserved exactly at every finer root, while finer roots trivialize XOR6 through pigeonhole saturation.
<h3>Key Results</h3>
<ul>
<li><strong>ζ_8 → ζ_16 RIGIDITY (13/13, 0.000°)</strong>: All 13 of ζ_8's eigenvector directions appear identically in ζ_16 to machine precision. Zero angular drift. The match is not approximate — algebraically forced by ζ_8 = (ζ_16)², so every ζ_8 braid word is a valid doubled word in ζ_16, and squaring a quaternion preserves its rotation axis.</li>
<li><strong>ζ_8 → ζ_32 partial nesting (8/13, 2.07° max drift)</strong>: Cap artifact limits enumeration. Monotonic recovery (6/13 at smaller cap → 8/13 at larger cap) with shrinking drift strongly supports full 13/13 nesting at sufficient depth. Algebraic argument (ζ_8 = (ζ_32)⁴) is watertight.</li>
<li><strong>Catalog explosion</strong>: ζ_8: 24 quaternions, 13 directions; ζ_16: 7,952 quaternions, 3,457 directions; ζ_32: 32,768+ quaternions, 4,096+ directions (still cap-limited). Direction-to-quaternion ratio drops from 0.54 to 0.43 to 0.13 as caps interfere.</li>
<li><strong>XOR6 trivialization</strong>: ζ_8 Voronoi (14 cells): 36 solutions, 0.007% of all triples. ζ_16 Voronoi (3,458 cells): 499,367 solutions, 90.6%. ζ_32 Voronoi (4,097 cells): 493,654 solutions, 89.6%. With 3,457+ cells the pigeonhole effect means 64 binary inputs spread over thousands of cells — almost any weight placement avoids collision.</li>
<li><strong>Fixed-resolution comparison</strong>: At 16 cells, ζ_16 (450 solutions) &gt; ζ_32 (393 solutions). Finer roots are not monotonically better at fixed resolution; which directions land in which cells matters more than raw direction count.</li>
<li><strong>ζ_8 is the computational sweet spot</strong>: Coarsest root that generates the 13-direction structure on S². Finer roots nest it exactly but add no computational power at fixed partition size — and at their natural Voronoi resolution they trivialize the computation entirely.</li>
<li><strong>Musical temperament analogy</strong>: ζ_8 = 13-note equal temperament (each solution meaningful); ζ_16 = 3,457 microtones (consonance trivially achieved); ζ_32 = effectively continuous (every triple sounds good).</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Theorem (Direction Nesting)</strong>: For any N, all eigenvector directions in the ζ<em>N catalog appear in the ζ</em>{2N} catalog. The nesting is exact on S². Algebraic proof: σ<em>i(2θ) = σ_i(θ)² as quaternions; squaring preserves the rotation axis; every ζ_N braid word is a valid doubled word in ζ</em>{2N}. PROVED algebraically, confirmed computationally for ζ_8 → ζ_16 (13/13, 0.000°).</li>
<li><strong>Result (Trivialization)</strong>: At ~3,457+ Voronoi cells (ζ_16 resolution), approximately 90% of all XOR6 triples become solutions. The activation function has so many cells that most cells see at most one of the 64 binary input vectors — pigeonhole statistics dominate topology. DEMONSTRATED.</li>
<li><strong>Conjecture (Trivialization threshold)</strong>: The transition from topology-driven to pigeonhole-dominated computation lies between ~50 and ~500 Voronoi cells. Below this threshold the geometry of directions matters; above it statistics dominate. CONJECTURED; threshold not yet precisely located.</li>
<li><strong>Result (ζ_32 nesting)</strong>: The 5 missing ζ_8 directions in the ζ_32 catalog are a cap artifact, not genuine geometric independence. The 2.07° drift on the 8 found directions reflects accumulated numerical error from composing many small-angle rotations. STRONGLY SUPPORTED, not yet confirmed at 13/13.</li>
</ul>
<h3>Data</h3>
<ul>
<li>ζ_8: 24 quaternions, 13 directions, ~5,500 braids enumerated</li>
<li>ζ_16: 7,952 quaternions, 3,457 directions, ~5,500 braids enumerated</li>
<li>ζ_32: 32,768+ quaternions (cap: MAX_QCAT=32768), 4,096+ directions (cap: MAX_ECAT=4096)</li>
<li>ζ_8 → ζ_16 nesting: 13/13, avg 0.0000°, max 0.0000° — RIGIDITY</li>
<li>ζ_8 → ζ_32 nesting (large cap): 8/13, max drift 2.07° — DRIFT (cap artifact)</li>
<li>ζ_8 → ζ_32 nesting (small cap): 6/13, max drift 10.9° — INDEPENDENCE (cap artifact)</li>
<li>XOR6 solutions: ζ_8 Voronoi: 36 (2.57 sol/cell); ζ_16 Voronoi: 499,367 (144.4 sol/cell, 90.6%); ζ_32 Voronoi: 493,654 (120.5 sol/cell, 89.6%)</li>
<li>Fixed-resolution at 16 cells: ζ_16: 450 solutions; ζ_32: 393 solutions</li>
<li>Braid group sizes: ζ_8 = binary octahedral (48 elements, 24 mod ±1); ζ_16 ~16,000 elements; ζ_32 ≥65,536 elements (generator cos π/16 ∉ Q, group is infinite)</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>Multi-root catalog enumeration</strong>: generates quaternion and eigenvector catalogs for arbitrary ζ_N with configurable MAX_QCAT and MAX_ECAT caps; same braid enumeration depth (~5,500) across all roots for fair comparison</li>
<li><strong>Direction nesting comparator</strong>: for each ζ<em>8 direction, finds nearest match in ζ</em>{2N} catalog and reports angular distance; classifies result as RIGIDITY (0°), DRIFT (small positive), or INDEPENDENCE (large positive)</li>
<li><strong>Adaptive Voronoi XOR6 search</strong>: builds natural Voronoi from catalog directions, then enumerates all weight triples for XOR6 solutions; reports sol/cell and % of C(150,3)</li>
<li><strong>Fixed-resolution grid activation</strong>: lat/lon grid with specified cell count applied to all three root catalogs for apples-to-apples comparison</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Aizenberg (2008): k-sector MVN activation; the trivialization result shows that at sufficiently fine resolution Aizenberg-style activation loses discriminative power entirely</li>
<li>Conway &amp; Smith (2003): binary octahedral group and its 24 quaternions — the ζ_8 ground case whose structure nests universally</li>
<li>Birman (1974) / braid group theory: the tower ζ_8 ⊂ ζ_16 ⊂ ζ_32 ⊂ ... is a tower of finite quotients of the infinite braid group</li>
<li>Nazer &amp; Gastpar / Habiro / Abramsky / TL non-semisimplicity (background DKC literature arc, confirmed novel connection)</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li><strong>Trivialization threshold</strong>: Where exactly does XOR6 transition from topology-driven (36 solutions at 14 cells) to pigeonhole-dominated (~90% at 3,458 cells)? Likely 50–500 cells but not yet located precisely.</li>
<li><strong>ζ_32 full confirmation</strong>: With uncapped enumeration, do all 13 ζ_8 directions appear in ζ_32 at exactly 0° drift? The algebraic argument says yes; computational confirmation requires deeper catalog.</li>
<li><strong>XOR6 solutions at intermediate resolutions</strong>: Is the solution count monotonically increasing with cell count, or does it have a non-monotonic peak analogous to <a href="./entries/demo_50.html">Demo 50</a>'s k=6 result?</li>
<li><strong>Optimal root for fixed compute budget</strong>: Given a cap on enumeration depth, which root maximizes XOR6 solutions at fixed cell count? <a href="./entries/demo_69.html">Demo 69</a> shows ζ_16 &gt; ζ_32 at 16 cells, but the full curve is unmapped.</li>
<li><strong>Nesting across non-power-of-2 roots</strong>: The algebraic argument requires ζ<em>N = (ζ</em>{2N})^2. Does any form of nesting hold for e.g. ζ_8 ⊂ ζ_24 (ζ_8 = (ζ_24)^3)?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_70.html">Demo 70</a>: Musica Nodorum</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_70_musica_nodorum/main.c.html">demo_70_musica_nodorum/main.c</a></code> (~812 lines)</li>
<li><strong>Tests</strong>: 8/8 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_66.html">Demo 66</a> (24-cell), <a href="./entries/demo_67.html">Demo 67</a> (13-direction S², Hopf decomposition)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_71.html">Demo 71</a></li>
</ul>
<h3>Headline</h3>
The ζ_8 algebra produces exactly 4 musical notes (C, Eb, E, F#) spanning consonance to tritone, and Yang-Baxter equivalent braids are not just topologically equivalent — they are literally the same melody.
<h3>Key Results</h3>
<ul>
<li>4 eigenvalue angles of the binary octahedral group map to 4 notes: C (0°, unison), Eb (45°, minor 3rd), E (60°, major 3rd), F# (90°, tritone)</li>
<li>Trace descends cleanly from 2.000 (C) to √2 (Eb) to 1.000 (E) to 0.000 (F#) — maximum consonance to maximum dissonance</li>
<li>Braid words become playable melodies: each crossing yields the eigenvalue angle of the running quaternion product, mapped to a note</li>
<li>Yang-Baxter relation σ₁σ₂σ₁ = σ₂σ₁σ₂ produces identical melodies step-by-step, not just at the final note — melody depends only on product length, not specific generators</li>
<li>Music (eigenvalue/pitch) and space (eigenvector/position) are orthogonal: Pearson r = -0.0624 over 253 pairs</li>
<li>Spatial sound mapping: latitude → MIDI pitch (C3 south to C5 north), longitude → stereo pan</li>
<li>Dodecahedral and icosahedral Voronoi both give ZERO XOR6 solutions; only the data-intrinsic 13-direction eigenvector Voronoi gives 36 solutions</li>
<li>Tritone-antipodal correspondence on dodecahedron: antipodal faces carry tritone pairs (C/F#, G/Db, D/Ab, A/Eb, E/Bb, B/F) — dissonance IS the antipodal map</li>
<li>Garside element (s1 s2)³ melody: Eb E F# E Eb C — a complete rising-falling arch visiting all 4 knot notes</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Conjugation-Invariance of Melody</strong> (confirmed): tr(q) = 2cos(θ) is conjugation-invariant, so the melody of a braid word depends only on the length of each partial product, not which generators are used</li>
<li><strong>Hopf Orthogonality</strong> (confirmed): eigenvalue (pitch) and eigenvector (spatial direction) are independent dimensions of a unit quaternion; r = -0.06 empirically</li>
<li><strong>Intrinsic Geometry Conjecture</strong> (confirmed): Platonic solids with the wrong symmetry group (icosahedral, order 120) cannot replicate results from the binary octahedral group (order 48); wrong symmetry → zero solutions</li>
</ul>
<h3>Data</h3>
<ul>
<li>Pearson r (pitch vs. spatial distance): -0.0624 over 253 pairs, 72 same-note/different-direction pairs</li>
<li>XOR6 solutions: eigenvector Voronoi = 36, icosahedron (6 effective cells after antipodal collapse) = 0, dodecahedron (10 effective cells) = 0</li>
<li>6 pairwise intervals from 4 notes: m2 (45→60°), M2 (60→90°), m3 (0→45°, 45→90°), M3 (0→60°), tritone (0→90°)</li>
<li>Garside element (s1 s2)³: Eb4 E4 F#4 E4 Eb4 C4</li>
<li>Longest braid (s1 s2⁻¹)⁵: Eb4 E3 F#4 E3 Eb4 C3 Eb4 E3 F#4 E3</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li>Eigenvalue-to-interval mapping (quaternion trace → cents → note name)</li>
<li>Braid word melody generator (running quaternion product, per-crossing note extraction)</li>
<li>Spatial sound mapper (eigenvector → latitude/longitude → MIDI pitch + stereo pan)</li>
<li>XOR6 checker against arbitrary Voronoi cell assignments</li>
<li>Platonic solid vertex generators (icosahedron, dodecahedron) for comparative Voronoi testing</li>
<li>ABC notation formatter for top braid melodies</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>Garside normal form / fundamental braid element (Garside 1969)</li>
<li>Binary octahedral group and its representation theory (McKay correspondence context)</li>
<li>Yang-Baxter equation and braid group relations</li>
<li>Circle of fifths / dodecahedral symmetry correspondence (music theory)</li>
<li>Hopf fibration S³ → S² (<a href="./entries/demo_67.html">Demo 67</a> foundational)</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Do other binary polyhedral groups (tetrahedral order 24, icosahedral order 120) produce analogous note sets, and do they compute XOR for their respective NPN-class counts?</li>
<li>Is the tritone-antipodal correspondence on the dodecahedron a coincidence of the circle-of-fifths assignment, or does it follow from some deeper symmetry argument?</li>
<li>Can the Garside melody (Eb E F# E Eb C) be heard as a recognizable motif in any existing musical tradition, or is it genuinely novel?</li>
<li>What happens to the melody structure under stabilization (adding a strand to a braid without changing the knot type)?</li>
<li>Does the music-space orthogonality (r ≈ 0) hold for other quaternion algebras, or is it specific to the ζ_8 / binary octahedral case?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_71.html">Demo 71</a>: Spectral DKC — Spherical Harmonic Decomposition</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_71_spectral_dkc/main.c.html">demo_71_spectral_dkc/main.c</a></code> (~1151 lines)</li>
<li><strong>Tests</strong>: 10/10 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_67.html">Demo 67</a> (13-direction S² Voronoi, 36 XOR6 solutions), <a href="./entries/demo_69.html">Demo 69</a> (trivialization observation, ζ_16 ~90% solution rate), <a href="./entries/demo_70.html">Demo 70</a> (musical mapping, 4 eigenvalue notes)</li>
<li><strong>Feeds into</strong>: Future work on analytical proofs of S² bandwidth bounds</li>
</ul>
<h3>Headline</h3>
Spherical harmonic decomposition of XOR6 DKC on S² reveals a sharp phase transition at bandwidth l=6, explained entirely by a degrees-of-freedom argument: 2×6+1 = 13 = number of eigenvector directions.
<h3>Key Results</h3>
<ul>
<li><strong>Phase transition (Part E)</strong>: 0% of winners recovered at l≤5, 100% recovered at l=6. The threshold is exact and sharp — no partial recovery.</li>
<li><strong>Mode l=6 dominance (Part C)</strong>: The XOR6 Voronoi labeling function concentrates ~83.9% of its power in mode l=6 for the best winner; the global average across all 36 winners is 80.7%.</li>
<li><strong>Spectral universality (Part D)</strong>: All 36 winning triples share the same spectral shape — l=6 dominant (~80%), l=4 secondary (~6%), l=12 tertiary (~6–7%). Variation is small and concentrated in l=2. The spectrum is a structural invariant of XOR6 solutions.</li>
<li><strong>Antipodal symmetry</strong>: All odd modes are exactly zero. The Voronoi partition is antipodally symmetric by construction (directions are undirected), so only even modes carry power.</li>
<li><strong>Super-Nyquist compression (Part E/H)</strong>: 14 Voronoi cells suffice where Nyquist predicts (6+1)²=49, a 3.5× compression. Explained by compressed sensing: XOR6 is a binary function at 13 known positions, so sparsity plus known support eliminates the generic sampling requirement.</li>
<li><strong>Eigenvector density spectrum (Part B)</strong>: The direction density itself (von Mises-Fisher, κ=50) is dominated by l=0 (51.6%) and l=8 (35.8%) — high bandwidth because the directions are point-like. This is the spectrum of WHERE the directions are, not what the computation does with them.</li>
<li><strong>Trivialization prediction</strong>: For ζ_16 with 3,457 directions the DOF formula predicts minimum bandwidth l≥1728 (2×1728+1=3,457), with Nyquist cell count ~3M. At such bandwidth any coarse partition resolves XOR6, explaining the ~90% solution rate seen in <a href="./entries/demo_69.html">Demo 69</a>.</li>
<li><strong>Musical connection (Part F)</strong>: The computation lives at l=6 (200 cents, note D, whole tone), which is ABOVE the eigenvalue-resonant modes l=2,3,4 (tritone F#, major 3rd E, minor 3rd Eb). The XOR6 labeling requires higher angular frequency than the eigenvalue geometry itself provides.</li>
<li><strong>Spherical harmonic engine (Part A)</strong>: Real Y_lm via stable three-term Legendre recurrence; Gauss-Legendre quadrature on 64×128=8,192 grid points. Orthonormality max error 6.82e-14 across all 1,225 pairs with l≤6.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>The 13=13 Theorem (PROVEN)</strong>: The minimum bandwidth for XOR6 DKC on S² is l=6 because mode l has (2l+1) independent spherical harmonic components, and 2×6+1=13 equals the number of eigenvector directions. At l=5 there are 11 components trying to address 13 regions (underdetermined); at l=6 there are exactly 13 (determined). The phase transition is all-or-nothing at the DOF boundary.</li>
<li><strong>Spectral Universality (DEMONSTRATED)</strong>: All 36 XOR6 winners share the same spectral envelope with l=6 dominant. The spectrum is a structural invariant: the 80% figure is universal, not solution-specific.</li>
<li><strong>Compressed Sensing on S² (EXPLAINED)</strong>: The 3.5× super-Nyquist compression of the eigenvector Voronoi is a consequence of compressed sensing — binary function at known support positions. The Voronoi cells need only distinguish 13 directions from each other, not generically sample an arbitrary l=6 function.</li>
<li><strong>Trivialization DOF Prediction (CONJECTURED)</strong>: The minimum bandwidth scales as l≥(N-1)/2 where N is the number of eigenvector directions. For ζ_16 this predicts l≥1728. At such enormous bandwidth any coarse partition trivially resolves the computation. CONJECTURED (not yet proven analytically).</li>
</ul>
<h3>Data</h3>
<ul>
<li>Minimum bandwidth: l=6 (sharp threshold: 0% at l≤5, 100% at l=6)</li>
<li>Mode l=6 power fraction: 83.9% (best winner), 80.7% average, 70.0% minimum across 36 winners</li>
<li>Mode l=4 power: ~6.0% (low spread, 5.6–6.3%); mode l=12: ~6.4–7.3%</li>
<li>Mode l=2 power: 4.1% average but highly variable (0.02%–17.6%), main source of inter-winner variance</li>
<li>Nyquist prediction for l=6: (6+1)²=49 cells; actual cell count: 14; compression: 3.5×</li>
<li>Orthonormality check: max error 6.82e-14 (1,225 pairs, l≤6); round-trip: max error 8.38e-15</li>
<li>Quadrature grid: 64 theta × 128 phi = 8,192 points</li>
<li>Direction density spectrum (Part B): l=0: 51.6%, l=8: 35.8% (high-kappa point-like density)</li>
<li>Musical mapping: l=6 → 200 cents (D, whole tone); computation lives one step above the tritone (l=2, 600 cents, F#) that spans the eigenvalue range</li>
<li>ζ_16 prediction: l≥1728, Nyquist ~2,989,441 cells (1,729²)</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>Spherical harmonic engine</strong>: real Y_lm via associated Legendre polynomials with three-term recurrence; numerically stable to l=12+</li>
<li><strong>Gauss-Legendre quadrature</strong>: 64-point integration in theta; uniform grid in phi; produces integration weights on S²</li>
<li><strong><code>spectrum_of_function()</code></strong>: decomposes an arbitrary S² function (given as Voronoi label array over grid) into power per l-mode up to l_max</li>
<li><strong><code>bandwidth_test()</code></strong>: reconstructs a function from coefficients up to l_cut and evaluates winner recovery fraction; used to find the phase-transition threshold</li>
<li><strong>Von Mises-Fisher density on S²</strong>: direction density representation for the 13-direction catalog (Part B)</li>
<li><strong>Comparative spectrum harness</strong>: runs Parts C and D over all 36 winners and aggregates power-per-mode statistics</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>Aizenberg (2008)</strong>: k-sector MVN activation on S¹; the present demo establishes the S² analogue and its spectral characterization</li>
<li><strong>Compressed sensing (Candès, Romberg, Tao 2006; Donoho 2006)</strong>: sparsity + known support yields sub-Nyquist recovery; the 3.5× compression is a direct instance of this framework applied to S²</li>
<li><strong>Nyquist-Shannon sampling on S² (Driscoll &amp; Healy 1994)</strong>: bandlimited functions on S² require (l+1)² samples; XOR6 beats this by the compressed sensing argument</li>
<li><strong>Nazer &amp; Gastpar (2011)</strong>: compute-and-forward / lattice coding; DKC as a structured computation on algebraic inputs connects to this framework</li>
<li><strong>Habiro (2002) / Ohtsuki TL modules</strong>: the Z[ζ_8] bracket structure that generates the 13 directions; the spectral result gives a harmonic-analytic characterization of this algebraic structure</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li><strong>Analytical proof of the bandwidth bound</strong>: The 13=13 theorem is computationally verified. Can it be proven that the minimum bandwidth of any binary Voronoi partition separating N points on S² in general position is l=⌈(N-1)/2⌉?</li>
<li><strong>Is l=6 tight?</strong>: The phase transition is sharp at l=6, but is there a single-mode (l=6 only) solution, or do the small l=4 and l=12 contributions play a necessary role in the actual Voronoi geometry?</li>
<li><strong>XOR7 bandwidth</strong>: <a href="./entries/demo_65.html">Demo 65</a> showed XOR7 requires k=127 sectors on S¹. If S² reduces XOR6 from k=24 to l=6, what is the S² bandwidth for XOR7, and does the DOF formula generalize?</li>
<li><strong>ζ_16 trivialization confirmation</strong>: The prediction l≥1728 explains the ~90% <a href="./entries/demo_69.html">Demo 69</a> solution rate, but the exact spectral structure of ζ_16 XOR solutions has not been computed. Does the same universality (single dominant mode) hold?</li>
<li><strong>Relationship to quantum information</strong>: The computation lives on S²=CP¹ (the Bloch sphere). The l=6 mode is associated with hexadecapole operators in quantum optics. Is there a quantum-information interpretation of the bandwidth result?</li>
<li><strong>Spectral characterization of non-solutions</strong>: Do failed triples (bracket values that do not solve XOR6) have a systematically different spectral shape, or is the spectrum of the Voronoi labeling similar and the failure occurs elsewhere?</li>
</ul>
<p>---</p>

<h2><a href="./entries/demo_72.html">Demo 72</a>: Spherical Design Test — Are the 13 Directions Optimal?</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_72_spherical_design/main.c.html">demo_72_spherical_design/main.c</a></code> (~971 lines)</li>
<li><strong>Tests</strong>: 8/8 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_67.html">Demo 67</a> (13 eigenvector directions on S², 36 XOR6 solutions), <a href="./entries/demo_71.html">Demo 71</a> (DKC bandwidth l=6, DOF argument)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_73.html">Demo 73</a> (automaton structure), <a href="./entries/demo_74.html">Demo 74</a> (computational invariant)</li>
</ul>
<h3>Headline</h3>
The 13 eigenvector directions are NOT a spherical t-design (t=0, directed) — the worst possible for sampling — yet stochastic optimization confirms that better geometric distribution gives fewer XOR6 solutions (36 vs 4), establishing an anti-correlation between sampling quality and computational quality.
<h3>Key Results</h3>
<ul>
<li><strong>t=0 directed (Part A)</strong>: The 13 directions fail the t-design property at l=1 (centroid off-origin, |S_{1,m}|=2.43). Exactly l=2 passes at machine precision (|S_{2,m}|=5.11e-16). Fails at all subsequent levels through l=8+.</li>
<li><strong>Bandwidth gap (Part B)</strong>: DKC operates at bandwidth l=6 (<a href="./entries/demo_71.html">Demo 71</a>) but the directions achieve t=0. The gap of 6 modes is entirely filled by compressed sensing and the DOF argument — classical sampling theory does not apply.</li>
<li><strong>Even/odd mode asymmetry (Part C)</strong>: Directed even-mode t-design is t_even=2 (l=2 passes); directed odd-mode is t_odd=0. Undirected (26 points, both +dir and -dir) achieves t=3 because antipodal symmetry kills all odd modes automatically. First genuine failure for DKC-relevant even modes is l=4 (|S_{4,m}|=0.576).</li>
<li><strong>S³ design (Part D)</strong>: The full 48-element binary octahedral group on S³ achieves t=1. Odd degrees are exactly zero by symmetry; even degrees fail. The 24-cell vertices (binary tetrahedral subgroup) form a 5-design; the additional 24 elements break the property at degree 2.</li>
<li><strong>Delsarte bounds (Part E)</strong>: With 13 points, t-designs up to t=7 are theoretically possible (Delsarte minimum for t=7 is 10 points). The actual achievement (t=0) is the worst possible given that the points trivially satisfy no integration condition.</li>
<li><strong>Residual analysis (Part F)</strong>: First failing mode is l=1 (odd mode, irrelevant for DKC). All three l=1 components are large (max 2.435). The effective first failure for DKC is l=4 (even mode, residual 0.576).</li>
<li><strong>Optimized design gets fewer solutions (Part G)</strong>: Stochastic optimization of 13 points to minimize t=6 design residual achieved residual 0.93 (vs 2.43 for eigenvectors — 2.6× better geometry). XOR6 solutions: eigenvector 36, optimized 4. Better geometry destroys the computation.</li>
<li><strong>Perturbation robustness (Part H)</strong>: At 1° perturbation mean XOR6 count is 38 (slightly above unperturbed 36, showing some near-miss solutions exist). Robust through 5° (mean 35.8). Collapses at 10° (mean 11.5) and 20° (mean 2.1). The algebraic placement is sharp to ~5°.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Anti-Correlation Theorem (DEMONSTRATED)</strong>: The 13 eigenvector directions are simultaneously the worst choice for spherical integration (t=0) and a locally optimal choice for DKC computation (36 vs 4 solutions for better-distributed directions). Sampling quality and computational quality are anti-correlated for this configuration.</li>
<li><strong>Algebra &gt; Geometry Principle (DEMONSTRATED)</strong>: The DKC computation is algebraic, not geometric. The directions are selected by the binary octahedral group acting on Z[ζ_8] quaternions; they compute because of specific angular relationships, not uniform distribution. Moving directions to "better" positions (geometrically) destroys the Voronoi partition structure needed for XOR6.</li>
<li><strong>DOF-not-Design Conjecture (SUPPORTED)</strong>: The reason DKC works at bandwidth l=6 with only 13 directions (well below Nyquist) is the DOF coincidence 2×6+1=13=directions, combined with compressed sensing for binary functions at known positions. The t-design property is irrelevant to this mechanism.</li>
</ul>
<h3>Data</h3>
<ul>
<li>Directed t-design parameter: t=0 (fails at l=1)</li>
<li>l=2 residual: 5.11e-16 (machine precision — single exact pass)</li>
<li>Even-mode t-design: t_even=2; odd-mode: t_odd=0; undirected: t=3</li>
<li>S³ design (48 elements): t=1</li>
<li>Delsarte maximum possible with 13 points: t=7 (none achieved)</li>
<li>First l=1 failure: max |S_{1,m}|=2.435 (m=+1 component)</li>
<li>First DKC-relevant (even) failure: l=4, |S_{4,m}|=0.576</li>
<li>Optimized 13-point design residual (t=6): 0.93 vs eigenvector 2.43 (2.6× better)</li>
<li>XOR6 solutions: eigenvectors 36, optimized design 4</li>
<li>Perturbation: robust at 5° (mean 35.8/36), collapses at 10° (mean 11.5/36)</li>
<li>At 1° perturbation: mean 38.0 (can exceed unperturbed count — local not global optimum)</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>Spherical harmonic t-design test</strong>: directed and undirected summation of Y_lm over arbitrary point sets; max |S_lm| per l computed cleanly</li>
<li><strong>S³ monomial design test</strong>: tests homogeneous polynomial averages over quaternion sets against exact S³ integrals via double factorial formula</li>
<li><strong><code>design_residual()</code></strong>: computes t=T design residual (max over l=1..T of max_m |S_lm|) for any point set on S²; reusable quality metric</li>
<li><strong>Stochastic optimizer for spherical designs</strong>: gradient-free simulated annealing with Gaussian perturbation and normalization; 20 random restarts, 2000 steps each; minimizes design residual</li>
<li><strong><code>count_xor6_ext()</code></strong>: counts XOR6 solutions for an arbitrary direction set (not just the canonical 13); used for the optimized vs eigenvector comparison</li>
<li><strong>LCG random number generator + Box-Muller</strong>: self-contained deterministic PRNG for perturbation trials; no stdlib rand dependency</li>
<li><strong>Even/odd mode analysis harness</strong>: separates t-design test into even-l and odd-l streams and reports independently</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>Delsarte, Goethals, Seidel (1977)</strong>: lower bounds on N for spherical t-designs on S^d; the t=7 feasibility bound for N=13 comes from this framework</li>
<li><strong>Seymour &amp; Zaslavsky (1984)</strong>: existence of spherical t-designs for all t and N large enough; establishes that the eigenvector configuration is far from optimal despite being algebraically distinguished</li>
<li><strong>Aizenberg (2008)</strong>: the algebraic selection of directions by the MVN/DKC mechanism is the reason the t-design property is irrelevant; the paper's framework predicts directions from algebraic rather than geometric criteria</li>
<li><strong>Compressed sensing (Candès, Romberg, Tao 2006)</strong>: the DOF-not-Design explanation relies on sparsity at known positions bypassing the Nyquist-Shannon/spherical-design sampling requirement</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li><strong>Is 5° the Voronoi cell boundary?</strong>: The robustness threshold of ~5° matches the typical angular size of a Voronoi cell for 13 points on S². Is there a clean geometric formula relating cell angular radius to robustness threshold?</li>
<li><strong>Why exactly l=2 passes?</strong>: The l=2 mode vanishes to machine precision despite t=0 overall. This suggests a hidden quadrupole symmetry in the binary octahedral group action. What algebraic identity ensures Σ Y_{2,m}(dir_i)=0?</li>
<li><strong>Optimized design lower bound</strong>: The stochastic optimizer found 4 solutions for the "better" design. Is 0 achievable? Is there a geometric argument that any t≥1 spherical design on S² yields fewer XOR6 solutions than the algebraic eigenvector configuration?</li>
<li><strong>Perturbation non-monotonicity</strong>: Small perturbations (1°) slightly increase the mean solution count (38 &gt; 36). Can the maximum XOR6 solution count for any 13-point configuration on S² be characterized? Is 36 a local or global maximum?</li>
<li><strong>Analog for higher Boolean functions</strong>: XOR6 uses l=6, 13 directions. For XOR7 on S², what is the expected t-design parameter of the algebraically-selected directions, and does the anti-correlation persist?</li>
</ul>
<h2><a href="./entries/demo_73.html">Demo 73</a>: Eigenvector Automaton — Can DKC Be a Finite Automaton?</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_73_eigenvector_automaton/main.c.html">demo_73_eigenvector_automaton/main.c</a></code> (~1042 lines)</li>
<li><strong>Tests</strong>: 7/7 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_67.html">Demo 67</a> (13-direction S² Voronoi, 36 XOR6 solutions), <a href="./entries/demo_71.html">Demo 71</a> (bandwidth l=6, DOF argument), <a href="./entries/demo_72.html">Demo 72</a> (spherical design test, algebraic structure)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_74.html">Demo 74</a> (computational invariant, bracket vs cell comparison)</li>
</ul>
<h3>Headline</h3>
DKC is fundamentally additive (weight vector sum, not braid matrix product), and the 13-cell Voronoi partition is almost but not quite a finite automaton state space: 82.8% of cell transitions are deterministic — a structural constant identical across all 36 winning triples — with non-determinism arising entirely from discarded magnitude information.
<h3>Key Results</h3>
<ul>
<li><strong>Multiplicative formulation fails entirely (Part B)</strong>: The 6-step braid product σ₁^±1·σ₂^±1·...·σ₂^±1 assigns exactly 8 even-parity and 8 odd-parity inputs to every final cell. Every cell is maximally non-separating. The product cannot compute XOR6 at all — parity is structurally invisible because flipping all bits (changing parity) maps M→M⁻¹, which shares the same eigenvector cell as M.</li>
<li><strong>Additive formulation computes XOR6 (Part D)</strong>: Weight sum S_k = S_{k-1} + w_k with winning triple catalog[0,4,19]. Weights map to only 3 distinct cells (0, 1, 10). All 14 final cell states are parity-pure. State space expands from 2 (step 0) to 14 (step 4) distinct cells as weights accumulate.</li>
<li><strong>Additive determinism: 82.8% (Part E)</strong>: Of 58 (prev_cell, bit, step) triples in the additive trajectories, 48 are deterministic (same prev_cell + bit always yields same next_cell). 10 are not. Every non-deterministic transition occurs on bit=1 (adding a weight). Bit=0 transitions are trivially deterministic. Cell 0 is the main split point.</li>
<li><strong>Cell is not a sufficient statistic (Part E)</strong>: The cell at step k does not predict the final XOR6 output for any k &lt; 5. Only the final step's cell (the complete sum's eigenvector) determines output.</li>
<li><strong>Why 82.8% and not 100% (Part E synthesis)</strong>: The Voronoi cell captures eigenvector direction but discards two pieces of information: (1) eigenvalue angle θ, and (2) magnitude. Two quaternion sums with the same eigenvector direction but different magnitude or angle produce different results when a weight is added. Max split factor is always binary (2-way).</li>
<li><strong>27 cells needed for 100% direction-level determinism (Part F)</strong>: Distinct partial sums at each step: 2, 3, 6, 9, 18, 27. The 27-cell signed partition (no antipodal identification) achieves 87.1% determinism vs 82.8% for unsigned. Still not 100% — the remaining non-determinism comes from partial sums with different magnitudes but the same eigenvector direction. Only 17 of 27 cells are actually occupied at step 5.</li>
<li><strong>82.8% is a universal structural constant (Part G)</strong>: All 36 winning triples have exactly 82.8% determinism (48/58 transitions). Zero variation. This universality follows from the binary octahedral group acting transitively on the 13 directions — the combinatorial structure of cell collisions is identical across all triples.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>DKC is Additive, Not Multiplicative (PROVEN)</strong>: The multiplicative braid product formulation is structurally incapable of computing XOR6 via the Voronoi cell mechanism. The reason is algebraic: complement-all-bits maps M to its inverse M⁻¹, which shares the same cell (antipodal eigenvectors are identified), but changes parity. The computation requires additive weight sums.</li>
<li><strong>82.8% Universal Determinism (PROVEN)</strong>: The determinism fraction 48/58 is a structural constant of the ζ_8 DKC system, not an artifact of triple selection. It follows from the symmetry of the 13-direction partition: all 36 winning triples are related by the binary octahedral group, so the collision structure is identical.</li>
<li><strong>Compass Without Odometer (STATED)</strong>: The Voronoi cell captures the compass heading (eigenvector direction) of the partial sum but not the odometer reading (magnitude). This missing magnitude information is the precise source of the 17% non-determinism. A state machine that also tracked magnitude modulo the weight lattice would achieve 100% determinism but would require infinitely many states.</li>
<li><strong>Minimum States Conjecture</strong>: The theoretical minimum cell count for a fully deterministic automaton computing XOR6 via DKC at ζ_8 is 27 (max distinct partial sums). Whether a 27-state automaton actually exists (i.e., whether 27 appropriately-chosen cells achieves 100% determinism) is not yet proven — the signed partition with 27 cells reaches only 87.1%.</li>
</ul>
<h3>Data</h3>
<ul>
<li>Multiplicative determinism: 81.2% (26/32 transitions); XOR6: NO (every cell is perfectly balanced)</li>
<li>Additive determinism: 82.8% (48/58 transitions); XOR6: YES</li>
<li>Signed 27-cell partition determinism: 87.1%; cells occupied at step 5: 17 of 27</li>
<li>Number of distinct partial sums per step: 2, 3, 6, 9, 18, 27 (step 0–5)</li>
<li>Cell collisions (same cell, different partial sum history): 1,296 instances across all steps</li>
<li>Number of winning triples with exactly 82.8% determinism: 36/36 (100%)</li>
<li>Cell 0 split count: steps 2, 3, 4, 5; Cell 1 split count: steps 4, 5</li>
<li>Generator cells: σ₁ and σ₁⁻¹ both → cell 0; σ₂ and σ₂⁻¹ both → cell 1</li>
<li>Even multiplicative steps are 100% deterministic; odd steps split at 67%</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong><code>determinism_test()</code></strong>: generic automaton determinism checker for any trajectory array; reports per-step and overall fraction, prints split events, works for both multiplicative and additive formulations</li>
<li><strong><code>determinism_pct()</code></strong>: quiet version returns determinism percentage; used in batch loop over all 36 winners (Part G)</li>
<li><strong><code>compute_mul_trajectories()</code></strong>: computes 64×6 cell trajectory table for the multiplicative braid product formulation</li>
<li><strong><code>compute_add_trajectories()</code></strong>: computes 64×6 cell trajectory table for the additive weight sum formulation given a winning triple</li>
<li><strong><code>vor_cell_signed()</code></strong>: signed Voronoi partition (26 directions, no antipodal identification); returns cell in 0..25 with identity pseudo-cell at 26</li>
<li><strong><code>quat_to_cell_26()</code></strong>: maps quaternion to signed cell index; companion to unsigned <code>quat_to_cell()</code></li>
<li><strong>Distinct partial sum counter</strong>: counts unique quaternion vectors at each step to determine theoretical minimum state count; O(N²) exact comparison</li>
<li><strong>Sufficient statistic tester</strong>: for each cell at each step, checks whether all inputs reaching that cell have a consistent final output (tests if cell is a Markov blanket for the computation)</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>Mealy/Moore automata (classical)</strong>: the 13-cell partition is a near-Mealy machine; the gap from 82.8% to 100% identifies exactly what information a state machine must track beyond cell identity</li>
<li><strong>Braid group B_3 (Artin 1947)</strong>: the multiplicative vs additive distinction corresponds to using the group element vs the representation matrix sum; the group element loses parity by the M→M⁻¹ argument</li>
<li><strong>Nazer &amp; Gastpar (2011) compute-and-forward</strong>: additive structure is the key feature connecting DKC to lattice computation; the present demo confirms the computation is fundamentally additive at the level of trajectory tracking</li>
<li><strong>Compressed sensing / sparse recovery</strong>: the 27-state sufficiency argument connects to the sparsity structure of partial sums — only 27 of 64 possible 6-bit sums are distinct, a 2.4× reduction from the maximum</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li><strong>Exact 27-state automaton</strong>: The signed 27-cell partition reaches 87.1% determinism, not 100%. Is there a different 27-partition of S² that achieves 100% determinism? Or does 100% require tracking more than direction (i.e., some magnitude information)?</li>
<li><strong>What encodes the missing 17%?</strong>: The non-determinism comes from magnitude loss. Is there a natural algebraic quantity — perhaps the norm of the partial sum modulo the weight lattice — that, when added to the cell as state, achieves 100% determinism with a finite state count?</li>
<li><strong>Automaton for other Boolean functions</strong>: XOR6 at ζ_8 gives 82.8% universal determinism. Does XOR5 at ζ_8 (<a href="./entries/demo_50.html">Demo 50</a>) have a different universal determinism constant? Is the constant always a ratio of integers (48/58 = 24/29)?</li>
<li><strong>Relationship to the 13=13 theorem</strong>: The 13 cells and the 13 directions are the same partition. The DOF theorem (<a href="./entries/demo_71.html">Demo 71</a>) explains why 13 directions suffice for XOR6. Does the 82.8% automaton constant have an analogous DOF interpretation?</li>
<li><strong>Cellular automaton generalization</strong>: The additive DKC trajectory on cells (with non-determinism) resembles a probabilistic cellular automaton on a 13-cell state space. Is there a stochastic matrix formulation that exactly captures the 82.8% determinism?</li>
</ul>
<h2><a href="./entries/demo_74.html">Demo 74</a>: Computational Invariant of Braids</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_74_computational_invariant/main.c.html">demo_74_computational_invariant/main.c</a></code> (~1623 lines)</li>
<li><strong>Tests</strong>: 20/20 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_66.html">Demo 66</a> (24 quaternions, Kauffman bracket at Z[ζ_8], 100 bracket values), <a href="./entries/demo_67.html">Demo 67</a> (13 eigenvector directions, Voronoi cell assignment, 36 XOR6 solutions), <a href="./entries/demo_70.html">Demo 70</a> (music space, r=-0.06 geometric/computational orthogonality), <a href="./entries/demo_73.html">Demo 73</a> (82.8% automaton determinism, additive structure)</li>
<li><strong>Feeds into</strong>: Future work on braid invariant theory from computational perspective</li>
</ul>
<h3>Headline</h3>
The DKC Voronoi cell and the Kauffman bracket are incomparable braid invariants — neither subsumes the other — and their combination produces 119 equivalence classes (vs 100 bracket-alone and 14 cell-alone), with the cell separating 97.8% of bracket collisions at the braid level while the bracket separates 53.8% of cell collisions; the DKC computation exploits exactly this geometric information the bracket discards.
<h3>Key Results</h3>
<ul>
<li><strong>97.8% bracket collision separation (Part A)</strong>: Of 58,078 braid pairs with the same bracket but different quaternion, 56,825 (97.8%) land in different Voronoi cells. The remaining 2.2% correspond to quaternion pairs sharing an eigenvector direction but differing in eigenvalue angle — the angle is what the cell discards.</li>
<li><strong>Cell does not subsume bracket (Part B)</strong>: At the quaternion catalog level, 13 pairs share a Voronoi cell. Of these, 7 pairs have different bracket values. The cell is strictly coarser than the bracket in certain cases. Cell 0, 1, and 10 each contain 3 quaternions with up to 3 distinct bracket values; cells 2–5 (body-type, 60° angle) each have 2 quaternions with 1 bracket value.</li>
<li><strong>119 combined classes (Part C)</strong>: Braid-level equivalence classes: cell alone gives 14, bracket alone gives 100, (bracket, cell) pair gives 119. The combination is 19% finer than bracket alone. 28 of 100 bracket values (28%) appear in braids across multiple cells; max distinct brackets per cell is 19 (cell is very coarse relative to bracket). The two invariants capture orthogonal information.</li>
<li><strong>Computational significance (Part D)</strong>: For each winning triple, the cell labeling assigns binary parity to cells. 33 of 36 winners (92%) use their labeling to XOR6-separate at least some bracket collisions. The 3 exceptions are triples containing quaternions 18 and 22 (edge-type), where colliding cells happen to share a label. Total XOR6-separated collisions across all 36 winners: 186.</li>
<li><strong>Information hierarchy (Part E)</strong>: Quaternion→Direction→Cell is a well-defined factoring chain. Direction and Cell are identical (Voronoi IS the direction catalog). The bracket does NOT factor through quaternion — different braids with the same quaternion can have different bracket values. The factoring: Braid→Quaternion→Cell (well-defined), Braid→Bracket (well-defined), Quaternion→Bracket (many-to-many, NOT well-defined).</li>
<li><strong>Incomparability synthesis (Part F)</strong>: At the quaternion catalog level: bracket collisions (same bracket, different quaternion) = 30, of which 24 are separated by cell (80%); cell collisions (same cell, different quaternion) = 13, of which 7 are separated by bracket (54%). Neither invariant refines the other. 6 pairs are unseparated by either.</li>
<li><strong>6 computational type vectors (Part G)</strong>: Each of the 36 winning triples assigns a binary parity label to each cell, giving a 36-bit type vector per cell. Among 14 cells, only 6 distinct type vectors exist. Types: 0={cell 0 / axis σ₁, 3 quats}, 1={cell 1 / axis σ₂, 3 quats}, 2={cells 2,3,4,5 / body 60° cells, 8 quats}, 3={cells 6,7,8,9,11,12 / edge cells, 6 quats}, 4={cell 10 / axis third, 3 quats}, 5={cell 13 / identity, 1 quat}. The DKC computation is invariant under permutation within each symmetry orbit.</li>
<li><strong>Refinement chain (Part I)</strong>: Bracket→Type→Quaternion: 43 bracket groups (of 100 catalog values that appear in braids) → 61 type subgroups → 168 quaternion subgroups. Max types per bracket value: 4. Max quaternions per type within a bracket: 8.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Incomparability Theorem (PROVEN)</strong>: The Kauffman bracket (at A=-ζ_8) and the DKC Voronoi cell are incomparable braid invariants. The bracket is a trace/normalization operation; the cell is an eigenvector direction projection. These operations discard orthogonal information. Neither refines the other: cell separates bracket collisions (97.8% at braid level, 80% at qcat level), and bracket separates cell collisions (54% at qcat level).</li>
<li><strong>Strict Combination Theorem (PROVEN)</strong>: The combined invariant (bracket, cell) is strictly finer than either alone: 119 &gt; 100 &gt; 14. The 19% improvement over bracket alone confirms genuinely new information in the cell.</li>
<li><strong>6-Type Orbit Theorem (PROVEN)</strong>: The DKC computation on the 13-cell Voronoi partition uses only 6 distinct computational roles. These correspond to the 3 axis orbits (σ₁, σ₂, third axis), the 4 body cells, the 6 edge cells, and the identity cell. The binary octahedral symmetry group acts transitively within each type — the computation is invariant under intra-orbit permutation.</li>
<li><strong>Bracket-Blind Computation (STATED)</strong>: The 36 XOR6 winning triples actively exploit information the bracket cannot see. 92% of them use their cell labeling to distinguish braid pairs that the bracket treats as equal. The DKC computation is accessing a fundamentally different projection of the braid group representation than the bracket provides.</li>
</ul>
<h3>Data</h3>
<ul>
<li>Correspondence records analyzed: 2,000 (1,124,250 pairs at braid level)</li>
<li>Bracket collisions (braid level): 58,078 pairs with same bracket, different quaternion; 56,825 (97.8%) in different cells</li>
<li>Cell collisions (braid level): 1,253 pairs with same bracket and same cell (the 2.2% unseparated)</li>
<li>Quaternion catalog level: 30 bracket collisions (24/30 = 80% separated by cell); 13 cell collisions (7/13 = 54% separated by bracket)</li>
<li>Equivalence classes: cell=14, quaternion=24, bracket=100, (bracket,cell)=119</li>
<li>Combined improvement over bracket: +19 classes (+19%)</li>
<li>Bracket values split across multiple cells: 28 of 100 (28%); max cells per bracket: 6</li>
<li>Max distinct brackets per cell: 19 (cell is very coarse)</li>
<li>Computational types: 6 distinct among 14 cells; 4 body cells interchangeable; 6 edge cells interchangeable</li>
<li>XOR6-separating winners: 33/36 (92%); exceptions: triples with q18 and q22 (edge-type)</li>
<li>Total XOR6-separated bracket collisions across all 36 winners: 186</li>
<li>Refinement chain: 43→61→168 (bracket→type→quaternion subgroups from appearing braids)</li>
<li>Unseparated pairs (same cell AND same bracket at qcat level): 6</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>Full catalog builder with bracket computation</strong>: computes Kauffman bracket at A=-ζ_8 for every braid up to length 8 on 2 and 3 strands; stores quaternion, bracket, and per-braid correspondence records simultaneously</li>
<li><strong>Z[ζ_8] exact arithmetic</strong>: <code>Cyc8</code> struct with <code>cyc8_mul()</code>, <code>cyc8_add()</code>, <code>cyc8_conj()</code>, <code>cyc8_pow_int()</code>, <code>cyc8_eq()</code>; coefficients remain exact integers throughout</li>
<li><strong>Union-find loop counter for bracket</strong>: <code>braid_loops()</code> counts Temperley-Lieb loops for each state-sum assignment; union-find on (len+1)×n grid handles arbitrary braid words</li>
<li><strong><code>find_winners()</code></strong>: finds all 36 XOR6 winning triples from the 24-element quaternion catalog; identical to <a href="./entries/demo_67.html">Demo 67</a>/73 logic but integrated with full catalog</li>
<li><strong><code>compute_type_vectors()</code></strong>: for each of the 14 Voronoi cells, computes the 36-bit type vector encoding its parity label under each winning triple; <code>TypeVec</code> struct with <code>typevec_eq()</code> for comparison</li>
<li><strong><code>braid_type_idx()</code></strong>: maps a cell index to its type vector index (0–5); key for the 6-type orbit analysis</li>
<li><strong>Per-braid correspondence record</strong>: stores (quaternion, bracket, qcat_idx, bcat_idx, braid_word, word_len, n_strands) for up to 2,000 braids; used for all collision and separation analyses</li>
<li><strong>Bracket collision separation analysis (Part A/F)</strong>: counts pairs by (same/diff bracket) × (same/diff cell) at both braid-level and catalog-level; cleanly separated into directed and reverse analyses</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>Kauffman (1987)</strong>: the bracket polynomial as a braid/knot invariant at variable A; the specific evaluation A=-ζ_8 is the connection point to the DKC quaternion structure (<a href="./entries/demo_66.html">Demo 66</a> established this)</li>
<li><strong>Jones polynomial (Jones 1985)</strong>: the bracket at A=q^{-1/4} specializes to the Jones polynomial; the 119-class combined invariant is a refinement that the Jones polynomial alone cannot achieve</li>
<li><strong>Temperley-Lieb algebra</strong>: the union-find loop counting in <code>braid_loops()</code> implements the TL state-sum expansion of the bracket; the computation is exact over Z[ζ_8]</li>
<li><strong>Braid group representations (Burau, Lawrence-Krammer)</strong>: the SU(2) representation used for DKC is distinct from Burau/LK; the incomparability result shows the SU(2) eigenvector direction extracts information neither representation captures algebraically</li>
<li><strong>Turaev-Viro / TL non-semisimplicity</strong>: the bracket at ζ_8 is a root-of-unity evaluation where the TL category becomes non-semisimple; the fact that 119 classes exceed 100 suggests the cell is detecting some non-semisimple structure that the trace/bracket misses</li>
<li><strong>Abramsky (2004) / topological quantum computation</strong>: the Voronoi cell as a classical readout of a topological quantity; the 6-type structure suggests the DKC computation sees the braid through a 6-element coarse-graining of the representation</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li><strong>What are the 6 unseparated pairs?</strong>: At the qcat level, 6 pairs have the same cell AND the same bracket. These correspond to body-type cells (2–5) with 60° angles. Do these pairs represent genuinely equivalent braids under some stronger invariant, or is there a finer invariant that separates them?</li>
<li><strong>Is 119 near-optimal?</strong>: With 24 quaternions and 13 cells, the theoretical maximum for (bracket, cell) pairs is min(24×13, number of braids) but in practice is bounded by the braid word space sampled. Is 119 close to the maximum achievable combined class count with this braid space?</li>
<li><strong>[*,18,22] dead zone</strong>: Triples containing q18 and q22 (edge-type) separate zero bracket collisions. Is this a geometric accident (those cells happen to share labels) or is there a group-theoretic reason that edge-type triples cannot exploit bracket collisions?</li>
<li><strong>Algebraic characterization of the 97.8%</strong>: The cell separates 97.8% of bracket collisions at the braid level. The unseparated 2.2% are pairs with the same eigenvector direction but different eigenvalue angle. Is there a closed-form expression for exactly which braid pairs are unseparated (i.e., which Z[ζ_8] elements share direction but differ in angle)?</li>
<li><strong>Refinement chain completeness</strong>: The chain 43→61→168 uses only braids appearing in the length-1-to-8 catalog. The full braid group is infinite. Does the refinement ratio (bracket→type→quat) stabilize as longer braid words are included, or does it grow without bound?</li>
<li><strong>Connection to knot invariant strength</strong>: The combined (bracket, cell) invariant defines a function on braids. When the braid closure is taken, does this descend to a knot invariant? If so, how does it compare to known invariants (Jones, HOMFLY, Khovanov) in distinguishing power?</li>
</ul>
<h2><a href="./entries/demo_75.html">Demo 75</a>: Binocular DKC (Multi-Output)</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_75_binocular_dkc/main.c.html">demo_75_binocular_dkc/main.c</a></code> (~1495 lines)</li>
<li><strong>Tests</strong>: 23/23 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_66.html">Demo 66</a> (quaternionic DKC, 24-cell catalog), <a href="./entries/demo_67.html">Demo 67</a> (13 directions, 36 XOR6 solutions), <a href="./entries/demo_70.html">Demo 70</a> (music space, geometric vs computational independence), <a href="./entries/demo_71.html">Demo 71</a> (spectral DKC, bandwidth l=6), <a href="./entries/demo_72.html">Demo 72</a> (spherical design), <a href="./entries/demo_73.html">Demo 73</a> (eigenvector automaton, additive compass without odometer), <a href="./entries/demo_74.html">Demo 74</a> (computational invariant, bracket vs cell incomparability)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_76.html">Demo 76</a> (scaling to 8 inputs), <a href="./entries/demo_77.html">Demo 77</a> (activation zoo)</li>
</ul>
<h3>Headline</h3>
A single braid evaluation yields two simultaneous output channels — eigenvalue angle and eigenvector cell — where the angle subsumes the cell entirely, giving 2.3× capacity over cell-only while the multiplicative product channel has maximum entropy but is completely blind to XOR6.
<h3>Key Results</h3>
<ul>
<li><strong>Angle subsumes cell (Parts B-D)</strong>: The eigenvalue angle perfectly predicts parity for ALL 36 winning triples. Every angle value maps to exactly one parity bit. The cell channel is a coarsening of the angle channel; knowing the angle tells you the cell parity but not vice versa.</li>
<li><strong>Seven eigenvalue angles</strong>: Sum quaternions from 36 winning triples produce exactly 7 distinct eigenvalue angles: 0°, 30°, 35.264° (tetrahedral), 45°, 60°, 65.905°, 90°. Three of these (30°, 35.264°, 65.905°) are non-canonical — they arise from vector addition breaking the 24-cell group structure.</li>
<li><strong>Mutual information never zero</strong>: MI(angle; cell) ranges 0.14–1.0 bits, mean 0.7218 bits. 20/36 triples achieve MI = 1.0 (angle perfectly determines cell). No triple has independent channels.</li>
<li><strong>Capacity (Part F)</strong>: Cell entropy = 1.000 bit, angle entropy = 2.004 bits, joint = 2.282 bits. Gain over cell-only: +1.282 bits (2.3×). Efficiency 76% of the 3.004-bit additive bound (24% lost to inter-channel MI).</li>
<li><strong>Eight triple families (Part E)</strong>: 36 winning triples partition into exactly 8 groups based on their angle function, containing 3–8 triples each. The cell function is identical across all groups; the angle function distinguishes them.</li>
<li><strong>√n magnitude quantization (Part G)</strong>: The additive sum magnitude |S| takes exactly 6 values: √0, √1, √2, √3, √4, √6. The value √5 is absent, reflecting the inner product structure of the 24-cell (pairwise inner products drawn from {-1, -½, 0, ½, 1}). H(|S|) = 1.839 bits. Magnitude does NOT reliably predict parity (only 16/36 triples at 44%).</li>
<li><strong>Multiplicative channel blind to XOR6 (Part H)</strong>: The quaternion product M = Π w_i produces only 4 eigenvalue angles (the canonical set: 0°, 45°, 60°, 90°), uses all 13 Voronoi cells, has 4.241 bits total entropy — but 0/36 triples compute XOR6 from either channel. Multiplication preserves the 24-cell group structure; DKC requires breaking it.</li>
<li><strong>Reconciliation with <a href="./entries/demo_74.html">Demo 74</a></strong>: <a href="./entries/demo_74.html">Demo 74</a> showed bracket and cell are incomparable at the individual-quaternion level; <a href="./entries/demo_75.html">Demo 75</a> shows angle subsumes cell at the sum-quaternion level. These concern different mathematical objects (individual vs. summed quaternions).</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Angle Subsumption (DEMONSTRATED)</strong>: For all 36 XOR6 winning triples, the eigenvalue angle of the sum quaternion perfectly predicts parity. The Voronoi cell assignment carries no information beyond what the angle already encodes at the computation level.</li>
<li><strong>DKC Requires Group-Breaking (OBSERVED)</strong>: The 3 non-canonical angles (30°, 35.264°, 65.905°) arise only through quaternion addition, which breaks the 24-cell group closure. The multiplicative channel, which stays inside the group (only 4 canonical angles), has zero XOR6 solutions. Conjecture: computation requires the non-canonical angles that addition creates.</li>
<li><strong>√n Quantization (PROVEN)</strong>: |S|² = Σ w_i · w_j where inner products are from {-1, -½, 0, ½, 1}, so integer sums can only reach {0, 1, 2, 3, 4, 6} — the perfect squares and non-square integers achievable from these half-integer building blocks. √5 is unreachable.</li>
</ul>
<h3>Data</h3>
<ul>
<li>Distinct eigenvalue angles: 7 (3 non-canonical: 30°, 35.264°, 65.905°)</li>
<li>Angle entropy: 2.004 bits; cell entropy: 1.000 bit; joint: 2.282 bits</li>
<li>Mean MI(angle; cell): 0.7218 bits; range: 0.14–1.0 bits; 20/36 triples achieve MI = 1.0</li>
<li>Capacity gain over cell-only: +1.282 bits (2.3× improvement)</li>
<li>|S| values: {0, 1, √2, √3, 2, √6}; |S| entropy: 1.839 bits</li>
<li>Magnitude predicts parity: 16/36 triples (44%)</li>
<li>Multiplicative channel: 4 eigenvalue angles, 13 Voronoi cells, 4.241 bits total entropy, 0/36 XOR6 solutions</li>
<li>Triple families: 8 groups of 3–8 triples; group 0 is largest (8 triples)</li>
<li>MI(additive cell; multiplicative cell): 0.5174 bits (moderate correlation)</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>Quaternion arithmetic suite</strong>: add, multiply, conjugate, normalize, eigenvalue-angle extraction; reused across demos 75–77</li>
<li><strong><code>eigenvalue_angle()</code></strong>: computes the rotation half-angle arccos(q.a) for a unit quaternion</li>
<li><strong><code>mutual_information()</code></strong>: entropy-based MI computation for two discrete channels over 64 mask inputs</li>
<li><strong><code>classify_magnitude()</code></strong>: bins |S| values into the 6 algebraic classes with tolerance; identifies √n pattern</li>
<li><strong><code>triple_angle_function()</code></strong>: maps each of 64 input masks to an angle class for a given winning triple</li>
<li><strong><code>product_channel_analysis()</code></strong>: computes quaternion product and extracts eigenvalue + eigenvector for the multiplicative channel</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>Aizenberg (2008)</strong>: MVN sector activation on S¹; <a href="./entries/demo_75.html">Demo 75</a> shows the additive angle channel is the S¹ component of a product space, and angle subsumes the S² Voronoi cell</li>
<li><strong><a href="./entries/demo_74.html">Demo 74</a> / this series</strong>: Bracket-vs-cell incomparability at catalog level vs. angle-subsumes-cell at sum level — two layers of the same structure</li>
<li><strong>Nazer &amp; Gastpar (2011)</strong>: Compute-and-forward; additive combination of algebraic integers for computation is the structural parallel</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Can the 8-family partition of winning triples be explained algebraically from the 24-cell geometry, or is it an empirical coincidence of DKC at ζ_8?</li>
<li>Does the 2.3× capacity gain over cell-only hold for other roots of unity, or is it specific to ζ_8?</li>
<li>Is there a combinatorial argument for why √5 is unreachable given the 24-cell inner product structure?</li>
<li>Can the binocular channel be decoded jointly (not independently) to recover more than 2.282 bits — or does the 24% MI loss set a hard ceiling?</li>
<li>What is the angle channel equivalent for 8-input DKC (sum of 4 quaternions)?</li>
</ul>
<h2><a href="./entries/demo_76.html">Demo 76</a>: Scaling DKC to 8 Inputs</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_76_scaling_8input/main.c.html">demo_76_scaling_8input/main.c</a></code> (~959 lines)</li>
<li><strong>Tests</strong>: 10/10 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_50.html">Demo 50</a> (parity at k=6 sectors, all 13 NPN classes), <a href="./entries/demo_66.html">Demo 66</a> (quaternionic DKC, 24-cell catalog), <a href="./entries/demo_67.html">Demo 67</a> (13 directions, 36 XOR6 solutions), <a href="./entries/demo_69.html">Demo 69</a> (Clifford staircase, ζ_16 trivialization), <a href="./entries/demo_71.html">Demo 71</a> (spectral DKC, bandwidth l=6), <a href="./entries/demo_74.html">Demo 74</a> (computational invariant, 6 types), <a href="./entries/demo_75.html">Demo 75</a> (binocular DKC, √n magnitudes)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_77.html">Demo 77</a> (activation zoo — corrects this demo's conclusion)</li>
</ul>
<h3>Headline</h3>
XOR8 has zero solutions at ζ_8 under S² Voronoi activation: the 14-cell partition lacks the resolution to separate 256 masks, and the algebraic structure of 4-term sums breaks down from 7 discrete angles to 86 near-continuous angles.
<h3>Key Results</h3>
<ul>
<li><strong>Total failure (Part A)</strong>: 0 of 10,626 possible weight quadruples (C(24,4)) compute XOR8 with S² Voronoi activation. Best achievable accuracy: 50.0% (random chance). Hit rate: 0.00% vs. 1.78% for 6-input.</li>
<li><strong>Capacity argument (Part C)</strong>: At 6 inputs, 64 masks / 14 cells ≈ 4.6 masks per cell — sparse enough for parity-pure cells. At 8 inputs, 256 masks / 14 cells ≈ 18.3 masks per cell — parity-pure cells are geometrically impossible by pigeonhole.</li>
<li><strong>Conflict distribution (Part B)</strong>: Minimum conflict cells for any quadruple is 2 (achieved by 11 quadruples, 0.1%). Most quadruples (93%) have 5 or more conflict cells. Even the best 2-conflict quadruple achieves only 50.0% accuracy — the conflicting cells each contain balanced even/odd masks.</li>
<li><strong>Direction concentration (Part C)</strong>: Best quadruple [0,1,2,3] sends 81.3% of 256 masks to a single cell. 4-term sums cluster more tightly than 3-term sums, reducing directional diversity vs. 6-input winners which spread across 8–10 cells.</li>
<li><strong>Algebraic structure breakdown (Parts D-E)</strong>: 3-term sums give 7 discrete eigenvalue angles (algebraic, clean). 4-term sums give 86 eigenvalue angles (near-continuous, values like 7.861°, 9.736°). The √n magnitude quantization also collapses: 6 values for 3-term sums vs. 28 values for 4-term sums including non-algebraic values like 0.4142, 0.7654.</li>
<li><strong>Scaling path (Part E)</strong>: From <a href="./entries/demo_69.html">Demo 69</a>, ζ_16 has 3,457 directions. At ζ_16, 256 masks / 3,458 cells ≈ 0.07 masks per cell — trivially easy. The open question is whether a root of unity with ~56 directions provides the non-trivial sweet spot for 8-input DKC.</li>
<li><strong>Bandwidth constraint</strong>: <a href="./entries/demo_71.html">Demo 71</a> showed XOR6 requires spherical harmonic bandwidth l=6 with 2l+1=13 directions. XOR8 would need higher bandwidth and more directions. The required bandwidth constrains which roots of unity can support which input sizes.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>ζ_8 S²-capacity limit (DEMONSTRATED)</strong>: The 14-cell Voronoi partition of S² at ζ_8 is a hard geometric ceiling for 6-input computation. Exhaustive search over all C(24,4)=10,626 quadruples confirms 0 solutions.</li>
<li><strong>Algebraic discreteness requires 3-term sums (OBSERVED)</strong>: The 7-angle quantization is specific to 3-term sums from the 24-cell. At 4-term sums the algebraic constraints weaken and angles explore most of the rotation space (86 values). CONJECTURED: k-term sums produce O(k²) distinct angles, with discrete structure only at k=3 for this lattice.</li>
<li><strong>Sweet-spot formula (CONJECTURED)</strong>: The non-trivial DKC sweet spot occurs when masks/cells ≈ 4.6. For n inputs (2^n masks) this requires cells ≈ 2^n / 4.6. For n=8: cells ≈ 56. Is there a root of unity with ~56 eigenvector directions?</li>
<li><strong>NOTE — CORRECTED BY DEMO 77</strong>: The conclusion that "ζ_8 is a 6-input structure" is activation-specific. With S¹ × S² product activation (112 cells), XOR8 IS solvable at ζ_8. <a href="./entries/demo_76.html">Demo 76</a>'s failure is a failure of S²-only activation, not of the root of unity.</li>
</ul>
<h3>Data</h3>
<ul>
<li>XOR8 solutions (S² Voronoi): 0 / 10,626 quadruples</li>
<li>XOR6 solutions (S² Voronoi, baseline): 36 / 2,024 triples (1.78%)</li>
<li>Minimum conflict cells achieved: 2 (11 quadruples, 0.1% of total)</li>
<li>Best quadruple accuracy: 50.0% (128/256 masks correct)</li>
<li>Best quadruple [0,1,2,3]: 81.3% of masks in single cell (cell 0), 18.8% in identity cell (13)</li>
<li>3-term sum eigenvalue angles: 7 (discrete, algebraic)</li>
<li>4-term sum eigenvalue angles: 86 (near-continuous)</li>
<li>3-term sum |S| values: 6 (√{0,1,2,3,4,6})</li>
<li>4-term sum |S| values: 28 (including non-algebraic like 0.4142, 0.7654)</li>
<li>ζ_16 direction count: 3,457 (from <a href="./entries/demo_69.html">Demo 69</a>); masks/cell at ζ_16 for XOR8: ~0.07</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>Exhaustive quadruple search</strong>: C(24,4)=10,626 quadruple enumeration with conflict-cell counting; reusable for n-input DKC search at any k</li>
<li><strong><code>conflict_count()</code></strong>: counts Voronoi cells containing both even and odd parity masks for a given weight set</li>
<li><strong><code>best_accuracy()</code></strong>: majority-vote accuracy per cell for non-zero-conflict quadruples</li>
<li><strong>Direction concentration metric</strong>: counts cells used and fraction of masks per dominant cell; characterizes collapse vs. spread of sum-quaternion directions</li>
<li><strong>Eigenvalue angle histogram</strong>: bins sum-quaternion angles to discover algebraic structure (or lack thereof) at different input counts</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong><a href="./entries/demo_69.html">Demo 69</a> (Clifford Staircase)</strong>: ζ_8 ⊂ ζ_16 nesting and trivialization rates; the scaling path requires higher roots</li>
<li><strong><a href="./entries/demo_71.html">Demo 71</a> (Spectral DKC)</strong>: Bandwidth l=6 requires 2l+1=13 directions; XOR8 bandwidth would require more directions and constrains feasible roots</li>
<li><strong>Pigeonhole / information-theoretic capacity</strong>: The 256/14 masks-per-cell argument is an elementary counting bound that establishes the hard geometric limit</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Is there a root of unity with approximately 56 eigenvector directions that would provide the sweet spot for 8-input DKC at S²?</li>
<li>Does the masks-per-cell ≈ 4.6 sweet spot hold across different input sizes and roots of unity, or is it a coincidence of ζ_8 at 6 inputs?</li>
<li>Can the algebraic structure breakdown (7 → 86 angles) be explained as a function of the number of summands relative to the lattice symmetry group?</li>
<li>What is the minimum root of unity that supports XOR8 without trivializing (as ζ_16 trivializes XOR6)?</li>
<li>(Now answered by <a href="./entries/demo_77.html">Demo 77</a>): The S² wall was activation-specific. Does the same correction apply to XOR10, XOR12 — are those also solvable at ζ_8 with sufficiently fine product activation?</li>
</ul>
<h2><a href="./entries/demo_77.html">Demo 77</a>: Activation Zoo for 8-Input DKC</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_77_activation_zoo/main.c.html">demo_77_activation_zoo/main.c</a></code> (~1012 lines)</li>
<li><strong>Tests</strong>: 14/14 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_50.html">Demo 50</a> (parity at k=6, all 13 NPN classes), <a href="./entries/demo_66.html">Demo 66</a> (quaternionic DKC, 24-cell), <a href="./entries/demo_67.html">Demo 67</a> (13 directions, 36 XOR6 solutions), <a href="./entries/demo_74.html">Demo 74</a> (computational invariant, bracket vs cell incomparability), <a href="./entries/demo_75.html">Demo 75</a> (binocular DKC, angle subsumes cell for sums), <a href="./entries/demo_76.html">Demo 76</a> (XOR8 = 0 solutions under S² Voronoi)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_78.html">Demo 78</a> (recursive scaling), <a href="./entries/demo_79.html">Demo 79</a> (ζ_12 capacity)</li>
</ul>
<h3>Headline</h3>
XOR8 IS computable at ζ_8 with the combined Sec(8) × Voronoi activation (112 cells, 6 winning quadruples): the wall in <a href="./entries/demo_76.html">Demo 76</a> was the activation function, not the root of unity — the same discovery pattern as <a href="./entries/demo_50.html">Demo 50</a> where parity was blocked by split-sigmoid, not the lattice.
<h3>Key Results</h3>
<ul>
<li><strong>XOR8 solved (Part D/F)</strong>: Sec(8) × Voronoi activation (S¹ × S²) yields 6 winning quadruples out of 10,626. All 6 achieve 100% accuracy on all 256 input masks.</li>
<li><strong>Phase transition (Parts D/E)</strong>: Accuracy climbs monotonically: S² Voronoi (50%) → Sec(8) at 85.2% → Polar 14×6 at 99.2% → Sec(8)×Vor at 100%. The phase transition from 0 to 6 winners occurs between 84 cells (k=6, 0 winners, 96.9%) and 112 cells (k=8, 6 winners, 100%). Critical threshold approximately 100 cells.</li>
<li><strong>Neither channel alone suffices</strong>: Sector activation alone (S¹, even at k=16 with 16 cells): 0 winners, max 96.9%. S² Voronoi alone (14 cells): 0 winners, 50.0%. Both channels are required — this is computationally necessary given <a href="./entries/demo_74.html">Demo 74</a>'s incomparability result.</li>
<li><strong>Paired quaternion structure (Part F)</strong>: Every winning quadruple contains exactly one pair of quaternions sharing the same eigenvector direction but differing in eigenvalue angle. Removing either element of the pair leaves an XOR6-winning triple. All 6 winners contribute exactly 2 XOR6 subsets each; 12 of the 24 embedded triples (50%) are XOR6 winners.</li>
<li><strong>Eigenvalue angles in winners</strong>: The 6 winning quadruples use only 2 distinct eigenvalue half-angles: 45° and 90° (the two canonical octahedral angles). The non-canonical angles (30°, 35.264°, 65.905°) that appear in additive sums are NOT present in the individual catalog entries forming winning quadruples.</li>
<li><strong>Geometry of winners</strong>: 15 of 24 catalog quaternions participate across the 6 winners. Three dominant Voronoi cells (0, 1, 10) each appear in 6 of 24 winner slots — axis-aligned and edge-diagonal directions form the structural skeleton.</li>
<li><strong>Polar activation near-miss (Part B)</strong>: Polar 14×6 (S² direction × magnitude bins, 84 cells) reaches 99.2% — one misclassified pair from perfection. The magnitude channel ("odometer" from <a href="./entries/demo_75.html">Demo 75</a>) adds genuine power over direction alone (50% → 99.2%) but the missing information is in the angle channel, not magnitude.</li>
<li><strong>S³ Voronoi worse than expected (Part C)</strong>: 24-cell Voronoi on S³ (24 cells) achieves only 90.2% — worse than Sec(16) at 96.9% despite more cells. The S³ partition mixes angle and direction information non-optimally; the factored S¹ × S² decomposition is superior to the unfactored S³ approach.</li>
<li><strong>Corrects <a href="./entries/demo_76.html">Demo 76</a></strong>: <a href="./entries/demo_76.html">Demo 76</a>'s conclusion "ζ_8 is a 6-input structure" is activation-specific. ζ_8 with S¹ × S² activation supports at least 8 inputs.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Activation Determines Capacity (DEMONSTRATED)</strong>: The root of unity alone does not fix computational capacity. The activation function (how you read the quaternion) determines what functions the computation can express. Same ζ_8, same 24-cell — 0 XOR8 solutions with S² activation, 6 solutions with S¹ × S² activation.</li>
<li><strong>Incomparability Implies Product Necessity (DEMONSTRATED)</strong>: <a href="./entries/demo_74.html">Demo 74</a> proved bracket (eigenvalue) and cell (eigenvector) are incomparable invariants. <a href="./entries/demo_77.html">Demo 77</a> confirms this incomparability is computationally necessary: neither channel alone can compute XOR8, but their product can. The incomparability is not just structural — it reflects independent computational information.</li>
<li><strong>Paired Quaternion Structure (OBSERVED)</strong>: Every XOR8 winner is an XOR6 winner plus a "paired partner" sharing the same eigenvector direction but different eigenvalue angle. CONJECTURED: XOR(n) winners at ζ_8 are built by extending XOR(n-2) winners with paired quaternion partners, giving a recursive structure connecting input sizes.</li>
<li><strong>Critical Cell Count ~100 (OBSERVED)</strong>: The phase transition from 0 to non-zero winners occurs between 84 and 112 cells. CONJECTURED: the critical threshold is related to the masks-per-cell dropping below 256/100 ≈ 2.56, with the exact threshold depending on the parity structure of the partition.</li>
<li><strong>S¹ × S² Activation as Quaternionic MVN (ESTABLISHED)</strong>: The combined activation is the quaternionic generalization of Aizenberg's MVN: instead of reading the argument of a complex number (S¹ only), read both eigenvalue angle (S¹) and eigenvector direction (S²) of the quaternion (S¹ × S²). <a href="./entries/demo_77.html">Demo 77</a> provides the first proof that this generalization unlocks computation not achievable by S¹ or S² alone.</li>
</ul>
<h3>Data</h3>
<ul>
<li>XOR8 winners (Sec8 × Voronoi, 112 cells): 6 / 10,626 quadruples</li>
<li>XOR8 winners (S² Voronoi, 14 cells): 0 / 10,626</li>
<li>Phase transition: 0 winners at 84 cells (Sec6×Vor), 6 winners at 112 cells (Sec8×Vor)</li>
<li>Accuracy by activation: S²Vor(50%) → Sec4(77.7%) → Sec8(85.2%) → S³Vor(90.2%) → Sec10(92.6%) → Sec12(90.6%) → Polar14×3(93.0%) → Sec4×Vor(93.8%) → Polar14×2(93.8%) → Sec16(96.9%) → Sec6×Vor(96.9%) → Polar14×6(99.2%) → Sec8×Vor(100%)</li>
<li>Winning quadruples: [0,1,9,23], [0,1,18,22], [2,4,5,23], [2,9,19,21], [4,5,15,16], [17,19,20,21]</li>
<li>Each winner: exactly 2 XOR6-winning triple subsets; 12 of 24 embedded triples are XOR6 winners</li>
<li>Eigenvalue angles in winners: only 45° and 90° (canonical octahedral)</li>
<li>Quaternions participating: 15 of 24</li>
<li>Dominant Voronoi cells: 0 (axis x), 1 (axis z), 10 (edge diagonal) — 6 appearances each</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>14-activation comparison harness</strong>: exhaustive search over all 10,626 quadruples under each of 14 activation functions; single loop structure with pluggable activation callback</li>
<li><strong><code>sector_activate()</code></strong>: bins quaternion eigenvalue angle into k equal sectors on [0°, 360°); implements Aizenberg MVN in the quaternion context</li>
<li><strong><code>polar_activate()</code></strong>: joint direction (Voronoi cell) × magnitude bin activation; configurable bin count for magnitude axis</li>
<li><strong><code>s3_voronoi_activate()</code></strong>: nearest-quaternion in the 24-cell catalog on S³ (no antipodal identification)</li>
<li><strong><code>product_activate()</code></strong>: S¹ × S² combined activation; cell index = sector_index * 14 + voronoi_cell; the key new activation function</li>
<li><strong><code>xor6_subsets()</code></strong>: for a winning quadruple, enumerates all C(4,3)=4 triples and identifies which are XOR6 winners; establishes the paired structure</li>
<li><strong><code>majority_vote_accuracy()</code></strong>: given an activation and a weight set, computes XOR8 accuracy by majority vote per activation cell</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>Aizenberg (2008, 2011)</strong>: MVN sector activation on S¹; <a href="./entries/demo_77.html">Demo 77</a> demonstrates that the S¹ component alone (even at k=16) cannot compute XOR8, while the quaternionic S¹ × S² product can. The S¹ → S¹ × S² generalization from C to H is the central contribution.</li>
<li><strong><a href="./entries/demo_50.html">Demo 50</a></strong>: The parity wall at split-sigmoid, broken at k=6 sectors. <a href="./entries/demo_77.html">Demo 77</a> is the same story one level up: XOR8 wall at S²-only activation, broken at S¹ × S² combined activation.</li>
<li><strong><a href="./entries/demo_74.html">Demo 74</a> (Computational Invariant)</strong>: Incomparability of bracket vs. cell invariants at catalog level; <a href="./entries/demo_77.html">Demo 77</a> proves this incomparability is computationally load-bearing.</li>
<li><strong>Nazer &amp; Gastpar (2011)</strong>: Compute-and-forward; the product activation reads both "channels" of the algebraic integer ring, analogous to reading both amplitude and phase in lattice coding.</li>
<li><strong>Abramsky / TL categorical quantum mechanics</strong>: The non-semisimplicity of the Temperley-Lieb algebra at roots of unity is where the extra computational power lives; the product activation exposes both the S¹ (eigenvalue) and S² (eigenvector) faces of this structure.</li>
<li><strong>Habiro (2002) / cyclotomic invariants</strong>: Z[ζ_8] is richer than any single projection reveals; <a href="./entries/demo_77.html">Demo 77</a> demonstrates empirically that the algebraic structure of ζ_8 supports at least 8-input computation.</li>
<li><strong>literature-survey.md</strong>: comprehensive novelty analysis in the demo folder; DKC fills a gap between knot theory, algebraic number theory, spherical geometry, lattice codes, and complex-valued neural networks that no existing paper occupies.</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Does the paired quaternion structure (XOR8 winner = XOR6 triple + paired partner) hold recursively? Can XOR10 winners be built from XOR8 winners by adding another paired quaternion?</li>
<li>Is there a combinatorial formula for the number of XOR(n) winners as a function of input size n at ζ_8 with Sec(n) × Voronoi activation?</li>
<li>Why do the winning quadruples use only the two canonical octahedral angles (45°, 90°) while additive sums introduce non-canonical angles? Is there a group-theoretic explanation?</li>
<li>What is the minimum k in Sec(k) × Voronoi for XOR10? Does the cell-count threshold scale as ~2^n / 2.3 for XOR(n)?</li>
<li>Does the S¹ × S² activation connect to the Hopf fibration S³ → S²? The eigenvalue (S¹) and eigenvector (S²) decomposition of a unit quaternion is structurally a Hopf fibration; is the computational power of the product activation related to the fiber bundle structure?</li>
<li>Can the 99.2% accuracy of Polar 14×6 be pushed to 100% with a different magnitude binning — or is there a fundamental obstruction at 84 cells?</li>
</ul>
<h2><a href="./entries/demo_78.html">Demo 78</a>: Recursive Scaling + Phase Diagram</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_78_recursive_scaling/main.c.html">demo_78_recursive_scaling/main.c</a></code> (~1052 lines)</li>
<li><strong>Tests</strong>: 9/9 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_66.html">Demo 66</a> (24-quaternion catalog, 24-cell geometry), <a href="./entries/demo_67.html">Demo 67</a> (13 directions, 36 XOR6 solutions), <a href="./entries/demo_77.html">Demo 77</a> (XOR8 = 6 solutions via Sec8×Vor activation, shadow structure)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_79.html">Demo 79</a> (zeta_12 capacity, breaking the wall), <a href="./entries/demo_80.html">Demo 80</a> (group finiteness survey)</li>
</ul>
<h3>Headline</h3>
XOR10 = 0 winners at ζ₈, confirmed by both recursive search (120 candidates) and exhaustive brute-force (all 42,504 quintuples); the ζ₈ XOR hierarchy terminates at 8 inputs, with non-monotonic accuracy in sector count echoing <a href="./entries/demo_50.html">Demo 50</a>'s pi/4 incommensurability.
<h3>Key Results</h3>
<ul>
<li><strong>XOR10 = 0 (exhaustive)</strong>: All C(24,5) = 42,504 quintuples tested at k=8, 10, 12, 16. Zero winners at any sector count. Best accuracy 98.4% (1008/1024 masks) at k=10 and k=16.</li>
<li><strong>Non-monotonicity</strong>: k=12 accuracy (96.9%) is worse than k=10 (98.4%). The pi/4 lattice incommensurability creates destructive interference at certain k values, mirroring <a href="./entries/demo_50.html">Demo 50</a>'s finding (906 solutions at k=6 &gt; 756 at k=7 &gt; 96 at k=8).</li>
<li><strong>XOR12 skipped</strong>: No XOR10 parents to extend, so recursive XOR12 search was vacuously skipped.</li>
<li><strong>Recursive structure confirmed (Part E)</strong>: All 6 XOR8 winners contain exactly 2 XOR6 sub-triples (100% verified). Each shadow entry shares its Voronoi cell with at least one parent member (12/12 = 100%). All shadows have eigenvalue half-angle = 45 degrees. Shadow pairs are {0,1}, {4,5}, {19,21} — each pair shares direction and half-angle, differs only in sign/orientation.</li>
<li><strong>Phase diagram</strong>: XOR6 (14 cells, 36 winners, Voronoi) → XOR8 (112 cells, 6 winners, Sec8×Vor) → XOR10 (WALL, 0 winners). Capacity/masks ratios: XOR6 = 4.6, XOR8 = 2.3.</li>
<li><strong>Catalog exhaustion diagnosis</strong>: The ζ₈ catalog has only 13 distinct eigenvector directions and 2 half-angles (45°, 90°). Selecting 5 entries from 24 exhausts structural diversity — too many entries share properties for 1024-mask separation.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>ζ₈ Wall Theorem (CONFIRMED)</strong>: The binary octahedral group (24 elements) generates a fixed catalog whose combinatorial diversity is exhausted at 5-element selection. XOR8 is the maximum computable XOR function at ζ₈.</li>
<li><strong>Recursive Shadow Conjecture (CONFIRMED for XOR6→XOR8)</strong>: Every XOR(N+2) winner = XOR(N) winner + one "shadow" quaternion that shares the same eigenvector direction but provides additional eigenvalue resolution. All 6 XOR8 winners decompose this way.</li>
<li><strong>Non-Monotonicity Conjecture (SUPPORTED)</strong>: The pi/4 incommensurability of the ζ₈ lattice creates sector boundaries that produce destructive interference at specific k values, causing accuracy to decrease as k increases in some ranges.</li>
</ul>
<h3>Data</h3>
<ul>
<li>XOR6: 36 winners, 14 cells minimum, Voronoi-only activation, 1.779% hit rate</li>
<li>XOR8: 6 winners, 112 cells minimum (k=8), Sec8×Vor activation, 0.057% hit rate</li>
<li>XOR10: 0 winners, 42,504 quintuples exhaustively tested</li>
<li>Best XOR10 accuracy: 98.4% = 1008/1024 masks at k=10 and k=16</li>
<li>Non-monotonic dip: k=12 achieves only 96.9% (worse than k=10)</li>
<li>Shadow cell-sharing: 12/12 (100%) of XOR8 shadows share Voronoi cell with a parent</li>
<li>All 6 XOR8 shadows have half-angle exactly 45 degrees</li>
<li>Catalog: 24 quaternions, 13 directions, 2 half-angles (45°, 90°)</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong><code>test_combined(indices, n_idx, k_sec, acc_out)</code></strong>: Generic XOR tester using Combined Sec(k)×Vor activation; pre-computes all 2^N sums once and tests multiple k values; handles up to 4096 masks and 512 cells</li>
<li><strong>Brute-force XOR10 harness (Part B)</strong>: Computes all 1024 sums once per quintuple, caches angle and Voronoi cell, then sweeps k values cheaply — avoids redundant sum computation across multiple k tests</li>
<li><strong><code>part_e_recursive()</code></strong>: Verifies parent-shadow structure for any XOR(N) → XOR(N-2) decomposition; reports cell sharing, half-angle, and paired quaternion structure for each shadow</li>
<li><strong>Sorted tuple insertion</strong>: Pattern for maintaining sorted index arrays when extending N-tuples to (N+1)-tuples without full re-sort (find insertion position, shift)</li>
<li><strong>Deduplication with lookup</strong>: is_win6/is_win8/is_win10 linear-scan lookups prevent redundant testing when multiple parent winners produce the same extended tuple</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>Aizenberg (2008)</strong>: Combined Sec(k)×Voronoi activation generalizes the k-sector MVN; the wall at XOR10 sets a concrete capacity limit for the ζ₈ instantiation</li>
<li><strong>Nazer &amp; Gastpar (2011)</strong>: The information-theoretic framing of catalog exhaustion — fixed algebraic structure provides fixed diversity, determining the compute-and-forward capacity ceiling</li>
<li><strong><a href="./entries/demo_50.html">Demo 50</a> connection</strong>: Non-monotonicity in sector count previously observed (906@k=6 &gt; 756@k=7 &gt; 96@k=8 for XOR4 parity); the pi/4 incommensurability pattern is confirmed as a recurring structural feature</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li><strong>16 misclassified masks at XOR10</strong>: The 98.4% best accuracy leaves 16 masks wrong. Do these form a structured pattern (same Hamming weight? same bit-pattern class?)</li>
<li><strong>Information-theoretic lower bound</strong>: Is there a clean formula relating max computable N to catalog size |C|, direction count, and angle count?</li>
<li><strong>What does ζ_16 buy?</strong>: Higher roots produce larger catalogs with more directions and angles. Is there a scaling law max_N = f(|catalog|, n_directions, n_angles)?</li>
<li><strong>Is the wall at 8 specific to the octahedral group?</strong>: Other finite groups (binary tetrahedral at ζ₄, binary icosahedral in principle) should have their own walls at different N values.</li>
</ul>
<h2><a href="./entries/demo_79.html">Demo 79</a>: zeta_12 Capacity Test</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_79_zeta12_capacity/main.c.html">demo_79_zeta12_capacity/main.c</a></code> (~877 lines)</li>
<li><strong>Tests</strong>: 14/14 pass (Parts A-E + XOR12 retest)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_78.html">Demo 78</a> (ζ₈ wall at XOR10 confirmed, recursive shadow structure), <a href="./entries/demo_66.html">Demo 66</a> (quaternion catalog construction from braid words), <a href="./entries/demo_67.html">Demo 67</a> (Voronoi partition approach)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_80.html">Demo 80</a> (group finiteness survey — the finite/infinite distinction identified here drives that investigation)</li>
</ul>
<h3>Headline</h3>
ζ₁₂ breaks the ζ₈ XOR wall entirely: XOR10 goes from 0 winners (ζ₈) to 124 winners (ζ₁₂), XOR12 yields 50+ winners with expanded catalog, and the fundamental cause is that ζ₈ generates a finite group (24 elements, binary octahedral) while ζ₁₂ generates an infinite (or very large) group still growing past 4096 entries.
<h3>Key Results</h3>
<ul>
<li><strong>XOR10 breakthrough</strong>: 124 winners at ζ₁₂ (256-entry catalog, k=8, 520 cells). ζ₈ had 0. The wall was not a wall for ζ₁₂.</li>
<li><strong>XOR12 solvable</strong>: 50+ winners found from just the first 11 of 124 XOR10 parents using the 4096-entry expanded catalog (k=8, 4104 cells). The initial XOR12=0 result was a truncation artifact (256-entry cap).</li>
<li><strong>XOR6 and XOR8 both massive</strong>: 1024+ winners each (capped at MAX_WIN), vs 36 and 6 for ζ₈. The ζ₁₂ catalog is dramatically richer.</li>
<li><strong>Non-nesting confirmed</strong>: Only 3/24 ζ₈ quaternions appear in ζ₁₂ catalog (12%). Only 2/13 ζ₈ directions appear in ζ₁₂ directions (15%). These are independent views of the quaternion sphere, not a subset relationship.</li>
<li><strong>Finite vs infinite is the key variable</strong>: ζ₈ closes at round 4 with 24 elements. ζ₁₂ roughly doubles each closure round, reaching 4096+ by round 8. Growth pattern: 5 → 17 → 51 → 127 → 275 → 564 → 1140 → 2292 → 4096+.</li>
<li><strong>Catalog properties at ζ₁₂ (256-entry cap)</strong>: 64 directions, 12 distinct half-angles (vs ζ₈'s 13 directions, 2 half-angles). Half-angle spectrum spans 0°–90° in 12 distinct values.</li>
<li><strong>N-2 pattern disproven</strong>: The initial hypothesis that ζ_N → XOR(N-2) capacity was wrong. ζ₁₂ can do at least XOR12, and potentially beyond as the catalog grows.</li>
<li><strong>XOR12 sixth quaternion always from expanded catalog</strong>: Every XOR12 winner requires at least one catalog entry with index &gt; 256, confirming that the larger group is genuinely necessary, not just convenient.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Finite Group Ceiling Theorem (DEMONSTRATED)</strong>: A finite quaternion group imposes a hard capacity ceiling: once the catalog is fixed, combinatorial diversity is exhausted at some XOR(N). An infinite group has no such ceiling — capacity is limited only by computational search resources.</li>
<li><strong>Nesting Failure (CONFIRMED)</strong>: ζ₈ and ζ₁₂ generate largely disjoint finite subgroups of SU(2). Different angles (π/4 vs π/6) produce different algebraic structures; the capacity gain from ζ₁₂ is from genuinely new structure, not "more of the same."</li>
<li><strong>Union Catalog Conjecture (OPEN)</strong>: Since ζ₈ and ζ₁₂ are largely non-overlapping, a union catalog (ζ₈ + ζ₁₂) might push XOR capacity beyond what either achieves alone.</li>
<li><strong>ζ_N → N Conjecture (INVALIDATED for finite, PLAUSIBLE for infinite)</strong>: The "ζ_N → XOR N" capacity law was originally proposed but refuted: ζ₁₂ goes well past XOR12. The real determining factor is group finiteness, not the subscript N.</li>
</ul>
<h3>Data</h3>
<ul>
<li>ζ₁₂ catalog (256-entry cap): 256 quaternions, 64 directions, 12 half-angles, 65 Voronoi cells</li>
<li>ζ₁₂ catalog (4096-entry expanded): 4096+ quaternions, 512 directions, 43 half-angles</li>
<li>XOR6 (ζ₁₂): 1024+ winners (capped), k=1 (Voronoi only), 65 cells</li>
<li>XOR8 (ζ₁₂): 1024+ winners (capped), k=6, 390 cells</li>
<li>XOR10 (ζ₁₂): 124 winners, k=8, 520 cells</li>
<li>XOR12 (ζ₁₂ truncated, 256 entries): 0 winners (artifact)</li>
<li>XOR12 (ζ₁₂ expanded, 4096 entries): 50+ winners, k=8, 4104 cells</li>
<li>ζ₁₂ group closure: rounds 0–8 sizes: 5, 17, 51, 127, 275, 564, 1140, 2292, 4096+ (roughly doubling)</li>
<li>ζ₈ group closure: closes at round 4 with 24 elements</li>
<li>Quaternion overlap: 3/24 (12%); direction overlap: 2/13 (15%)</li>
<li>Ratio comparisons (ζ₁₂ vs ζ₈ at 256-cap): quaternions 10.7×, directions 4.9×, half-angles 6×, Voronoi cells 4.6×</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>Parameterized <code>init_su2_generators(half_angle)</code></strong>: takes the rotation half-angle as a parameter, enabling catalog construction for any ζ_N without code changes</li>
<li><strong>Generic <code>g_win[8][MAX_WIN][MAX_TUPLE]</code> winner storage</strong>: stores XOR6 through XOR14 winners (levels 3–7) in a single unified structure indexed by level</li>
<li><strong><code>find_recursive(level)</code></strong>: generic recursive extension from level-1 winners to level winners; replaces the per-XOR-level functions in <a href="./entries/demo_78.html">Demo 78</a> with a single reusable routine parameterized by level</li>
<li><strong><code>find_quat_in(q, arr, arr_size)</code></strong>: searches for a quaternion in an arbitrary array (not just the global catalog); used in Part E nesting verification</li>
<li><strong>Save/restore catalog pattern</strong>: Part E saves the ζ₁₂ catalog, rebuilds ζ₈, does the comparison, without needing separate static arrays for each root</li>
<li><strong>Dynamic n_vor</strong>: cell count <code>n_vor = g_nd + 1</code> computed from catalog rather than hardcoded to 14; handles catalogs with different direction counts transparently</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>ADE classification of finite SU(2) subgroups</strong>: ζ₈ maps to binary octahedral (E₇, order 48). The finiteness observation connects to the complete ADE classification surveyed in <a href="./entries/demo_80.html">Demo 80</a>.</li>
<li><strong>Kuperberg #P-hardness</strong>: his result applies at non-lattice roots of unity; our finite groups (ζ₄, ζ₈) are lattice roots where computation is tractable. The infinite-group roots correspond to the #P-hard regime.</li>
<li><strong>Habiro (2002) / Z[ζ₈] bracket</strong>: the 24-element ζ₈ group is the algebraic substrate underlying the bracket computations from <a href="./entries/demo_26.html">Demos 26</a>–<a href="./entries/demo_29.html">29</a>. The finiteness of this group explains the capacity ceiling observed in the forward DKC arc.</li>
<li><strong>Nazer &amp; Gastpar (2011)</strong>: infinite group → unbounded combinatorial space → potentially unlimited compute-and-forward capacity.</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li><strong>Is ζ₁₂ truly infinite or very large finite?</strong>: The doubling pattern suggests infinite, but this is a concrete group theory question. Does the group generated by cos(π/6) and cos(π/6) rotations around perpendicular axes close at some enormous order?</li>
<li><strong>What is ζ₁₂'s true XOR capacity?</strong>: XOR14 and beyond may also be solvable. The recursive search becomes expensive but is in principle feasible.</li>
<li><strong>Does ζ₁₀ (Fibonacci anyons territory) behave similarly?</strong>: ζ₁₀ was identified as infinite in <a href="./entries/demo_80.html">Demo 80</a>. Does it also show XOR10+ capacity? Its 71 distinct half-angles at 4096 entries (most of any surveyed root) suggests it might be particularly rich.</li>
<li><strong>Union catalog performance</strong>: A combined ζ₈ + ζ₁₂ catalog exploiting both independent algebraic structures — does it provide superadditive capacity?</li>
</ul>
<h2><a href="./entries/demo_80.html">Demo 80</a>: Group Finiteness Survey</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_80_group_finiteness/main.c.html">demo_80_group_finiteness/main.c</a></code> (~467 lines)</li>
<li><strong>Tests</strong>: 11/11 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_79.html">Demo 79</a> (finite vs infinite group hypothesis), <a href="./entries/demo_78.html">Demo 78</a> (ζ₈ wall at XOR10), <a href="./entries/demo_66.html">Demo 66</a> (binary octahedral group = 24 elements)</li>
<li><strong>Feeds into</strong>: Future demos selecting which ζ_N to use for extended XOR capacity; ADE/quantum group connections</li>
</ul>
<h3>Headline</h3>
Only ζ₄ and ζ₈ generate finite SU(2) subgroups under the standard two-generator construction; all other tested roots (ζ₆, ζ₁₀, ζ₁₂, ζ₁₆, ζ₂₀) generate infinite groups, the finite cases correspond exactly to rotations by π/2 and π/4 which are symmetries of the cube/octahedron, and at ζ₈ the quantum dimension [2]_q vanishes — the most singular point of quantum group parameter space.
<h3>Key Results</h3>
<ul>
<li><strong>Only ζ₄ and ζ₈ finite</strong>: Of 7 roots tested (N = 4, 6, 8, 10, 12, 16, 20), only ζ₄ (4 elements, binary dihedral Q₄) and ζ₈ (24 elements, binary octahedral) close under group multiplication.</li>
<li><strong>Non-monotonic boundary</strong>: ζ₆ is infinite despite sitting between the two finite cases. Finiteness is NOT a monotone function of N. The pattern is: finite(4), infinite(6), finite(8), infinite(10,12,16,20,...).</li>
<li><strong>ADE identification</strong>: ζ₄ → Binary Dihedral 2D₂ (order 8, the quaternion group Q₈ = {±1, ±i, ±j, ±k}). ζ₈ → Binary Octahedral 2O (order 48, E₇ in ADE classification).</li>
<li><strong>ζ₁₀ is NOT binary icosahedral</strong>: Despite π/5 being the golden ratio angle (Fibonacci anyons territory), ζ₁₀ generates an infinite group. The binary icosahedral group (order 120, E₈) is not reached by this generator construction.</li>
<li><strong>Infinite groups approach continuum</strong>: All infinite groups at 4096 entries show 512 directions (saturated MAX_DIR), 37–71 distinct half-angles, minimum angle gaps &lt; 1° (approaching dense subgroup of SU(2)).</li>
<li><strong>Non-monotone angle counts</strong>: ζ₁₀ has 71 half-angles at 4096 entries vs ζ₁₂'s 43 and ζ₁₆'s 51. Different infinite groups have different density structures despite similar closure behavior.</li>
<li><strong>Algebraic diagnosis</strong>: cos(π/2) = 0 (rational) and cos(π/4) = √2/2 (degree 2) generate finite groups. cos(π/3) = 1/2 (rational!) generates infinite. Algebraic degree alone does not predict finiteness.</li>
<li><strong>Geometric characterization</strong>: The finite cases are exactly the angles that are rotational symmetries of the cube/octahedron. π/2 and π/4 rotations around perpendicular axes generate the octahedral symmetry group and close. π/3 rotations are symmetries of the hexagonal lattice but two perpendicular hexagonal axes generate an infinite group.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Power-of-Two Finiteness Conjecture (PROPOSED)</strong>: The finite cases under this construction are exactly angles of the form π/2^k for k ≥ 1. This predicts θ = π/2 (k=1, ζ₄) and θ = π/4 (k=2, ζ₈), and further predicts ζ₃₂ (θ = π/16) should also be finite. Not yet tested.</li>
<li><strong>ADE Exhaustion (DEMONSTRATED for E₇)</strong>: ζ₈ → Binary Octahedral → E₇. The ζ₄ → Binary Dihedral is the D-series. E₆ (binary tetrahedral, 24 elements) and E₈ (binary icosahedral, 120 elements) are not reachable under the two-perpendicular-axes construction tested here.</li>
<li><strong>Quantum Dimension Vanishing (CONFIRMED)</strong>: At ζ₈, q = i, and [2]_q = q + q⁻¹ = i + (-i) = 0. The quantum dimension vanishes. The two finite groups correspond to the lattice (singular) points of quantum group parameter space. Non-lattice roots (all infinite groups) are where Kuperberg's #P-hardness applies.</li>
<li><strong>Dense Subgroup Conjecture (SUPPORTED)</strong>: Infinite groups under this construction generate dense subgroups of SU(2) — the directions approach uniform S² coverage as the group grows. Not proven analytically.</li>
</ul>
<h3>Data</h3>
<ul>
<li>ζ₄: 4 elements, 2 closure rounds, 3 directions, 2 half-angles. ADE: Binary Dihedral 2D₂.</li>
<li>ζ₆: &gt;4096 elements, 10 rounds to cap, 512 directions (saturated), 37 half-angles. INFINITE.</li>
<li>ζ₈: 24 elements, 4 closure rounds, 13 directions, 4 half-angles. ADE: Binary Octahedral (E₇).</li>
<li>ζ₁₀: &gt;4096 elements, 7 rounds to cap, 512 directions, 71 half-angles. INFINITE.</li>
<li>ζ₁₂: &gt;4096 elements, 8 rounds to cap, 512 directions, 43 half-angles. INFINITE.</li>
<li>ζ₁₆: &gt;4096 elements, 8 rounds to cap, 512 directions, 51 half-angles. INFINITE.</li>
<li>ζ₂₀: &gt;4096 elements, 7 rounds to cap, 512 directions, 67 half-angles. INFINITE.</li>
<li>Finite count: 2. Infinite count: 5.</li>
<li>Quantum dimension [2]_q at ζ₈: exactly 0 (q = i, [2]_q = i + 1/i = i - i = 0).</li>
<li>Angle algebraic degrees: cos(π/2)=0 (rational, finite), cos(π/4)=√2/2 (degree 2, finite), cos(π/3)=1/2 (rational, INFINITE), cos(π/5)=φ/2 (degree 2, INFINITE).</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong><code>build_closure(rounds_out)</code></strong>: generic group closure algorithm; starts from generators + inverses + identity, multiplies all current elements by all generators each round, stops when no new elements are added or MAX_QCAT is hit; returns 1 if finite, 0 if hit cap</li>
<li><strong><code>test_root(N)</code></strong>: complete per-root survey: init generators at half_angle=2π/N, run closure, count directions, count angles, identify ADE type, print and store in results array</li>
<li><strong><code>identify_ade(order)</code></strong>: maps group size to ADE classification; handles binary tetrahedral (order 12), octahedral (24), icosahedral (60), binary dihedral (4n), cyclic (n)</li>
<li><strong><code>analyze_direction_distribution()</code></strong>: for infinite groups, reports S² octant coverage and angle gap statistics to characterize density structure</li>
<li><strong><code>RootResult</code> struct</strong>: compact storage for per-root survey results (N, angle, finite flag, size, rounds, dirs, angles, ADE string); enables summary table across all roots</li>
<li><strong><code>count_angles()</code> with bubble sort</strong>: collects distinct half-angles with 0.1° tolerance, sorts ascending; pattern for angle census reusable in any catalog analysis</li>
<li><strong>Closure vs brute-word-enumeration tradeoff</strong>: <a href="./entries/demo_80.html">Demo 80</a> uses true group closure (multiply existing elements by generators) rather than <a href="./entries/demo_78.html">Demo 78</a>'s enumerate-all-words approach; closure is exact and efficient for finite groups, and correctly identifies infinite groups by hitting the cap</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>ADE classification of finite subgroups of SU(2)</strong>: the complete classification (cyclic, binary dihedral, binary tetrahedral/octahedral/icosahedral) is the organizing framework. Our construction reaches only two of the exceptional cases.</li>
<li><strong>Kuperberg (1994, 1996) #P-hardness of Jones polynomial</strong>: hardness applies at non-lattice roots of unity; the lattice roots ζ₄ and ζ₈ where [2]_q ∈ {-2, 0} are exactly our finite cases and the tractable computational regime.</li>
<li><strong>Witten-Reshetikhin-Turaev TQFT</strong>: the finite subgroups of SU(2) are the building blocks of WRT invariants; the ADE classification connects to the Dynkin diagram structure of the relevant quantum groups.</li>
<li><strong>Fibonacci anyons / topological quantum computation</strong>: ζ₁₀ (angle π/5, golden ratio) is the relevant parameter for Fibonacci anyons and universal quantum computation via braiding. Our finding that ζ₁₀ generates an infinite group is consistent with its use in quantum computation: the infinite group provides universal coverage of SU(2).</li>
<li><strong>Habiro (2002)</strong>: the Z[ζ₈] bracket from the DKC arc lives at the ζ₈ = E₇ point; the finiteness of this group is the algebraic foundation of the finite capacity ceiling demonstrated in <a href="./entries/demo_76.html">Demos 76</a>–<a href="./entries/demo_78.html">78</a>.</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li><strong>Is ζ₃₂ (θ = π/16) finite?</strong>: The power-of-two conjecture predicts yes. A single additional test_root(32) call would confirm or refute.</li>
<li><strong>Why do perpendicular π/3 rotations not close?</strong>: The geometric argument (hexagonal symmetry vs octahedral symmetry) explains the result intuitively but a rigorous algebraic proof of why exactly π/2 and π/4 are special has not been given.</li>
<li><strong>Do all infinite groups give unbounded XOR capacity?</strong>: <a href="./entries/demo_79.html">Demo 79</a> confirmed ζ₁₂ (infinite) breaks the ζ₈ wall. But do all infinite groups provide unbounded capacity, or do some infinite groups have structural limitations that impose their own ceilings?</li>
<li><strong>Which infinite group is computationally optimal?</strong>: ζ₁₀ has the most half-angles at 4096 entries (71) of all surveyed roots. Does more angular diversity directly translate to easier XOR computation and lower minimum k values?</li>
<li><strong>E₆ and E₈ reachability</strong>: Binary tetrahedral (order 24, E₆) and binary icosahedral (order 120, E₈) are not reached by the two-perpendicular-axes generator construction. Is there a different natural generator construction that reaches them?</li>
</ul>
<h2><a href="./entries/demo_81.html">Demo 81</a>: Capacity Scaling Law</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_81_capacity_scaling/main.c.html">demo_81_capacity_scaling/main.c</a></code> (~604 lines)</li>
<li><strong>Tests</strong>: 14/14 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_66.html">Demo 66</a> (quaternionic DKC, 24-cell geometry), <a href="./entries/demo_77.html">Demo 77</a> (activation zoo, XOR8=6 at ζ₈), <a href="./entries/demo_78.html">Demo 78</a> (recursive scaling, XOR10=0 at ζ₈, wall confirmed), <a href="./entries/demo_79.html">Demo 79</a> (ζ₁₂ capacity, XOR10=124 and XOR12=50+), <a href="./entries/demo_80.html">Demo 80</a> (finiteness survey, only ζ₄ and ζ₈ finite)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_82.html">Demo 82</a> (crossing depth interpretation of the scaling law), future work verifying XOR14 prediction at ~38K entries</li>
</ul>
<h3>Headline</h3>
For ζ₁₂ (infinite group), XOR capacity scales logarithmically with catalog size: max_xor ≈ 0.62 × log₂(catalog_size) + 4.6, meaning each +2 XOR inputs requires approximately 10× more entries.
<h3>Key Results</h3>
<ul>
<li><strong>Logarithmic scaling law</strong>: max_xor ≈ 0.62 × log₂(catalog_size) + 4.6. Each doubling of catalog size adds ~0.62 to max XOR; each +2 XOR level costs ~3.2 more doublings (~10× more entries).</li>
<li><strong>Transition points</strong>: XOR6 at ~5 entries (log₂ ≈ 2.3), XOR8 at ~51 (log₂ ≈ 5.7), XOR10 at ~275 (log₂ ≈ 8.1), XOR12 at ~1140 (log₂ ≈ 10.2).</li>
<li><strong>Monotonicity confirmed</strong>: capacity never decreases as more entries are added.</li>
<li><strong>Winner saturation</strong>: XOR6–XOR10 reach the 32-winner cap at every level where they appear; XOR12 emerges at 12 winners at round 6 then saturates at 32.</li>
<li><strong>Two-regime vocabulary</strong>: directions scale as ~40–45% of catalog size until saturating at MAX_DIR=512 (rounds 7–8); angles grow much more slowly, roughly as sqrt(catalog_size). Angular resolution is the limiting factor for higher XOR levels.</li>
<li><strong>Decreasing transition gap</strong>: doublings between XOR transitions are 3.35, 2.43, 2.05 — possibly sub-logarithmic behavior, but more data needed.</li>
<li><strong>Finite vs. infinite contrast</strong>: ζ₈ (binary octahedral group, ADE type E₇) hard-caps at XOR8; ζ₁₂ grows logarithmically with no hard ceiling within the explored range.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Logarithmic Scaling Law (DEMONSTRATED)</strong>: max_xor ≈ 0.62 × log₂(catalog_size) + 4.6 across 9 snapshot rounds (cat=5 to cat=4096). Equivalently catalog_size ≈ 3^M in the XOR level M.</li>
<li><strong>Possibly Sub-Logarithmic (CONJECTURE)</strong>: The decreasing gaps between transitions (3.35 → 2.43 → 2.05 doublings) suggest scaling may be O(log N / log log N) rather than pure O(log N). Requires more data points (XOR14+) to distinguish.</li>
<li><strong>Direction Bottleneck Theorem (OBSERVED)</strong>: Each XOR transition is gated by direction count — 22 dirs for XOR8, 114 for XOR10, 507 for XOR12. After direction saturation (round 7), angular diversity alone drives continued winner-count growth.</li>
<li><strong>Kuperberg Consistency</strong>: The exponential cost per XOR level is consistent with Kuperberg's #P-hardness result for non-lattice roots of unity.</li>
</ul>
<h3>Data</h3>
<ul>
<li>Snapshot table (round, catalog, dirs, angles, max XOR): (0,5,2,2,6), (1,17,6,4,6), (2,51,22,6,8), (3,127,46,10,8), (4,275,114,12,10), (5,564,239,16,10), (6,1140,507,21,12), (7,2292,512,35,12), (8,4096,512,43,12)</li>
<li>Scaling constant: 0.62 XOR per doubling</li>
<li>Intercept: 4.6 (at catalog=1)</li>
<li>Transition costs in doublings: XOR6→XOR8: 3.35, XOR8→XOR10: 2.43, XOR10→XOR12: 2.05</li>
<li>XOR14 prediction: ~38,000 entries (~11 closure rounds), feasible in minutes</li>
<li>XOR16 prediction: ~615,000 entries (~14 rounds), feasible in hours</li>
<li>XOR20 prediction: ~160 million entries, memory-limited</li>
<li>XOR32 prediction: ~10^14 entries, infeasible</li>
<li>Direction saturation: MAX_DIR=512 reached at round 7 (cat=2292)</li>
<li>Angles at saturation: 35 (round 7), 43 (round 8)</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>Group closure with snapshot tracking</strong>: builds ζ₁₂ catalog via BFS-style generator multiplication; records <code>round_end[]</code> for per-snapshot analysis; identity + 4 generators (σ₁, σ₁⁻¹, σ₂, σ₂⁻¹)</li>
<li><strong><code>build_dirs()</code> / <code>count_angles()</code></strong>: extract unique rotation axes (Voronoi directions on S²) and unique half-angles from a catalog prefix; run independently per snapshot</li>
<li><strong><code>combined_cell()</code></strong>: Sec×Vor activation — maps a quaternion sum to a (sector, Voronoi-cell) pair; sector from rotation angle divided into k_sec bins, Voronoi cell from nearest direction</li>
<li><strong><code>test_xor()</code></strong>: early-exit XOR verification with sparse cell cleanup using <code>touched_cells[]</code> array; checks that all 2^(2n) input masks map even/odd parity to distinct activation cells</li>
<li><strong><code>find_xor6()</code> + <code>find_recursive()</code></strong>: brute-force XOR6 search over triples, then recursive extension to XOR8/10/12 by appending one entry to each winner; sorted-tuple deduplication</li>
<li><strong><code>Snap</code> struct + <code>test_snapshot()</code></strong>: per-round snapshot driver that runs the full XOR6→12 pipeline and records results for the scaling table</li>
<li><strong>Logarithmic fit analysis</strong>: inline computation of XOR-per-doubling slope and prediction for next XOR level</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>Kuperberg (2015)</strong>: #P-hardness of approximating the Jones polynomial for non-lattice roots of unity; the exponential catalog cost per XOR level is consistent with this hardness result</li>
<li><strong>Aizenberg (2008)</strong>: k-sector MVN activation (Sec×Vor is the S² generalization); the logarithmic scaling characterizes how the S² analog scales with group complexity</li>
<li><strong>Habiro (2002) / Z[ζ_8] bracket theory</strong>: the finite-group ceiling at ζ₈ vs. logarithmic growth at ζ₁₂ maps to the algebraic difference between lattice (E₇/binary octahedral) and non-lattice roots</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li><strong>Does scaling continue to XOR14?</strong> Prediction of ~38K entries at ~11 closure rounds is directly testable by increasing MAX_QCAT; would add one more data point to the transition gap series.</li>
<li><strong>Is scaling truly O(log N) or O(log N / log log N)?</strong> The decreasing gap series (3.35 → 2.43 → 2.05) needs at least one more data point (XOR14 transition) to distinguish these hypotheses.</li>
<li><strong>Does the 0.62 constant depend on the root of unity?</strong> ζ₁₀ might give a different slope (ζ₁₀ has 71 angles at 4096 entries vs ζ₁₂'s 43); the constant may be a function of angular density per round.</li>
<li><strong>What determines the ~0.62 constant?</strong> Is it a consequence of the quaternion dimension (4D) or the specific Sec×Vor activation geometry?</li>
<li><strong>Can union catalogs improve the constant?</strong> Mixing ζ₁₀ + ζ₁₂ entries might give denser angular coverage per entry and change the scaling constant without altering the logarithmic character.</li>
</ul>
<h2><a href="./entries/demo_82.html">Demo 82</a>: Crossing Depth and Computational Role</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_82_crossing_depth/main.c.html">demo_82_crossing_depth/main.c</a></code> (~930 lines)</li>
<li><strong>Tests</strong>: 17/17 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_66.html">Demo 66</a> (quaternionic DKC, 24-cell geometry), <a href="./entries/demo_79.html">Demo 79</a> (ζ₁₂ capacity, XOR12 reachable), <a href="./entries/demo_81.html">Demo 81</a> (logarithmic scaling law, 0.62 XOR per doubling)</li>
<li><strong>Feeds into</strong>: Future work on direct deep-entry generation, optimal subset selection for XOR computation, connection between crossing number and computational capacity</li>
</ul>
<h3>Headline</h3>
Quaternion "depth" (birth round in group closure = number of generator multiplications = crossing depth in knot-theory sense) is the fundamental variable governing XOR capacity: max_xor ≈ depth + 6, deep entries are 2× more efficient than shallow ones, and algebraic coherence beats raw vocabulary.
<h3>Key Results</h3>
<ul>
<li><strong>Linear depth law</strong>: max_xor ≈ depth + 6. Each unit of crossing depth adds a fixed increment to computational capacity. The logarithmic law from <a href="./entries/demo_81.html">Demo 81</a> was an artifact of exponential catalog growth per round — taking log of an exponential gives a linear function.</li>
<li><strong>Deep entries 2× more efficient</strong>: 564 pure depth-8 entries reach XOR12 with 19 winners; the full mixed catalog needs ~1140 entries to first reach XOR12 (round 6). Deep subset is half the size.</li>
<li><strong>Algebraic coherence beats vocabulary</strong>: Strided 564 has maximum spatial coverage (512 dirs, 43 angles — matching the full 4096-entry catalog) yet only reaches XOR10. Deep 564 has fewer directions (476) and fewer angles (19) but reaches XOR12. More vocabulary loses to less vocabulary with more depth.</li>
<li><strong>Two-component winner architecture</strong>: every XOR winner = shallow core + deep extensions. Depth-0 entries (generators + identity) appear in every winner at every XOR level. Mean entry depth rises monotonically: 0.52 (XOR6) → 0.63 (XOR8) → 1.00 (XOR10) → 1.98 (XOR12).</li>
<li><strong>Deep entries contain effective generators</strong>: Part D shows deep-only subsets (without generators) can compute XOR10 and XOR12. Deep entries encode effective rotation axes from their algebraic structure as many-generator products.</li>
<li><strong>Two vocabulary regimes</strong>: depths 0–6 produce a direction explosion (new directions grow roughly exponentially, 2/4/16/24/68/125/268 per depth); depths 7–8 shift to angle refinement (directions saturate at MAX_DIR=512, but angles accelerate: +14 at depth 7, +8 at depth 8).</li>
<li><strong>ζ₈ control confirms pattern</strong>: finite group closes at 24 entries with max depth 3; same depth→XOR trend holds but the group ceiling limits both catalog size and achievable depth.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Linear Depth Law (DEMONSTRATED)</strong>: max_xor ≈ depth + 6 across all measured transition points (depth 0→XOR6, depth 2→XOR8, depth 4→XOR10, depth 6→XOR12). The <a href="./entries/demo_81.html">Demo 81</a> logarithmic law is a corollary: catalog grows as ~2^depth, so log₂(catalog) ≈ depth, giving max_xor ≈ 0.62 × log₂(catalog) + const.</li>
<li><strong>Algebraic Coherence Dominance (DEMONSTRATED)</strong>: vocabulary (direction count + angle count) is necessary but not sufficient for XOR capacity. Strided 564 achieves the maximum possible vocabulary yet cannot reach XOR12; Deep 564 with strictly less vocabulary does reach XOR12. The determining factor is the shared algebraic structure of deep entries — every depth-8 entry is a product of 8 generators, creating common intermediate factors.</li>
<li><strong>Depth IS Crossing Depth (INTERPRETATION)</strong>: Each closure round = one generator multiplication = one crossing in the braid/knot sense. A depth-d quaternion encodes d crossings of the associated knot diagram. The linear capacity law says computational power scales linearly with knot crossing complexity. Consistent with Kuperberg's #P-hardness: the hardness is in generating deep entries (exponential cost), not in their algebraic structure itself (linear gain).</li>
<li><strong>Direction Explosion / Angle Refinement Phase Transition (OBSERVED)</strong>: There is a clean phase boundary at depth 6–7. Below: new directions dominate, catalog explores S². Above: directions saturate, angle refinement dominates. The XOR10→XOR12 transition is driven by angle refinement, not new directions.</li>
</ul>
<h3>Data</h3>
<ul>
<li>Depth census (depth, count, cumulative): (0,5,5), (1,12,17), (2,34,51), (3,76,127), (4,148,275), (5,289,564), (6,576,1140), (7,1152,2292), (8,1804,4096)</li>
<li>Catalog growth per round: roughly 2× each round (exponential); round 8 alone is 44% of all entries</li>
<li>Winner mean depth: XOR6=0.52, XOR8=0.63, XOR10=1.00, XOR12=1.98</li>
<li>Sample XOR12 winner: indices [0,1,3,6,52,388], depths [0,0,0,1,3,5] (shallow core + progressively deeper harmonics)</li>
<li>Shallow vs. strided vs. deep at 127 entries: max XOR 8 / 10 / 10</li>
<li>Shallow vs. strided vs. deep at 564 entries: max XOR 10 / 10 / 12</li>
<li>Strided 564 vocabulary: 512 dirs, 43 angles (matches full 4096-entry catalog)</li>
<li>Deep 564 vocabulary: 476 dirs, 19 angles (less than strided, yet 2 XOR levels higher)</li>
<li>Depth 7 new angles: 14; depth 8 new angles: 8 (angle acceleration at saturation)</li>
<li>ζ₈ control: 24 entries, 4 rounds, max depth 3, max XOR 8; same depth→XOR pattern confirmed</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>Group closure with depth tracking</strong>: <code>g_depth[]</code> array assigned round index at birth; identity + generators get depth 0; subsequent products get depth = current round number</li>
<li><strong><code>save_catalog()</code> / <code>restore_catalog()</code></strong>: full catalog snapshot/restore (quaternions + depths) enabling repeated subset experiments without rebuilding closure</li>
<li><strong>Subset construction patterns</strong>: three reusable strategies implemented — shallow (first N entries by natural closure order), strided (every K-th entry from full catalog, deterministic), deep (last N entries, all from deepest round); pattern is copy-and-overwrite <code>g_cat[]</code> then set <code>g_cat_size</code></li>
<li><strong><code>find_capacity()</code></strong>: unified capacity measurement driver — builds dirs, counts angles, runs find_xor6 + find_recursive chain up to XOR12; returns <code>CapResult</code> struct</li>
<li><strong>Winner depth analysis</strong>: per-level depth histogram and min/max/mean computation; iterates over all winner tuples and indexes into <code>g_depth[]</code>; checks that mean depth is monotonically non-decreasing across XOR levels</li>
<li><strong>Vocabulary-by-depth scan</strong>: single-pass O(N²) scan accumulating unique directions and angles in per-depth buckets; separates direction explosion regime from angle refinement regime</li>
<li><strong><code>CapResult</code> struct</strong>: captures dirs, angles, xor6, xor8, xor10, xor12, max_xor in one place; enables clean side-by-side comparisons in summary tables</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>Kuperberg (2015)</strong>: #P-hardness of Jones polynomial for non-lattice roots; the linear depth law says the hardness is precisely in generating deep entries (exponential BFS cost) while the algebraic gain is linear — matching #P structure</li>
<li><strong>Knot theory / braid groups (Birman 1974, Jones 1985)</strong>: depth = number of generator multiplications = crossing number of braid word; the demo gives computational meaning to crossing depth</li>
<li><strong>Aizenberg (2008)</strong>: k-sector MVN activation; the Sec×Vor activation on S² here shows that algebraic coherence (not just angular coverage) determines computational capacity</li>
<li><strong>Nazer &amp; Gastpar (2011)</strong>: compute-and-forward / structured codes; the algebraic coherence result (shared intermediate products enabling higher-order parity separation) connects to structured computation in coding theory</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li><strong>What is the optimal depth for a target XOR level?</strong> Pure depth-8 is demonstrated to be better than shallow or strided at matched size, but is pure depth-8 optimal or would a mixed depth (e.g., pure depth-6 or depth-7) achieve XOR12 with even fewer entries?</li>
<li><strong>Can deep entries be generated directly?</strong> Rather than building the full BFS closure and taking the last entries, can the algebraic properties of depth-d entries (shared intermediate products, angular refinement structure) be characterized and sampled directly without computing all shallower depths?</li>
<li><strong>What algebraic property does strided-564 lack?</strong> It has full vocabulary (512 dirs, 43 angles) but cannot reach XOR12. Deep-564 has less vocabulary but can. The missing property is presumably the shared common-factor structure of deep entries — can this be made precise?</li>
<li><strong>Does the depth law hold for other roots of unity?</strong> ζ₁₀ deep entries vs. shallow comparison has not been run. The linear law max_xor ≈ depth + const may have a different constant or break down at a different root.</li>
<li><strong>Connection to knot complexity</strong>: a more complexly knotted strand computes more than many simply knotted strands with equal or greater total vocabulary. Does this connect to known results about the computational power of specific knot types (torus knots, hyperbolic knots)? ## <a href="./entries/demo_83.html">Demo 83</a>: Framing as Computational Content</li>
</ul>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_83_framing_test/main.c.html">demo_83_framing_test/main.c</a></code> (~1035 lines)</li>
<li><strong>Tests</strong>: 12/12 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_66.html">Demo 66</a> (quaternionic DKC, 24-cell geometry), <a href="./entries/demo_79.html">Demo 79</a> (ζ₁₂ capacity, XOR12 reachable, early "N-2" pattern first observed), <a href="./entries/demo_81.html">Demo 81</a> (logarithmic scaling law), <a href="./entries/demo_82.html">Demo 82</a> (crossing depth, "+2 per resource unit" pattern, depth as independent computational axis)</li>
<li><strong>Feeds into</strong>: Future work verifying the +2 framing loss at other roots (ζ₁₆, ζ₂₄); analytic proof of "+2 per writhe unit" from the (-A³)^w factor; writhe distribution of 24-cell vertices; reservoir computing interpretation of writhe × depth as independent channels</li>
</ul>
<h3>Headline</h3>
Jones normalization destroys exactly 2 XOR levels of computational capacity at every root tested. The "N-2" pattern observed in early demos was the Jones polynomial's capacity all along, not a bracket truncation artifact. Framing is not a bookkeeping anomaly to be normalized away — it is one discrete computational resource worth +2 XOR levels, independent of and additive with crossing depth.
<h3>Key Results</h3>
<ul>
<li><strong>Consistent 2-level loss</strong>: bracket capacity = N, Jones capacity = N-2 at both roots tested. ζ₁₂: bracket XOR12, Jones XOR10. ζ₈: bracket XOR8, Jones XOR6. The loss is exact and constant across roots.</li>
<li><strong>The N-2 pattern resolved</strong>: the "N-2" observation from <a href="./entries/demo_79.html">Demo 79</a> was Jones capacity, not a bracket truncation artifact. The bracket genuinely reaches XOR12 at ζ₁₂; earlier demos that stopped at XOR10 were inadvertently computing Jones-normalized quantities.</li>
<li><strong>Framing lives in angles, not directions</strong>: Jones normalization reduces distinct quaternions from 4096 to 2710 (-33.8%), angles from 43 to 31 (-28%), but leaves direction count unchanged (512 → 512). The angular vocabulary reduction is the mechanism of capacity loss.</li>
<li><strong>Writhe and depth are independent computational axes</strong>: depth-writhe correlation r = 0.139 across 4096 entries. Mean |writhe| grows linearly with depth (0.80 → 1.33 → 1.82 → 2.14 → 2.61 → 3.19 for depths 0–8), but the low correlation means a deep entry can have low writhe (crossings cancel) or high writhe (crossings accumulate). These are genuinely separate resources.</li>
<li><strong>Writhe alone can compute (but not far)</strong>: writhe-only XOR test (replacing quaternion sums with writhe sums) finds 32 XOR6 winners. Writhe as a standalone feature = one unit of computational resource. Writhe alone cannot reach XOR8 or higher — full power requires writhe × lattice interaction.</li>
<li><strong>Winners use mixed writhe (chirality variation)</strong>: XOR12 winners use both positive and negative writhe entries. The computation exploits chirality variation, not just magnitude. Mixed-writhe fractions: XOR6 41%, XOR8 25%, XOR10 9%, XOR12 12%.</li>
<li><strong>Additive resource decomposition</strong>: lattice structure provides the base (XOR6 achievable from lattice alone); depth adds +2 per closure round (<a href="./entries/demo_82.html">Demo 82</a>); writhe adds +2 on top. These three resources are independent and additive.</li>
<li><strong>ζ₈ control confirms structural origin</strong>: at ζ₈ (24 entries, finite group), the same -2 loss holds: bracket XOR8, Jones XOR6. The framing effect is not an artifact of infinite-group scaling — it is a structural property of the bracket-to-Jones relationship itself.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Framing = +2 XOR Levels (DEMONSTRATED)</strong>: Jones normalization costs exactly 2 XOR levels at both ζ₈ and ζ₁₂. The loss is a discrete, constant, root-independent structural feature of the writhe-dependent phase factor. Framing is one discrete unit of computational resource, comparable in magnitude to one crossing-depth unit (<a href="./entries/demo_82.html">Demo 82</a>).</li>
<li><strong>Resource Decomposition Conjecture (SUPPORTED)</strong>: DKC computational power decomposes as lattice base (XOR6) + 2 × depth_rounds + 2 × framing_present. The "+2 per resource unit" pattern matches across both the depth scaling (<a href="./entries/demo_82.html">Demo 82</a>: each closure round at transition depths) and writhe. Whether these are truly additive across all roots and depths requires further verification.</li>
<li><strong>Angular Vocabulary is the Mechanism (DEMONSTRATED)</strong>: framing loss manifests entirely through angle reduction (43 → 31), not direction reduction (512 → 512). The writhe-dependent phase rotates quaternions in the angular coordinate, not the directional coordinate. This is consistent with the <a href="./entries/demo_82.html">Demo 82</a> finding that angular refinement (not direction count) drives XOR10 → XOR12.</li>
<li><strong>Writhe Independence from Depth (DEMONSTRATED at r=0.14)</strong>: near-zero correlation at 4096 entries is strong evidence these are genuinely independent. The interpretation is that braid words with equal crossing number can have very different writhes depending on whether crossings cancel or accumulate — chirality structure is not determined by length.</li>
<li><strong>TQFT Anomaly is Computational Resource (INTERPRETATION)</strong>: the Jones polynomial removes the writhe phase as a "framing anomaly." TQFT's maximally degenerate point (δ=0) discards this term first. <a href="./entries/demo_83.html">Demo 83</a> demonstrates that the anomaly term is not noise but computation — exactly the component that contributes 2 XOR levels.</li>
</ul>
<h3>Data</h3>
<ul>
<li>ζ₁₂ catalog: 4096 entries, 9 closure rounds</li>
<li>Writhe range: [-9, 9]; 91.4% of entries have nonzero writhe; mean writhe 1.697 (positive bias from generator structure)</li>
<li>Depth-writhe correlation: r = 0.139</li>
<li>Mean |writhe| by depth: depth 0 → 0.80, depth 1 → 1.33, depth 2 → 1.82, depth 4 → 2.14, depth 6 → 2.61, depth 8 → 3.19</li>
<li>Capacity table (ζ₁₂): bracket XOR6=32, XOR8=32, XOR10=32, XOR12=32; Jones XOR6=32, XOR8=32, XOR10=32, XOR12=0</li>
<li>Capacity table (ζ₈): bracket XOR6=32, XOR8=32; Jones XOR6=32, XOR8=0</li>
<li>Information collapse (ζ₁₂): distinct quaternions 4096 → 2710 (-33.8%), directions 512 → 512 (unchanged), angles 43 → 31 (-28%)</li>
<li>Writhe-only XOR6 winners: 32 (confirming writhe as a standalone unit); writhe alone cannot reach XOR8</li>
<li>Mixed-writhe winners: XOR6 41% (13/32), XOR8 25% (8/32), XOR10 9% (3/32), XOR12 12% (4/32)</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>Writhe tracking in <code>build_closure()</code></strong>: <code>g_writhe[]</code> array updated alongside <code>g_depth[]</code>; generator writhes σ₁=+1, σ₁⁻¹=-1, σ₂=+1, σ₂⁻¹=-1; each new product inherits parent writhe plus generator writhe contribution</li>
<li><strong><code>jones_normalize_catalog()</code></strong>: computes Jones phase per unit writhe as <code>-(3<em>half_angle + pi)</code>, applies per-entry rotation <code>phi = writhe[i] </em> jones_phase_per_w</code> as a unit quaternion left-multiplier; works for any root (auto-adapts via <code>g_half_angle</code>)</li>
<li><strong><code>save_catalog()</code> / <code>restore_catalog()</code></strong>: snapshots and restores quaternions + depths + writhes; enables bracket→Jones→bracket switching without rebuilding closure; extends the <a href="./entries/demo_82.html">Demo 82</a> pattern to also save writhe array</li>
<li><strong><code>test_xor_writhe()</code></strong>: independent XOR verifier using writhe sums instead of quaternion sums; uses a flat array of 129 cells (writhe offset 64, range -64 to +64); confirms writhe alone as a standalone computational feature</li>
<li><strong><code>find_capacity()</code></strong>: reused from <a href="./entries/demo_82.html">Demo 82</a> pattern; unified XOR6 → XOR12 pipeline returning <code>CapResult</code> struct; used three times (bracket, Jones, ζ₈ control)</li>
<li><strong>Winner writhe analysis (Part D)</strong>: per-level writhe histogram, min/max/mean absolute writhe, and mixed-writhe fraction; iterates saved winner tuples and indexes into <code>g_writhe[]</code>; confirms chirality variation signature of higher XOR levels</li>
<li><strong><code>count_distinct_quats()</code></strong>: O(N²) exact quaternion comparison (checking both q and -q as representatives); used to measure information collapse between bracket and Jones catalogs</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>Kirby (1978)</strong>: framing determines 3-manifold topology; the writhe phase factor carries exactly this topological information, and <a href="./entries/demo_83.html">Demo 83</a> proves it also carries computational information</li>
<li><strong>Witten (1989)</strong>: framing anomaly is the first term removed in TQFT (maximally degenerate point δ=0); the demo proves that what TQFT calls an anomaly is what DKC computes with</li>
<li><strong>Rasmussen (2004)</strong>: writhe appears explicitly in Khovanov q-grading and is not normalized away in categorified knot theory; the Khovanov perspective preserves the same quantity that DKC uses for computation</li>
<li><strong>Kuperberg (2015)</strong>: #P-hardness of Jones polynomial for non-lattice roots; the demo is agnostic to hardness but uses the Jones polynomial as a controlled degraded comparison against the bracket</li>
<li><strong>Aizenberg (2008)</strong>: k-sector MVN activation; the Sec×Vor activation here shows that framing's contribution is through angular refinement, consistent with angular resolution as the limiting factor for higher XOR levels</li>
<li><strong>Reservoir Computing (Jaeger 2001, Maass 2002)</strong>: writhe and depth as independent computational axes is the knot-theory analog of independent channels in a reservoir — each adds capacity without interfering with the other; the "+2 per resource unit" pattern matches the independent-channel additivity expected from reservoir theory</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li><strong>Does the +2 loss hold at other roots?</strong> ζ₁₆ and ζ₂₄ have not been tested. The loss is constant across ζ₈ and ζ₁₂ despite very different group sizes (24 vs. 4096), suggesting universality, but more roots are needed.</li>
<li><strong>Can the "+2 per writhe unit" be proved analytically?</strong> The (-A³)^{-w} factor acts as a rotation by <code>-(3<em>half_angle + pi)</em>w</code> per entry. The 2-level loss should follow from how this rotation redistributes angular vocabulary. A direct count of angle equivalence classes before and after normalization would confirm.</li>
<li><strong>At ζ₈, is Jones XOR6 exactly the "standard sector activation" capacity from <a href="./entries/demo_63.html">Demo 63</a>?</strong> If the 6-sector activation that saturates at XOR6 in <a href="./entries/demo_63.html">Demo 63</a> is the same regime as the Jones-normalized ζ₈ catalog, this would be a non-trivial structural coincidence worth pursuing.</li>
<li><strong>What is the writhe distribution of the 24-cell vertices?</strong> The 24 entries of the ζ₈ closure form the binary octahedral group. Do antipodal pairs (q and -q) have opposite writhes (writhe inversion under negation)?</li>
<li><strong>Does writhe add exactly +2 regardless of depth?</strong> The demo shows framing = +2 at the group's maximum capacity level. But at intermediate depths, does the bracket also beat Jones by exactly 2, or does the gap vary with depth?</li>
</ul>
<h2><a href="./entries/demo_84.html">Demo 84</a>: Null States and Logarithmic Structure</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_84_null_states/main.c.html">demo_84_null_states/main.c</a></code> (~1330 lines)</li>
<li><strong>Tests</strong>: 17/17 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_66.html">Demo 66</a> (24-cell geometry, 24-entry ζ₈ catalog), <a href="./entries/demo_79.html">Demo 79</a> (ζ₁₂ capacity, infinite group), <a href="./entries/demo_82.html">Demo 82</a> (crossing depth law, algebraic coherence)</li>
<li><strong>Feeds into</strong>: Reservoir Computing pillar (Pillar 5), future exactification work, null-state geometry as design principle for weight selection</li>
</ul>
<h3>Headline</h3>
Bracket-null entries (Re(q)=0, Kauffman trace vanishes) are not computational dead weight: they maintain the S² directional vocabulary essential for XOR8 capacity, and removing them drops capacity to XOR6 — worse than removing a random equal-size subset. The geometry of nulls (cube-edge-midpoint directions, flat k_sec profile) directly supports the Reservoir Computing null-state hypothesis and has a natural LCFT interpretation via Jordan cells.
<h3>Key Results</h3>
<ul>
<li><strong>Part A — Bracket-null census</strong>: 9 of 24 ζ₈ entries are bracket-null (Re(q)=0, 37.5%). Depth distribution monotonically increases: depth-0 = 0% null, depth-1 = 20% null, depth-2 = 75% null, depth-3 = 100% null. Every maximally-deep entry in the ζ₈ catalog is bracket-null.</li>
<li><strong>Part B — Gap theorem</strong>: The spectrum of |Re(q)| across the 24-entry catalog is discrete: exactly 4 values {0, 0.5, 0.707, 1.0}. There is a hard gap of 0.5 between null (Re=0) and the nearest non-null (Re=0.5). The spectrum is not a continuum — it reflects the algebraic structure of the binary octahedral group.</li>
<li><strong>Part E — Direction geometry</strong>: 13 total S² directions across the catalog. Null-only directions: 6 (cube edge midpoints, components ±1/√2). Non-null-only directions: 4 (tetrahedral axes, components ±1/√3). Shared directions: 3 (coordinate axes). Null entries cover 1.00 direction per entry; non-null entries cover only 0.47 direction per entry. Nulls are directionally efficient — each null entry points to a unique region of S² not covered by non-null entries.</li>
<li><strong>Part C (Crux) — Capacity without nulls</strong>: Full catalog (24 entries, 13 dirs) achieves XOR8. Non-null-only subset (15 entries, 7 dirs) achieves only XOR6. Null-only subset (9 entries, 9 dirs) also achieves XOR6. Removing nulls destroys one full XOR level of capacity.</li>
<li><strong>Part C.3 — Random controls</strong>: Random 15-entry subsets of the full 24-entry catalog achieve a mean max_xor of 7.8. The non-null-only subset (max_xor=6) performs below this random baseline. Removing the specific null entries is strictly worse than removing random entries of the same count — nulls are disproportionately important.</li>
<li><strong>Part C.4 — k_sec sweep (S¹ vs S² decomposition)</strong>: Null-only XOR6 count is flat across all tested k_sec values (k=1,2,4,6,8). This confirms the null-only subset occupies a single S¹ sector (all half-angles = 90°, a single point on S¹) and derives all its computational power from S² directional diversity alone. At k_sec=1 (direction-only scoring), null-only outperforms non-null-only because it has 9 directions vs 7.</li>
<li><strong>Part D — Null prevalence in winners</strong>: At XOR6, mean null count per winner is 0.344 (ratio 0.31 vs. random expectation). At XOR8, mean null count per winner is 1.188 (ratio 0.79). Null entries participate more heavily in higher-capacity winners — they are specifically required for XOR8 solutions, not just incidentally present.</li>
<li><strong>Part F — Cross-root comparison</strong>: ζ₄: 75% null (3/4 entries). ζ₈: 37.5% null (9/24 entries). ζ₁₂ (truncated at 4096): 3.0% null (121/4096 entries). As the group grows, the null fraction decreases sharply. ζ₁₂ has 29 null-only directions, 453 non-null-only, and 30 shared — the directional richness is overwhelmingly from non-null entries in the larger group. The ζ₈ regime is the one where nulls represent a significant structural fraction.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Null Indispensability Theorem (DEMONSTRATED)</strong>: In the ζ₈ catalog, bracket-null entries cannot be removed without destroying XOR capacity. The 9 null entries contribute 6 directions exclusively unavailable to the 15 non-null entries (cube-edge-midpoint directions), and these directions are necessary for XOR8 solutions.</li>
<li><strong>Null Directional Efficiency (DEMONSTRATED)</strong>: Each null entry uniquely covers a distinct direction (1.00 dir/entry) while non-null entries share directions (0.47 dir/entry). Null entries are maximally efficient as directional vocabulary.</li>
<li><strong>S¹ Flatness of Null-Only (DEMONSTRATED)</strong>: All bracket-null entries have half-angle exactly 90°, placing them at a single point on S¹. Their entire computational contribution comes from S² direction diversity. At k_sec=1, null-only beats non-null-only on this dimension alone.</li>
<li><strong>Logarithmic Partner Hypothesis (SUPPORTED)</strong>: The LCFT interpretation is consistent with all results. In logarithmic conformal field theory, null states have zero two-point function (trace vanishes) but are not zero vectors — they are paired with logarithmic partners via Jordan cells. These partner states carry the computational content. The null-entry directions (cube-edge-midpoints) correspond to the geometric footprint of the Jordan-cell coupling: invisible in the trace but essential in the full representation.</li>
<li><strong>Null Fraction Dilution Conjecture (OBSERVED)</strong>: As the group order grows (ζ₄ → ζ₈ → ζ₁₂), the null fraction decreases (75% → 37.5% → 3.0%). In an infinite group the null fraction approaches zero, consistent with the hypothesis that nulls are a finite-group boundary effect — the discrete S¹ spectrum collapses, and the half-angle=90° entries become an infinitesimal measure.</li>
</ul>
<h3>Connection to Reservoir Computing (Pillar 5)</h3>
<p>Reservoir Computing (RC) uses a high-dimensional fixed dynamical system (the reservoir) to project inputs into a space where linear readout can separate otherwise inseparable patterns. The critical requirement is that the reservoir maintains a rich, high-dimensional manifold — the "separation property." Null states in an RC reservoir are states that produce zero output under the readout (analogous to Re(q)=0, trace=0). The standard assumption is that null reservoir states are wasted capacity.</p>
<p><a href="./entries/demo_84.html">Demo 84</a> directly refutes this for the quaternionic DKC setting:</p>
<p>1. The 9 null entries maintain 6 directions (cube-edge-midpoints) that are absent from non-null entries. In RC terms: null reservoir states hold the manifold open in directions that active states do not cover. 2. Removing nulls drops XOR capacity by one full level, even though the remaining 15 entries have more information per entry (non-zero Re(q)). In RC terms: removing null states collapses the reservoir manifold in specific directions, destroying the separation property for higher-order parity functions. 3. The k_sec=1 result shows that null-only states provide more directional separation than non-null-only states. In RC terms: null states provide better geometric coverage of the output space even though they produce zero scalar readout.</p>
<p>The LCFT connection deepens this: the logarithmic partners of null states carry the actual computational content via Jordan cells. In a Jordan-cell representation, the null state and its partner form a 2×2 block with 1 on the superdiagonal. The null state alone is computationally invisible (Re=0), but the partner cannot be defined without the null state (the Jordan cell requires both). Removing the null state removes the partner's anchor — the capacity collapses.</p>
<h3>Connection to LCFT (Logarithmic Conformal Field Theory)</h3>
<p>In LCFT, a null state |N⟩ satisfies ⟨N|N⟩ = 0 but |N⟩ ≠ 0. The state is paired with a logarithmic partner |L⟩ through a non-diagonalizable (Jordan-cell) action of the Virasoro zero-mode L₀:</p>
<p><code></code>` L₀ |N⟩ = h |N⟩ L₀ |L⟩ = h |L⟩ + |N⟩ <code></code>`</p>
<p>The two-point function of |N⟩ vanishes, but the mixed two-point function ⟨N|L⟩ is nonzero. The computational content lives in the Jordan-cell coupling, not in |N⟩ alone.</p>
<p>In the quaternionic DKC context: bracket-null entries (Re(q)=0) are the |N⟩ states — their Kauffman bracket trace vanishes, making them "invisible" to the scalar invariant. Their logarithmic partners are the non-null entries that share the same S² direction (the "both" entries in Part E — the 3 coordinate-axis directions). The shared-direction entries form the Jordan-cell analog: they are computationally active (non-zero trace) but geometrically tethered to the null state's axis.</p>
<p>The 6 null-only directions (cube-edge-midpoints, no non-null partner) have no logarithmic partner in the catalog — consistent with the observation that removing these directions (via removing the null entries) destroys capacity rather than just reducing it.</p>
<h3>Data</h3>
<ul>
<li>ζ₈ catalog size: 24 entries, 4 closure rounds (depths 0–3)</li>
<li>Null count by depth: d=0: 0/5 (0%), d=1: 2/10 (20%), d=2: 6/8 (75%), d=3: 1/1 (100%)</li>
<li>Distinct |Re(q)| values: 4 — {0, 0.5, 0.707, 1.0}</li>
<li>Hard gap: 0.5 (from null at 0 to nearest non-null at 0.5)</li>
<li>Direction breakdown: 6 null-only (cube-edge-midpoints, 1/√2 components), 4 non-null-only (tetrahedral axes, 1/√3 components), 3 shared (coordinate axes)</li>
<li>Directional efficiency: null = 1.00 dir/entry, non-null = 0.47 dir/entry</li>
<li>Full catalog capacity: XOR8 (13 dirs, 2 angles)</li>
<li>Non-null subset (15 entries, 7 dirs): XOR6</li>
<li>Null-only subset (9 entries, 9 dirs): XOR6</li>
<li>Random-15 mean max_xor: 7.8 (non-null-only at 6.0 is below this baseline)</li>
<li>k_sec sweep (null-only XOR6 count): flat across k=1,2,4,6,8 (confirms single S¹ sector)</li>
<li>XOR6 null prevalence: 0.344 mean nulls per winner (ratio 0.31 vs. expected 9/24)</li>
<li>XOR8 null prevalence: 1.188 mean nulls per winner (ratio 0.79 vs. expected 9/24)</li>
<li>Cross-root null fraction: ζ₄=75.0%, ζ₈=37.5%, ζ₁₂=3.0%</li>
<li>ζ₁₂ direction breakdown (at 4096-entry truncation): 29 null-only, 453 non-null-only, 30 shared</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong><code>classify_null(cat_size)</code></strong>: classifies each catalog entry as null (|Re(q)| &lt; 1e-10) or non-null; fills <code>is_null[]</code> array; returns null count</li>
<li><strong><code>null_idx[]</code> / <code>nonnull_idx[]</code> arrays</strong>: index arrays for partition into null and non-null subsets, built once after <code>classify_null</code>; reused throughout Parts C–F</li>
<li><strong><code>load_subset(indices, count)</code></strong>: loads an arbitrary subset of the saved catalog into <code>g_cat[]</code> for capacity measurement; enables non-null-only and null-only experiments without separate catalog arrays</li>
<li><strong><code>save_catalog()</code> / <code>restore_catalog()</code></strong>: snapshot/restore pattern from <a href="./entries/demo_82.html">Demo 82</a>, extended here with <code>g_writhe[]</code> tracking alongside depth</li>
<li><strong><code>find_capacity(cat_size, CapResult *r)</code></strong>: unified capacity driver (builds dirs, counts angles, runs XOR6 brute force + recursive extension chain); returns <code>CapResult</code> struct with dirs, angles, xor6, xor8, xor10, xor12, max_xor</li>
<li><strong><code>count_xor6_at_k(bf_limit, k_sec)</code></strong>: XOR6 count at a fixed k_sec without winner storage; used for the k_sec sweep in Part C.4</li>
<li><strong><code>random_subset(subset, subset_size, total_size)</code></strong>: Fisher-Yates partial shuffle producing a random size-N subset of [0, total_size); used for 100-trial random-control experiment in Part C.3</li>
<li><strong><code>g_writhe[]</code> tracking</strong>: writhe accumulated through closure rounds (generator writhes defined as ±1 per generator type); enables depth×writhe cross-tabulation for Part A null census</li>
<li><strong>Direction geometry analysis (Part E)</strong>: per-direction null/non-null count arrays; classifies each direction as null-only, non-null-only, or both; computes directional efficiency ratio</li>
<li><strong>Cross-root comparison loop (Part F)</strong>: calls <code>init_su2()</code> with π/6 (ζ₁₂) and π/2 (ζ₄), runs <code>build_closure()</code>, <code>classify_null()</code>, and direction analysis for each; produces unified comparison table</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>Gurarie (1993) / Flohr (1996) / Gaberdiel &amp; Kausch (1996)</strong>: Logarithmic CFT — null states paired with logarithmic partners via Jordan-cell L₀ action. The null entries here (Re(q)=0, trace=0) are the DKC analog of LCFT null states; their logarithmic partners carry the computational content through the Jordan-cell coupling.</li>
<li><strong>Habiro (2002) / Z[ζ₈] bracket</strong>: the 24-element ζ₈ catalog is the algebraic substrate established in <a href="./entries/demo_26.html">Demos 26</a>–<a href="./entries/demo_29.html">29</a>; <a href="./entries/demo_84.html">Demo 84</a> shows that 9/24 of those entries are bracket-null, revealing previously invisible structure within this established catalog.</li>
<li><strong>Aizenberg (2008)</strong>: k-sector MVN activation; the k_sec sweep in Part C.4 decomposes S¹ (angular) vs S² (directional) contributions to XOR capacity, extending the sector framework to a null/non-null anatomy.</li>
<li><strong>Jaeger, Vertigan &amp; Welsh (1990) / Kuperberg (2015)</strong>: #P-hardness of Jones polynomial; null states correspond to the algebraically simplest (zero-trace) representations, yet their geometric contribution is essential — hardness lives in the interplay of null and non-null structure.</li>
<li><strong>Reservoir Computing (Jaeger 2001, Maass et al. 2002)</strong>: echo state networks / liquid state machines; the null-state separation-property argument directly parallels the RC requirement that reservoir null states maintain the high-dimensional manifold enabling linear readout.</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li><strong>Are there null entries in the ζ₁₂ catalog that are similarly indispensable?</strong> At 3% null fraction (121/4096), the null entries are a small minority, but Part F shows 29 null-only directions — are any of those directions essential for the XOR12 solutions found in <a href="./entries/demo_79.html">Demo 79</a>?</li>
<li><strong>Can the LCFT Jordan-cell structure be made explicit?</strong> The 3 shared directions (coordinate axes) appear in both null and non-null entries. Do these pairs (null entry on axis X, non-null entry on axis X) form a literal Jordan-cell pair in some representation of the braid group algebra?</li>
<li><strong>What is the null entry count for ζ₁₀ (Fibonacci anyons)?</strong> ζ₁₀ was identified as infinite in <a href="./entries/demo_80.html">Demo 80</a> with 71 distinct half-angles at 4096 entries. The null fraction and directional role of null entries at ζ₁₀ has not been measured.</li>
<li><strong>Does the depth=3 → 100% null result generalize?</strong> In ζ₈, every depth-3 entry is bracket-null. Is this a general theorem — does the maximum-depth stratum of any finite SU(2) subgroup consist entirely of null entries?</li>
<li><strong>Null entries and knot complexity</strong>: <a href="./entries/demo_82.html">Demo 82</a> established that crossing depth governs XOR capacity. Bracket-null entries are maximally deep (depth-3 in ζ₈). Does the connection between nullness, depth, and LCFT have a direct knot-theoretic interpretation — e.g., do depth-d null entries correspond to specific knot types whose Jones polynomial vanishes at δ=0?</li>
<li><strong>RC exactification</strong>: The RC null-state hypothesis now has a precise DKC analog. Can the quaternionic DKC framework be used to design reservoir weight matrices where null-state geometry is explicitly controlled, yielding provably optimal XOR capacity per parameter?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_85.html">Demo 85</a>: Indecomposability Parameter b for TL_n at delta=0</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_85_indecomposability/main.c.html">demo_85_indecomposability/main.c</a></code> (~6861 lines)</li>
<li><strong>Tests</strong>: 58/58 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_51.html">Demo 51</a> (TL algebra infrastructure, Gram matrix, radical basis), <a href="./entries/demo_35.html">Demo 35</a> (integer TL generators at delta=0)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_86.html">Demo 86</a> (direct b on single P_{0,0} -- negative result, divergence), <a href="./entries/demo_87.html">Demo 87</a>+ (non-semisimplicity thesis, logarithmic CFT structure constants)</li>
</ul>
<h3>Headline</h3>
The indecomposability parameter b = -5/8 (Pearce-Rasmussen) is computed exactly from first principles at TL_4 using leading-coefficient extraction from the delta-parameterized Markov trace on the full regular representation. The literature "controversy" between b = -2 (GRS) and b = -5/8 (PR) dissolves: b_delta = -5/2 on the regular rep divides by dim(0-TL sector) = 4 to give b_PR = -5/8 exactly to 12 decimal places.
<h3>Key Results</h3>
<ul>
<li><strong>b = -5/8 confirmed at TL_4</strong>: leading-coefficient extraction from delta-parameterized Gram matrix on the full 14-dimensional regular representation gives b_delta = -5/2. Normalizing by the 0-TL sector dimension (4 diagrams with zero through-lines) yields b_PR = -5/2 / 4 = -5/8, exact to 12 decimal places.</li>
<li><strong>Valuation condition</strong>: the method requires p_tt = 2 <em> p_Tt (where p_tt and p_Tt are the minimum delta-powers in the bilinear forms). At TL_4: p_tt = 2, p_Tt = 1, so 2 = 2</em>1 -- satisfied. At TL_6: p_tt = 4, p_Tt = 3, so 4 != 6 -- fails, b diverges as delta^{-2}.</li>
<li><strong>-2 vs -5/8 resolved</strong>: these are NOT competing predictions. b = -5/8 is the per-cell (physical/lattice) value. b = -5/2 is the regular-representation value. The factor of 4 = dim(0-TL sector for TL_4) = C_2 = number of 0-through-line diagrams. The quantum group approach (GRS) uses different normalization conventions for the bilinear form.</li>
<li><strong>Standard modules are fully diagonalizable</strong>: H on W_{n,0} (standard module = link states) has NO Jordan blocks at any size tested (n=4,6,8,10,12). Jordan blocks only exist on projective covers (P_{0,0}) and the full regular representation. This falsifies Gemini's claim that b is extracted from standard module Jordan structure.</li>
<li><strong>Fixed-point form is degenerate</strong>: the fixpt-trace bilinear form G[i][j] = fixpt(star(i)*j) is too degenerate at delta=0 -- almost all products create loops -&gt; 0. It gives an affine b with 3-dimensional gauge freedom (TL_4) or all zeros (TL_6). Not the right form.</li>
<li><strong>Delta-parameterized Markov trace is the correct form</strong>: G_delta[i][j] = delta^{L(i,j)} where L = compose_loops + closure_loops. This form is non-degenerate at delta != 0 and the leading-coefficient extraction as delta -&gt; 0 gives the physical b.</li>
<li><strong>Projective cover P_{0,0} has Jordan blocks at nonzero eigenvalues</strong>: TL_4 P_{0,0} (dim=5, composition 0-TL:2 + 2-TL:3) has eigenvalues from char poly x(x^2-2)^2, with Jordan blocks at lambda = +/-sqrt(2), NOT at lambda = 0. The 0-TL left ideals (dim=2) equal W_{0,0} and have no Jordan blocks -- they are too small.</li>
<li><strong>TL_3 is semisimple</strong>: L_H on the 5-dimensional TL_3 algebra is fully diagonalizable (radical dimension 0). TL_2 (dim=2) has Jordan blocks. TL_4 (dim=14) and TL_5 (dim=42) have Jordan blocks in the regular representation.</li>
<li><strong>Gauge analysis (bonus)</strong>: the fixed-point form has 3-dimensional gauge freedom at TL_4. Full quadratic decomposition: M (quadratic coefficient matrix) = 0, E (linear denominator) = 0, so b_fixpt(c) is purely AFFINE in gauge parameters. Both -2 and -5/8 are reachable points on this flat manifold. The delta-form breaks the degeneracy.</li>
<li><strong>TL_6 divergence is structural</strong>: all 14 kernel directions at TL_6 introduce lower-power cross-terms; 0 safe directions exist. The 25-fold multiplicity (dim(0-TL for TL_6)^2 = 25) does not rescue the valuation condition as the 4-fold multiplicity does at TL_4.</li>
<li><strong>Cross-model verification</strong>: both Gemini 3 Pro and GPT-5 (Codex) independently confirmed the factor-of-4 relationship and dim(0-TL)^2 multiplicity structure. Gemini's claim about standard-module Jordan blocks was FALSIFIED by computation.</li>
<li><strong>Spin chain at q=i</strong>: Phase 4 builds the TL representation on (C^2)^{tensor n} at q=i (delta=0). Verified e_i^2=0, braid relation, far commutativity. H is symmetric (conformal/transpose form). Jordan blocks found at specific eigenvalues; b computed via augmented RREF for Jordan partner solve + minimum-norm gauge projection.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>b = -5/8 for dense polymers at delta=0 (DEMONSTRATED at TL_4)</strong>: exact computation via leading-coefficient extraction from delta-parameterized Gram matrix on full regular representation, normalized by 0-TL sector dimension.</li>
<li><strong>Valuation condition p_tt = 2*p_Tt (VERIFIED at TL_4, FAILS at TL_6)</strong>: this condition is necessary for the leading-coefficient method to produce a finite b. Its failure at TL_6 means the regular-representation approach requires modification for larger lattices.</li>
<li><strong>Standard modules have no Jordan blocks at delta=0 (DEMONSTRATED at n=4,6,8,10,12)</strong>: H on W_{n,0} is fully diagonalizable at every size tested. The min poly is square-free (gcd(mu,mu') degree = 0) at all sizes. Jordan structure lives exclusively in projective covers.</li>
<li><strong>TL algebra dimensions match Catalan numbers (VERIFIED)</strong>: dim(TL_n) = C_n at n=2,3,4,5,6. dim(W_{n,0}) = C_{n/2} at n=4,6,8,10,12.</li>
<li><strong>e_i^2 = 0 at delta=0 (VERIFIED)</strong>: all TL relations (e_i^2=delta<em>e_i, braid relation e_i</em>e_{i+1}*e_i = e_i, far commutativity) verified on both link-state standard module (n=6) and spin chain representation (n=4).</li>
<li><strong>Fixed-point form gauge manifold is flat (DEMONSTRATED at TL_4)</strong>: the quadratic coefficient matrix M = 0, making b_fixpt an affine function of gauge parameters with no unique critical point.</li>
</ul>
<h3>Data</h3>
<ul>
<li>TL algebra dimensions: TL_2=2, TL_3=5, TL_4=14, TL_5=42, TL_6=132</li>
<li>Standard module dimensions: W_{4,0}=2, W_{6,0}=5, W_{8,0}=14, W_{10,0}=42, W_{12,0}=132</li>
<li>TL_4 regular rep: b_delta = -5/2, 0-TL sector dim = 4 (diagrams: id, e_1, e_2, e_1*e_2), b_PR = -5/8</li>
<li>TL_4 standard module H: eigenvalues +/-sqrt(2), 2x2 matrix [[0,-2],[-1,0]], fully diagonalizable</li>
<li>TL_4 P_{0,0}: dim=5, composition 0-TL:2 + 2-TL:3, char poly x(x^2-2)^2, Jordan blocks at lambda=+/-sqrt(2)</li>
<li>TL_4 leading coefficients: p_Tt=1, coeff_Tt computed; p_tt=2, coeff_tt computed; valuation 2=2*1 satisfied</li>
<li>TL_6 leading coefficients: p_Tt=3, p_tt=4; valuation 4 != 6 FAILS; diverges as delta^{-2}; 0/14 safe directions</li>
<li>Spin chain Sz=0 dimensions: n=4 -&gt; dim=6, n=6 -&gt; dim=20, n=8 -&gt; dim=70</li>
<li>b accuracy: |b_PR - (-5/8)| &lt; 10^{-12}</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>Link state enumeration (<code>enumerate_link_states</code>)</strong>: recursive non-crossing perfect matching generator for W_{n,0}, sizes n=4 through n=12</li>
<li><strong>e_i action on link states (<code>apply_ei</code>)</strong>: TL generator action with loop detection at delta=0</li>
<li><strong>Hamiltonian construction (<code>build_hamiltonian</code>)</strong>: H = -(e_0+...+e_{n-2}) on standard module</li>
<li><strong>Gauss rank with partial pivoting (<code>gauss_rank</code>)</strong>: fraction-free rank computation for integer matrices</li>
<li><strong>Jordan analysis (<code>jordan_analysis</code>)</strong>: ker(M) vs ker(M^2) comparison for Jordan block detection at given eigenvalue</li>
<li><strong>Modular arithmetic suite</strong>: mod_pos, mod_mul, mod_add, mod_sub, mod_pow, mod_inv over prime 10^9+7</li>
<li><strong>Faddeev-LeVerrier characteristic polynomial (<code>char_poly_mod</code>)</strong>: modular char poly computation</li>
<li><strong>Polynomial GCD mod p (<code>poly_gcd_degree_mod</code>)</strong>: Euclidean algorithm for diagonalizability test</li>
<li><strong>Minimal polynomial via Krylov iteration (<code>min_poly_mod</code>)</strong>: definitive Jordan block detection via gcd(mu,mu')</li>
<li><strong>Full TL algebra infrastructure</strong>: <code>AlgDiagram</code> type, basis enumeration (<code>alg_enumerate_basis</code>), composition with loop counting (<code>alg_compose</code>), multiplication table (<code>alg_compute_mult_table</code>), identity/generator construction, star anti-involution</li>
<li><strong>Star operation (<code>alg_star</code>, <code>alg_compute_star_indices</code>)</strong>: top/bottom flip for adjoint diagrams</li>
<li><strong>Through-line sector analysis (<code>analyze_through_line_sectors</code>)</strong>: classifies basis by through-line count, checks L_H sector preservation</li>
<li><strong>Left ideal closure (<code>left_ideal_closure</code>)</strong>: BFS closure under left multiplication for projective cover construction</li>
<li><strong>Null space extraction (<code>extract_null_space</code>, <code>extract_null_space_d</code>)</strong>: RREF-based null space for integer and double matrices</li>
<li><strong>Eigenvalue sweep (<code>find_eigenvalues_sweep</code>)</strong>: sign-change + golden-section refinement for real eigenvalues; handles both simple and double roots</li>
<li><strong>Geometric multiplicity (<code>geometric_multiplicity</code>)</strong>: rank-based computation at given eigenvalue</li>
<li><strong>Complex arithmetic suite</strong>: Cx type with add/sub/mul/div/neg/abs, cx_mat_mul, cx_mat_vec, cx_null_space, cx_absdet</li>
<li><strong>Spin chain representation</strong>: Sz=0 basis enumeration (<code>sc_enumerate_sz0</code>), generator action at q=i (<code>sc_apply_ei</code>), generator/Hamiltonian matrix builders</li>
<li><strong>Complex eigenvalue finder (<code>cx_find_real_evals</code>)</strong>: |det| local-minimum sweep with golden-section refinement for complex matrices</li>
<li><strong>Delta-parameterized Gram/Hamiltonian builders</strong>: <code>build_gram_matrix_delta</code>, <code>build_hamiltonian_delta</code> for perturbation analysis</li>
<li><strong>Leading-coefficient extraction (Phase 6)</strong>: per-pair delta-power computation L[i][j] = compose_loops + closure_loops, minimum power detection, coefficient summation, both Gram (star) and Trace (no star) forms</li>
<li><strong>Gauge analysis infrastructure</strong>: full N-dimensional coset scan computing A, D, L, E, M matrices for quadratic b decomposition; critical point finding via Cramer's rule (3D case)</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>Gainutdinov-Read-Saleur (GRS)</strong>: quantum group / algebraic definition of b, projective cover approach. <a href="./entries/demo_85.html">Demo 85</a> shows this gives different normalization (b = -2 under GRS conventions) but the same underlying structure.</li>
<li><strong>Pearce-Rasmussen (PR)</strong>: finite-size lattice scaling approach giving b = -5/8. <a href="./entries/demo_85.html">Demo 85</a> confirms this is the per-cell physical value.</li>
<li><strong>Symplectic fermion continuum theory at c=-2</strong>: b = -2 predicted (GRS convention). <a href="./entries/demo_85.html">Demo 85</a> shows the exact relationship: b_GRS convention differs from b_PR convention by normalization factor.</li>
<li><strong>Gemini 3 Pro literature claims (FALSIFIED)</strong>: Gemini claimed b is extracted from off-diagonal Jordan cell coupling in standard modules. <a href="./entries/demo_85.html">Demo 85</a> proved standard modules are fully diagonalizable at all tested sizes -- Jordan blocks only exist on projective covers.</li>
<li><strong>Faddeev-LeVerrier algorithm</strong>: used for characteristic polynomial computation in both modular and complex arithmetic.</li>
<li><strong>Krylov iteration</strong>: used for minimal polynomial computation (definitive Jordan block test).</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li><strong>Why does the valuation condition fail at TL_6?</strong> The structural reason for p_tt = 4, p_Tt = 3 (gap = -2) at TL_6 is understood (cross-copy interference from 25-fold multiplicity), but is there a modified extraction that works for larger sizes?</li>
<li><strong>Can b = -5/8 be confirmed at TL_6 or TL_8?</strong> The regular-representation approach diverges. The standard module has no Jordan blocks. The single P_{0,0} also diverges (<a href="./entries/demo_86.html">Demo 86</a>). What is the correct finite-lattice method beyond TL_4?</li>
<li><strong>How does the literature (PR) actually compute b at larger lattice sizes?</strong> The method likely uses transfer matrix + finite-size scaling, not the diagram-algebraic approach tested here. Identifying and implementing their exact method remains open.</li>
<li><strong>Does the spin chain approach give b = -2 at larger sizes?</strong> Phase 4 computes b on (C^2)^{tensor n} at q=i. Results at n=4,6,8 should be compared with the algebraic approach. The conformal (transpose) bilinear form may give different normalization.</li>
<li><strong>What is the relationship between b and the DKC computational capacity?</strong> The k_sec=1 synergy value (36) from <a href="./entries/demo_84.html">Demo 84</a> was hypothesized to encode b. This connection remains unexplored.</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_86.html">Demo 86</a>: Direct b on Single P_{0,0} via Delta-Parameterized Forms</h2>
<ul>
<li><strong>Status</strong>: COMPLETE (NEGATIVE RESULT)</li>
<li><strong>File</strong>: <code><a href="../demo_86_b_direct/main.c.html">demo_86_b_direct/main.c</a></code> (~1787 lines)</li>
<li><strong>Tests</strong>: 15/15 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_85.html">Demo 85</a> (TL algebra infrastructure, left ideal construction, b = -5/8 on regular representation at TL_4)</li>
<li><strong>Feeds into</strong>: Open — the actual literature method for computing b at larger lattice sizes remains to be identified and implemented; dense polymer fusion calculation (narrative.md seed)</li>
</ul>
<h3>Headline</h3>
The delta-parameterized Gram matrix approach universally diverges on a single projective cover P_{0,0} at every eigenvalue, every lattice size, and for both loop and trace forms. The multiplicity from the regular representation is structurally essential to the b computation, not just a scale factor. This is a novel negative finding — nobody in the literature has tried this specific approach.
<h3>Key Results</h3>
<ul>
<li><strong>Universal divergence</strong>: the valuation condition p_tt = 2*p_Tt never holds on a single P_{0,0}. The delta-form b computation returns NaN (diverges) at every eigenvalue tested, for both loop form (predicting b = -5/8, Pearce-Rasmussen) and trace form (predicting b = -2, GRS).</li>
<li><strong>Exhaustive eigenvalue scan</strong>: TL_4 tested at lambda = 0, +/-sqrt(2); TL_6 tested at lambda = 0, +/-1, +/-sqrt(3), +/-(sqrt(3)+1), +/-(sqrt(3)-1). All diverge with negative gap (p_tt &lt; 2*p_Tt).</li>
<li><strong>TL_8 P_{0,0} is completely semisimple</strong>: no Jordan blocks at lambda=0 on the dim-42 ideal. The non-semisimple structure that enables b computation does not persist at this lattice size on P_{0,0} alone.</li>
<li><strong>Full regular rep at TL_6 also diverges</strong>: the same d^{-2} gap appears in the full regular representation at TL_6. The TL_4 success (<a href="./entries/demo_85.html">Demo 85</a>) may be coincidental — cross-copy terms provide the right extra delta-power at TL_4 but fail at TL_6.</li>
<li><strong>Generator independence confirmed</strong>: all 2-through-line generators produce identical ideals and identical divergence patterns.</li>
<li><strong>Projective-cover-exclusive eigenvalues discovered</strong>: TL_6 P_{0,0} has eigenvalues +/-(sqrt(3)+/-1) that do not appear on the standard module W_0 — these are structurally intrinsic to the projective cover.</li>
<li><strong>Gemini cross-model check partially wrong</strong>: Gemini 3 Pro confirmed TL_4 eigenvalues and ground state formula E_GS = -2cos(pi/n), but got TL_6 wrong (predicted standard module spectrum, missing projective-cover-exclusive eigenvalues).</li>
<li><strong>Gemini literature claim falsified by <a href="./entries/demo_85.html">Demo 85</a></strong>: Gemini claimed the standard method extracts b from Jordan cell coupling on standard modules. <a href="./entries/demo_85.html">Demo 85</a> proved standard modules have no Jordan blocks at any tested size (n=4,6,8,10,12). Jordan blocks only exist on P_{0,0} (projective covers).</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Delta-form divergence on single P_{0,0} (DEMONSTRATED)</strong>: the delta-parameterized Gram matrix approach universally diverges. This is a novel negative finding — the approach has not been tried in the literature.</li>
<li><strong>Multiplicity essentiality (DEMONSTRATED)</strong>: the dim(V_0)^2 multiplicity from the regular representation is not a removable scale factor. It participates in the valuation balance required for the b ratio to converge.</li>
<li><strong>P_{0,0} dimension pattern (OBSERVED)</strong>: dim(P_{0,0}) at TL_n = C_{n/2+1} (next Catalan number): TL_4 -&gt; 5 = C_3, TL_6 -&gt; 14 = C_4, TL_8 -&gt; 42 = C_5.</li>
<li><strong>Pearce-Rasmussen method conjecture (OPEN)</strong>: the actual PR method likely works on P_{0,0} directly but extracts b from the Jordan cell coupling L_0|t&gt; = |T&gt; + b|T&gt; structure, NOT from delta-parameterized Gram matrices.</li>
</ul>
<h3>Data</h3>
<ul>
<li><strong>TL_4 P_{0,0}</strong>: dim=5, char poly x(x^2-2)^2, Jordan blocks at lambda=+/-sqrt(2) only</li>
<li><strong>TL_6 P_{0,0}</strong>: dim=14, char poly x^2(u-1)(u-3)(u^2-8u+4)^2 where u=x^2, Jordan blocks at lambda = 0, +/-(sqrt(3)+1), +/-(sqrt(3)-1)</li>
<li><strong>TL_8 P_{0,0}</strong>: dim=42, completely semisimple at lambda=0</li>
<li><strong>Divergence table</strong>:</li>
</ul>
<table><thead><tr><th>Size</th><th>lambda</th><th>Form</th><th>p_Tt</th><th>p_tt</th><th>2*p_Tt</th><th>Gap</th></tr></thead><tbody><tr><td>TL_4</td><td>+/-sqrt(2)</td><td>loop</td><td>2</td><td>2</td><td>4</td><td>-2</td></tr><tr><td>TL_4</td><td>+/-sqrt(2)</td><td>trace</td><td>1</td><td>1</td><td>2</td><td>-1</td></tr><tr><td>TL_6</td><td>0</td><td>loop</td><td>3</td><td>4</td><td>6</td><td>-2</td></tr><tr><td>TL_6</td><td>0</td><td>trace</td><td>3</td><td>2</td><td>6</td><td>-4</td></tr><tr><td>TL_6</td><td>+/-(sqrt(3)+1)</td><td>loop</td><td>3</td><td>3</td><td>6</td><td>-3</td></tr><tr><td>TL_6</td><td>+/-(sqrt(3)+1)</td><td>trace</td><td>1</td><td>1</td><td>2</td><td>-1</td></tr><tr><td>TL_6</td><td>+/-(sqrt(3)-1)</td><td>loop</td><td>3</td><td>3</td><td>6</td><td>-3</td></tr><tr><td>TL_6</td><td>+/-(sqrt(3)-1)</td><td>trace</td><td>1</td><td>1</td><td>2</td><td>-1</td></tr></tbody></table>
<ul>
<li><strong>Formal coefficient ratios</strong> (divergent, for reference): TL_4 lambda=-sqrt(2) loop gives 1/2; TL_6 lambda=0 loop gives -5/18. Neither matches -5/8 or -2.</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong>TL algebra infrastructure</strong> (reused from <a href="./entries/demo_85.html">Demo 85</a>): <code>alg_init()</code>, <code>alg_enumerate_basis()</code>, <code>alg_compose()</code>, <code>alg_compute_mult_table()</code>, <code>alg_star()</code>, <code>alg_closure_loops()</code>, <code>alg_count_through()</code></li>
<li><strong>Left ideal construction</strong> (reused from <a href="./entries/demo_85.html">Demo 85</a>): <code>left_ideal_closure()</code> — BFS closure under left multiplication at delta=0</li>
<li><strong><code>build_restricted_hamiltonian()</code></strong>: constructs L_H = -(e_0 + ... + e_{n-2}) restricted to a left ideal subspace with invariance verification</li>
<li><strong><code>compute_b_on_ideal()</code></strong>: delta-form b computation on integer Hamiltonian (lambda=0); finds Jordan partners via ker(L_H^2)\ker(L_H), computes loop power matrix, extracts leading delta-power coefficients</li>
<li><strong><code>compute_b_shifted()</code></strong>: double-precision version for irrational eigenvalues (lambda != 0); same algorithm but with floating-point shifted operator M = L_sub - lambda*I</li>
<li><strong><code>compute_loop_power()</code></strong>: computes total loop count for G_delta[i][j] using star (loop form) or direct (trace form) composition</li>
<li><strong>Modular arithmetic suite</strong>: <code>mod_pos</code>, <code>mod_mul</code>, <code>mod_add</code>, <code>mod_sub</code>, <code>mod_pow</code>, <code>mod_inv</code> over prime 10^9+7; used for minimal polynomial and characteristic polynomial computation</li>
<li><strong><code>min_poly_mod()</code></strong>: minimal polynomial via Krylov iteration mod p — used for Jordan block detection via square-freeness test</li>
<li><strong><code>has_jordan_blocks()</code></strong>: detects Jordan blocks by checking gcd(mu, mu') degree &gt; 0</li>
<li><strong><code>extract_null_space()</code></strong>: double-precision RREF null space extraction</li>
<li><strong><code>gauss_rank()</code></strong>: Gaussian elimination rank computation for integer matrices</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>Pearce-Rasmussen</strong>: b = -5/8 value for the indecomposability parameter at delta=0 (critical dense polymers); the demo attempts to reproduce this via a different (ultimately unsuccessful) method</li>
<li><strong>Graham-Read-Rasmussen (GRS)</strong>: b = -2 value from the algebraic trace form; the demo tests this form alongside the loop form, both diverge</li>
<li><strong>Belletete et al.</strong>: tilting module classification referenced in earlier planning (the demo was originally conceived as a tilting module decomposition test, pivoted to direct b computation)</li>
<li><strong>Gainutdinov et al. (2013)</strong>: dense polymer fusion calculation at p=2; <a href="./entries/demo_86.html">Demo 86</a> seeds this as a future direction for algebraic description of DKC composition</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>How does the literature actually compute b at lattice sizes beyond TL_4? The delta-parameterized Gram matrix approach fails; the standard modules have no Jordan blocks; the actual Pearce-Rasmussen method remains unidentified.</li>
<li>Is there a different bilinear form or representation choice that avoids the valuation divergence on single P_{0,0}?</li>
<li>Is b = -5/8 fundamentally a small-lattice (TL_4) phenomenon, or does the literature have a scaling/extrapolation method that works at larger sizes?</li>
<li>What is the structural reason for the universal d^{-2} gap? Is there a representation-theoretic explanation for why p_tt &lt; 2*p_Tt on a single copy?</li>
<li>Why is TL_8 P_{0,0} completely semisimple when TL_4 and TL_6 have Jordan blocks? Is there a periodicity or parity pattern in the non-semisimple structure?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_87.html">Demo 87</a>: Null Indispensability at zeta_12</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_87_null_indispensability/main.c.html">demo_87_null_indispensability/main.c</a></code> (~907 lines)</li>
<li><strong>Tests</strong>: 14/14 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_84.html">Demo 84</a> (null states and logarithmic structure at zeta_8, direction partition framework, null indispensability theorem), <a href="./entries/demo_79.html">Demo 79</a> (zeta_12 capacity, infinite group XOR12)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_88.html">Demo 88</a> (anti-correlation mechanism, cross-root comparison uses <a href="./entries/demo_87.html">D87</a> dispensability finding), Reservoir Computing pillar (null-state role depends on group regime)</li>
</ul>
<h3>Headline</h3>
Null indispensability is a finite-group phenomenon: at zeta_12 (infinite group, 4096 entries), bracket-null entries are directionally indispensable (67 exclusive S2 axes) but computationally dispensable (XOR capacity fully preserved without nulls) — a regime transition from zeta_8 where removing nulls destroys capacity.
<h3>Key Results</h3>
<ul>
<li><strong>zeta_8 control baseline (24 entries, 13 directions)</strong>: 9 null entries (37.5%), direction partition 6 null-only + 3 shared + 4 non-null-only = 13. Full catalog achieves XOR6=32, XOR8=32. Non-null-only (15 entries, 7 dirs) achieves XOR6=32 but XOR8=4. Removing nulls destroys XOR8 capacity. Confirms <a href="./entries/demo_84.html">Demo 84</a>'s findings as a baseline.</li>
<li><strong>zeta_12 catalog (4096 entries, 2043 directions)</strong>: 121 null entries (3.0%), appearing at depths 2-8. Direction partition: 67 null-only + 54 shared + 1922 non-null-only = 2043. Null fraction drops from 37.5% (zeta_8) to 3.0% (zeta_12).</li>
<li><strong>zeta_12 capacity preservation</strong>: Full catalog (4096 entries) and non-null-only subset (3975 entries) BOTH achieve XOR6=32, XOR8=32, XOR10=32, XOR12=32. Maximum XOR level and winner counts are identical. Removing 121 null entries has zero effect on computational capacity.</li>
<li><strong>Directional vs computational indispensability decoupling</strong>: At zeta_12, nulls are directionally indispensable (67 exclusive axes that no non-null entry reaches) but computationally dispensable. The 1976 non-null directions provide enough combinatorial diversity that losing 67 null-only directions does not constrain XOR solutions.</li>
<li><strong>Depth distribution</strong>: Null entries appear at depths 2-8 in zeta_12, with null fraction increasing at greater depths (consistent with zeta_8 pattern where depth-3 = 100% null). Detailed depth x null cross-tabulation computed per phase.</li>
<li><strong>Half-angle of null entries</strong>: All null entries have half-angle exactly 90 degrees. This is tautological: null means Re(q)=0 means half_angle = arccos(0) = 90 degrees by definition. Not a discovery.</li>
<li><strong>Truncation artifact caught and fixed</strong>: Initial run with MAX_DIR=600 truncated zeta_12's true 2043 directions to 600, producing a wrong partition (39/30/531) and a spurious XOR12 drop (32 to 24). Increasing MAX_DIR to 2048 fixed the issue. The capacity drop was a measurement artifact, not a real finding.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Null Dispensability at Infinite Groups (DEMONSTRATED)</strong>: At zeta_12, removing all 121 bracket-null entries preserves full XOR capacity (XOR6/8/10/12 all 32 winners). Null indispensability, demonstrated at zeta_8 in <a href="./entries/demo_84.html">Demo 84</a>, does not generalize to infinite groups.</li>
<li><strong>Regime Transition Theorem (DEMONSTRATED)</strong>: There is a qualitative transition between finite groups (zeta_8: nulls computationally critical, 37.5% of catalog, 6/13 exclusive directions in a sparse direction set) and infinite groups (zeta_12: nulls computationally redundant, 3% of catalog, 67/2043 exclusive directions in a dense direction set). The transition mechanism is direction density — when the non-null direction count is large enough, losing null-only directions cannot constrain combinatorial search.</li>
<li><strong>Null Fraction Dilution (CONFIRMED)</strong>: zeta_4 = 75%, zeta_8 = 37.5%, zeta_12 = 3.0%. The null fraction decreases sharply as group order grows, consistent with the <a href="./entries/demo_84.html">Demo 84</a> conjecture that nulls approach measure zero in infinite groups.</li>
<li><strong>Directional Indispensability Without Computational Indispensability (NEW OBSERVATION)</strong>: Owning exclusive S2 directions is necessary but not sufficient for computational indispensability. The question is whether the remaining directions provide enough combinatorial diversity for XOR solutions — at zeta_8 they do not (too sparse), at zeta_12 they do (dense enough).</li>
</ul>
<h3>Data</h3>
<ul>
<li>zeta_8 catalog: 24 entries, 13 directions, 9 null (37.5%), 4 closure rounds</li>
<li>zeta_8 direction partition: 6 null-only, 3 shared, 4 non-null-only</li>
<li>zeta_8 capacity: Full XOR8=32, Non-null XOR8=4 (capacity destroyed)</li>
<li>zeta_12 catalog: 4096 entries, 2043 directions, 121 null (3.0%)</li>
<li>zeta_12 direction partition: 67 null-only, 54 shared, 1922 non-null-only</li>
<li>zeta_12 capacity (full): XOR6=32, XOR8=32, XOR10=32, XOR12=32</li>
<li>zeta_12 capacity (non-null only, 3975 entries): XOR6=32, XOR8=32, XOR10=32, XOR12=32</li>
<li>Brute-force limit for zeta_12: bf_limit=100 (first 100 entries for XOR6 triple search)</li>
<li>K_LADDER values tested: {1, 6, 8, 10, 12, 16, 20, 24}</li>
<li>MAX_DIR bug: initial 600 truncated to wrong results; fixed at 2048</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong><code>classify_null(cat_size)</code></strong>: classifies each catalog entry as null (|Re(q)| &lt; 1e-10) or non-null; fills <code>is_null[]</code>, <code>null_idx[]</code>, <code>nonnull_idx[]</code> arrays with counts <code>n_null_total</code>, <code>n_nonnull_total</code></li>
<li><strong><code>compute_dir_partition(cat_size)</code></strong>: builds direction catalog and classifies each direction as null-only, non-null-only, or shared; returns <code>DirPartition</code> struct with counts; also fills <code>dir_null_cnt[]</code> and <code>dir_nonnull_cnt[]</code> per-direction arrays</li>
<li><strong><code>DirPartition</code> struct</strong>: {total_dirs, null_only, nonnull_only, shared} — reusable partition type</li>
<li><strong><code>load_subset(indices, count)</code></strong>: loads arbitrary subset of saved catalog into <code>g_cat[]</code> for capacity measurement; enables null-removal experiments</li>
<li><strong><code>save_catalog()</code> / <code>restore_catalog()</code></strong>: snapshot/restore pattern for catalog state including depth tracking</li>
<li><strong><code>find_capacity(cat_size, bf_limit, CapResult *r)</code></strong>: unified capacity pipeline — builds dirs, runs XOR6 brute force then recursive extension to XOR8/10/12; returns <code>CapResult</code> with n_dirs, xor6, xor8, xor10, xor12, max_xor</li>
<li><strong><code>CapResult</code> struct</strong>: {n_dirs, xor6, xor8, xor10, xor12, max_xor} — reusable capacity result type</li>
<li><strong><code>test_xor()</code> with early conflict detection</strong>: XOR test uses <code>cell_even[]</code>/<code>cell_odd[]</code> counters with touched-cell tracking for fast cleanup; <code>goto cleanup</code> on first conflict for early exit</li>
<li><strong><code>combined_cell()</code> with k_sec sectors</strong>: Sec x Vor activation using angular sectors and Voronoi direction cells; used with K_LADDER for multi-resolution capacity search</li>
<li><strong><code>find_xor6()</code> and <code>find_recursive(level, cat_limit)</code></strong>: two-stage winner search — brute-force triples for XOR6, then recursive extension for XOR8/10/12; stores winners in <code>g_win[][]</code> arrays</li>
<li><strong><code>g_depth[]</code> tracking through closure</strong>: each catalog entry records its generation depth during <code>build_closure()</code>; enables depth-stratified analysis in Phase 4</li>
<li><strong>Phase 1-4 modular structure</strong>: <code>phase1_catalog()</code>, <code>phase2_capacity()</code>, <code>phase3_direction_analysis()</code>, <code>phase4_depth()</code> — each phase is a self-contained function taking root_name as parameter, reusable for any root of unity</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>Gurarie (1993) / Flohr (1996) / Gaberdiel &amp; Kausch (1996)</strong>: LCFT null-state framework — <a href="./entries/demo_87.html">Demo 87</a> shows the LCFT null-state interpretation (null entries as Jordan-cell anchors) is regime-dependent: critical at finite groups, redundant at infinite groups where direction density absorbs the loss.</li>
<li><strong>Habiro (2002) / Z[zeta_8] bracket</strong>: the zeta_8 baseline confirms Habiro's algebraic substrate; the zeta_12 extension tests whether null-state structure persists beyond the finite-group regime.</li>
<li><strong>Reservoir Computing (Jaeger 2001, Maass et al. 2002)</strong>: <a href="./entries/demo_84.html">Demo 84</a>'s RC null-state hypothesis (null reservoir states hold the manifold open) is refined: this only applies in sparse-direction regimes. In dense-direction regimes (infinite groups), the non-null states alone provide sufficient manifold dimensionality.</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li><strong>Where exactly is the transition?</strong> Between zeta_8 (nulls indispensable) and zeta_12 (nulls dispensable), there must be a crossover point. Is it at a specific catalog size, direction count, or null fraction? Testing at intermediate sizes (e.g., zeta_10 or truncated zeta_12 catalogs) could locate the transition.</li>
<li><strong>Are the 67 null-only directions at zeta_12 ever needed?</strong> At larger XOR levels (XOR14, XOR16), could null-only directions become essential again? The current search stops at XOR12.</li>
<li><strong>Does the bf_limit=100 truncation affect the result?</strong> The XOR6 brute force only searches the first 100 of 4096 (or 3975 non-null) entries. If null entries cluster in the first 100, this could bias the comparison. The identical 32-winner result for both full and non-null suggests the truncation is not an issue, but exhaustive search would confirm.</li>
<li><strong>Null fraction at zeta_10 (Fibonacci anyons)?</strong> <a href="./entries/demo_84.html">Demo 84</a> raised this question. zeta_10 was identified as infinite in <a href="./entries/demo_80.html">Demo 80</a>. Measuring its null fraction and direction partition would fill in the dilution curve between zeta_8 (37.5%) and zeta_12 (3.0%).</li>
<li><strong>Is per-direction residual the right metric for the transition?</strong> <a href="./entries/demo_88.html">Demo 88</a> found zeta_12's per-direction spherical design residual is 8x lower than zeta_8's. Is direction density (or equivalently per-direction residual) the control parameter for the indispensability transition?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_88.html">Demo 88</a>: Anti-Correlation Mechanism</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_88_anti_correlation/main.c.html">demo_88_anti_correlation/main.c</a></code> (~1175 lines)</li>
<li><strong>Tests</strong>: 8/8 pass</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_72.html">Demo 72</a> (Voronoi optimization destroys computation, 36-&gt;4 XOR6), <a href="./entries/demo_84.html">Demo 84</a> (null states and direction classification: 6 null-only + 3 shared + 4 non-null), <a href="./entries/demo_87.html">Demo 87</a> (null indispensability at zeta_12)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_89.html">Demo 89</a> (depth law mechanism), reservoir computing robustness pillar, future constrained optimization work, zeta_12 Sec*Vor optimization priority assessment</li>
</ul>
<h3>Headline</h3>
The algebraic directions that are worst for spherical integration are best for DKC computation because the 4 non-null body-diagonal directions are the rigid computational anchors while the 6 null-only edge-midpoint directions are flexible topological scaffolding; constrained optimization (nulls free, non-nulls clamped to 2 deg) achieves 48% design improvement with only 2.8% XOR loss, and the k-ladder activation provides 14x better perturbation resilience than <a href="./entries/demo_72.html">D72</a>'s Voronoi-only activation (6.4% vs 89% loss under design-improving gradient).
<h3>Key Results</h3>
<ul>
<li><strong>Phase 1 (Geometric Characterization)</strong>: The 13 zeta_8 directions form a cuboctahedron on S^2. Three orbits under octahedral symmetry: 3 coordinate axes (shared, mutual angle 90 deg), 4 body diagonals (non-null-only, mutual angle 70.5 deg = arccos(1/3)), 6 edge midpoints (null-only, mutual angle 60 deg or 90 deg). Pairwise angle statistics: min=35.3 deg, max=90.0 deg, mean=63.1 deg over 78 pairs.</li>
<li><strong>Phase 1 (Gram eigenspectrum)</strong>: The 13x13 |dot| Gram matrix has eigenvalues including golden ratio pairs (phi=1.618 x2 and -phi+1=-0.618 x2), leading eigenvalue 6.110, three eigenvalues at 2.000, three at -1/3. Negative eigenvalues expected for |dot| kernel on RP^2 (not PSD). The golden ratio eigenvalues arise from the specific angular ratios of zeta_8's three Oh orbits (54.7/45/35.3 deg).</li>
<li><strong>Phase 1 (Spherical design quality)</strong>: Residual(t=6) = 2.225. NOT a 2-design (residual &gt; 0.01). The algebraic directions are among the worst possible for 13 points on S^2 in terms of spherical integration quality.</li>
<li><strong>Phase 2 (Algebraic Characterization)</strong>: Direction partition confirmed: 6 null-only (type 0, cube edge midpoints), 3 shared (type 1, coordinate axes), 4 non-null-only (type 2, body diagonals). Intra-group mean angles: null-only=66.0 deg, non-null=70.5 deg, shared=90.0 deg, null-to-non-null inter=62.6 deg. Null and non-null groups have geometrically distinct clustering (difference &gt; 1.0 deg).</li>
<li><strong>Phase 3 SURPRISE (Perturbation Sensitivity)</strong>: Baseline XOR6 = 1239 out of 2024 triples. At eps=10 deg: null-only perturbation causes -2.4% loss (i.e., a GAIN -- perturbing nulls slightly improves computation), non-null-only perturbation causes 8.0% loss. The prediction that null directions would be more sensitive (radical-driven anti-correlation) was INVERTED. Non-null body-diagonal directions are the fragile, load-bearing computational anchors. Null edge-midpoint directions are redundant scaffolding.</li>
<li><strong>Phase 3b (Unconstrained design gradient)</strong>: Starting from algebraic directions, 5000-step simulated-annealing optimization toward lower spherical design residual: 52% residual improvement (2.23 -&gt; 1.06) with only 6.4% XOR loss (1239 -&gt; 1160). This is dramatically less catastrophic than <a href="./entries/demo_72.html">D72</a>'s 89% destruction (36 -&gt; 4).</li>
<li><strong>Phase 3e (Constrained optimization -- KEY RESULT)</strong>: Null directions move freely, non-null and shared clamped to 2 deg from original. Result: 48% design improvement (residual 2.23 -&gt; 1.16) with only 2.8% XOR loss (1239 -&gt; 1204). Null directions carry nearly all the design-improvement capacity (48% vs 52% unconstrained) while non-null rigidity cuts computational loss in half (2.8% vs 6.4%).</li>
<li><strong>Phase 4 (Cross-root comparison)</strong>: zeta_8 has 13 directions with Res(t=6)=2.225, Res/N=0.171. zeta_12 has 2043 directions with Res(t=6)=42.400, Res/N=0.021. Per-direction residual at zeta_12 is 8x lower than zeta_8. More directions = better per-direction integration = nulls dispensable at larger groups. Connects directly to <a href="./entries/demo_87.html">Demo 87</a>'s dispensability finding.</li>
<li><strong>K-Ladder Robustness (standalone insight)</strong>: <a href="./entries/demo_72.html">D72</a> (Voronoi-only activation) shows catastrophic 89% destruction under design-improving optimization. <a href="./entries/demo_88.html">D88</a> (k-ladder activation with K_LADDER={1,6,8,10,12,16,20,24}) shows only 6.4% loss for the same gradient. The k-ladder provides perturbation resilience: Voronoi-only gives each triple ONE chance at a specific angular resolution (knife-edge sensitivity), k-ladder gives each triple 8 chances at different resolutions (small direction shifts absorbed by switching k_sec). The Sec*Vor activation introduced for capacity also provides computational robustness. Dual benefit.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Two-Role Direction Theorem (DEMONSTRATED)</strong>: In the zeta_8 cuboctahedral direction set, the 13 directions serve two distinct computational roles: the 4 non-null body-diagonal directions are rigid computational anchors (perturbation-sensitive, load-bearing for XOR), and the 6 null-only edge-midpoint directions are flexible topological scaffolding (perturbation-tolerant, movable, provide S^2 coverage for spherical integration).</li>
<li><strong>Constrained Optimality (DEMONSTRATED)</strong>: Constraining non-null directions to within 2 deg of algebraic placement while allowing null directions to move freely captures 92% of unconstrained design improvement (48% vs 52%) while reducing computational loss by 56% (2.8% vs 6.4%).</li>
<li><strong>K-Ladder Resilience Theorem (DEMONSTRATED)</strong>: The Sec*Vor k-ladder activation provides an order-of-magnitude better perturbation resilience than Voronoi-only activation under the same design-improving gradient (6.4% loss vs 89% loss). The mechanism is that multiple k_sec values provide fallback resolutions when direction perturbation invalidates the optimal sector assignment.</li>
<li><strong>Anti-Correlation Persistence Conjecture (SUPPORTED)</strong>: The anti-correlation between spherical design quality and computational power persists at zeta_12 (per-direction residual 8x lower but still nonzero), though the mechanism shifts from null-direction-driven to sheer direction-count-driven as the group grows.</li>
<li><strong>Activation Function as Variable (CONFIRMED)</strong>: The dramatic difference between <a href="./entries/demo_72.html">D72</a> (89% loss) and <a href="./entries/demo_88.html">D88</a> (6.4% loss) under the same geometric optimization confirms that the activation function (Voronoi-only vs Sec*Vor k-ladder) is the primary variable controlling perturbation sensitivity, not the optimization procedure itself.</li>
</ul>
<h3>Data</h3>
<ul>
<li>zeta_8 catalog: 24 entries, 13 directions</li>
<li>Direction partition: 6 null-only + 3 shared + 4 non-null-only = 13</li>
<li>Cuboctahedral orbits: 3 coordinate axes (90 deg mutual), 4 body diagonals (70.5 deg mutual), 6 edge midpoints (60/90 deg mutual)</li>
<li>Pairwise angle stats: min=35.3 deg, max=90.0 deg, mean=63.1 deg (78 pairs)</li>
<li>Gram eigenspectrum: 6.110, 2.000(x3), phi(x2), 0.520, -1/3(x3), -phi+1(x2), -0.630</li>
<li>Spherical design residual(t=6): 2.225 (NOT a 2-design)</li>
<li>Baseline XOR6 count: 1239 / 2024 triples</li>
<li>Perturbation at eps=10 deg: null-only = -2.4% loss (gain), non-null-only = 8.0% loss, all-random = 3.7% loss</li>
<li>Unconstrained design gradient (5000 steps): residual 2.23 -&gt; 1.06 (52% improvement), XOR6 1239 -&gt; 1160 (6.4% loss)</li>
<li>Constrained optimization (nulls free, non-nulls clamped 2 deg): residual 2.23 -&gt; 1.16 (48% improvement), XOR6 1239 -&gt; 1204 (2.8% loss)</li>
<li><a href="./entries/demo_72.html">D72</a> Voronoi-only design optimization: 36 -&gt; 4 XOR6 solutions (89% loss)</li>
<li>zeta_12: 2043 directions, Res(t=6)=42.400, Res/N=0.021 (8x lower per-direction than zeta_8)</li>
<li>zeta_12 pairwise angle (sampled): min~0 deg, max~90 deg, mean=57.3 deg</li>
<li>K_LADDER = {1, 6, 8, 10, 12, 16, 20, 24} (8 values)</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong><code>build_closure(verbose)</code></strong>: SU(2) group closure from two generators with inverse augmentation; returns catalog size in <code>g_cat_size</code>, round count in <code>n_rounds</code>; supports verbose output per round</li>
<li><strong><code>classify_null(cat_size)</code></strong>: classifies each catalog entry as null (|Re(q)| &lt; 1e-10) or non-null; fills <code>is_null[]</code> array with counts <code>n_null_total</code>, <code>n_nonnull_total</code></li>
<li><strong><code>build_dirs(cat_size)</code></strong>: extracts distinct S^2 axis directions from catalog (antipodal-identified); populates <code>g_dir[]</code> with <code>g_nd</code> count</li>
<li><strong><code>classify_directions(cat_size)</code></strong>: per-direction null/non-null counts; classifies each direction as null-only (type 0), shared (type 1), or non-null-only (type 2); fills <code>dir_type[]</code>, counts <code>n_null_only_dirs</code>, <code>n_shared_dirs</code>, <code>n_nonnull_only_dirs</code></li>
<li><strong><code>combined_cell(sa,sb,sc,sd,k_sec)</code></strong>: Sec<em>Vor activation function mapping quaternion sum to integer cell index via angular sector (k_sec divisions of [0,360)) crossed with Voronoi nearest-direction; returns <code>sec </em> (n_dir+1) + vor</code></li>
<li><strong><code>test_xor(indices, n_weights, k_sec)</code></strong>: XOR parity test for a given weight tuple and k_sec; uses cell-based even/odd accumulation with touched-cell cleanup</li>
<li><strong><code>count_xor6(bf_limit)</code></strong>: brute-force XOR6 counter over all 3-element subsets with k-ladder fallback (tests 8 k_sec values, counts success on first hit)</li>
<li><strong><code>design_residual(dirs, nd, t)</code></strong>: spherical t-design residual via real spherical harmonics Y_l^m; max over all (l,m) with 1&lt;=l&lt;=t of |sum_i Y_l^m(dir_i)|; uses <code>assoc_legendre</code> and <code>ylm_real</code></li>
<li><strong><code>jacobi_eigen(a, n, evals)</code></strong>: Jacobi eigendecomposition for small symmetric matrices (up to 200 iterations); returns sorted (descending) eigenvalues</li>
<li><strong>Phase 3 perturbation framework</strong>: Gaussian direction perturbation with normalize3; supports selective perturbation by direction type (null-only, non-null-only, or all); constrained mode with angular clamp relative to original algebraic placement</li>
<li><strong>Simulated annealing optimizer</strong>: temperature-decay random jitter, accept-if-better for spherical design residual; with optional angular clamping for constrained optimization</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong><a href="./entries/demo_72.html">Demo 72</a> (Voronoi Design Destruction)</strong>: <a href="./entries/demo_72.html">D72</a> showed that optimizing 13 eigenvector directions for spherical design quality using Voronoi-only activation destroys computation (36-&gt;4 XOR6, 89% loss). <a href="./entries/demo_88.html">D88</a> identifies the mechanism: the activation function (Voronoi-only vs k-ladder) is the variable, and k-ladder provides order-of-magnitude better resilience.</li>
<li><strong><a href="./entries/demo_84.html">Demo 84</a> (Null States)</strong>: <a href="./entries/demo_84.html">D84</a> established the 6+3+4 direction partition (null-only, shared, non-null-only) and the directional efficiency of null entries. <a href="./entries/demo_88.html">D88</a> extends this by showing the partition maps to distinct computational roles (scaffolding vs anchors).</li>
<li><strong><a href="./entries/demo_87.html">Demo 87</a> (Null Indispensability at zeta_12)</strong>: <a href="./entries/demo_87.html">D87</a> showed nulls become dispensable at zeta_12. <a href="./entries/demo_88.html">D88</a>'s Phase 4 cross-root comparison provides the geometric explanation: per-direction residual is 8x lower at zeta_12, so null directions are no longer needed for coverage.</li>
<li><strong>Spherical t-designs (Delsarte, Goethals, Seidel 1977)</strong>: the design residual metric quantifies how far a point set is from a t-design; <a href="./entries/demo_88.html">D88</a> shows the algebraic directions are maximally far from a 2-design but this is precisely what makes them computationally optimal.</li>
<li><strong>Cuboctahedron / Archimedean solids</strong>: the 13 zeta_8 directions form a cuboctahedron (3+4+6 orbits under Oh symmetry); recognized as the complete orbit structure of the octahedral group acting on RP^2.</li>
<li><strong>Golden ratio in eigenspectrum</strong>: phi and -phi+1 eigenvalue pairs in the |dot| Gram matrix arise from the specific angular ratios of the three Oh orbits, connecting Fibonacci-like structure to the octahedral geometry.</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>At zeta_12 with 2043 directions, is there ANY subset that is computationally load-bearing (analogous to the 4 body-diagonal anchors at zeta_8), or is the direction set fully redundant?</li>
<li>The algebraic placement is slightly off-peak for null directions (~6% improvement accessible at eps=10 deg, with the -2.4% gain suggesting room for optimization). Is this universal across roots or specific to zeta_8?</li>
<li>Does the k-ladder robustness finding change the priority of "zeta_12 Sec*Vor optimization" as a research direction? (The resilience may make optimization less necessary.)</li>
<li>Can the constrained optimization approach (flexible nulls + rigid non-nulls) be formulated as a principled optimization problem rather than simulated annealing, e.g., as a semidefinite program preserving non-null directions?</li>
<li>The golden ratio eigenvalue pairs (phi, -phi+1) in the Gram spectrum: do these appear at other roots (zeta_10, zeta_12), or are they specific to zeta_8's octahedral geometry?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_89.html">Demo 89</a>: Depth Law Mechanism</h2>
<ul>
<li><strong>Status</strong>: PRELIMINARY</li>
<li><strong>File</strong>: <code><a href="../demo_89_depth_law_mechanism/main.c.html">demo_89_depth_law_mechanism/main.c</a></code> (~1964 lines)</li>
<li><strong>Tests</strong>: 14/14 pass (12 phase completions + catalog built + direction coverage; Phase 5 intra&gt;inter coherence FAIL is expected negative result, Phase 8 deep&gt;strided Cayley FAIL is expected negative result)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_82.html">Demo 82</a> (depth law: max_xor ~ depth + 6, algebraic coherence), <a href="./entries/demo_84.html">Demo 84</a> (null states, direction geometry), <a href="./entries/demo_66.html">Demo 66</a> (24-cell geometry, zeta_8 catalog), <a href="./entries/demo_79.html">Demo 79</a> (zeta_12 capacity, infinite group), <a href="./entries/demo_77.html">Demo 77</a> (paired extension at zeta_8)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_90.html">Demo 90</a> (sum-angle structure, axis cancellation mechanism), <a href="./entries/demo_91.html">Demo 91</a> (activation bottleneck), future representation-theoretic analysis of "algebraic coherence"</li>
</ul>
<h3>Headline</h3>
Systematic investigation of WHY the depth law holds, testing 8 mechanistic hypotheses across 11 computational phases — killing pairwise coherence, direction coverage, Cayley density, sector diversity, and angle coherence as explanations, while confirming paired extension as a real but minority pathway (6-20% at zeta_12 vs 100% at zeta_8) and identifying "algebraic coherence" as the remaining open question attacked in <a href="./entries/demo_90.html">Demo 90</a>.
<h3>Key Results</h3>
<ul>
<li><strong>Phase 1 — Depth decomposition (zeta_12)</strong>: Single-depth XOR6 capacity grows with depth (d=0: 8 winners, d=8: 2011 winners at bf=24). Direction count grows exponentially across depth shells: 2-&gt;6-&gt;22-&gt;46-&gt;114-&gt;239-&gt;507-&gt;975-&gt;2043. Cumulative XOR6 capacity saturates around 1903.</li>
<li><strong>Phase 2 — Discriminating experiment</strong>: Deep single-depth entries (d&gt;=4-5) beat random at matched sample size (N=20, N=50) by 5-10%. Shallow entries (d=2, d=3) LOSE to random. Confirms deep entries have genuine per-entry advantage.</li>
<li><strong>Phase 3 — Pairwise coherence</strong>: KILLED. Mean pairwise |qdot| is flat at ~0.42 across all depths, identical to random baseline. Depth-shell vs random-sample coherence ratio ~1.0. Quaternion alignment is NOT the mechanism.</li>
<li><strong>Phase 4 — Direction coverage (zeta_8)</strong>: KILLED as intercept explanation. All 13 directions in zeta_8 covered by depth 2. The +6 intercept relates to XOR6 base capacity, not direction coverage depth. Also classifies directions into null-only, shared, and non-null types with first-appearance depth.</li>
<li><strong>Phase 5 — Cross-depth coherence matrix</strong>: Intra-depth coherence (0.4214) &lt; inter-depth (0.4254). Depth shells are MORE internally orthogonal than across shells — the opposite of what a coherence-based mechanism would predict. Expected negative result.</li>
<li><strong>Phase 6 — Cell diversity</strong>: Pairwise sum cell diversity grows EXPONENTIALLY with depth. log2(distinct_cells) ~ 1.17d + 2, which IS linear and tracks max_xor. Both directions and sectors contribute. ~66% fill ratio at k=6 regardless of depth. Quantitative correspondence is real but causality unclear (both may be driven by same underlying cause).</li>
<li><strong>Phase 7 — Sector diversity</strong>: KILLED. Pairwise sum sectors saturate at 4/6 (k=6), 7/12 (k=12), 13/24 (k=24). Voronoi directions always 100% covered. Sectors are NOT the bottleneck. Single-entry angle range: generator half-angle = pi/6 = 30deg, so max angle at depth d = 60d degrees.</li>
<li><strong>Phase 8 — Cayley graph density</strong>: KILLED and INVERTED. Same-depth entries have ZERO mutual Cayley edges (mathematically necessary from BFS construction). Deep-564 has 0 edges; strided-564 has 58. Yet deep beats strided on XOR capacity. Edges/entry converges to 4/3. Cross-depth connectivity: 100% of depth-d entries connected to depth-(d-1) entries.</li>
<li><strong>Phase 9 — Multi-element sum sector diversity</strong>: KILLED. Sectors slightly DECREASE with depth for multi-element sums. BUT: each additional weight adds ~2 sectors to coverage, matching the +2 XOR input step per additional weight.</li>
<li><strong>Phase 10 — Angle coherence within shells</strong>: KILLED for deep entries. Shallow shells (d=0, d=1) ARE angle-coherent (d=1 has half the variance of random). Deep shells (d&gt;=3) have approximately the same angle variance as random. Distinct angles per depth listed explicitly. Full catalog: distinct rotation angles grow linearly by cumulative depth: 2-&gt;4-&gt;6-&gt;10-&gt;12-&gt;16-&gt;21-&gt;35-&gt;44 (~5/depth).</li>
<li><strong>Phase 11 — Paired extension verification</strong>: At zeta_12 cumulative depth 4 (275 entries, 114 dirs): XOR6 has 3736 winners, 234 (6%) with shadow pairs. XOR8 has 2200 winners, 430 (20%) with shadow pairs, 430/430 (100%) nested. Paired extension is REAL but MINORITY at zeta_12 — direction diversity provides an alternative dominant pathway. At zeta_8 (24 entries, 13 dirs) it was 100% because direction scarcity forces shadow pairing as the only viable strategy.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Pairwise Coherence Non-Mechanism (DEMONSTRATED)</strong>: Mean |qdot| is flat (~0.42) across all depth shells and identical to random baseline. Quaternion alignment does not explain depth advantage.</li>
<li><strong>Direction Coverage Non-Mechanism (DEMONSTRATED)</strong>: All 13 zeta_8 directions covered by depth 2; the +6 intercept is not from direction coverage timing.</li>
<li><strong>Cayley Density Non-Mechanism (DEMONSTRATED, INVERTED)</strong>: Same-depth entries have zero Cayley edges by BFS construction. Deep subsets have FEWER Cayley edges than strided subsets of equal size, yet higher XOR capacity. Graph density and computational capacity are anti-correlated.</li>
<li><strong>Sector Saturation Non-Mechanism (DEMONSTRATED)</strong>: Pairwise sum sectors saturate early and do not grow with depth. Voronoi coverage is always 100%.</li>
<li><strong>Angle Coherence Non-Mechanism (DEMONSTRATED for deep)</strong>: Deep shells have random-like angle variance. Only shallow shells (d=0, d=1) show coherence.</li>
<li><strong>Paired Extension as Minority Pathway (DEMONSTRATED)</strong>: Shadow pairing is real (100% nesting when present) but constitutes only 6-20% of winners at zeta_12. Dominant pathway (80-94%) uses all-distinct-direction tuples.</li>
<li><strong>Paired Extension / Diversity Duality (OBSERVED)</strong>: Shadow pairing dominates when direction vocabulary is small (zeta_8); direction diversity dominates when large (zeta_12). Both depend on same underlying algebra.</li>
<li><strong>Combinatorial-Algebraic Balance Conjecture (PROPOSED)</strong>: Exponential catalog growth provides exponentially more candidate tuples per depth round; parity constraint is exponentially hard per XOR level; these two exponentials balance to give linear depth growth (one XOR level per ~2 depth rounds). Algebraic coherence tilts the balance favorably for deep entries.</li>
<li><strong>log2(cell_diversity) ~ 1.17d + 2 (OBSERVED)</strong>: Linear in depth, tracks max_xor quantitatively. Causality vs epiphenomenality unresolved.</li>
<li><strong>+2 Sectors per Weight (OBSERVED)</strong>: Each additional weight in multi-element sums adds ~2 sectors to coverage, matching the +2 XOR input step.</li>
<li><strong>Casimir Balance Hypothesis (SUGGESTED by researcher)</strong>: Catalog doubling vs linear eigenvalue gap yields ~1 new representation per depth. Consistent with angle data but not proven.</li>
</ul>
<h3>Data</h3>
<ul>
<li>zeta_12 catalog: 3888 entries, 9 closure rounds (depths 0-8)</li>
<li>Direction count by cumulative depth: 2, 6, 22, 46, 114, 239, 507, 975, 2043</li>
<li>Pairwise |qdot| coherence: ~0.42 at all depths (flat, matches random)</li>
<li>Cross-depth coherence: intra=0.4214, inter=0.4254 (intra &lt; inter)</li>
<li>zeta_8 directions: 13 total, all covered by depth 2</li>
<li>Cell diversity (k=6): ~66% fill at all depths</li>
<li>log2(distinct_cells) slope: ~1.17 per depth</li>
<li>Cayley edges/entry: converges to 4/3</li>
<li>Deep-564 Cayley edges: 0; strided-564: 58</li>
<li>Cumulative distinct angles: 2-&gt;4-&gt;6-&gt;10-&gt;12-&gt;16-&gt;21-&gt;35-&gt;44</li>
<li>XOR6 winners (Phase 11): 3736 total, 234 shadow (6%)</li>
<li>XOR8 winners (Phase 11): 2200 total, 430 shadow (20%), 430/430 nested (100%)</li>
<li>Phase 2 deep advantage: 5-10% over random at matched N</li>
<li>Structural constants: ~66% cell fill, 100% Voronoi coverage, 4/3 edges/entry, +2 sectors/weight</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong><code>build_closure(verbose)</code></strong>: BFS-based SU(2) group closure with per-entry depth tracking (<code>g_depth[]</code>), per-round counts (<code>round_count[]</code>, <code>round_start[]</code>). Reused across all phases with <code>save_catalog()</code>/<code>restore_catalog()</code>.</li>
<li><strong><code>load_single_depth(d)</code> / <code>load_cumulative(max_d)</code></strong>: Subset extraction by depth — loads entries at exactly depth d, or all entries up to depth d, into <code>g_cat[]</code> for analysis. Enables controlled depth-stratified experiments.</li>
<li><strong><code>load_random_from_depth(d, n)</code> / <code>load_random_full(n)</code></strong>: Fisher-Yates shuffle-based random sampling from specific depth shell or full catalog. Used in discriminating experiments (Phase 2) and random baselines (Phases 3, 10).</li>
<li><strong><code>mean_pairwise_qdot(cat_size)</code></strong>: Mean absolute quaternion dot product across all pairs. Coherence metric used in Phases 3, 5.</li>
<li><strong><code>combined_cell(sa, sb, sc, sd, k_sec)</code></strong>: S1 x S2 activation cell assignment for quaternion sums. Maps 4D quaternion to (sector, voronoi_cell) index. Core of XOR test and cell diversity analysis.</li>
<li><strong><code>is_cayley_neighbor(a, b, gens, n_gens)</code></strong>: Tests whether two quaternions are one generator step apart. Used in Phase 8 Cayley density analysis.</li>
<li><strong><code>extract_angle(q)</code></strong>: Extracts rotation angle in degrees from quaternion. Used in Phase 10 angle variance analysis and Phase 11 shadow pair detection.</li>
<li><strong><code>quat_vor(q)</code></strong>: Extracts Voronoi cell index from quaternion rotation axis. Used in Phase 11 shadow pair detection.</li>
<li><strong>Phase 11 paired extension framework</strong>: Shadow pair detection (same Voronoi direction, different angle) + nesting test (remove shadow element, test remaining as lower-arity XOR winner). Generalizable to any catalog/direction setup.</li>
<li><strong>LCG random number generator</strong>: Simple <code>g_rng</code> state with <code>rng_uniform()</code> and <code>shuffle()</code>. Self-contained, no stdlib rand dependency.</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong><a href="./entries/demo_82.html">Demo 82</a> depth law</strong>: max_xor ~ depth + 6 (linear). <a href="./entries/demo_89.html">Demo 89</a> investigates the mechanism.</li>
<li><strong><a href="./entries/demo_77.html">Demo 77</a> paired extension</strong>: 100% paired extension at zeta_8 (24 entries, 13 dirs). <a href="./entries/demo_89.html">Demo 89</a> Phase 11 shows this drops to 6-20% at zeta_12 (275 entries, 114 dirs) — the mechanism shifts from shadow pairing to direction diversity as vocabulary grows.</li>
<li><strong>Tahmasebi &amp; Jegelka (NeurIPS 2023)</strong>: Group invariance implies dimension reduction. SU(2)/U(1) = S2. Consistent with DKC's independent discovery (<a href="./entries/demo_67.html">Demo 67</a>) that S2 directional structure matters.</li>
<li><strong>Lauda et al. (2025, Nature Comms)</strong>: Neglecton anyons for universal QC. External validation of <a href="./entries/demo_84.html">Demo 84</a>'s null-indispensability findings.</li>
<li><strong>Reservoir Computing (Jaeger 2001, Maass et al. 2002)</strong>: Echo state networks / liquid state machines. The depth law's "algebraic coherence" parallels the reservoir separation property — deep entries maintain richer computational manifold.</li>
<li><strong>Casimir operator theory</strong>: Casimir balance hypothesis (catalog doubling vs linear eigenvalue gap) suggested as possible explanation for ~1 new representation per depth round.</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li><strong>What is "algebraic coherence" precisely?</strong> Deep tuples are more likely to satisfy parity than random tuples at matched catalog size. <a href="./entries/demo_89.html">Demo 89</a> eliminated 5 candidate mechanisms but did not identify the actual one. Attacked in <a href="./entries/demo_90.html">Demo 90</a> (sum-angle structure, axis cancellation).</li>
<li><strong>Why is the slope exactly 1?</strong> One XOR level per ~2 depth rounds. The combinatorial-algebraic balance conjecture proposes exponential catalog growth cancels exponential parity difficulty, but the precise coefficient is unexplained.</li>
<li><strong>Does the +6 intercept connect to the 13=13 theorem's l=6 bandwidth?</strong> Phase 4 ruled out direction coverage timing. The connection, if any, remains open.</li>
<li><strong>At what depth does XOR14 (7 weights) first appear?</strong> Extrapolated from depth law but not directly verified.</li>
<li><strong>Is log2(cell_diversity) ~ 1.17d + 2 causal or epiphenomenal?</strong> Both cell diversity and max_xor grow linearly with depth. Are they causally linked or both consequences of the same underlying algebraic structure?</li>
<li><strong>Does the paired extension / diversity duality generalize to other roots of unity?</strong> Tested at zeta_8 (shadow dominant) and zeta_12 (diversity dominant). What about zeta_10, zeta_16?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_90.html">Demo 90</a>: Sum-Angle Structure — Why Deep Entries Compose Better</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_90_sum_angle_structure/main.c.html">demo_90_sum_angle_structure/main.c</a></code> (~1713 lines)</li>
<li><strong>Tests</strong>: 10/12 pass (2 informative fails: Phase 1 count hypothesis — all subsets produce 2048+ distinct sum angles, so deep vs strided/random distinct-count comparisons fail because count is not the discriminating feature)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_89.html">Demo 89</a> (depth law mechanism elimination — narrowed to "algebraic coherence"), <a href="./entries/demo_82.html">Demo 82</a> (crossing depth law, deep-564 vs strided-564), <a href="./entries/demo_75.html">Demo 75</a> (computation requires non-canonical sum angles), <a href="./entries/demo_79.html">Demo 79</a> (zeta_12 capacity, infinite group)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_91.html">Demo 91</a> (activation bottleneck test — tests whether linear depth law is activation artifact or parity wall), <a href="./entries/demo_89.html">D89</a>-<a href="./entries/demo_90.html">D90</a>-<a href="./entries/demo_91.html">D91</a> arc summary (depth law explained)</li>
</ul>
<h3>Headline</h3>
The depth law mechanism is <strong>axis cancellation</strong> (anti-aligned rotation axes producing low sum angles) combined with <strong>cross-depth algebraic constraints</strong> (BFS ancestry creating limited sum-angle vocabularies between related entries), and the computational advantage is <strong>relational, not positional</strong> — the S² point cloud bandwidth actually DECREASES with depth (spectral inversion), ruling out all positional/bandwidth explanations.
<h3>Key Results</h3>
<ul>
<li><strong>Axis cancellation mechanism (Phase 2b)</strong>: XOR8 winners select anti-aligned axis pairs. Mean min_dot for winners = -0.75 vs -0.65 for random non-winners. Two quaternions with nearly opposite rotation axes partially cancel, yielding a sum quaternion with a small rotation angle (30-66°) — exactly what sector activation needs for parity satisfaction. This is the geometric mechanism underlying "algebraic coherence."</li>
<li><strong>Cross-depth algebraic constraint (Phase 2c)</strong>: Generator × deep-entry (d=7-8) sums produce only 73 distinct angles from 50K pairs. Compare: shallow × shallow = 15 distinct, deep × deep = 1313 distinct. BFS-derived entries are algebraically related to generators, constraining their pairwise sums to a small vocabulary. This is the concrete realization of the abstract "algebraic coherence" identified in <a href="./entries/demo_82.html">D82</a>.</li>
<li><strong>Relational, not positional (Phase 5)</strong>: Spherical harmonic decomposition of the S² point cloud (rotation axes on the sphere) shows bandwidth DECREASES with depth. BW_90% drops from l=4 (depth 0 only) to l=2 (cumulative all depths). BW_99% drops from l=11 to l=6. The point cloud converges to uniform — individual entry positions become LESS informative with depth, yet computation improves. The mechanism is relational (axis alignment between entries, cross-depth algebraic constraints), not positional.</li>
<li><strong>Vocabulary is not the bottleneck (Phases 2d, 2e)</strong>: New cross-depth angle vocabulary grows exponentially with depth: 3 → 6 → 10 → 22 → 33 → 72 → 120 → 258 → 381 new distinct angles per depth level (~2x per depth round). The useful subset (&lt;70°) also grows exponentially but its fraction drops from 80% to 32%. The linear depth law is NOT caused by vocabulary running out.</li>
<li><strong>Pairwise sum-angle census (Phase 1)</strong>: All subsets (deep-564, strided-564, shallow-564, random-564) produce 2048+ distinct pairwise sum angles. Raw count is not discriminating. However distributions differ: deep skews toward 135-180° range. The informative result is that WHICH angles appear matters, not HOW MANY.</li>
<li><strong>XOR winner sum-angle diversity (Phase 2)</strong>: XOR6 winners have mean 2.80 distinct pairwise sum angles; XOR8 winners have 5.18 distinct. Higher-level winners use more angular diversity within each tuple.</li>
<li><strong>Direction concentration null result (Phase 3)</strong>: Entries-per-direction is flat at ~2 across all depths. There is no concentration effect — depth does not cause entries to cluster onto fewer directions.</li>
<li><strong>Balanced exponentials linearity (PRELIMINARY)</strong>: Supply (vocabulary, entries) grows ~2× per depth round via BFS closure. Demand (parity constraints) grows 4× per XOR weight (2^(2N) masks). Ratio gives ~2 depth rounds per weight → max_xor ≈ depth + 6. Consistent with all data but not analytically derived. (Later confirmed by <a href="./entries/demo_91.html">D91</a> from the activation side.)</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Axis Cancellation Mechanism (DEMONSTRATED)</strong>: XOR winners preferentially contain anti-aligned quaternion pairs (axis dot product ≈ -0.75). The partial cancellation of nearly-opposite rotation axes produces low sum angles that create the fine-grained sector separations needed for parity satisfaction. This is the geometric content of "algebraic coherence."</li>
<li><strong>Cross-Depth Algebraic Constraint (DEMONSTRATED)</strong>: BFS-derived entries at depth d have constrained pairwise sums with generators: only 73 distinct angles from 50K gen × deep pairs, compared to 1313 for deep × deep. The BFS ancestry creates algebraic relationships that restrict the sum-angle vocabulary between related entries.</li>
<li><strong>Spectral Inversion (DEMONSTRATED)</strong>: The S² point cloud bandwidth DECREASES as depth increases. The point cloud converges to spherical uniformity (l=0 dominant in spherical harmonics). Computational power grows while positional information content shrinks — ruling out ALL positional/bandwidth-based explanations for the depth law.</li>
<li><strong>Relational Computation Thesis (DEMONSTRATED)</strong>: The depth law is relational: what matters is how entries combine (axis cancellation, cross-depth constraints), not where they individually sit on S². The spectral inversion is the cleanest evidence — positional information degrades monotonically while computation improves linearly.</li>
<li><strong>Balanced Exponentials Conjecture (PRELIMINARY)</strong>: BFS branching produces ~2× entries per depth round; parity constraints require 4× masks per XOR weight. The ratio 2:4 = 1:2 predicts ~2 depth per weight → linear slope ≈ 1. Consistent with all data; later supported by <a href="./entries/demo_91.html">D91</a>'s activation invariance test.</li>
<li><strong>Altschuler-Parrilo Point Cloud Hypothesis (DEAD as formulated)</strong>: The hypothesis that deeper point clouds access higher spherical harmonic modes (giving quadratic capacity growth) is INVERTED — bandwidth shrinks, not grows. The AP framework may still apply via kernel rank analysis of the activation matrix, but the point-cloud-spectrum version is dead.</li>
</ul>
<h3>Data</h3>
<ul>
<li>Lattice: ζ₁₂ (pi/6 half-angle), &gt;3000 entries in catalog, 8-9 closure rounds</li>
<li>Subset size for comparative tests: N=564 (matching <a href="./entries/demo_82.html">D82</a> protocol)</li>
<li><strong>Phase 1 sum-angle census</strong>: deep-564, strided-564, shallow-564, random-564 all produce 2048+ distinct angles (0.01° tolerance). Discriminating feature is distribution shape, not count.</li>
<li><strong>Phase 2 winner diversity</strong>: XOR6 winners (3 weights, bf=30): mean 2.80 distinct pairwise sum angles. XOR8 winners (4 weights, bf=20): mean 5.18 distinct.</li>
<li><strong>Phase 2b axis cancellation</strong>: XOR8 winners mean(min_dot) = -0.75, non-winners mean(min_dot) = -0.65. Winners mean(mean_dot) lower than non-winners. Sum angle range for winners: 30-66°.</li>
<li><strong>Phase 2c cross-depth</strong>: shallow×shallow (d=0-1) = 15 distinct angles. deep×deep (d=7-8) = 1313 distinct. shallow×deep (cross-depth) = 73 distinct from 50K pairs.</li>
<li><strong>Phase 2d vocabulary growth</strong>: New distinct angles per depth level: 3→6→10→22→33→72→120→258→381 (~2× per round).</li>
<li><strong>Phase 2e useful (&lt;70°) angle growth</strong>: Exponential growth but fraction drops from 80% (depth 1) to 32% (depth 8).</li>
<li><strong>Phase 3 direction concentration</strong>: Entries/direction ≈ 2 at all depths (flat, no concentration effect).</li>
<li><strong>Phase 5 spectral decomposition</strong>: Per-depth BW_90% decreases from l=4 (d=0) toward l=2 (cumulative). BW_99% decreases from l=11 to l=6. Power concentrates at l=0 (uniform) as depth increases.</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong><code>build_closure(verbose)</code></strong>: BFS closure of SU(2) generators with depth tracking. Builds <code>g_cat[]</code> with <code>g_depth[]</code>, <code>round_start[]</code>, <code>round_count[]</code>. Supports ζ₁₂ catalogs up to MAX_QCAT=4096 entries.</li>
<li><strong><code>save_catalog()</code> / <code>restore_catalog()</code></strong>: Snapshot/restore pattern for switching between subsets while preserving the full catalog.</li>
<li><strong><code>load_deep(n)</code> / <code>load_shallow(n)</code> / <code>load_strided(n)</code> / <code>load_random(n)</code></strong>: Four subset-loading strategies for comparative experiments (SUBSET_N=564).</li>
<li><strong><code>extract_angle(q)</code></strong>: Extracts full rotation angle in degrees [0,360) from a (possibly non-unit) quaternion.</li>
<li><strong><code>extract_axis(q, ax, ay, az)</code></strong>: Extracts unit rotation axis from quaternion (normalizing and canonicalizing sign).</li>
<li><strong><code>axis_dot(p, q)</code></strong>: Computes dot product between rotation axes of two quaternions — the key metric for axis cancellation analysis.</li>
<li><strong><code>count_distinct(angles, n, tol)</code></strong>: Counts distinct angles within tolerance, using g_distinct[] buffer (MAX_DISTINCT=2048).</li>
<li><strong><code>sum_angle_census(label, out_n_distinct)</code></strong>: Computes all pairwise quaternion sum angles for current catalog subset, prints histogram (12 bins, 0-180°), min/max/mean, and distinct count.</li>
<li><strong><code>entry_angle_census(label)</code></strong>: Individual entry angle statistics for comparison with sum-angle census.</li>
<li><strong><code>find_winners(n_weights, bf_limit)</code></strong>: Brute-force XOR winner search at given weight count with k-ladder optimization. Stores winning tuples in <code>g_winners[]</code>.</li>
<li><strong><code>phase2b_winning_anatomy()</code></strong>: Axis cancellation analysis comparing XOR8 winners vs random non-winners on min_dot, mean_dot, and mean sum angle.</li>
<li><strong><code>phase2c_cross_depth_sum_angles()</code></strong>: Cross-depth sum-angle analysis: shallow×shallow vs deep×deep vs shallow×deep.</li>
<li><strong><code>phase2d_cross_depth_by_level()</code></strong>: Per-depth-level vocabulary growth tracking (gen × depth_d), including cumulative distinct set and Phase 2e low-angle tail (&lt;70°) growth.</li>
<li><strong><code>assoc_legendre(l, m, x)</code></strong>: Associated Legendre polynomial P_l^m(x) for spherical harmonic computation.</li>
<li><strong><code>ylm_real(l, m, theta, phi)</code></strong>: Real spherical harmonic Y_lm evaluation, LMAX=16 (289 coefficients).</li>
<li><strong><code>phase5_spectral_decomposition()</code></strong>: Full spherical harmonic power spectrum P(l) = sum_m f_lm^2 of S² point cloud per depth, with BW_90% and BW_99% bandwidth metrics. Both per-depth and cumulative tables.</li>
<li><strong><code>combined_cell()</code> / <code>vor_cell()</code> / <code>test_xor()</code></strong>: Standard DKC XOR test infrastructure (Voronoi cell + angular sector combined activation, parity verification).</li>
<li><strong>K_LADDER[]</strong>: k-sector ladder {1, 6, 8, 10, 12, 16, 20, 24} for multi-resolution XOR testing.</li>
<li><strong>LCG RNG</strong>: Simple deterministic <code>rng_uniform()</code> for reproducible random subset generation and random baseline sampling.</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>Altschuler &amp; Parrilo (2023)</strong>: Spherical point configurations and polynomial energy — the hypothesis that S² point cloud quality (spherical harmonic bandwidth) drives computational capacity. <a href="./entries/demo_90.html">Demo 90</a> INVERTS this: bandwidth decreases with depth while computation increases. The AP framework may still apply via kernel rank analysis of the activation matrix rather than the point cloud geometry.</li>
<li><strong>Habiro (2002) / Z[ζ₈] bracket</strong>: The algebraic substrate; <a href="./entries/demo_90.html">Demo 90</a> reveals that BFS ancestry within the group algebra creates cross-depth algebraic constraints (73 distinct angles from 50K gen × deep pairs) that are the concrete manifestation of algebraic coherence.</li>
<li><strong>Reservoir Computing (Jaeger 2001, Maass et al. 2002)</strong>: The relational-not-positional finding connects to RC theory — reservoir quality is about the separation property (how inputs map to distinguishable states), not about where reservoir states sit in space. The axis cancellation mechanism is the DKC analog of reservoir separation.</li>
<li><strong>BFS closure and Cayley graphs</strong>: The depth-tracking BFS closure is a walk on the Cayley graph of the SU(2) subgroup. The cross-depth algebraic constraint (gen × deep = constrained vocabulary) reflects the algebraic structure of Cayley graph neighborhoods.</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li><strong>Can axis cancellation be exploited for weight selection?</strong> If the mechanism is anti-aligned axis pairs, can we directly select weight tuples by maximizing anti-alignment rather than brute-force XOR testing?</li>
<li><strong>Kernel rank analysis (seeded for <a href="./entries/demo_91.html">D91</a>+)</strong>: Apply Altschuler-Parrilo to the Gram matrix of combined_cell activations rather than the S² point cloud. The point cloud spectrum is dead as an explanation, but the activation kernel might reveal quadratic potential.</li>
<li><strong>Relational activation</strong>: If the mechanism is axis cancellation (relational), could an activation function that explicitly uses axis dot products between entries break the linear depth law? Current sector/Voronoi activations treat entries independently.</li>
<li><strong>Why slope = 1 analytically</strong>: The balanced-exponentials argument (supply ~2×/depth, demand 4×/weight → slope 1) is consistent with data but not derived from first principles. Connecting BFS branching factor to parity constraint growth rate would be a genuine theoretical result.</li>
<li><strong>Generalization beyond parity</strong>: Does the linear depth law hold for ALL Boolean functions, or just parity? Different functions might have different constraint growth rates, giving different slopes.</li>
<li><strong>Group dependence</strong>: How does the depth law change with a different group (not SU(2))? Different groups have different BFS branching factors and algebraic structures.</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_91.html">Demo 91</a>: Activation Bottleneck Test</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_91_activation_bottleneck/main.c.html">demo_91_activation_bottleneck/main.c</a></code> (~769 lines)</li>
<li><strong>Tests</strong>: 6/7 pass (1 informative fail: activation bottleneck hypothesis refuted)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_89.html">Demo 89</a> (depth law hypothesis space narrowing, 8 hypotheses tested), <a href="./entries/demo_90.html">Demo 90</a> (depth law mechanism — axis cancellation, cross-depth algebraic constraint, balanced exponentials preliminary)</li>
<li><strong>Feeds into</strong>: Future Boolean function generalization (does linear law hold beyond parity?), algebraic catalog construction variants (BFS vs other), non-SU(2) group generalizations</li>
</ul>
<h3>Headline</h3>
The combined_cell activation is NOT the bottleneck for the linear depth law — the parity constraint itself is the wall; the depth gap (XOR6 to XOR8) is invariant across all angular resolutions (k_sec 2–48) and all Voronoi direction counts (2–114), confirming the balanced exponentials explanation: vocabulary grows ~2x/depth round, parity demand grows 4x/weight level, yielding a linear slope of ~2 depth per weight.
<h3>Key Results</h3>
<ul>
<li><strong>Parity wall confirmed (Phase 1)</strong>: max_xor is INDEPENDENT of activation resolution. k_sec swept from 2 to 48 at fixed cumulative depth 0–4 (275 entries, 114 directions). max_xor = 8 at ALL k_sec values. Even 4 total cells (k=2 with 2 dirs) can compute XOR8. The wall is parity, not activation.</li>
<li><strong>Resolution affects count, not existence (Phase 1)</strong>: XOR8 winner count grows 13x (586 at k=2 to 7652 at k=48) as angular resolution increases. But max_xor never changes. Finer resolution reveals MORE solutions to the same parity constraint; it does not enable HIGHER parity.</li>
<li><strong>Depth gap is k_sec-invariant (Phase 3)</strong>: The depth increment required to go from XOR6 to XOR8 is the same (1 level) at all k_sec values from 2 to 48. The slope of the depth law is fixed by parity, not activation geometry.</li>
<li><strong>Voronoi resolution also non-limiting (Phase 2)</strong>: With the full catalog but only depth-0 Voronoi directions (2 dirs), XOR8 has 2 winners. With depth-1 dirs (6 dirs), 35 winners. With all 114 dirs, 5800 winners. More directions produce more solutions, not higher arity.</li>
<li><strong>Balanced exponentials confirmed</strong>: <a href="./entries/demo_90.html">D90</a>'s preliminary linearity explanation is confirmed from the complementary direction. The linearity comes from the supply/demand ratio (vocabulary ~2x per depth round vs parity 4x per weight level), not activation limitations. If activation were the bottleneck, finer resolution would shift the depth gap — it does not.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Parity Wall Theorem (DEMONSTRATED)</strong>: The maximum achievable XOR arity at a given catalog depth is determined entirely by the parity constraint (whether any weight tuple exists whose signed quaternion sums separate even vs odd input subsets). Activation resolution (angular sectors, Voronoi directions) controls the number of solutions but not their existence.</li>
<li><strong>Depth Gap Invariance (DEMONSTRATED)</strong>: The depth gap between consecutive XOR levels (e.g., XOR6 first appearing at depth d₁ and XOR8 first appearing at depth d₂) is constant across all tested activation resolutions (k_sec = 2 to 48, direction counts 2 to 114).</li>
<li><strong>Balanced Exponentials Linearity (CONFIRMED)</strong>: The linear depth law max_xor ≈ depth + 6 arises because BFS closure rounds add vocabulary at rate ~2x/round while parity demand grows at 4x/weight. The ratio yields ~2 depth rounds per additional weight, producing the observed slope ≈ 1.</li>
<li><strong>Activation Resolution–Solution Count Scaling (DEMONSTRATED)</strong>: XOR8 winner count at fixed depth scales roughly linearly with the number of activation cells (k_sec x n_dirs), growing from hundreds at minimal resolution to tens of thousands at maximum resolution.</li>
</ul>
<h3>Data</h3>
<ul>
<li>Catalog: ζ₁₂ (half-angle π/6), built via BFS closure, saved and loaded at various depth cutoffs</li>
<li>Full catalog at depth 0–4: 275 entries, 114 directions</li>
<li>Phase 1 k_sec sweep: k = {2, 4, 6, 8, 12, 16, 24, 32, 48}, brute-force limit bf=25</li>
<li>Phase 1 results: max_xor = 8 at all k_sec; XOR8 winners range from 586 (k=2) to 7652 (k=48), ~13x growth</li>
<li>Phase 2 Voronoi sweep at k_sec=24: direction counts from 2 (depth-0 only) to 114 (all depths); XOR8 at all levels</li>
<li>Phase 3 depth x k_sec interaction: 9 depths (0–8) x 9 k_sec values; max XOR arity table, XOR6 winner count table, XOR8 winner count table</li>
<li>Phase 3 depth law slope: XOR6 first appears at depth 0 (requires k_sec &gt;= 8) or depth 1 (lower k_sec); XOR8 first appears at depth 1 (k_sec &gt;= 16) or depth 2 (all k_sec)</li>
<li>Phase 3 depth gap (XOR6→XOR8): invariant at 1 depth level across all k_sec</li>
<li>XOR8 winner counts at depth 4: 1106 (k=2) to 16962 (k=48)</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong><code>build_closure(verbose)</code></strong>: BFS closure of SU(2) generators with depth tracking per entry, round-start/round-count bookkeeping; supports verbose output of per-round growth</li>
<li><strong><code>save_catalog()</code> / <code>load_up_to_depth(max_d)</code></strong>: snapshot the full closure catalog, then load subsets by depth cutoff; enables depth-sweep experiments without rebuilding the group</li>
<li><strong><code>build_dirs(cat_size)</code> / <code>build_dirs_from_saved(max_d)</code></strong>: extract distinct S² rotation-axis directions from the catalog (or from saved catalog up to a depth), identifying directions modulo antipodal equivalence</li>
<li><strong><code>combined_cell(sa, sb, sc, sd, k_sec)</code></strong>: the activation function under test — maps a quaternion sum to a cell index via angular-sector (k_sec bins on rotation angle) x Voronoi-cell (nearest direction); the core object whose resolution is varied across phases</li>
<li><strong><code>test_xor(indices, n_weights, k_sec)</code></strong>: tests whether a weight tuple computes XOR by checking that all even-parity input sums land in different cells than all odd-parity input sums; uses touched-cell bookkeeping for O(1) cleanup</li>
<li><strong><code>count_xor_winners(n_weights, bf_limit, k_sec)</code></strong>: brute-force enumeration of all C(bf, n_weights) tuples that pass test_xor; supports n_weights = 3, 4, 5</li>
<li><strong><code>phase1_ksec_sweep()</code></strong>: sweeps k_sec at fixed depth 0–4 catalog, measures XOR6/XOR8/XOR10 winner counts and max arity</li>
<li><strong><code>phase2_voronoi_sweep()</code></strong>: sweeps Voronoi direction count at fixed k_sec=24 and fixed catalog, tests whether coarser direction quantization limits arity</li>
<li><strong><code>phase3_depth_ksec_interaction()</code></strong>: full 9x9 grid (depths 0–8 x k_sec 2–48), computes max arity table + winner count tables + depth gap analysis; includes the key bottleneck diagnostic (does depth gap decrease at higher k_sec?)</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>Aizenberg (2008)</strong>: k-sector MVN activation — the combined_cell function is a direct implementation of the MVN activation with variable sector count (k_sec parameter), decomposing the activation into angular (S¹) and directional (S²) components</li>
<li><strong><a href="./entries/demo_89.html">Demo 89</a>–<a href="./entries/demo_90.html">90</a>–91 arc</strong>: this demo is the third in a three-demo arc investigating the depth law mechanism established in <a href="./entries/demo_82.html">Demo 82</a>. <a href="./entries/demo_89.html">D89</a> narrowed the hypothesis space (killed 6/8 candidates), <a href="./entries/demo_90.html">D90</a> found the mechanism (axis cancellation + cross-depth algebraic constraint), <a href="./entries/demo_91.html">D91</a> identified the wall (parity, not activation)</li>
<li><strong>Balanced exponentials (information-theoretic)</strong>: the supply/demand framework — BFS vocabulary growth rate vs parity demand growth rate — echoes capacity arguments in information theory where linear scaling emerges from the ratio of two exponential processes</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li><strong>Does the linear depth law hold for ALL Boolean functions, or just parity?</strong> Different Boolean functions might scale differently with depth — parity is the hardest for single-neuron models, but other functions might have sub-linear or super-linear depth dependence.</li>
<li><strong>Does the law depend on BFS catalog construction specifically?</strong> The ~2x/round vocabulary growth rate is a property of BFS closure of SU(2) generators. Alternative catalog constructions (random quaternion sampling, algebraically structured non-BFS methods) might have different growth rates, yielding different depth law slopes.</li>
<li><strong>How does the depth law change with a different group?</strong> SU(2) yields quaternionic structure with specific S¹ x S² geometry. Other groups (SU(3), exceptional groups) would have different activation cell geometry and different vocabulary growth rates.</li>
<li><strong>Can the solution-count scaling (winners vs resolution) be made precise?</strong> The ~13x growth from k=2 to k=48 suggests a scaling law; characterizing this precisely could connect to counting arguments in combinatorial geometry.</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_92.html">Demo 92</a>: Function Scaling — The Parity-Lock Theorem</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../demo_92_function_scaling/main.c.html">demo_92_function_scaling/main.c</a></code> (~1399 lines)</li>
<li><strong>Tests</strong>: 13/16 pass (3 informative fails — AND/OR/MAJ are impossible under the encoding, so tests expecting them to be achievable correctly fail; these confirm the theorem rather than indicating bugs)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_82.html">Demo 82</a> (crossing depth law, algebraic coherence), <a href="./entries/demo_89.html">Demo 89</a> (depth law mechanism, max_xor ~ depth+6), <a href="./entries/demo_91.html">Demo 91</a> (activation bottleneck, combined_cell framework), <a href="./entries/demo_48.html">Demo 48</a>/50 (forward DKC, NPN class zoo — the 1wpi encoding contrast)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_93.html">Demo 93</a> (complement-blindness theorem under 1wpi encoding), encoding design (targeting specific Boolean functions), activation symmetry-breaking research (phase-sensitive activations)</li>
</ul>
<h3>Headline</h3>
The +/-q input encoding is structurally parity-locked — only XOR/XNOR are computable. AND/OR/MAJ/THRESHOLD = 0 winners at ALL depths.
<h3>Key Results</h3>
<ul>
<li><strong>Phase 1 — Function comparison across depths (zeta_12 catalog, depths 0-8)</strong>: XOR scales from 8 to 3866 winners (6-input) and 0 to 3080 (8-input) as depth increases. AND, OR, MAJ, THRESHOLD-2 produce ZERO winners at every depth for both 6-input and 8-input arities. The depth law (max_xor ~ depth+6) applies only to parity.</li>
<li><strong>Phase 1b — Truth table census (10,000 random 3-weight triples)</strong>: 83.7% of random triples are XOR6-separable. AND, OR, MAJ separability = 0.0% each. This is not a matter of rarity — non-parity functions are structurally impossible.</li>
<li><strong>Phase 1c — Mask collision check</strong>: 76 exact quaternion-sum collisions among C(64,2)=2016 mask pairs. ALL 76 are same-parity (0 cross-parity collisions). Same-parity collisions preserve XOR but break non-XOR functions that need to distinguish same-parity masks.</li>
<li><strong>Phase 1d — Equivalence class analysis (27 classes for k=3 weights)</strong>: The encoding creates 3^k equivalence classes (per-weight effective states {-q, 0, +q}). XOR is constant on all 27 classes (0 conflicts). AND has 1/27 class conflicts, OR has 1/27, MAJ has 19/27. The critical class is (0,0,0): contains both mask 000000 and mask 111111 (both produce sum=0), but AND(000000)=0 and AND(111111)=1 — impossible to separate. 11 distinct cells for 27 classes at k_sec=12.</li>
<li><strong>Phase 1e — Sign-flip symmetry</strong>: All 13 sign-flip pairs (c vs -c) map to identical sector, Voronoi cell, combined cell, and parity. This is provable from the combined_cell code: normalization by |qa| maps S and -S identically. Multi-triple analysis: XOR winners have 11-13 distinct cells (of 27 classes), non-winners have 6-11.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Parity-Lock Theorem (PROVED + computationally verified)</strong>: 6-part theorem. (a) The (0,0) equiv (1,1) collision means masks 0...0 and 1...1 always produce identical sums (both zero). (b) Any f where f(0...0) != f(1...1) is impossible under ANY activation. (c) AND, OR, MAJ all have f(0...0) != f(1...1) — all impossible. (d) XOR(0...0) = XOR(1...1) = 0 for even-length inputs — collision harmless. (e) 3^k equivalence classes, parity constant on each (swapping (0,0)&lt;-&gt;(1,1) changes popcount by +/-2, preserving parity). (f) XOR/XNOR are the only standard Boolean functions constant on all classes. Full proof in <code>proofs/parity-lock-theorem.md</code>.</li>
<li><strong>Sign-Flip Symmetry (PROVED computationally)</strong>: combined_cell(S) = combined_cell(-S) for all sums S. The 3^k equivalence classes collapse to at most (3^k + 1)/2 distinguishable groups under the activation. For k=3: 27 classes -&gt; at most 14 groups. Observed: 11 distinct cells.</li>
<li><strong>Encoding Concentrates on Hardest Function (DEMONSTRATED)</strong>: The +/-q paired encoding channels all computational power into parity — the single Boolean function outside AC^0 (the class of constant-depth polynomial-size circuits). This is not a limitation to be overcome but a structural feature of the encoding.</li>
</ul>
<h3>Data</h3>
<ul>
<li>Catalog: zeta_12, 4096 entries, 9 BFS rounds</li>
<li>Phase 1 XOR winners (6-input): depth 0 = 8, depth 8 = 3866</li>
<li>Phase 1 XOR winners (8-input): depth 0 = 0, depth 8 = 3080</li>
<li>Phase 1 AND/OR/MAJ/THR2 winners: 0 at all depths, both arities</li>
<li>Phase 1b XOR6-separable: 8370/10000 (83.7%)</li>
<li>Phase 1b AND/OR/MAJ-separable: 0/10000 each (0.0%)</li>
<li>Phase 1c mask collisions: 76 total, 76 same-parity, 0 cross-parity</li>
<li>Phase 1d class conflicts: AND 1/27, OR 1/27, MAJ 19/27, XOR 0/27</li>
<li>Phase 1d distinct cells: 11 of 27 classes at k_sec=12</li>
<li>Phase 1e sign-flip pairs: 13/13 same sector, same Voronoi, same cell, same parity</li>
<li>Phase 1e multi-triple distinct cells: winners 11-13, non-winners 6-11</li>
<li>K-ladder: K_SHORT = {6, 12, 24} (short ladder for tractable runtime)</li>
<li>bf_max limits: 30 (6-input), 20 (8-input)</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong><code>test_bool_func(indices, n_weights, k_sec, truth_table)</code></strong>: generalized Boolean function test — checks whether a weight tuple separates class-0 from class-1 masks in the combined_cell activation space. Returns 1 if separable, 0 if not. Reusable for any truth table.</li>
<li><strong><code>count_bool_winners(n_weights, bf_limit, truth_table)</code></strong>: counts weight tuples that achieve a given Boolean function across the short k-ladder {6,12,24}. Supports 3/4/5-weight tuples.</li>
<li><strong>Truth table generators</strong>: <code>make_xor_tt</code>, <code>make_and_tt</code>, <code>make_or_tt</code>, <code>make_maj_tt</code>, <code>make_threshold_tt</code> — produce truth tables for standard Boolean functions given n_inputs. Reusable.</li>
<li><strong><code>check_separability(cell_labels, truth_table, n_masks)</code></strong>: checks whether a cell-labeling can separate a truth table (all masks in each cell have same truth value). Used in Phase 1b census.</li>
<li><strong><code>phase1b_truth_table_census()</code></strong>: Monte Carlo census — 10,000 random 3-weight triples tested for XOR/XNOR/AND/OR/MAJ separability. Stores distinct cell-label patterns.</li>
<li><strong><code>phase1c_mask_collisions()</code></strong>: exhaustive pairwise collision check (C(64,2) pairs), classifies collisions by parity agreement. Confirms same-parity-only collision structure.</li>
<li><strong><code>phase1d_class_analysis()</code></strong>: enumerates all 27 equivalence classes for 3 weights, checks each standard Boolean function for constancy on each class, prints conflict counts and cell assignments.</li>
<li><strong><code>phase1e_sign_flip_symmetry()</code></strong>: decomposes combined_cell into sector_of and voronoi_of, checks all 13 sign-flip pairs for agreement, plus multi-triple cell count comparison between winners and non-winners.</li>
<li><strong><code>sector_of()</code> / <code>voronoi_of()</code></strong>: decomposition of the combined_cell activation into its angular (S^1) and directional (S^2) components. Useful for future activation analysis.</li>
<li><strong><code>build_closure(verbose)</code></strong>: SU(2) group closure with BFS depth tracking and round-by-round reporting. Shared infrastructure from earlier demos.</li>
<li><strong><code>save_catalog()</code> / <code>load_up_to_depth(max_d)</code></strong>: snapshot/filter pattern enabling cumulative depth experiments without rebuilding the catalog.</li>
<li><strong>LCG RNG</strong>: simple <code>rng_uniform()</code> for Monte Carlo sampling (deterministic seed 42).</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>Circuit complexity (AC^0)</strong>: Parity is the canonical function outside AC^0 — it cannot be computed by constant-depth polynomial-size circuits of AND/OR/NOT gates. The +/-q encoding naturally selects for the hardest Boolean function, concentrating computational power on parity. Furst-Saxe-Sipser (1984) / Hastad (1987) parity-not-in-AC^0 result is the theoretical backdrop.</li>
<li><strong>Habiro (2002) / Z[zeta_8] bracket</strong>: the algebraic substrate underlying the weight catalog; <a href="./entries/demo_92.html">Demo 92</a> reveals that the encoding structure on top of this substrate is parity-selective.</li>
<li><strong>Aizenberg (2008) / MVN neurons</strong>: the k-sector activation framework (k_sec parameter in combined_cell). <a href="./entries/demo_92.html">Demo 92</a>'s Phase 1d and 1e decompose the activation into angular sectors (S^1) and Voronoi cells (S^2).</li>
<li><strong><a href="./entries/demo_48.html">D48</a>/<a href="./entries/demo_50.html">D50</a> (forward DKC NPN classes)</strong>: the critical contrast — 1-weight-per-input encoding with split-sigmoid/MVN activation computes all 13 NPN classes including parity. The +/-q encoding's parity lock is encoding-specific, not a fundamental limit of the DKC framework. This contrast motivated <a href="./entries/demo_93.html">Demo 93</a>.</li>
<li><strong><a href="./entries/demo_89.html">D89</a>-<a href="./entries/demo_91.html">D91</a> (depth law)</strong>: max_xor ~ depth+6 describes the capacity curve for the +/-q encoding's ONLY achievable function family (parity). <a href="./entries/demo_92.html">Demo 92</a> reinterprets the depth law as parity-specific, not function-general.</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li><strong>Encoding design</strong>: Can we construct encodings that target specific Boolean functions other than parity? The parity-lock theorem identifies the structural mechanism (per-weight pair cancellation); can this be exploited to engineer encodings for AND, OR, or MAJ?</li>
<li><strong>Optimality</strong>: Is the +/-q encoding provably optimal for parity among all 2-bit-per-weight encodings? Among all encodings with the same number of input bits?</li>
<li><strong>Phase-sensitive activation</strong>: The sign-flip symmetry (combined_cell(S) = combined_cell(-S)) is identified as a second parity-lock mechanism (exploited in <a href="./entries/demo_93.html">D93</a>). Can a phase-sensitive activation that distinguishes S from -S break the parity lock while preserving the depth law structure?</li>
<li><strong>Hybrid encodings</strong>: Can a mixed encoding (some weights +/-q paired, some 1wpi) achieve a richer set of Boolean functions while maintaining some depth-law structure?</li>
<li><strong>MAJ conflict count (19/27)</strong>: MAJ has the most class conflicts of any tested function. Is this related to MAJ's computational complexity (MAJ is TC^0-complete, strictly between AC^0 and NC^1)?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_93.html">Demo 93</a>: Function Scaling — 1-Weight-Per-Input Encoding</h2>
<ul>
<li><strong>Status</strong>: COMPLETE (LANDMARK)</li>
<li><strong>File</strong>: <code><a href="../demo_93_function_scaling_1wpi/main.c.html">demo_93_function_scaling_1wpi/main.c</a></code> (~1636 lines)</li>
<li><strong>Tests</strong>: 37/37 pass (Phases 1-8)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_92.html">Demo 92</a> (parity-lock theorem, +/-q encoding is XOR-only), <a href="./entries/demo_82.html">Demo 82</a>-<a href="./entries/demo_91.html">91</a> (depth-law arc, combined_cell activation framework), <a href="./entries/demo_48.html">Demo 48</a>/50 (forward DKC, 1wpi encoding computes all 13 NPN classes with split-sigmoid/MVN), <a href="./entries/demo_80.html">Demo 80</a> (finite/infinite boundary)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_94.html">Demo 94</a> (binary icosahedral group, solvability as capacity bottleneck), <a href="./entries/demo_95.html">Demo 95</a> (RKHS kernel computation), activation zoo research, encoding design theory, depth law under phase_cell</li>
</ul>
<h3>Headline</h3>
The 1-weight-per-input encoding under combined_cell is complement-blind (only complement-invariant functions achievable); removing the sign flip (phase_cell) recovers all 13 NPN classes, and a circuit complexity hierarchy emerges as hit-rate divergence: AND/XOR ratio explodes from 1.01 to infinity as N grows from 3 to 8.
<h3>Key Results</h3>
<ul>
<li><strong>Complement-Blindness Theorem (Phases 1-4)</strong>: Under combined_cell, mask m and ~m produce sums S and -S; the <code>if (qa &lt; 0)</code> normalization maps both to the same cell. ANY function where f(m) != f(~m) is impossible. At odd N, NO standard Boolean function survives. At N=3, only 2 obscure NPN classes (out of 14) are complement-invariant — none contains AND, OR, XOR, or MAJ.</li>
<li><strong>Phase 5 — Phase-sensitive activation recovery (N=3)</strong>: Removing the <code>if (qa &lt; 0)</code> flip creates phase_cell: sector spans [0,360) not [0,180). Complement-pair sharing drops from 100% to 1.1%. ALL 13 NPN classes recovered (12/13 at depth 0, last at depth 1).</li>
<li><strong>Phases 6-8 — Circuit Complexity Hierarchy</strong>: AND/XOR ratio at depth 1: 1.01 (N=3), 1.08 (N=4), 1.44 (N=5), 7.27 (N=6), 2762 (N=7), infinity (N=8). Three regimes: AND (AC^0) degrades gracefully 97%→42%, MAJ (TC^0) cliff at N=8 (2.4%), XOR (parity, outside AC^0) killed by pigeonhole at N≥7.</li>
<li><strong>Pigeonhole mechanism</strong>: 84 cells at depth 1. XOR dies when 2^N &gt; cells. AND survives (1-hot needs one unique cell).</li>
<li><strong>MAJ/XOR crossover at depth ≈3-4 (N=6)</strong>: Depth disproportionately helps parity.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Complement-Blindness Theorem (PROVED + computationally verified)</strong>: combined_cell(S) = combined_cell(-S) due to |qa| normalization. Extends <a href="./entries/demo_92.html">D92</a>'s Parity-Lock Theorem: encoding provides algebra, activation selects extractable functions.</li>
<li><strong>Circuit Complexity Hierarchy in DKC (DEMONSTRATED)</strong>: Universal across group structures (confirmed by <a href="./entries/demo_94.html">D94</a>).</li>
<li><strong>Pigeonhole Mechanism (DEMONSTRATED)</strong>: The circuit depth bottleneck in finite discrete systems.</li>
</ul>
<h3>Data</h3>
<ul>
<li><strong>Phase 8 headline table (depth 1, 17 entries, 84 cells, exhaustive)</strong>:</li>
</ul>
<table><thead><tr><th>N</th><th>masks</th><th>XOR%</th><th>AND%</th><th>MAJ%</th><th>AND/XOR ratio</th></tr></thead><tbody><tr><td>3</td><td>8</td><td>96.8%</td><td>97.7%</td><td>99.7%</td><td>1.01</td></tr><tr><td>4</td><td>16</td><td>85.6%</td><td>92.3%</td><td>91.1%</td><td>1.08</td></tr><tr><td>5</td><td>32</td><td>58.3%</td><td>84.1%</td><td>94.3%</td><td>1.44</td></tr><tr><td>6</td><td>64</td><td>9.9%</td><td>71.7%</td><td>49.6%</td><td>7.27</td></tr><tr><td>7</td><td>128</td><td>0.02%</td><td>56.8%</td><td>68.7%</td><td>2762</td></tr><tr><td>8</td><td>256</td><td>0.00%</td><td>41.6%</td><td>2.4%</td><td>infinity</td></tr></tbody></table>
<ul>
<li><strong>Phase 7 N=6 AND/XOR ratio by depth</strong>: d=1: 7.27, d=2: 2.77, d=3: 1.75, d=4: 1.27, d=5: 1.13, d=6: 1.08 (convergence)</li>
<li><strong>Pigeonhole</strong>: 84 cells at depth 1. N≥7: 2^N &gt; cells → XOR impossible.</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><strong><code>phase_cell</code></strong>: Phase-sensitive activation — combined_cell WITHOUT sign flip. THE key activation for circuit complexity hierarchy.</li>
<li><strong><code>test_1wpi_phase</code></strong>: 1wpi Boolean function test under phase_cell.</li>
<li><strong><code>init_npn()</code> / <code>sweep_triple_npn()</code></strong>: NPN equivalence class enumeration for 3-input functions.</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>Hastad (1986/1987)</strong>: Parity requires exp(Omega(n^{1/(d-1)})) gates at bounded depth. <a href="./entries/demo_93.html">D93</a> makes concrete: AND/XOR = 1→2762→∞.</li>
<li><strong>Barrington (1989)</strong>: NC^1 = programs over non-solvable groups. Solvable/non-solvable boundary predicts capacity walls.</li>
<li><strong>LMN (1993)</strong>: AC^0 Fourier concentration below degree (log n)^d. AND's robustness to cell limits.</li>
<li><strong>Furst-Saxe-Sipser (1984)</strong>: Parity-not-in-AC^0. Theoretical backdrop.</li>
<li><strong>Nazer-Gastpar</strong>: DKC = multiplicative catalog + additive readout + activation. Novel hybrid model.</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Higher k_sec: does N=8 XOR become nonzero at k_sec=24?</li>
<li>Depth law under phase_cell: does max_xor ≈ depth+6 still hold?</li>
<li>MAJ cliff mechanism: threshold phenomenon or gradual?</li>
<li>RKHS kernel rank test (seeded as <a href="./entries/demo_95.html">D95</a>)</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_94.html">Demo 94</a>: Binary Icosahedral Group (2I, E8) — Solvability as Capacity Bottleneck</h2>
<ul>
<li><strong>Status</strong>: COMPLETE (RESULT)</li>
<li><strong>File</strong>: <code><a href="../demo_94_binary_icosahedral/main.c.html">demo_94_binary_icosahedral/main.c</a></code> (~1282 lines)</li>
<li><strong>Tests</strong>: 20/20 pass (Phases 0-4)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_93.html">Demo 93</a> (circuit complexity hierarchy, 1wpi framework), <a href="./entries/demo_80.html">Demo 80</a> (finite/infinite capacity boundary), <a href="./entries/demo_92.html">Demo 92</a> (parity-lock theorem), <a href="./entries/demo_48.html">Demo 48</a>/50 (forward DKC)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_95.html">Demo 95</a> (RKHS kernel computation), higher k_sec with 2I, quantum dimension direct test, cross-depth 2I analysis</li>
</ul>
<h3>Headline</h3>
The binary icosahedral group 2I (order 120, unique non-solvable finite SU(2) subgroup) outperforms solvable z8 at matched catalog size, confirming solvability as the capacity bottleneck predicted by Barrington's theorem.
<h3>Key Results</h3>
<ul>
<li><strong>Phase 0 — Z[sqrt5] exact arithmetic</strong>: All group operations in exact integer arithmetic. Generators: s = (1+i+j+k)/2 (order 6), t = (phi+phi_inv*i+j)/2 (order 10). 11 verification tests.</li>
<li><strong>Phase 1 — BFS closure</strong>: |2I| = 60 (mod sign), 7 BFS rounds. Depth profile: 5,8,11,12,11,8,4,1 (symmetric diamond). 9 conjugacy classes, ~31 S^2 directions (vs 13 for z8).</li>
<li><strong>Phase 2 — Size-controlled comparison (24 vs 24)</strong>: N=6 XOR: 2I wins by 78% (23137 vs 12983). N=7 XOR: 2I wins ~3.4x. N=7 AND: 2I wins ~3.4x.</li>
<li><strong>Phase 2b — Depth-matched</strong>: 2I advantage ACCELERATES: 1.07x (N=3) → 1.14x (N=4) → 1.21x (N=5) → 1.67x (N=6).</li>
<li><strong>Phase 3 — Full 2I (60 entries, 384 cells)</strong>: AND/XOR ratio 1.25→68827 (N=3→8). Hierarchy universal across groups. N=7 XOR: 2I=2.38% vs z12=0.02% (119x).</li>
<li><strong>Phase 4 — Three-way</strong>: Crossover at N=6: z12 wins small N (angular variety), 2I wins N=6-7 (non-solvability at computational boundary).</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Solvability Bottleneck (CONFIRMED computationally)</strong>: Non-solvable 2I beats solvable z8 at matched size, advantage growing with arity.</li>
<li><strong>Circuit Complexity Hierarchy Universality (CONFIRMED)</strong>: AND/XOR explosion in ALL tested groups.</li>
<li><strong>DKC as Discrete Algebraic Reservoir Computer (PROPOSED)</strong>: Testable: rank(K_2I)/rank(K_z8) &gt; 120/24 if non-solvability contributes above size.</li>
</ul>
<h3>Data</h3>
<p><strong>Phase 2b depth-matched (first 24 from 2I by BFS vs z8, 12 dirs, 156 cells):</strong></p>
<table><thead><tr><th>N</th><th>z8 XOR%</th><th>2I-24 XOR%</th><th>ratio</th></tr></thead><tbody><tr><td>3</td><td>73.12%</td><td>78.06%</td><td>1.07x</td></tr><tr><td>4</td><td>75.38%</td><td>85.77%</td><td>1.14x</td></tr><tr><td>5</td><td>40.47%</td><td>48.95%</td><td>1.21x</td></tr><tr><td>6</td><td>9.65%</td><td>16.11%</td><td>1.67x</td></tr></tbody></table>
<p><strong>Phase 3 full capacity (60 entries, 31 dirs, 384 cells):</strong></p>
<table><thead><tr><th>N</th><th>XOR%</th><th>AND%</th><th>MAJ%</th><th>AND/XOR</th></tr></thead><tbody><tr><td>3</td><td>74.80%</td><td>93.42%</td><td>74.78%</td><td>1.25</td></tr><tr><td>4</td><td>91.33%</td><td>94.73%</td><td>74.50%</td><td>1.04</td></tr><tr><td>5</td><td>59.98%</td><td>93.74%</td><td>61.34%</td><td>1.56</td></tr><tr><td>6</td><td>37.12%</td><td>89.72%</td><td>26.20%</td><td>2.42</td></tr><tr><td>7</td><td>2.38%</td><td>81.62%</td><td>5.06%</td><td>34.29</td></tr><tr><td>8</td><td>0.00%</td><td>68.83%</td><td>0.01%</td><td>68827</td></tr></tbody></table>
<p><strong>Quantum dimension table:</strong></p>
<table><thead><tr><th>Root</th><th>[2]_q</th><th>Finite?</th><th>Group</th><th>Solvable?</th><th>Capacity</th></tr></thead><tbody><tr><td>z4</td><td>-2</td><td>YES (4)</td><td>Q8</td><td>Yes</td><td>Very limited</td></tr><tr><td>z8</td><td>0</td><td>YES (24)</td><td>2O (E7)</td><td>Yes</td><td>XOR8 ceiling</td></tr><tr><td>z12</td><td>1</td><td>NO (inf)</td><td>Dense</td><td>N/A</td><td>XOR12+</td></tr><tr><td>2I</td><td>phi</td><td>YES (120)</td><td>2I (E8)</td><td>NO</td><td>Higher than z8</td></tr></tbody></table>
<h3>Code Assets</h3>
<ul>
<li><strong><code>Zr5</code> / <code>Q2I</code></strong>: Exact Z[sqrt5] quaternion arithmetic. Fully reusable.</li>
<li><strong><code>build_2i()</code></strong>: BFS closure of 2I from generators s,t. Depth tracking.</li>
<li><strong><code>build_z12_truncated(max_depth)</code></strong>: Truncated z12 catalog for controlled comparisons.</li>
<li><strong>Fisher-Yates shuffle</strong>: Random subset selection for size-controlled experiments.</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>Barrington (1989)</strong>: NC^1 = non-solvable groups. <a href="./entries/demo_94.html">D94</a> confirms computationally.</li>
<li><strong>ADE classification</strong>: 2I is the unique non-solvable finite SU(2) subgroup (E8).</li>
<li><strong>Burrello et al. (2010 PRL)</strong>: Fibonacci anyons use 2I for universal TQC.</li>
<li><strong>Liu &amp; Calderbank (2008 IEEE)</strong>: Icosian ring = E8 lattice. DKC sums are icosian ring elements.</li>
<li><strong>Mochon (2003)</strong>: Fibonacci parameter [2]_q = phi^{-1}, maximally computational for TQC.</li>
<li><strong>Reservoir computing (Maass/Gonon)</strong>: DKC = discrete algebraic reservoir. Five-pillar synthesis complete.</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>RKHS kernel rank (<a href="./entries/demo_95.html">D95</a>): does rank(K_2I)/rank(K_z8) &gt; 120/24?</li>
<li>Higher k_sec with 2I: does 384-cell space fully exploit 9 half-angles?</li>
<li>N=6-7 crossover mechanism: why does 2I overtake z12 specifically there?</li>
<li>Size vs solvability disentangling: 2I truncated to 51 entries vs z12 at 51</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_95.html">Demo 95</a>: Commutator Depth and XOR Capacity</h2>
<ul>
<li><strong>Status</strong>: COMPLETE (RESULT)</li>
<li><strong>File</strong>: <code><a href="../demo_95_commutator_depth/main.c.html">demo_95_commutator_depth/main.c</a></code> (~1242 lines)</li>
<li><strong>Tests</strong>: 19 pass, 0 fail (Phases 1-4 + 3b)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_94.html">Demo 94</a> (binary icosahedral 2I vs solvable z8, solvability bottleneck confirmed), <a href="./entries/demo_93.html">Demo 93</a> (1wpi phase_cell framework, circuit complexity hierarchy), <a href="./entries/demo_84.html">Demo 84</a> (0+0=36 null synergy), <a href="./entries/demo_88.html">Demo 88</a> (anti-correlation, load-bearing non-null directions), <a href="./entries/demo_89.html">Demo 89</a> (depth law: max_xor ~ depth + 6)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_96.html">Demo 96</a> (TL-group cross-classification: are <a href="./entries/demo_84.html">D84</a> null/non-null and <a href="./entries/demo_95.html">D95</a> derived series the same partition?), unify <a href="./entries/demo_84.html">D84</a>/<a href="./entries/demo_95.html">D95</a> synergy, cross-depth synergy matrix (all 4 level-pairs of derived series), RKHS kernel rank (does kernel rank predict synergy?), zeta_12 stratification question</li>
</ul>
<h3>Headline</h3>
The commutator structure of solvable vs non-solvable groups is made VISIBLE through derived series computation and subset XOR capacity testing. The key result: neither the commutator subgroup nor the non-commutator coset carries disproportionate XOR capacity in isolation. Computational power emerges from CROSS-LAYER interaction between algebraic strata. This is the same 0+0&gt;0 synergy pattern as <a href="./entries/demo_84.html">D84</a>, now traced to its algebraic origin.
<h3>Key Results</h3>
<ul>
<li><strong>Phase 1 -- Commutator Classification (5 tests)</strong>: z8 (binary octahedral, 24 bracket values): 12/24 entries are single commutators (exactly the binary tetrahedral 2T subgroup). G1 (commutator subgroup) = 12 entries. G0\G1 (non-commutator coset) = 12 entries. 2I (binary icosahedral, 60 bracket values): 60/60 entries are single commutators -- PERFECT GROUP confirmed computationally. Matches Liebeck-O'Brien-Shalev-Tiep (2011): since 2I is isomorphic to SL(2,5), every element is a commutator.</li>
<li><strong>Phase 2 -- Derived Series (5 tests)</strong>: z8 derived series: 24 &gt; 12 &gt; 4 &gt; 1. Matches the chain 2O &gt; 2T &gt; Q8 &gt; {+/-1} (binary octahedral &gt; binary tetrahedral &gt; quaternion group &gt; center). Level membership partition: Level 0 (D0\<a href="./entries/demo_01.html">D1</a>) = 12 entries (outermost, non-commutator), Level 1 (<a href="./entries/demo_01.html">D1</a>\<a href="./entries/demo_02.html">D2</a>) = 8 entries (first commutator layer), Level 2 (<a href="./entries/demo_02.html">D2</a>\<a href="./entries/demo_03.html">D3</a>) = 3 entries (deep commutator, Q8), Level 3 (<a href="./entries/demo_03.html">D3</a>) = 1 entry (identity). 2I: G1 = G0 = 60 -&gt; PERFECT. Derived series terminates immediately. First direct computation of this partition in the DKC context.</li>
<li><strong>Phase 3 -- COMM vs NON-COMM XOR Capacity (3 tests)</strong>: COMM (G1, 12 entries) and NON-COMM (G0\G1, 12 entries) perform SIMILARLY in isolation (~1.1x COMM edge). But ALL(24) dramatically outperforms both -- 2.7x the rate at N=5. The computational power is in the CROSS-TERMS between solvable layers, not in either layer alone. This is the same DKC synergy mechanism as <a href="./entries/demo_84.html">D84</a>'s 0+0=36. COMM survives at N=7 (1.01%) while NON-COMM dies (0%) -- algebraic depth provides last-resort structure at the computational boundary.</li>
<li><strong>Phase 3b -- 90-Degree Split Test (3 tests)</strong>: 9 bracket-null entries (half-angle 90 degrees, Re=0) come from TWO derived levels: 3 from Q8 (algebraically deep, <a href="./entries/demo_02.html">D2</a>) and 6 from outermost shell (algebraically shallow, D0). Same half-angle, different algebraic origin. Q8-null (3 entries): XOR = 0 at all N. Outermost-null (6 entries): XOR = 0 at all N. All-null combined (9 entries): XOR = 33/126 = 26.19% at N=4, zero elsewhere. NEITHER subset can do XOR alone. Only the MIX produces capacity. Cleanest synergy demonstration in the project: pure 0+0=26% at matched geometry. Algebra wins over geometry.</li>
<li><strong>Phase 4 -- Matched Comparison z8-COMM-12 vs 2I-first-12 (3 tests)</strong>: 2I-first-12 crushes z8-COMM at N=3-5 (1.56x to 2.15x). Crossover at N=6-7 mirrors <a href="./entries/demo_94.html">D94</a> Phase 4 pattern (z8-COMM slightly leads at N=6 with 6.28% vs 5.95%). Non-solvable 2I wins at matched size because it has no stratification bottleneck -- every element is a commutator, so all 60 entries participate equally.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Cross-Layer Synergy Mechanism (DEMONSTRATED computationally)</strong>: Neither the commutator subgroup (COMM) nor the non-commutator coset (NON-COMM) of z8 carries disproportionate XOR capacity. Capacity emerges from mixing algebraic strata. The Barrington mechanism works through CROSSING between algebraic layers, not through commutators alone.</li>
<li><strong>Solvability Bottleneck via Stratification (REFINED from <a href="./entries/demo_94.html">D94</a>)</strong>: Solvable groups waste combinatorial budget on cross-layer constraints. Having derived series layers forces cross-layer dependence which constrains how many useful signed sums exist. 2I's perfection (G1=G0) means every pair (i,j) contributes commutator-quality interference. Solvability bottleneck operates THROUGH stratification.</li>
<li><strong>90-Degree Algebra-over-Geometry (DEMONSTRATED)</strong>: Within the same half-angle (90 degrees), algebraic origin creates computational capacity. Entries from Q8 (<a href="./entries/demo_02.html">D2</a>) and outermost shell (D0) are geometrically identical but algebraically distinct. Neither subset alone produces XOR solutions, but their union does. Geometry is necessary but not sufficient; algebraic depth is the active ingredient.</li>
<li><strong>Synergy Universality Conjecture (PROPOSED)</strong>: <a href="./entries/demo_84.html">D84</a> synergy (TL null/non-null = 0+0=36) and <a href="./entries/demo_95.html">D95</a> synergy (derived series layers = 0+0=26%) may be the same algebraic split seen through different lenses. Seeded <a href="./entries/demo_96.html">D96</a> to test this.</li>
</ul>
<h3>Data</h3>
<p><strong>z8 group structure (Phase 1-2):</strong> <ul> <li>|z8| = 24 bracket values (binary octahedral 2O, order 48 mod sign)</li> <li>Generators: g1 = (sqrt2/2)(1 + i), g2 = (sqrt2/2)(1 - k), plus their conjugates</li> <li>12/24 entries are single commutators</li> <li>G1 (commutator subgroup) = 12 entries (binary tetrahedral 2T)</li> <li>Derived series: 24 &gt; 12 &gt; 4 &gt; 1</li> </ul>
<p><strong>z8 derived series level membership:</strong></p>
<table><thead><tr><th>Level</th><th>Size</th><th>Algebraic identity</th></tr></thead><tbody><tr><td>D0\<a href="./entries/demo_01.html">D1</a></td><td>12</td><td>Outermost, non-commutator</td></tr><tr><td><a href="./entries/demo_01.html">D1</a>\<a href="./entries/demo_02.html">D2</a></td><td>8</td><td>First commutator layer (2T\Q8)</td></tr><tr><td><a href="./entries/demo_02.html">D2</a>\<a href="./entries/demo_03.html">D3</a></td><td>3</td><td>Deep commutator (Q8\center)</td></tr><tr><td><a href="./entries/demo_03.html">D3</a></td><td>1</td><td>Identity</td></tr></tbody></table>
<p><strong>2I group structure (Phase 1):</strong> <ul> <li>|2I| = 60 bracket values (binary icosahedral, order 120 mod sign)</li> <li>60/60 entries are single commutators -- PERFECT GROUP</li> <li>Derived series: 60 = 60 (terminates immediately)</li> </ul>
<p><strong>Phase 3 -- COMM vs NON-COMM vs ALL XOR hit rates:</strong></p>
<table><thead><tr><th>N</th><th>COMM(12)</th><th>NON-COMM(12)</th><th>ALL(24)</th><th>COMM/NONC</th></tr></thead><tbody><tr><td>3</td><td>48.64%</td><td>42.73%</td><td>71.94%</td><td>1.14x</td></tr><tr><td>4</td><td>44.04%</td><td>51.52%</td><td>75.04%</td><td>0.85x</td></tr><tr><td>5</td><td>15.15%</td><td>13.64%</td><td>40.76%</td><td>1.11x</td></tr><tr><td>6</td><td>6.28%</td><td>5.63%</td><td>9.64%</td><td>1.12x</td></tr><tr><td>7</td><td>1.01%</td><td>0.00%</td><td>0.18%</td><td>inf</td></tr></tbody></table>
<p><strong>Phase 3b -- 90-degree split (Re=0 entries, matched half-angle):</strong></p>
<table><thead><tr><th>Subset</th><th>Size</th><th>N=3 XOR</th><th>N=4 XOR</th><th>N=5 XOR</th><th>N=6 XOR</th></tr></thead><tbody><tr><td>Q8-null (<a href="./entries/demo_02.html">D2</a>)</td><td>3</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>Outermost-null (D0)</td><td>6</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>All-null (mixed)</td><td>9</td><td>0</td><td>33/126 = 26.19%</td><td>0</td><td>0</td></tr></tbody></table>
<p><strong>Phase 4 -- Matched comparison (12 entries each):</strong></p>
<p>XOR hit rates:</p>
<table><thead><tr><th>N</th><th>z8-COMM (12)</th><th>2I-first-12</th><th>ratio (2I/z8)</th></tr></thead><tbody><tr><td>3</td><td>48.64%</td><td>75.91%</td><td>1.56x</td></tr><tr><td>4</td><td>44.04%</td><td>72.12%</td><td>1.64x</td></tr><tr><td>5</td><td>15.15%</td><td>32.58%</td><td>2.15x</td></tr><tr><td>6</td><td>6.28%</td><td>5.95%</td><td>0.95x</td></tr><tr><td>7</td><td>1.01%</td><td>0.00%</td><td>0.00x</td></tr></tbody></table>
<h3>Code Assets</h3>
<ul>
<li><strong><code>Zr2</code> (Z[sqrt2] ring arithmetic)</strong>: Exact integer type representing a + b*sqrt(2). Operations: <code>zr2_make</code>, <code>zr2_add</code>, <code>zr2_sub</code>, <code>zr2_neg</code>, <code>zr2_mul</code>, <code>zr2_eq</code>, <code>zr2_div2</code>. Multiplication uses sqrt(2)^2 = 2. Reusable for any computation in Z[sqrt2].</li>
<li><strong><code>QZ8</code> (quaternion over Z[sqrt2])</strong>: Four-component quaternion with Zr2 entries (representing (a + b*sqrt2)/2 per component). Operations: <code>qz8_make</code>, <code>qz8_eq</code>, <code>qz8_neg</code>, <code>qz8_conj</code>, <code>qz8_mul</code>. Multiplication includes <code>zr2_div2</code> for /4 -&gt; /2 renormalization. Exact arithmetic, no floating point in group operations.</li>
<li><strong><code>Zr5</code> / <code>Q2I</code> (from <a href="./entries/demo_94.html">D94</a>)</strong>: Z[sqrt5] ring and quaternion arithmetic for binary icosahedral group. Carried forward unchanged.</li>
<li><strong><code>build_z8(verbose)</code></strong>: BFS closure of binary octahedral group from generators (sqrt2/2)(1+i) and (sqrt2/2)(1-k) plus conjugates. Stores elements in global array with depth tracking. Handles mod-sign identification (48 elements -&gt; 24 bracket values).</li>
<li><strong><code>build_2i(verbose)</code></strong>: BFS closure of binary icosahedral group from generators s and t (from <a href="./entries/demo_94.html">D94</a>). 120 elements -&gt; 60 bracket values.</li>
<li><strong><code>z8_commutator(a, b)</code> / <code>i2_commutator(a, b)</code></strong>: Compute [a,b] = a<em>b</em>a^{-1}*b^{-1} for z8 and 2I respectively. Uses conjugate as inverse (unit quaternions).</li>
<li><strong><code>close_z8_subgroup(in_set)</code></strong>: Takes a subset indicator array, closes under multiplication and inverse to produce a subgroup. Used for derived series computation. Returns size of closed subgroup.</li>
<li><strong><code>phase1_commutators()</code></strong>: Enumerates all single commutators [g_i, g_j] in both z8 and 2I. Classifies each group element as commutator or not. Verifies 2I is perfect (all elements are commutators).</li>
<li><strong><code>phase2_derived_series()</code></strong>: Iteratively computes derived series G0 &gt; G1 &gt; G2 &gt; ... by taking commutator subgroup at each level. Tracks level membership (which derived layer each element belongs to). Verifies z8 series terminates at 1 and 2I is perfect.</li>
<li><strong><code>phase3_capacity_comparison()</code></strong>: Tests XOR and AND capacity for COMM subset, NON-COMM subset, and full z8 group independently. Uses 1wpi phase_cell framework with k_sec shortlist {6, 12, 24}. Produces comparison table with hit rates.</li>
<li><strong><code>phase3b_ninety_degree_split()</code></strong>: Isolates Re=0 (90-degree half-angle) entries and splits them by derived series level (Q8-level vs outermost). Tests each subset and their union for XOR. Demonstrates algebra-over-geometry synergy.</li>
<li><strong><code>phase4_matched_comparison()</code></strong>: Size-controlled comparison: z8-COMM (12 entries) vs first 12 entries from 2I (by BFS depth). Tests XOR and AND. Demonstrates 2I advantage at matched size using the commutator subset as the solvable baseline.</li>
<li><strong><code>load_z8_subset(mask)</code> / <code>load_2i_first_n(n)</code></strong>: Catalog loading helpers that populate the global float catalog from subset masks or first-N selection.</li>
<li><strong><code>qz8_to_float()</code> / <code>q2i_to_float()</code></strong>: Convert exact algebraic quaternions to floating-point Quat for use with 1wpi phase_cell framework. Shared with <a href="./entries/demo_94.html">D94</a>.</li>
<li><strong><code>phase_cell()</code> / <code>vor_cell()</code> / <code>build_dirs()</code> / <code>count_phase_ex()</code></strong>: 1wpi activation and testing infrastructure. Shared pattern across <a href="./entries/demo_92.html">D92</a>-<a href="./entries/demo_95.html">D95</a>.</li>
<li><strong><code>make_xor_tt()</code> / <code>make_and_tt()</code></strong>: Truth table generators for XOR and AND Boolean functions.</li>
<li><strong><code>next_combo()</code> / <code>comb_nk()</code></strong>: Combinatorial utilities for exhaustive weight-tuple enumeration.</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>Barrington (1989) -- branching programs over groups</strong>: NC1 = programs over non-solvable groups. <a href="./entries/demo_95.html">D95</a> refines the mechanism: the bottleneck is not that commutators are individually weaker, but that stratification (having derived series layers) forces cross-layer dependence which wastes combinatorial budget. Non-solvable groups avoid this by being perfect (G1=G0).</li>
<li><strong>Liebeck, O'Brien, Shalev, Tiep (2011) -- Ore conjecture for finite simple groups</strong>: Every element of a finite simple group is a commutator. Computationally confirmed for 2I (isomorphic to SL(2,5) / perfect group): 60/60 bracket values are single commutators.</li>
<li><strong>ADE classification of finite SU(2) subgroups</strong>: z8 derived series 24 &gt; 12 &gt; 4 &gt; 1 corresponds exactly to 2O &gt; 2T &gt; Q8 &gt; {+/-1} in the ADE chain (E7 &gt; E6 &gt; <a href="./entries/demo_04.html">D4</a> &gt; A1). First direct computation of this partition in the DKC context.</li>
<li><strong>Barrington mechanism (refinement from <a href="./entries/demo_95.html">D95</a>)</strong>: Cross-layer interaction, not commutators in isolation, is the active mechanism. The commutator subgroup and its coset have nearly equal XOR capacity when tested alone. The 2.7x boost from ALL(24) over either 12-element subset demonstrates that the signed-sum interference between algebraic strata is load-bearing.</li>
<li><strong>Habiro (2002) / Z[zeta_8] bracket</strong>: Algebraic substrate for the z8 group; <a href="./entries/demo_95.html">D95</a> uses exact Z[sqrt2] arithmetic to compute derived series without floating-point error.</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li><strong>Are <a href="./entries/demo_84.html">D84</a> and <a href="./entries/demo_95.html">D95</a> synergy the same split?</strong> <a href="./entries/demo_84.html">D84</a> synergy (TL null/non-null = 0+0=36) and <a href="./entries/demo_95.html">D95</a> synergy (derived series layers = 0+0=26%) -- are they the same algebraic partition seen through different lenses, or independent? (Directly seeded <a href="./entries/demo_96.html">D96</a>.)</li>
<li><strong>Cross-depth synergy matrix</strong>: For z8, test ALL level-pair combinations (D0xD1, D0xD2, D1xD2, etc.) to map which crossings are most productive. The 90-degree split (Phase 3b) tested D0xD2; the full matrix would reveal the synergy landscape.</li>
<li><strong>Layer combination map</strong>: Which 2-layer and 3-layer combinations of derived series produce the most synergy? Is there a hierarchy of layer crossings?</li>
<li><strong>RKHS kernel rank</strong>: Does kernel rank predict synergy? If the kernel rank of the COMM+NON-COMM union exceeds the sum of individual ranks, that would mathematically quantify the cross-term mechanism.</li>
<li><strong>zeta_12 stratification</strong>: Does the dense (non-solvable, infinite) group have algebraic strata? If not, does that explain its high capacity?</li>
<li><strong>N=7 COMM survival mechanism</strong>: COMM survives at N=7 (1.01%) while NON-COMM dies (0%). What structural property of the commutator subgroup (2T) provides this last-resort capacity? Is it related to 2T's own commutator structure (Q8)?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_96.html">Demo 96</a>: TL-Group Cross-Classification — 2D Synergy Landscape</h2>
<ul>
<li><strong>Status</strong>: COMPLETE (LANDMARK)</li>
<li><strong>File</strong>: <code><a href="../demo_96_tl_group_cross/main.c.html">demo_96_tl_group_cross/main.c</a></code> (~1022 lines)</li>
<li><strong>Tests</strong>: 14 pass, 0 fail (Phases 1-4)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_84.html">Demo 84</a> (null/non-null split, 9/15 partition), <a href="./entries/demo_95.html">Demo 95</a> (derived series, 12/8/3/1 partition, Z[sqrt2] quaternion arithmetic, QZ8 type), <a href="./entries/demo_93.html">Demo 93</a> (circuit complexity hierarchy, 1wpi framework), <a href="./entries/demo_88.html">Demo 88</a> (anti-correlation, body-diagonal directions)</li>
<li><strong>Feeds into</strong>: <a href="./entries/demo_97.html">Demo 97</a> (Cell B perfection analysis), catalog pruning for 2I (<a href="./entries/demo_94.html">D94</a> follow-up), cross-derived synergy principle as general DKC design rule</li>
</ul>
<h3>Headline</h3>
The <a href="./entries/demo_84.html">D84</a> null/non-null split and the <a href="./entries/demo_95.html">D95</a> derived series split are INDEPENDENT partitions of the z8 bracket values. Their 2D cross-product creates a 5-cell landscape (A through E) that fully explains which entries carry computational capacity, which are synergy enhancers, and which are noise. The optimal z8 catalog is A+B+C (21 entries), not ALL (24) — removing the 3 Q8-null entries IMPROVES capacity.
<h3>Key Results</h3>
<ul>
<li><strong>Phase 1 — Cross-Tabulation (8 tests)</strong>: The 24 z8 bracket values partition into 5 cells: A = D0-null (6 entries, half-angle 90 deg), B = D0-nonnull (6 entries, 45 deg), C = <a href="./entries/demo_01.html">D1</a>-nonnull (8 entries, 60 deg, 2T commutators), D = <a href="./entries/demo_02.html">D2</a>-null (3 entries, 90 deg, Q8 deep), E = <a href="./entries/demo_03.html">D3</a>-identity (1 entry, 0 deg). Cross-checks: null total (A+D) = 9, commutator total (C+D+E) = 12, non-commutator total (A+B) = 12, grand total = 24. All counts verified exact.</li>
</ul>
<ul>
<li><strong>Phase 2 — Individual Cell Capacity (1 test)</strong>: Cell B achieves 100% XOR at EVERY N (3 through 6) with only 6 entries and 3 directions. Cell C achieves 100% at N=3,4 but drops to 42.86% at N=5 and 57.14% at N=6 (4 directions). Null cells A and D are completely dead individually (0% at all N). The rule: non-null is necessary AND sufficient for individual capacity; among non-null cells, 45 deg (B) outperforms 60 deg (C).</li>
</ul>
<ul>
<li><strong>Phase 3 — Pairwise Synergy Matrix (2 tests)</strong>: B+C wins at EVERY N despite having fewer directions (7) than A+B (9) or A+C (10). B+C rates: 96.70% (N=3), 94.01% (N=4), 73.18% (N=5), 31.00% (N=6). A+D (both null, 90 deg) is worst pair: 0% at N=3,5,6 with only 26.19% at N=4. Dimension analysis shows crossing the null boundary matters more than crossing the derived boundary at every N.</li>
</ul>
<ul>
<li><strong>Phase 4 — Triple Combinations (2 tests)</strong>: A+B+C (skip Q8/D) BEATS the full ALL(24) at EVERY N: 74.06% vs 71.94% (N=3), 77.51% vs 75.04% (N=4), 45.10% vs 40.76% (N=5), 12.98% vs 9.64% (N=6). The 3 Q8-deep-null entries are noise that actively degrades capacity. Missing cell impact: C (2T) is most important at N=3-5 (removing it loses 18-25%), B (D0-nonnull) is most important at N=6.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Two Independent Stratifications (CONFIRMED)</strong>: The bracket-null/non-null partition (9/15 from <a href="./entries/demo_84.html">D84</a>) and the derived series partition (12/8/3/1 from <a href="./entries/demo_95.html">D95</a>) cut ACROSS each other, creating a genuine 2D classification. Confirmed by character table analysis of 2O (8 conjugacy classes, Kirillov-Ostrik 2002). Independence at element level, unity at categorical level via ADE/E7 Dynkin diagram.</li>
</ul>
<ul>
<li><strong>Non-null = Load-bearing (CONFIRMED)</strong>: Null cells carry zero individual XOR capacity. Non-null is necessary AND sufficient for solo capacity. This sharpens <a href="./entries/demo_84.html">D84</a>'s "null indispensability" finding: Cell A (D0-null, outermost) enhances synergy when combined with non-null cells; Cell D (Q8-null, deep) is pure noise.</li>
</ul>
<ul>
<li><strong>Cross-derived Synergy Principle (CONFIRMED)</strong>: Non-null entries from DIFFERENT derived levels (B from D0, C from <a href="./entries/demo_01.html">D1</a>) produce maximum synergy. B+C dominates all 6 pairwise combinations at every N tested.</li>
</ul>
<ul>
<li><strong>Catalog Pruning Principle (PROPOSED)</strong>: For any DKC group, prune bracket-null entries in deep derived subgroups. Quality &gt; quantity. Optimal z8 catalog is 21 entries (A+B+C), not 24 (ALL). Testable prediction: analogous pruning improves 2I capacity.</li>
</ul>
<ul>
<li><strong>Prediction Scoreboard</strong>: Three pre-computation predictions tested. Barrington depth=capacity: WRONG (B beats C, A=D=0, depth hurts). Angular diversity outer&gt;inner: HALF RIGHT (B is best but A is also outer and dead). Dual-info both-dimensions: CLOSEST (B&gt;C&gt;&gt;A=D confirmed, but null/non-null binary distinction overpowers derived dimension).</li>
</ul>
<h3>Data</h3>
<p><strong>Phase 1 — Cross-tabulation (5 cells):</strong></p>
<table><thead><tr><th>Cell</th><th>Description</th><th>Count</th><th>Half-angle</th><th>Derived</th><th>Null?</th></tr></thead><tbody><tr><td>A</td><td>D0-null (outermost, bracket-null)</td><td>6</td><td>90 deg</td><td>D0</td><td>Yes</td></tr><tr><td>B</td><td>D0-nonnull (outermost, non-null)</td><td>6</td><td>45 deg</td><td>D0</td><td>No</td></tr><tr><td>C</td><td><a href="./entries/demo_01.html">D1</a>-nonnull (2T commutators)</td><td>8</td><td>60 deg</td><td><a href="./entries/demo_01.html">D1</a></td><td>No</td></tr><tr><td>D</td><td><a href="./entries/demo_02.html">D2</a>-null (Q8 deep)</td><td>3</td><td>90 deg</td><td><a href="./entries/demo_02.html">D2</a></td><td>Yes</td></tr><tr><td>E</td><td><a href="./entries/demo_03.html">D3</a>-identity</td><td>1</td><td>0 deg</td><td><a href="./entries/demo_03.html">D3</a></td><td>No</td></tr></tbody></table>
<p>Cross-checks: Null total (A+D) = 9, COMM total (C+D+E) = 12, NONCOMM total (A+B) = 12, Grand total = 24.</p>
<p><strong>Phase 2 — Individual cell XOR capacity:</strong></p>
<table><thead><tr><th>Cell</th><th>Size</th><th>Dirs</th><th>N=3</th><th>N=4</th><th>N=5</th><th>N=6</th></tr></thead><tbody><tr><td>A (D0-null)</td><td>6</td><td>6</td><td>0/20 (0.00%)</td><td>0/15 (0.00%)</td><td>0/6 (0.00%)</td><td>0/1 (0.00%)</td></tr><tr><td>B (D0-nonnull)</td><td>6</td><td>3</td><td>20/20 (100.00%)</td><td>15/15 (100.00%)</td><td>6/6 (100.00%)</td><td>1/1 (100.00%)</td></tr><tr><td>C (<a href="./entries/demo_01.html">D1</a>-nonnull)</td><td>8</td><td>4</td><td>56/56 (100.00%)</td><td>70/70 (100.00%)</td><td>24/56 (42.86%)</td><td>16/28 (57.14%)</td></tr><tr><td>D (<a href="./entries/demo_02.html">D2</a>-null)</td><td>3</td><td>3</td><td>0/1 (0.00%)</td><td>n/a</td><td>n/a</td><td>n/a</td></tr><tr><td>E (<a href="./entries/demo_03.html">D3</a>-identity)</td><td>1</td><td>0</td><td>n/a</td><td>n/a</td><td>n/a</td><td>n/a</td></tr></tbody></table>
<p><strong>Phase 3 — Pairwise synergy XOR rates:</strong></p>
<table><thead><tr><th>Pair</th><th>Size</th><th>Dirs</th><th>N=3</th><th>N=4</th><th>N=5</th><th>N=6</th></tr></thead><tbody><tr><td>A+B (outermost shell)</td><td>12</td><td>9</td><td>94/220 (42.73%)</td><td>255/495 (51.52%)</td><td>108/792 (13.64%)</td><td>52/924 (5.63%)</td></tr><tr><td>A+C (cross both dims)</td><td>14</td><td>10</td><td>168/364 (46.15%)</td><td>750/1001 (74.93%)</td><td>300/2002 (14.99%)</td><td>40/3003 (1.33%)</td></tr><tr><td>A+D (both null, 90-deg)</td><td>9</td><td>9</td><td>0/84 (0.00%)</td><td>33/126 (26.19%)</td><td>0/126 (0.00%)</td><td>0/84 (0.00%)</td></tr><tr><td>B+C (both nonnull, cross derived)</td><td>14</td><td>7</td><td>352/364 (96.70%)</td><td>941/1001 (94.01%)</td><td>1465/2002 (73.18%)</td><td>931/3003 (31.00%)</td></tr><tr><td>B+D (cross both dims)</td><td>9</td><td>3</td><td>20/84 (23.81%)</td><td>15/126 (11.90%)</td><td>6/126 (4.76%)</td><td>1/84 (1.19%)</td></tr><tr><td>C+D (comm subgroup)</td><td>11</td><td>7</td><td>80/165 (48.48%)</td><td>162/330 (49.09%)</td><td>96/462 (20.78%)</td><td>34/462 (7.36%)</td></tr></tbody></table>
<p>Best pair at every N: B+C.</p>
<p>Dimension analysis (average rates for cross-category pairs):</p>
<table><thead><tr><th>N</th><th>CrossNull (A+B, C+D)</th><th>CrossDerived (A+C, B+D)</th></tr></thead><tbody><tr><td>3</td><td>45.61%</td><td>34.98%</td></tr><tr><td>4</td><td>50.30%</td><td>43.41%</td></tr><tr><td>5</td><td>17.21%</td><td>9.87%</td></tr><tr><td>6</td><td>6.49%</td><td>1.26%</td></tr></tbody></table>
<p>CrossNull &gt; CrossDerived at every N: the null/non-null boundary matters more than the derived level boundary.</p>
<p><strong>Phase 4 — Triple combinations vs ALL:</strong></p>
<table><thead><tr><th>Subset</th><th>Size</th><th>Dirs</th><th>N=3</th><th>N=4</th><th>N=5</th><th>N=6</th></tr></thead><tbody><tr><td>ALL (A+B+C+D+E)</td><td>24</td><td>13</td><td>1456/2024 (71.94%)</td><td>7974/10626 (75.04%)</td><td>17325/42504 (40.76%)</td><td>12975/134596 (9.64%)</td></tr><tr><td>A+B+C (skip Q8)</td><td>21</td><td>13</td><td>985/1330 (74.06%)</td><td>4639/5985 (77.51%)</td><td>9178/20349 (45.10%)</td><td>7043/54264 (12.98%)</td></tr><tr><td>A+B+D (skip 2T)</td><td>16</td><td>9</td><td>288/560 (51.43%)</td><td>920/1820 (50.55%)</td><td>976/4368 (22.34%)</td><td>318/8008 (3.97%)</td></tr><tr><td>A+C+D (skip D0nn)</td><td>18</td><td>13</td><td>452/816 (55.39%)</td><td>2007/3060 (65.59%)</td><td>1977/8568 (23.07%)</td><td>614/18564 (3.31%)</td></tr><tr><td>B+C+D (skip D0null)</td><td>18</td><td>7</td><td>613/816 (75.12%)</td><td>2180/3060 (71.24%)</td><td>2744/8568 (32.03%)</td><td>1369/18564 (7.37%)</td></tr></tbody></table>
<p>Missing cell impact (triple rate minus ALL rate):</p>
<table><thead><tr><th>Missing</th><th>N=3</th><th>N=4</th><th>N=5</th><th>N=6</th></tr></thead><tbody><tr><td>D (Q8)</td><td>+2.12%</td><td>+2.47%</td><td>+4.34%</td><td>+3.34%</td></tr><tr><td>C (2T)</td><td>-20.51%</td><td>-24.49%</td><td>-18.42%</td><td>-5.67%</td></tr><tr><td>B (D0nn)</td><td>-16.54%</td><td>-9.45%</td><td>-17.69%</td><td>-6.33%</td></tr><tr><td>A (D0null)</td><td>+3.19%</td><td>-3.80%</td><td>-8.73%</td><td>-2.27%</td></tr></tbody></table>
<p>Most important cell: C (2T) at N=3-5, B (D0-nonnull) at N=6.</p>
<h3>Code Assets</h3>
<ul>
<li><strong><code>Zr2</code> (Z[sqrt2] ring arithmetic, from <a href="./entries/demo_95.html">D95</a>)</strong>: Exact integer type representing a + b*sqrt(2). Operations: <code>zr2_make</code>, <code>zr2_add</code>, <code>zr2_sub</code>, <code>zr2_neg</code>, <code>zr2_mul</code>, <code>zr2_eq</code>, <code>zr2_div2</code>. Multiplication uses the identity sqrt(2)^2 = 2. Reused from <a href="./entries/demo_95.html">D95</a> without modification.</li>
<li><strong><code>QZ8</code> (quaternion over Z[sqrt2]/2, from <a href="./entries/demo_95.html">D95</a>)</strong>: Four-component quaternion with Zr2 entries (representing (a + b*sqrt(2))/2 per component). Operations: <code>qz8_make</code>, <code>qz8_eq</code>, <code>qz8_neg</code>, <code>qz8_conj</code>, <code>qz8_mul</code>. Exact arithmetic, reused from <a href="./entries/demo_95.html">D95</a>.</li>
<li><strong><code>qz8_to_float()</code></strong>: Converts exact Z[sqrt2] quaternion to floating-point <code>Quat</code> for use with phase_cell framework.</li>
<li><strong><code>build_z8()</code></strong>: BFS closure from 4 generators (two generator pairs + conjugates). Produces 24 bracket values (mod sign).</li>
<li><strong><code>z8_commutator()</code> / <code>close_z8_subgroup()</code> / <code>compute_derived_series()</code></strong>: Derived series computation: generates commutator subgroups, closes under multiplication, assigns derived level to each element. Produces the D0/<a href="./entries/demo_01.html">D1</a>/<a href="./entries/demo_02.html">D2</a>/<a href="./entries/demo_03.html">D3</a> partition (12/8/3/1).</li>
<li><strong><code>compute_null_classification()</code></strong>: Tests if scalar component (Re part) of each quaternion is zero. Produces the null/non-null partition (9/15).</li>
<li><strong><code>compute_cells()</code></strong>: Cross-product of derived level x null classification -&gt; 5-cell assignment (A through E). Core new contribution of <a href="./entries/demo_96.html">D96</a>.</li>
<li><strong><code>load_cells(cell_mask)</code></strong>: Flexible subset loader: given a 5-element bitmask, loads the union of selected cells into the global catalog. Enables arbitrary cell combination testing.</li>
<li><strong><code>run_subset_capacity()</code> / <code>print_subset_result()</code></strong>: Runs exhaustive XOR capacity test at N=3,4,5,6 for the currently loaded catalog. k_sec sweep over {6, 12, 24}. Reports hit counts, totals, and percentages.</li>
<li><strong><code>build_dirs()</code> / <code>vor_cell()</code> / <code>phase_cell()</code></strong>: Voronoi direction extraction and 1wpi phase-cell activation framework. Shared with <a href="./entries/demo_93.html">D93</a>/<a href="./entries/demo_94.html">D94</a>/<a href="./entries/demo_95.html">D95</a>.</li>
<li><strong><code>count_phase_ex()</code> / <code>next_combo()</code></strong>: Exhaustive combinatorial weight-tuple testing. Iterates all C(n,k) combinations.</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>Kirillov-Ostrik (2002) — character table of 2O</strong>: 8 conjugacy classes of the binary octahedral group. The two stratifications (bracket-null/non-null = TL radical lens, derived series = group-theoretic) connect to E7 Dynkin diagram through different pathways — representation-theoretic for TL, group-theoretic for derived series. Independent at element level, unified at categorical level.</li>
<li><strong>Barrington (1989) — branching programs</strong>: <a href="./entries/demo_96.html">D96</a> partially refutes naive depth=capacity interpretation. Cell B (shallowest non-null, D0) is the BEST individual performer, while deeper cells (D, <a href="./entries/demo_02.html">D2</a>) are noise. Depth in the derived series HURTS capacity for null entries. The correct reading: non-solvability matters at the group level (<a href="./entries/demo_94.html">D94</a>), but within a solvable group, derived depth is secondary to the null/non-null distinction.</li>
<li><strong><a href="./entries/demo_84.html">D84</a> null indispensability (reinterpreted)</strong>: The original finding that null entries are "indispensable" specifically refers to Cell A (D0-null, outermost). Cell D (Q8-null, deep) is not indispensable — it is noise. The null/non-null distinction is load-bearing only in combination with derived level.</li>
<li><strong><a href="./entries/demo_95.html">D95</a> COMM vs NONCOMM (reinterpreted)</strong>: The near-equal capacity of commutator vs non-commutator subgroups in isolation is explained by contamination from null cells in both partitions. The true signal is B+C (non-null x cross-derived synergy), which was masked when averaging over all entries in each partition.</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li><strong>Cell B perfection mechanism</strong>: WHY does every combination of 6 Cell B entries compute XOR? What geometric/algebraic property of 3 mutually orthogonal directions at 45 deg half-angle makes this work? (Seeded as <a href="./entries/demo_97.html">D97</a>, now completed.)</li>
<li><strong>Catalog pruning for 2I</strong>: Does removing analogous "noise" entries (bracket-null in deep derived subgroups) from the binary icosahedral group 2I improve its capacity? If the pruning principle is universal across DKC groups, this is a general optimization rule.</li>
<li><strong>Non-monotonicity of missing-cell impact</strong>: Cell A (D0-null) shows +3.19% at N=3 (removing it helps) but -8.73% at N=5 (removing it hurts). Why does the synergy-enhancer role of outermost null entries depend on arity?</li>
<li><strong>BFS-as-braids dogfooding demo</strong>: Seeded from researcher manifold report during <a href="./entries/demo_96.html">D96</a> session.</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_97.html">Demo 97</a>: Why Is Cell B Perfect? — Geometric Robustness of Orthogonal-Frame XOR Separation</h2>
<ul>
<li><strong>Status</strong>: COMPLETE (RESULT)</li>
<li><strong>File</strong>: <code><a href="../demo_97_cell_b_perfect/main.c.html">demo_97_cell_b_perfect/main.c</a></code> (~815 lines)</li>
<li><strong>Tests</strong>: 8 pass, 0 fail (Phases 1-4)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_96.html">Demo 96</a> (cell taxonomy, Cell B identification as D^0-nonnull with 100% XOR), <a href="./entries/demo_95.html">Demo 95</a> (Z[sqrt2] + QZ8 arithmetic, derived series, phase_cell framework), <a href="./entries/demo_84.html">Demo 84</a> (null = dead discovery)</li>
<li><strong>Feeds into</strong>: Artificial perfect cell construction (can we build perfect cells for arbitrary groups?), 2I orthogonal structure analysis (do 2I entries show similar geometry?), 35-degree N=5 dip investigation (number-theoretic resonance?)</li>
</ul>
<h3>Headline</h3>
Cell B's 100% XOR perfection at every N is NOT a fine-tuned algebraic coincidence — it is geometric inevitability from 3 mutually orthogonal directions at any half-angle in a ~50-degree robust plateau (25-75 degrees). The 45-degree half-angle is simply the midpoint of this zone. Perfection is the octahedron.
<h3>Key Results</h3>
<ul>
<li><strong>Phase 1 — Anatomy of Cell B (2 tests)</strong>: Cell B = 6 entries from the z8 group (24 bracket values) at derived level 0, non-null. Structure: 3 mutually orthogonal directions (i, j, k axes) x 2 signs (+-q) per direction. All at half-angle 45 degrees (cos = sin = sqrt(2)/2, exact Z[sqrt2] representation: (0,1)/2). Direction pair angles: ALL 90 degrees. Entries per direction: exactly 2. Geometry = regular octahedron on S^2 (most symmetric 6-point arrangement). Cell B is NOT closed under multiplication — products escape to other cells (e.g., B[0]*B[0] lands at derived level 2).</li>
<li><strong>Phase 2 — Exhaustive Separation Analysis at N=3 (2 tests)</strong>: All 20 3-combinations of 6 entries pass XOR (100%). Cell-index margin at k=12: min=4, max=8, mean=5.6. Separation is substantial, not marginal — XOR=0 and XOR=1 signed sums land in well-separated phase_cell regions.</li>
<li><strong>Phase 3 — Angle Sensitivity Sweep (1 test)</strong>: Same 3 orthogonal directions tested at 21 half-angles from 10 to 90 degrees. Wide perfection plateau: 25-75 degrees achieves 100% at ALL N through N=6. 45 degrees is NOT a critical value — the midpoint of a ~50-degree robust zone. Boundary effects: low angles (&lt;25 degrees) lose N=5 first (imaginary differences shrink), high angles (&gt;75 degrees) lose N=6 first (approaching null collapse), 90 degrees = total collapse (zero real component, phase_cell blind). Isolated anomaly at 35 degrees: N=5 drops to 0% while N=3,4,6 remain 100%.</li>
<li><strong>Phase 4 — Large N Test (2 tests)</strong>: 100% XOR at ALL N from 3 through 6 (exhaustive — every combination passes). N=3: 20/20, N=4: 15/15, N=5: 6/6, N=6: 1/1. Beyond N=6, C(6,N) = 0 so the catalog is fully exhausted.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Geometric Perfection Thesis (CONFIRMED computationally)</strong>: XOR perfection at Cell B arises from orthogonal direction separation, not algebraic fine-tuning. The 50-degree angle plateau (25-75 degrees) demonstrates that any half-angle in this range produces identical 100% results — the mechanism is geometric inevitability from the orthonormal frame, not a magic-number coincidence.</li>
<li><strong>Lever Arm Mechanism (DEMONSTRATED)</strong>: Nonzero real component of the quaternion provides the "lever arm" for phase_cell to distinguish XOR=0 from XOR=1 signed sums. At 90 degrees (null), real component = 0, lever arm vanishes, total separation collapse. This geometrically explains <a href="./entries/demo_96.html">D96</a>'s finding that null entries are dead and non-null entries are load-bearing.</li>
<li><strong>Octahedral Optimality (OBSERVED)</strong>: 6 points forming a regular octahedron on S^2 is the maximally symmetric arrangement for 6 points — maximal mutual separation. This is the geometric reason Cell B outperforms other cells.</li>
<li><strong>35-Degree N=5 Resonance (OPEN)</strong>: Isolated failure at 35 degrees for N=5 only (N=3,4,6 all 100%). Possibly related to C(6,5) = 6 creating exact cancellation at this angle. Number-theoretic origin unresolved.</li>
</ul>
<h3>Data</h3>
<p><strong>Cell B entries (exact Z[sqrt2] representation, all components /2):</strong></p>
<table><thead><tr><th>#</th><th>a(Zr2)</th><th>b(Zr2)</th><th>c(Zr2)</th><th>d(Zr2)</th><th>Direction</th><th>Float (a,b,c,d)</th></tr></thead><tbody><tr><td>0</td><td>(0,1)</td><td>(0,1)</td><td>(0,0)</td><td>(0,0)</td><td>+i</td><td>(0.7071, +0.7071, 0, 0)</td></tr><tr><td>1</td><td>(0,1)</td><td>(0,-1)</td><td>(0,0)</td><td>(0,0)</td><td>-i</td><td>(0.7071, -0.7071, 0, 0)</td></tr><tr><td>2</td><td>(0,1)</td><td>(0,0)</td><td>(0,0)</td><td>(0,-1)</td><td>-k</td><td>(0.7071, 0, 0, -0.7071)</td></tr><tr><td>3</td><td>(0,1)</td><td>(0,0)</td><td>(0,0)</td><td>(0,1)</td><td>+k</td><td>(0.7071, 0, 0, +0.7071)</td></tr><tr><td>4</td><td>(0,1)</td><td>(0,0)</td><td>(0,1)</td><td>(0,0)</td><td>+j</td><td>(0.7071, 0, +0.7071, 0)</td></tr><tr><td>5</td><td>(0,1)</td><td>(0,0)</td><td>(0,-1)</td><td>(0,0)</td><td>-j</td><td>(0.7071, 0, -0.7071, 0)</td></tr></tbody></table>
<p><strong>Direction structure:</strong> <ul> <li>d0 = (1, 0, 0) — i axis</li> <li>d1 = (0, 0, -1) — -k axis</li> <li>d2 = (0, 1, 0) — j axis</li> <li>All direction pair angles: 90.00 degrees (mutually orthogonal)</li> <li>2 entries per direction (antipodal coverage)</li> </ul>
<p><strong>Phase 2 — Exhaustive separation at N=3 (k=12):</strong></p>
<table><thead><tr><th>Metric</th><th>Value</th></tr></thead><tbody><tr><td>XOR pass</td><td>20/20 (100%)</td></tr><tr><td>Cell-index margin (min)</td><td>4</td></tr><tr><td>Cell-index margin (max)</td><td>8</td></tr><tr><td>Cell-index margin (mean)</td><td>5.6</td></tr></tbody></table>
<p><strong>Phase 3 — Angle sensitivity sweep (6 quaternions, 3 orthogonal directions, varying half-angle):</strong></p>
<table><thead><tr><th>Half-angle</th><th>N=3 XOR%</th><th>N=4 XOR%</th><th>N=5 XOR%</th><th>N=6 XOR%</th></tr></thead><tbody><tr><td>10</td><td>100%</td><td>20%</td><td>0%</td><td>100%</td></tr><tr><td>15</td><td>100%</td><td>100%</td><td>0%</td><td>100%</td></tr><tr><td>20</td><td>100%</td><td>100%</td><td>0%</td><td>100%</td></tr><tr><td>25</td><td>100%</td><td>100%</td><td>100%</td><td>100%</td></tr><tr><td>30</td><td>100%</td><td>100%</td><td>100%</td><td>100%</td></tr><tr><td>35</td><td>100%</td><td>100%</td><td>0%</td><td>100%</td></tr><tr><td>40</td><td>100%</td><td>100%</td><td>100%</td><td>100%</td></tr><tr><td>42</td><td>100%</td><td>100%</td><td>100%</td><td>100%</td></tr><tr><td>44</td><td>100%</td><td>100%</td><td>100%</td><td>100%</td></tr><tr><td>45</td><td>100%</td><td>100%</td><td>100%</td><td>100%</td></tr><tr><td>46</td><td>100%</td><td>100%</td><td>100%</td><td>100%</td></tr><tr><td>48</td><td>100%</td><td>100%</td><td>100%</td><td>100%</td></tr><tr><td>50</td><td>100%</td><td>100%</td><td>100%</td><td>100%</td></tr><tr><td>55</td><td>100%</td><td>100%</td><td>100%</td><td>100%</td></tr><tr><td>60</td><td>100%</td><td>100%</td><td>100%</td><td>100%</td></tr><tr><td>65</td><td>100%</td><td>100%</td><td>100%</td><td>100%</td></tr><tr><td>70</td><td>100%</td><td>100%</td><td>100%</td><td>100%</td></tr><tr><td>75</td><td>100%</td><td>100%</td><td>100%</td><td>100%</td></tr><tr><td>80</td><td>100%</td><td>100%</td><td>100%</td><td>0%</td></tr><tr><td>85</td><td>100%</td><td>0%</td><td>0%</td><td>0%</td></tr><tr><td>90</td><td>0%</td><td>0%</td><td>0%</td><td>0%</td></tr></tbody></table>
<p>Full perfection plateau (all N through 6): 25-75 degrees (~50 degree range). N=3 perfection range: 10-85 degrees. N=3 first fails at 90 degrees.</p>
<p><strong>Phase 4 — Large N test (Cell B, 6 entries, 3 directions):</strong></p>
<table><thead><tr><th>N</th><th>C(6,N)</th><th>XOR count</th><th>XOR%</th></tr></thead><tbody><tr><td>3</td><td>20</td><td>20</td><td>100%</td></tr><tr><td>4</td><td>15</td><td>15</td><td>100%</td></tr><tr><td>5</td><td>6</td><td>6</td><td>100%</td></tr><tr><td>6</td><td>1</td><td>1</td><td>100%</td></tr></tbody></table>
<p>100% at ALL N through N=6 (exhaustive). Beyond N=6, C(6,N) = 0.</p>
<h3>Code Assets</h3>
<ul>
<li><strong><code>Zr2</code> (Z[sqrt2] ring arithmetic)</strong>: Exact integer type representing a + b*sqrt(2). Operations: <code>zr2_make</code>, <code>zr2_add</code>, <code>zr2_sub</code>, <code>zr2_neg</code>, <code>zr2_mul</code>, <code>zr2_eq</code>, <code>zr2_div2</code>. Multiplication uses sqrt(2)^2 = 2. Reused from <a href="./entries/demo_95.html">D95</a>.</li>
<li><strong><code>QZ8</code> (quaternion over Z[sqrt2])</strong>: Four-component quaternion with Zr2 entries (each representing (a + b*sqrt(2))/2). Operations: <code>qz8_make</code>, <code>qz8_eq</code>, <code>qz8_neg</code>, <code>qz8_conj</code>, <code>qz8_mul</code>. Exact integer arithmetic throughout group operations. Reused from <a href="./entries/demo_95.html">D95</a>.</li>
<li><strong><code>build_z8()</code></strong>: BFS closure of the z8 group from 4 generators. Produces 24 bracket values (mod +/- sign identification). Stores in global array.</li>
<li><strong><code>compute_derived_series()</code></strong>: Iterated commutator subgroup computation. Assigns each z8 element a derived level (0, 1, 2, ...). Cell B = derived level 0, non-null.</li>
<li><strong><code>extract_cell_b()</code></strong>: Filters z8 elements by derived level 0 and non-null real component. Produces the 6 Cell B entries in both exact (QZ8) and float (Quat) form.</li>
<li><strong><code>qz8_to_float()</code></strong>: Converts exact Z[sqrt2] quaternion to double-precision Quat for use with phase_cell framework.</li>
<li><strong><code>build_dirs(cat_size)</code></strong>: Extracts distinct S^2 directions from catalog quaternions (axis of rotation, deduplication at 1e-8 tolerance). Handles antipodal identification.</li>
<li><strong><code>phase_cell()</code> / <code>vor_cell()</code></strong>: 1wpi activation framework — sector (angle binning) x Voronoi cell (nearest direction). k_sec parameter controls angular resolution.</li>
<li><strong><code>test_1wpi_xor()</code></strong>: Tests whether a specific weight tuple achieves XOR separation at a given k_sec. Uses signed-sum accumulation and cell-based class counting with fast cleanup via touched_cells array.</li>
<li><strong><code>count_xor()</code></strong>: Iterates over all C(n,k) weight combinations, testing each at multiple k_sec values (6, 12, 24). Returns count of XOR-separable tuples.</li>
<li><strong><code>next_combo()</code></strong>: Combinatorial iterator for ordered k-subsets. Standard lexicographic advancement.</li>
<li><strong><code>comb_nk()</code></strong>: Binomial coefficient C(n,k) computation.</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong><a href="./entries/demo_96.html">D96</a> cell taxonomy</strong>: Cell B identified as D^0-nonnull, 6 entries, 45-degree half-angle, 3 directions, 100% XOR at every N=3-6. <a href="./entries/demo_97.html">D97</a> explains WHY this cell is perfect.</li>
<li><strong><a href="./entries/demo_84.html">D84</a>/<a href="./entries/demo_96.html">D96</a> null-is-dead</strong>: Null entries (90-degree half-angle, zero real component) contribute nothing to XOR separation. <a href="./entries/demo_97.html">D97</a> explains the mechanism: null = zero lever arm for phase_cell = blind readout.</li>
<li><strong>Octahedral symmetry / S^2 optimal packings</strong>: 6 points at vertices of a regular octahedron form the most symmetric arrangement on the 2-sphere. This maximal mutual separation is the geometric engine of Cell B's perfection.</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li><strong>Artificial perfect cells</strong>: Can we construct "perfect cells" for arbitrary groups by choosing orthogonal directions at any angle in the 25-75 degree plateau? Does the orthonormal-frame recipe generalize beyond z8?</li>
<li><strong>2I orthogonal structure</strong>: Do 2I's entries exhibit similar orthogonal subsets? With 9 distinct half-angles and ~31 directions, do overlapping perfection plateaus exist within 2I?</li>
<li><strong>35-degree N=5 dip</strong>: Isolated resonance where N=5 fails at 35 degrees while N=3,4,6 remain at 100%. Possibly number-theoretic — does this connect to C(6,5) = 6 or to some angular commensurability condition?</li>
<li><strong>Perfection-breaking threshold at large catalog</strong>: Cell B with 6 entries is perfect through N=6 (all combinations exhausted). For larger perfect cells (if they exist), at what N does perfection first break?</li>
<li><strong>Boundary asymmetry</strong>: Low-angle failure (N=5 first, then N=4) vs high-angle failure (N=6 first, then N=4) — the failure order reverses at the two boundaries. What determines which N is most fragile at each boundary?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_98.html">Demo 98</a>: 3-Strand DKC Proof of Concept — Readout Bottleneck Discovery</h2>
<ul>
<li><strong>Status</strong>: COMPLETE (RESULT)</li>
<li><strong>File</strong>: <code><a href="../demo_98_3strand_dkc/main.c.html">demo_98_3strand_dkc/main.c</a></code> (~1417 lines)</li>
<li><strong>Tests</strong>: 10 pass, 0 fail (Phases 1-5)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_35.html">Demo 35</a> (TL infrastructure, Cyc8 arithmetic, entanglement vanishing, axiality theorem), <a href="./entries/demo_67.html">Demo 67</a> (Hopf phase inert — wrong readout kills computation), <a href="./entries/demo_93.html">Demo 93</a> (circuit complexity hierarchy, 1wpi framework), <a href="./entries/demo_97.html">Demo 97</a> (orthogonal directions = perfection, quaternion readout structure)</li>
<li><strong>Feeds into</strong>: Demo 99b (column-vector readout on irreducible Delta_1 module — LANDMARK, first-ever 3-strand XOR), activation design for Cyc8^5 partitioning, multiple trace readout (Tr(M), Tr(M^2), Tr(M^3)), Fran's dimensional thesis testing</li>
</ul>
<h3>Headline</h3>
3-strand algebra is rich (infinite group, 2048 entries at cap, 98.5% interleaving, entanglement vanishing confirmed, column-4 has PERFECT diversity) but the trace readout is catastrophically lossy — ZERO XOR6 at any k_sec. The readout, not the algebra, is the research frontier for multi-strand DKC.
<h3>Key Results</h3>
<ul>
<li><strong>Phase 1 — 3-Strand BFS Catalog (2 tests)</strong>: Built via TL_3 matrix representation (5x5 over Z[zeta_8], from <a href="./entries/demo_35.html">Demo 35</a> infrastructure). BFS with 4 generators (sigma1+, sigma1-, sigma2+, sigma2-) reaches 2048-entry cap in 8 rounds. Growth: 1, 4, 12, 30, 68, 148, 314, 656, 815 (hit cap). Group is INFINITE at zeta_8 (unlike 2-strand's 24-element binary octahedral). Interleaving (uses both sigma1 and sigma2): 2017/2048 (98.5%). Non-interleaving: 31 entries, ALL with zero bracket (entanglement vanishing: 100%). Zero-bracket entries: 113/2048 (5.5%). Writhe range: [-8, 8].</li>
<li><strong>Phase 2 — Trace Readout (1 test)</strong>: 105 distinct trace values from 2048 matrices (5.1% retention). Traces are AXIAL (single nonzero Cyc8 component). Trace collapses 25 Cyc8 entries (100 integers) to 1 Cyc8 (4 integers) = 96% information loss.</li>
<li><strong>Phase 2b — Column Vector Diversity (1 test)</strong>: Column-0 through column-3 each yield ~1166-1167 distinct vectors (56.9-57.0% retention, 20 integer DOFs each). Column 4 is LOSSLESS: 2048 distinct vectors from 2048 matrices (100% retention). This is 11-20x more diversity than trace.</li>
<li><strong>Phase 3 — 3-Strand XOR Capacity (1 test)</strong>: Zero XOR6 at k=4,6,8,10,12,16,20,24,32. Zero even restricting to 1935 non-zero-bracket entries. The readout, not the algebra, is the bottleneck.</li>
<li><strong>Phase 4 — Matched Comparison at size 24 (1 test)</strong>: 3-strand XOR6 = 0, 2-strand XOR6 = 1109 (best at k=20). 2-strand wins completely — but this is a readout problem, not an algebraic one. 2-strand uses Voronoi + sector activation (all 4 quaternion DOFs); 3-strand trace readout collapses to 1D.</li>
<li><strong>Phase 5 — Interleaving Analysis (1 test)</strong>: Neither interleaving (2017 entries) nor non-interleaving (31) produces XOR6. The trace readout fails uniformly across all subsets.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Readout Bottleneck Thesis (DEMONSTRATED)</strong>: Multi-strand TL algebras contain MORE computational structure than 2-strand (infinite group, higher diversity, richer interleaving), but the standard trace readout destroys this information. The 2-strand pipeline succeeds because quaternions ARE the readout — SU(2) is isomorphic to S^3 and the Voronoi+sector activation uses all 4 real DOFs. For 3-strand, trace collapses 20 integers (column vector) to 4 integers (trace), losing 96% of information.</li>
<li><strong>Entanglement Vanishing at Scale (CONFIRMED)</strong>: All 31 non-interleaving entries (using only sigma1 or only sigma2) have zero bracket, confirming <a href="./entries/demo_35.html">Demo 35</a>'s result at 2048-entry scale. Interleaving (using both generators) is necessary for non-trivial bracket values.</li>
<li><strong>Axiality Constraint (CONFIRMED)</strong>: <a href="./entries/demo_35.html">Demo 35</a>'s axiality theorem (bracket values have single nonzero Cyc8 component) explains why both trace AND bracket readouts fail for 3-strand: axial = effectively 1D information, insufficient for XOR separation.</li>
<li><strong>Column-4 Losslessness (NEW FINDING)</strong>: Column 4 of the TL_3 representation preserves 100% of algebraic diversity (2048 distinct vectors). This directly seeds the activation design question: how to partition the 20-integer Cyc8^5 space into cells that enable XOR separation.</li>
</ul>
<h3>Data</h3>
<p><strong>3-strand BFS catalog growth:</strong></p>
<table><thead><tr><th>Round</th><th>Entries</th><th>New</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>5</td><td>4</td></tr><tr><td>2</td><td>17</td><td>12</td></tr><tr><td>3</td><td>47</td><td>30</td></tr><tr><td>4</td><td>115</td><td>68</td></tr><tr><td>5</td><td>263</td><td>148</td></tr><tr><td>6</td><td>577</td><td>314</td></tr><tr><td>7</td><td>1233</td><td>656</td></tr><tr><td>8</td><td>2048</td><td>815 (hit cap)</td></tr></tbody></table>
<p><strong>Readout diversity comparison:</strong></p>
<table><thead><tr><th>Readout</th><th>Distinct</th><th>Retention</th><th>DOFs</th></tr></thead><tbody><tr><td>Trace</td><td>105</td><td>5.1%</td><td>4 integers</td></tr><tr><td>Column 0</td><td>1166</td><td>56.9%</td><td>20 integers</td></tr><tr><td>Column 1</td><td>1166</td><td>56.9%</td><td>20 integers</td></tr><tr><td>Column 2</td><td>1167</td><td>57.0%</td><td>20 integers</td></tr><tr><td>Column 3</td><td>1167</td><td>57.0%</td><td>20 integers</td></tr><tr><td>Column 4</td><td>2048</td><td>100.0%</td><td>20 integers</td></tr></tbody></table>
<p><strong>Phase 4 — Matched comparison (size 24):</strong></p>
<table><thead><tr><th>Metric</th><th>3-strand</th><th>2-strand</th></tr></thead><tbody><tr><td>XOR6 winners</td><td>0</td><td>1109</td></tr><tr><td>Best k_sec</td><td>0</td><td>20</td></tr></tbody></table>
<p><strong>Phase 5 — Interleaving analysis:</strong></p>
<table><thead><tr><th>Subset</th><th>Count</th><th>XOR6</th><th>Best k</th></tr></thead><tbody><tr><td>Interleaving</td><td>2017</td><td>0</td><td>0</td></tr><tr><td>Non-interleaving</td><td>31</td><td>0</td><td>0</td></tr></tbody></table>
<p><strong>2-strand vs 3-strand structural comparison:</strong></p>
<table><thead><tr><th>Property</th><th>2-strand</th><th>3-strand</th></tr></thead><tbody><tr><td>TL dimension</td><td>2x2 (TL_2, C_2=2)</td><td>5x5 (TL_3, C_3=5)</td></tr><tr><td>Group order</td><td>24 (finite, binary octahedral)</td><td>Infinite (at zeta_8)</td></tr><tr><td>Generators</td><td>2 (sigma1+, sigma1-)</td><td>4 (sigma1+/-, sigma2+/-)</td></tr><tr><td>Interleaving</td><td>N/A (1 crossing)</td><td>98.5% (2017/2048)</td></tr><tr><td>Entanglement vanishing</td><td>N/A</td><td>100% (31/31 non-interleaving = zero bracket)</td></tr><tr><td>Readout DOFs (trace)</td><td>4 integers (Cyc8 = sufficient)</td><td>4 integers (Cyc8 = catastrophically lossy)</td></tr><tr><td>Readout DOFs (quaternion)</td><td>4 reals (full SU(2))</td><td>N/A</td></tr><tr><td>Readout DOFs (column)</td><td>N/A</td><td>20 integers (Cyc8^5 = lossless at col 4)</td></tr><tr><td>Fran's dim formula</td><td>dim=4 (2<em>2+0)</td><td>dim=6 (2</em>3+0)</td></tr><tr><td>XOR6 capacity</td><td>1109 (at k=20, size 24)</td><td>0 (trace readout)</td></tr></tbody></table>
<h3>Code Assets</h3>
<ul>
<li><strong><code>Cyc8</code> (Z[zeta_8] cyclotomic arithmetic)</strong>: Exact integer type with basis {1, zeta_8, zeta_8^2, zeta_8^3}, zeta_8^4 = -1. Operations: <code>cyc8_make</code>, <code>cyc8_zero</code>, <code>cyc8_one</code>, <code>cyc8_add</code>, <code>cyc8_neg</code>, <code>cyc8_mul</code>, <code>cyc8_eq</code>, <code>cyc8_is_zero</code>, <code>cyc8_conj</code>, <code>cyc8_to_double</code>. Reused from <a href="./entries/demo_35.html">Demo 35</a>.</li>
<li><strong><code>TLMat</code> (5x5 TL_3 matrix)</strong>: Matrix over Cyc8 for the 3-strand Temperley-Lieb representation (C_3=5 basis elements). Operations: <code>tlm_zero</code>, <code>tlm_identity</code>, <code>tlm_add</code>, <code>tlm_neg</code>, <code>tlm_scale</code>, <code>tlm_mul</code>, <code>tlm_eq</code>, <code>tlm_trace</code>.</li>
<li><strong><code>PMatch</code> / diagram composition</strong>: Planar matching representation for TL_3 (6 boundary points). <code>enumerate_basis()</code> builds all 5 non-crossing matchings. <code>compose_diagrams()</code> computes diagram multiplication with closed-loop counting. <code>build_gen_matrix()</code> constructs TL generator matrices e_1, e_2.</li>
<li><strong><code>build_braid_generators()</code></strong>: Constructs 4 braid generators from A = -zeta_8: sigma_i = A<em>I + A^{-1}</em>e_i, sigma_i^{-1} = A^{-1}<em>I + A</em>e_i. Verifies sigma<em>sigma^{-1} = I and braid relation sigma1</em>sigma2<em>sigma1 = sigma2</em>sigma1*sigma2.</li>
<li><strong><code>build_3strand_catalog()</code></strong>: BFS closure over 4 generators with bracket computation, depth tracking, writhe tracking, and interleaving bitmask (bit0=uses_sigma1, bit1=uses_sigma2). Caps at MAX_3CAT=2048.</li>
<li><strong><code>Quat</code> / <code>build_2strand_catalog()</code></strong>: Quaternionic 2-strand catalog (24 entries, binary octahedral group) for matched comparison. BFS closure with mod-sign identification.</li>
<li><strong><code>phase_cell_cyc8()</code></strong>: Trace-based activation for 3-strand: converts Cyc8 trace to complex via <code>cyc8_to_double</code>, uses angle-based sector assignment. k_sec sectors + 1 degenerate cell.</li>
<li><strong><code>combined_cell_2s()</code> / <code>vor_cell_2s()</code> / <code>build_2strand_dirs()</code></strong>: 1wpi Voronoi+sector activation for 2-strand quaternionic readout. Extracts S2 directions, assigns Voronoi cells, combines with angular sectors. Shared with <a href="./entries/demo_93.html">D93</a>-<a href="./entries/demo_97.html">97</a>.</li>
<li><strong><code>test_xor_3strand()</code> / <code>test_xor_2strand()</code></strong>: Exhaustive 1wpi XOR separability tests. 3-strand: matrix sum then trace then phase_cell. 2-strand: quaternion sum then combined_cell. Both use touched-cell optimization for fast cleanup.</li>
<li><strong><code>count_xor_bf()</code> / <code>search_xor()</code></strong>: Brute-force XOR6 search over all 3-element subsets, with multi-k_sec sweep (k=4,6,8,10,12,16,20,24,32).</li>
</ul>
<h3>Connection to Earlier Demos</h3>
<table><thead><tr><th>Demo</th><th>Finding</th><th>Relevance to <a href="./entries/demo_98.html">D98</a></th></tr></thead><tbody><tr><td><a href="./entries/demo_35.html">D35</a></td><td>Entanglement vanishing</td><td>CONFIRMED at scale: 31/31 non-interleaving have zero bracket</td></tr><tr><td><a href="./entries/demo_35.html">D35</a></td><td>Axiality theorem</td><td>Explains why trace/bracket readouts fail: axial = 1D information</td></tr><tr><td><a href="./entries/demo_67.html">D67</a></td><td>Hopf phase inert</td><td>Analogous lesson: wrong readout kills computation even when data is rich</td></tr><tr><td><a href="./entries/demo_97.html">D97</a></td><td>Orthogonal directions = perfection</td><td>2-strand works because quaternion components map to orthogonal axes. 3-strand needs analogous structure in Cyc8^5</td></tr></tbody></table>
<h3>Literature Touched</h3>
<ul>
<li><strong>Temperley-Lieb algebra TL_3</strong>: 5-dimensional representation (C_3 = Catalan number = 5 non-crossing matchings on 6 boundary points). Standard construction: planar matching composition with closed-loop counting. <a href="./entries/demo_98.html">D98</a> builds the full representation machinery from scratch.</li>
<li><strong>Kauffman bracket at zeta_8</strong>: 3-strand bracket values are axial in Z[zeta_8] (single nonzero component), extending <a href="./entries/demo_35.html">D35</a>'s axiality theorem from 2-strand to 3-strand. The axiality constraint is structural, not size-dependent.</li>
<li><strong>Braid group B_3</strong>: Infinite group (unlike B_2 which maps to finite subgroups of SU(2)). At the zeta_8 parameter, the TL_3 representation yields an infinite image — 2048 distinct matrices reached without closure. The braid relation sigma1<em>sigma2</em>sigma1 = sigma2<em>sigma1</em>sigma2 is verified computationally.</li>
<li><strong>Reservoir computing (Maass et al. 2002)</strong>: <a href="./entries/demo_98.html">D98</a> demonstrates the readout bottleneck in reservoir computing terms: the reservoir (3-strand BFS catalog) has high separation capacity (column-4 is lossless), but the linear readout (trace) destroys the information. This motivates D99b's approach of working on the irreducible module directly.</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li><strong>Column-vector activation design</strong>: Column 4 preserves 100% diversity (2048 distinct 20-integer vectors). How to partition Cyc8^5 into cells for XOR separation? This is the key design question for multi-strand DKC.</li>
<li><strong>Multiple trace readout</strong>: Using Tr(M), Tr(M^2), Tr(M^3) as characteristic polynomial coefficients could recover more information than single trace. 3 traces x 4 integers = 12 DOFs vs 4 DOFs for single trace.</li>
<li><strong>Irreducible module approach</strong>: The 5x5 representation is reducible (TL_3 decomposes into standard modules). Working on irreducible pieces may avoid the lossy trace problem — this is exactly what D99b pursues with the 2x2 Delta_1 module, achieving first-ever 3-strand XOR.</li>
<li><strong>Dimensional thesis</strong>: Fran's formula gives dim=6 for 3-strand vs dim=4 for 2-strand, predicting higher capacity. Cannot test until readout problem is solved. The algebra supports more complexity; the question is whether that complexity is computationally accessible.</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_99.html">Demo 99</a>: 3-Strand Delta_1 Block Decomposition — LANDMARK</h2>
<ul>
<li><strong>Status</strong>: COMPLETE (LANDMARK)</li>
<li><strong>Designation</strong>: Demo 99b (labeled 99b in source and explorer's log; supersedes earlier <a href="./entries/demo_99.html">D99</a> column-readout attempt)</li>
<li><strong>File</strong>: <code><a href="../demo_99_column_readout/main.c.html">demo_99_column_readout/main.c</a></code> (~2678 lines)</li>
<li><strong>Tests</strong>: 24+ pass, 0 fail (Phases 0-11, plus sub-phases 7b/7c/7d)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_51.html">Demo 51</a> (TL_3 semisimplicity at delta=0), <a href="./entries/demo_98.html">Demo 98</a> (5x5 trace readout gives ZERO XOR), <a href="./entries/demo_99.html">Demo 99</a> original (5oct_hash on 5x5 gives 3100 XOR6), <a href="./entries/demo_82.html">Demo 82</a> (depth law max_xor ~ depth+6), <a href="./entries/demo_97.html">Demo 97</a> (orthogonal directions = perfection)</li>
<li><strong>Feeds into</strong>: Demo 99c (algebraic classification, Cell B analog), <a href="./entries/demo_100.html">Demo 100</a> (4-strand W_{4,2} DKC), <a href="./entries/demo_101.html">Demo 101</a> (dimensionally-matched activation)</li>
</ul>
<h3>Headline</h3>
First-ever 3-strand XOR computation at ALL levels: XOR6=500,261, XOR8=48,143, XOR10=485, XOR12=16, XOR14=60 (best across activations). The key was building the irreducible 2x2 standard module Delta_1 directly over Z[zeta_8] instead of using the reducible 5x5 representation, combined with a 16-component sign-pattern activation (2x2_hash). The braid group image is INFINITE (Jordan block structure, sigma_1 has infinite order), with entry magnitudes growing by exact Fibonacci ratios. XOR counts saturate by ~4096 catalog entries. XOR14 requires deep entries (d&gt;=6); shallow entries give definitively ZERO. XOR16 is ZERO (genuine ceiling for this representation).
<h3>Key Results</h3>
<ul>
<li><strong>Phase 0 -- Representation Verification (8 tests)</strong>: A <em> A_inv = 1 (A = -zeta_8). A^2 + A^{-2} = 0 (delta=0 confirmed). sigma_1 </em> sigma_1_inv = I. sigma_2 <em> sigma_2_inv = I. Braid relation s1</em>s2<em>s1 = s2</em>s1<em>s2. Correct Hecke relation verified: sigma - sigma_inv = (A - A_inv)(I - e_i). Standard quadratic form (sigma-A)(sigma+A_inv)=0 does NOT hold on Delta_1 because 1+A^{-2} != 0. e_1^2 = 0 on Delta_1. e_1</em>e_2 = [[0,0],[0,1]] (projector).</li>
</ul>
<ul>
<li><strong>Phase 1 -- BFS Catalog (cap 32768)</strong>: Group is INFINITE. BFS produces 8192+ entries (32768 at full cap). Growth per round ~2.1x. max_abs sequence follows exact Fibonacci: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233. Fibonacci mechanism: sigma_1 alone grows linearly (Jordan block), but mixed products of sigma_1 and sigma_2 feed each other's off-diagonal entries via Fibonacci recursion.</li>
</ul>
<ul>
<li><strong>Phase 2 -- Catalog Statistics</strong>: Depth distribution across BFS rounds 0-10+. Triangular entries 104 (1.3%), anti-trace (a=d) entries ~1.1%, dense entries 99.5%+ beyond d=0. Quaternion structure: trace-zero and anti-trace-zero populations tracked.</li>
</ul>
<ul>
<li><strong>Phase 3 -- XOR Capacity Scan (activation hierarchy)</strong>:</li>
</ul>
<table><thead><tr><th>Activation</th><th>N=3(XOR6)</th><th>N=4(XOR8)</th><th>N=5(XOR10)</th><th>N=6(XOR12)</th></tr></thead><tbody><tr><td>4ent(16)</td><td>227624</td><td>5990</td><td>126</td><td>0</td></tr><tr><td>4ent(32)</td><td>258764</td><td>8098</td><td>206</td><td>8</td></tr><tr><td>4ent(64)</td><td>230568</td><td>7792</td><td>210</td><td>8</td></tr><tr><td>quat(16)</td><td>28748</td><td>284</td><td>0</td><td>0</td></tr><tr><td>quat(32)</td><td>29832</td><td>298</td><td>0</td><td>0</td></tr><tr><td>quat(64)</td><td>29124</td><td>294</td><td>0</td><td>0</td></tr><tr><td>2x2(32)</td><td>373194</td><td>11974</td><td>325</td><td>16</td></tr><tr><td>2x2(64)</td><td>373194</td><td>16404</td><td>485</td><td>16</td></tr><tr><td>2x2(128)</td><td>373194</td><td>16404</td><td>485</td><td>16</td></tr><tr><td>tr_oct(8)</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table>
<p>Best per XOR level (bf=200/60/30/18): XOR6=500,261 at 2x2(64), XOR8=48,143 at 2x2(128), XOR10=485 at 2x2(128), XOR12=16 at 2x2(32+). Activation hierarchy: 2x2_hash &gt;&gt; 4ent_hash &gt;&gt; quat_hash &gt;&gt; trace_oct.</p>
<ul>
<li><strong>Phase 3b -- Scaling Saturation</strong>: XOR counts do NOT increase with catalog size beyond ~4096 entries at fixed bf_limit. More activation cells DO help: 2x2(128) gives 48K XOR8 vs 2x2(64)'s 23.7K. bf_limit (search depth) is the real constraint, not catalog size.</li>
</ul>
<ul>
<li><strong>Phase 4 -- Matched Comparison (size 24, XOR6)</strong>:</li>
</ul>
<table><thead><tr><th>Metric</th><th>3-strand</th><th>2-strand</th></tr></thead><tbody><tr><td>XOR6 winners</td><td>527</td><td>1109</td></tr><tr><td>Catalog size</td><td>24</td><td>24</td></tr></tbody></table>
<p>2-strand leads 2.1:1 at matched size with first-24 entries.</p>
<ul>
<li><strong>Phase 4b -- Depth-Sampled Comparison (24 entries, d=6-8)</strong>: Gap closes from 2.1:1 to 1.4:1 (808 vs 1109 XOR6). Confirms deeper entries are richer. Remaining gap attributed to activation quality (Sec x Vor tuned for quaternions vs crude 2x2_hash). At full cap the 3-strand advantage is massive (500K vs 1109).</li>
</ul>
<ul>
<li><strong>Phase 5 -- Jordan Block Structure</strong>: sigma_1^n has off-diagonal (2,1) entry = n <em> A^{n-2}, growing linearly. Diagonal entries cycle with period 8 (A^8 = 1). sigma_1^8 has diagonal = I but (2,1) entry = 8</em>A^6 != 0. sigma_1^8 != I, confirming infinite order. Property F does NOT apply at delta=0.</li>
</ul>
<ul>
<li><strong>Phase 6 -- XOR14 = 60 (CEILING BROKEN)</strong>: Deep entries (d&gt;=6, bf=30) with 2x2_hash:</li>
</ul>
<table><thead><tr><th>Cells</th><th>XOR10</th><th>XOR12</th><th>XOR14</th></tr></thead><tbody><tr><td>64</td><td>2641</td><td>675</td><td>60</td></tr><tr><td>128</td><td>2966</td><td>675</td><td>60</td></tr><tr><td>256</td><td>4335</td><td>675</td><td>60</td></tr><tr><td>512</td><td>6883</td><td>759</td><td>60</td></tr><tr><td>1024</td><td>9418</td><td>1452</td><td>60</td></tr></tbody></table>
<p>XOR14=60 from deep entries, XOR14=0 from full catalog (shallow entries). Depth is a genuine computational resource.</p>
<ul>
<li><strong>Phase 7 -- XOR14 Winner Anatomy</strong>: 60 XOR14 winners analyzed. Super-hubs discovered: idx=7 and idx=9 appear in ALL 60 winners (100%). Both d=6, dense. idx=7 is anti-trace (a=d). 100% of winners are mixed depth (d=6 + d=7). Cross-depth mandatory. Star graph topology: 2 fixed core hubs + 5 rotating satellites from ~12 d=7 entries. Pairwise commutators are large (mean=126, typical entries are 1-89).</li>
</ul>
<ul>
<li><strong>Phase 7b -- Hub Commutator [hub7, hub9]</strong>: Traceless (scalar = 0), strong Cartan component (L1=84), e-root L1=108, f-root L1=18, e/f ratio = 6.0. Hallmark of sl_2 bracket structure.</li>
</ul>
<p>Super-hub idx=7 (d=6, w=2, anti-trace): a = d = (0,0,5,0), b = (12,0,0,0), c = (-2,0,0,0). Cartan L1 = 0. Pure scalar+nilpotent ("e-root carrier").</p>
<p>Super-hub idx=9 (d=6, w=-6, non-anti-trace): a = (0,0,-8,0), d = (0,0,1,0), b = c = (-3,0,0,0). Cartan L1 = 9. Strong h-carrier. b=c symmetry.</p>
<ul>
<li><strong>Phase 7c -- Casimir Discriminant Test</strong>: C(S) = (a-d)^2 + 4bc for 1wpi sums. Winner mean |C| = 1301 vs control mean |C| = 297 (4.4x higher). Winner has FEWER Jordan blocks (C=0): 384 total vs 816 control. Mechanism is NOT "more Jordan blocks = more computation." Winner entries are MORE diagonalizable. Computation happens in the semisimple layer; Jordan block is infrastructure creating the infinite group.</li>
</ul>
<ul>
<li><strong>Phase 7d -- Swap Test</strong>: ZERO substitutions preserve XOR14. Hub7 replacement: 0/1 survive. Hub9 replacement: 0/7 survive. Super-hubs are specific algebraic objects, not just structurally typed entries.</li>
</ul>
<ul>
<li><strong>Phase 8 -- XOR16 Push</strong>: XOR14 at bf=40, deep, cells=256: 4016 (abundant, not rare). XOR16 at bf=14, deep, cells=256: 0. C(14,8) = 3003 tuples tested with 65536 masks each. XOR16 is a genuine ceiling for Delta_1 at ell=2.</li>
</ul>
<ul>
<li><strong>Phase 9 -- Depth Parity Test</strong>: Mean writhe = 0.000 at every depth level (d=0 through d=12). Anti-trace fraction ~1.1% at all depths. Dense fraction 99.5%+ beyond d=0. No even/odd depth effect. Writhe perfectly balanced.</li>
</ul>
<ul>
<li><strong>Phase 10 -- Casimir Gap Scaling (Two-Regime Discovery)</strong>:</li>
</ul>
<table><thead><tr><th>XOR level</th><th>Winner</th><th>C</th><th></th><th>Control</th><th>C</th><th></th><th>Ratio</th></tr></thead><tbody><tr><td>XOR6</td><td>54</td><td>75</td><td>0.7x (INVERTED)</td></tr><tr><td>XOR8</td><td>73</td><td>104</td><td>0.7x (INVERTED)</td></tr><tr><td>XOR10</td><td>513</td><td>154</td><td>3.3x</td></tr><tr><td>XOR12</td><td>892</td><td>219</td><td>4.1x</td></tr><tr><td>XOR14</td><td>1301</td><td>245</td><td>5.3x</td></tr></tbody></table>
<p>Phase transition at XOR8 -&gt; XOR10 coincides with shallow -&gt; deep entry transition. Two computational mechanisms: (1) Combinatorial (XOR6-8): nilpotent-proximate, diversity-driven, shallow entries suffice. (2) Algebraic (XOR10-14): Ext^1 catalytic preparation, eigenvalue separation, deep entries required.</p>
<ul>
<li><strong>Phase 11 -- Casimir Distribution vs Tuple Size</strong>: Random walk exits nilpotent neighborhood as tuple size grows. Mean |C| and fraction with |C|&lt;50 tracked across N=4 through N=14.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Ext^1 Catalytic Preparation Thesis (ESTABLISHED)</strong>: 3-strand DKC computation at delta=0 lives on the non-trivial extension class Ext^1(L(0), L(1)) between simple modules of the restricted quantum group u_q(sl_2) at ell=2. The standard module Delta_1 is indecomposable but reducible: submodule L(0) and quotient L(1), extension does NOT split. Non-split extension is the computational resource. End-to-end causal chain: Ext^1 -&gt; complementary pairing -&gt; high-C sums -&gt; eigenvalue discrimination -&gt; Boolean computation.</li>
</ul>
<ul>
<li><strong>Jordan Block = Non-Split Extension</strong>: sigma_1^n has off-diagonal n*A^{n-2} (linear growth proves indecomposable). Extension class in Ext^1(L(0), L(1)) is non-zero.</li>
</ul>
<ul>
<li><strong>Fibonacci Growth</strong>: max_abs follows Fibonacci: connected to golden ratio phi through the spectral radius of trace-zero SL_2 elements and the 2x2 transfer matrix.</li>
</ul>
<ul>
<li><strong>Anti-Trace = Cartan-Zero</strong>: Entries with a=d have zero Cartan component in sl_2 decomposition M = scalar<em>I + b</em>e + c<em>f + ((a-d)/2)</em>h. These are "pure nilpotent+scalar" elements. Computationally powerful only IN COMBINATION with non-anti-trace entries (infrastructure, not engines).</li>
</ul>
<ul>
<li><strong>U-Shaped Cartan Correlation</strong>: XOR capacity vs Cartan |a-d| magnitude: cartan=0 is XOR12 champion (4292), cartan=1-5 is dead, cartan=11+ has 794. Both extremes compute; the middle is dead. Two complementary mechanisms.</li>
</ul>
<ul>
<li><strong>Two-Regime Hypothesis (CONFIRMED)</strong>: Combinatorial regime (XOR6-8) uses nilpotent-proximate, diversity-driven computation with shallow entries. Algebraic regime (XOR10-14) uses Ext^1 catalytic preparation with deep entries. The Ext^1 thesis governs specifically the algebraic (high-XOR) regime. Monotonic within each regime but not overall.</li>
</ul>
<ul>
<li><strong>Star-Graph Topology</strong>: XOR14 winners form a star graph (2 irreplaceable hubs + rotating satellites), structurally different from 2-strand Cell B's mutual orthogonality graph.</li>
</ul>
<ul>
<li><strong>Casimir Inversion</strong>: Non-semisimplicity is catalytic preparation, not the computation mechanism. Preparation selects complementary entries; evaluation produces high-C sums (4.4x control); readout discriminates eigenvalue structure. Shared architecture with non-semisimple TQFT, reservoir computing, and magic state distillation (but catalytic).</li>
</ul>
<ul>
<li><strong>Registered Prediction</strong>: Casimir gap (winner/control ratio) should increase monotonically with XOR level within the algebraic regime. CONFIRMED for XOR10 -&gt; XOR12 -&gt; XOR14.</li>
</ul>
<h3>Data</h3>
<p><strong>Direct standard module construction (Delta_1 basis and generators):</strong> <ul> <li>Basis: {h_0, h_2} -- half-diagrams with 1 through-strand at position 0 or 2</li> <li>TL generators: e_1|<em>{<a href="./entries/demo_01.html">D1</a>} = [[0,0],[1,0]], e_2|</em>{<a href="./entries/demo_01.html">D1</a>} = [[0,1],[0,0]]</li> <li>Braid generators: sigma_1 = [[A, 0], [A_inv, A]], sigma_2 = [[A, A_inv], [0, A]]</li> <li>A = -zeta_8 = (0,-1,0,0), A_inv = (0,0,0,1)</li> <li>16 DOF per entry: 4 Cyc8 components x 4 matrix entries = 16 integers (vs 8 for 2-strand quaternions)</li> </ul>
<p><strong>BFS growth (Fibonacci max_abs):</strong></p>
<table><thead><tr><th>Round</th><th>Entries</th><th>max_abs</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>-</td></tr><tr><td>1</td><td>5</td><td>1</td></tr><tr><td>2</td><td>17</td><td>2</td></tr><tr><td>3</td><td>47</td><td>3</td></tr><tr><td>4</td><td>115</td><td>5</td></tr><tr><td>5</td><td>263</td><td>8</td></tr><tr><td>6</td><td>577</td><td>13</td></tr><tr><td>7</td><td>1233</td><td>21</td></tr><tr><td>8</td><td>2581</td><td>34</td></tr><tr><td>9</td><td>5377</td><td>55</td></tr><tr><td>10</td><td>8192</td><td>89 (hit cap)</td></tr></tbody></table>
<p><strong>2-strand vs 3-strand comparison:</strong></p>
<table><thead><tr><th>Property</th><th>2-strand (TL_2)</th><th>3-strand (Delta_1)</th></tr></thead><tbody><tr><td>Group</td><td>Finite (cyclic, order 8)</td><td>Infinite (Jordan block)</td></tr><tr><td>Module</td><td>Simple L(1)</td><td>Indecomposable Delta_1</td></tr><tr><td>Extension</td><td>None (semisimple)</td><td>Ext^1(L(0),L(1)) != 0</td></tr><tr><td>XOR topology</td><td>Mutual orthogonality graph</td><td>Star graph (2 hubs + sats)</td></tr><tr><td>XOR ceiling</td><td>XOR12 (Cell B)</td><td>XOR14 (deep entries)</td></tr><tr><td>Matched (N=24)</td><td>1109 XOR6</td><td>527 XOR6</td></tr></tbody></table>
<p>2-strand wins at matched small size (finite group better density). 3-strand wins at scale (infinite group unbounded catalog depth). Crossover around catalog size ~100.</p>
<p><strong>XOR14 super-hub structure:</strong> <ul> <li>Hub idx=7: a = d = (0,0,5,0), b = (12,0,0,0), c = (-2,0,0,0). d=6, w=2, anti-trace. Cartan L1=0.</li> <li>Hub idx=9: a = (0,0,-8,0), d = (0,0,1,0), b = c = (-3,0,0,0). d=6, w=-6. Cartan L1=9.</li> <li>Hub commutator: traceless, Cartan L1=84, e-root L1=108, f-root L1=18.</li> <li>100% of 60 winners contain both hubs. 100% are mixed-depth (d=6 + d=7).</li> <li>0/1 substitutions survive for hub7. 0/7 substitutions survive for hub9.</li> </ul>
<p><strong>Casimir discriminant (winner vs control):</strong> <ul> <li>Winner: mean |C|_L1 = 1301 (even: 1301, odd: 1300). Jordan blocks: 384/16384.</li> <li>Control: mean |C|_L1 = 297. Jordan blocks: 816/16384.</li> <li>Winner is 4.4x MORE semisimple than control.</li> </ul>
<p><strong>D99c results (algebraic classification, separate program):</strong> <ul> <li>ALL entries have unit determinant (100%). 4 distinct det values = 4 units in Z[i]: {+/-1, +/-i}. Representation is in SL_2(Z[zeta_8]).</li> <li>Triangular entries (104, 1.3%) have 67.9% XOR6 hit rate -- nearly double next best class.</li> <li>Cell B analog (24 curated anti-trace+dense+deep entries): XOR12=896 (56x improvement over first-24).</li> </ul>
<h3>Code Assets</h3>
<ul>
<li><strong><code>Cyc8</code> (cyclotomic integer arithmetic in Z[zeta_8])</strong>: Basis {1, zeta_8, zeta_8^2, zeta_8^3} with zeta_8^4 = -1. Operations: <code>cyc8_make</code>, <code>cyc8_zero</code>, <code>cyc8_one</code>, <code>cyc8_add</code>, <code>cyc8_sub</code>, <code>cyc8_neg</code>, <code>cyc8_mul</code>, <code>cyc8_eq</code>, <code>cyc8_is_zero</code>, <code>cyc8_conj</code> (Galois conjugate: zeta_8 -&gt; zeta_8^7 = -zeta_8^3). <code>cyc8_to_cplx</code> converts to scaled integer complex (707 ~ 1000/sqrt(2)). <code>cyc8_octant</code> classifies into 8 octants (3 bits: sign of Re, sign of Im, |Im|&gt;|Re|). Fully exact long integer arithmetic.</li>
<li><strong><code>Mat2</code> (2x2 matrix over Cyc8)</strong>: Operations: <code>mat2_zero</code>, <code>mat2_identity</code>, <code>mat2_mul</code>, <code>mat2_eq</code>, <code>mat2_add</code>, <code>mat2_neg</code>, <code>mat2_max_abs</code>, <code>mat2_commutator</code>. Each entry is a Cyc8 (4 longs), so each matrix has 16 integer components.</li>
<li><strong><code>CycQuat</code> (quaternion extraction from Mat2)</strong>: q_0 = a+d, q_1 = b+c, q_2 = b-c, q_3 = a-d. Maps 2x2 matrices to quaternion components. All operations stay in Cyc8.</li>
<li><strong><code>build_generators()</code></strong>: Constructs the 4 braid generators (sigma_1, sigma_1_inv, sigma_2, sigma_2_inv) on the Delta_1 standard module. A = -zeta_8 = (0,-1,0,0).</li>
<li><strong><code>build_catalog()</code></strong>: BFS catalog builder with hash table deduplication. Tracks depth and writhe per entry. Overflow protection (max_abs &gt; 10^11). Global arrays: g_cat (Mat2), g_depth, g_writhe, g_cat_size.</li>
<li><strong>Hash table for Mat2 BFS</strong>: FNV-style hash over 16 long components. Separate chaining. HASH_SIZE=65537, MAX_CAT=32768.</li>
<li><strong>Activation functions (4 types)</strong>: ACT_4ENT_HASH (4 matrix entry octants hashed), ACT_QUAT_HASH (4 quaternion component octants hashed), ACT_2x2_HASH (16-component sign-bit hash, 3-valued per component), ACT_TRACE_OCT (trace octant only, 8 cells). Parameterized by k_param (number of cells).</li>
<li><strong><code>test_xor_mat2()</code></strong>: Tests whether a weight tuple computes XOR under 1wpi encoding on Mat2. 2N inputs from N weights (+/- pairs). Early termination on first parity violation. O(1) cleanup via touched-cell tracking.</li>
<li><strong><code>count_xor_bf()</code></strong>: Brute-force XOR search over all C(bf_limit, n_weights) tuples. Supports 3-8 weights (XOR6 through XOR16).</li>
<li><strong>2-strand comparison infrastructure</strong>: <code>Quat</code> type (floating-point quaternions), <code>build_2strand_catalog()</code> (BFS closure of z8, order 24), <code>build_2strand_dirs()</code> (S2 direction extraction), <code>combined_cell_2s()</code> (sector x Voronoi activation), <code>test_xor_2strand()</code>, <code>count_xor_2s_bf()</code>.</li>
<li><strong>Casimir discriminant</strong>: C(S) = (a-d)^2 + 4<em>b</em>c for summed Mat2. Exact computation in Z[zeta_8]. L1 norm for magnitude. Distinguishes Jordan blocks (C=0) from diagonalizable matrices.</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>Temperley-Lieb algebra standard modules (Graham-Lehrer)</strong>: TL_3(delta=0) decomposes as V = Delta_3(1) + Delta_1(2) + Delta_1(2) via Wedderburn-Artin. Delta_1 is the 2-dimensional standard module on half-diagram basis {h_0, h_2}. At delta=0, TL_3 is semisimple (n=3 odd, <a href="./entries/demo_51.html">Demo 51</a> confirms), but the braid group image is infinite.</li>
<li><strong>Ext^1 and non-semisimple representation theory</strong>: Delta_1 is an indecomposable but reducible module of the restricted quantum group u_q(sl_2) at ell=2 (q = e^{i*pi/4} = zeta_8). Extension class Ext^1(L(0), L(1)) is non-zero. Jordan block proves the extension does not split.</li>
<li><strong>Non-semisimple TQFT (Voss-Kim-Bhatt, Nature Comms 2025)</strong>: Alpha-anyon anchor (quantum trace zero) + sigma-anyon qubits + semisimple readout. Structural identification with <a href="./entries/demo_99.html">D99</a> findings: non-semisimplicity as catalytic preparation, computation in semisimple layer.</li>
<li><strong>Reservoir Computing (Maass et al. 2002, Gonon &amp; Ortega 2020)</strong>: Casimir = separation property. 4.4x winner/control gap = first quantitative measure of algebraic reservoir quality. DKC maps precisely to a discrete algebraic reservoir computer.</li>
<li><strong>Magic state distillation analogy</strong>: But CATALYTIC -- super-hubs are reused, not consumed.</li>
<li><strong>Property F (Freedman-Larsen-Wang)</strong>: Does NOT apply at delta=0. The braid group image through Delta_1 is infinite despite the representation being finite-dimensional, because Delta_1 is not a direct sum of simple modules.</li>
<li><strong>Fibonacci numbers and SL_2</strong>: max_abs Fibonacci growth connected to spectral radius of trace-zero SL_2 element and golden ratio phi = (1+sqrt5)/2 through the 2x2 transfer matrix.</li>
<li><strong>Habiro (2002) / Z[zeta_8] bracket</strong>: The algebraic substrate. All computation exact over cyclotomic integers.</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li><strong>Is XOR16 truly unreachable, or just search-limited?</strong> bf=14 may be insufficient. Need larger bf or smarter search.</li>
<li><strong>Two Delta_1 copies</strong>: TL_3 has two copies of Delta_1 in the decomposition. Do they give different or redundant XOR sets?</li>
<li><strong>Can the super-hub pair be characterized purely algebraically?</strong> What property of idx=7 and idx=9 makes them unique among all d=6 entries?</li>
<li><strong>Ext^1 dimension</strong>: Is dim Ext^1(L(0), L(1)) = 1 at ell=2? If so, Delta_1 is the UNIQUE non-trivial extension, explaining why super-hubs are irreplaceable.</li>
<li><strong>Higher strands</strong>: Does 4-strand (n=4, even, non-semisimple TL) give qualitatively different structure? ANSWERED by <a href="./entries/demo_100.html">D100</a>: yes, frozen radical, 6-hub positive-root ecology, no Casimir inversion.</li>
<li><strong>Better activations</strong>: 2x2_hash is a crude sign-pattern hash. Can Sec x Vor be adapted for Cyc8 quaternions (16 DOF)?</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_100.html">Demo 100</a>: 4-Strand DKC on W_{4,2} — Non-Semisimple Matrix Braid Representation</h2>
<ul>
<li><strong>Status</strong>: COMPLETE (RESULT)</li>
<li><strong>File</strong>: <code><a href="../demo_100_4strand_dkc/main.c.html">demo_100_4strand_dkc/main.c</a></code> (~1749 lines)</li>
<li><strong>Tests</strong>: 36 pass, 0 fail (Phases 0-5)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_80.html">Demo 80</a> (finite/infinite capacity boundary, quantum dimension), <a href="./entries/demo_92.html">Demo 92</a> (parity-lock theorem), <a href="./entries/demo_93.html">Demo 93</a> (circuit complexity hierarchy, 1wpi framework), <a href="./entries/demo_94.html">Demo 94</a> (binary icosahedral group, solvability bottleneck)</li>
<li><strong>Feeds into</strong>: Higher-strand W_{n,k} modules, radical-content XOR correlation studies, non-semisimple TL DKC theory, Casimir-guided weight selection</li>
</ul>
<h3>Headline</h3>
4-strand braid group B_4 acting on the 3-dimensional standard module W_{4,2} of TL_4 at delta=0 (non-semisimple) produces an infinite catalog of 3x3 matrices over Z[zeta_8] with exponential BFS growth (~3.1x per round), sustained XOR capacity through depth, and a 6-hub star-like winner topology where all hub commutators are traceless with zero radical content.
<h3>Key Results</h3>
<ul>
<li><strong>Phase 0 -- Representation verification (19 tests)</strong>: TL_4 at delta=0 is non-semisimple (n=4 even). Radical dim=9, Loewy length 3. Two simple modules: L_{4,2} (dim 2), L_{4,4} (dim 1). W_{4,2} is the standard module with 2 through-lines, dim=3. Extension: 0 -&gt; L_{4,4} -&gt; W_{4,2} -&gt; L_{4,2} -&gt; 0. Three TL generators e_1, e_2, e_3 verified as 3x3 integer matrices. All satisfy e_i^2 = 0 (delta=0), Jones-Wenzl relations (e_i<em>e_{i+1}</em>e_i = e_i), and far commutativity (e_1<em>e_3 = e_3</em>e_1). Braid generators sigma_i = A<em>I + A^{-1}</em>e_i where A = -zeta_8 = (0,-1,0,0), A^{-1} = (0,0,0,1). Verified: A<em>A^{-1} = 1, A^2 + A^{-2} = 0 (delta=0 condition). All sigma_i</em>sigma_i_inv = I. Braid relations s1<em>s2</em>s1 = s2<em>s1</em>s2, s2<em>s3</em>s2 = s3<em>s2</em>s3 verified. Far commutativity s1<em>s3 = s3</em>s1 verified. Hecke relations sigma_i - sigma_i_inv = (A-A_inv)(I-e_i) verified for all three generators.</li>
<li><strong>Phase 1 -- BFS catalog (1 test)</strong>: 6 generators (sigma_1, sigma_1_inv, sigma_2, sigma_2_inv, sigma_3, sigma_3_inv). BFS hits 32768-entry cap at depth 8 -- group is INFINITE. Depth profile: d0=1, d1=6, d2=26, d3=98, d4=338, d5=1110, d6=3444, d7=10390, d8=17355. Max entry magnitude at cap: 34. sigma_1 has infinite order (max_abs grows linearly with power: n=k gives max_abs=k; sigma_1^8 != I).</li>
<li><strong>Phase 2 -- Catalog statistics (1 test)</strong>: Growth rate stabilizes near 3.1x per round (d1: 6.00, d2: 4.33, d3: 3.77, d4: 3.45, d5: 3.28, d6: 3.10, d7: 3.02, d8: 1.67 -- last round truncated by cap). 15.0% of entries (4905/32768) have at least one zero diagonal element.</li>
<li><strong>Phase 3 -- XOR capacity scan (3 tests)</strong>: Activation function: 3x3_hash -- sign pattern of all 36 integer components (9 entries x 4 Cyc8 components), 3-valued (pos=2, zero=1, neg=0), hash mod k_param. At bf=30 (first 30 entries): XOR6 peaks at k=512 (2961 solutions), XOR8 also peaks at k=512 (6187), XOR10 peaks at k=512 (541), XOR12 steady at 48 across all k values. Deep sub-catalog (d&gt;=4, bf=30): XOR6=2017, XOR8=1169, XOR10=654, XOR12=305, XOR14=70. Key finding: deep entries SUSTAIN XOR capacity -- XOR14=70 at depth&gt;=4 demonstrates non-trivial computational power at 7-weight XOR.</li>
<li><strong>Phase 4 -- Radical analysis (6 tests)</strong>: Radical direction r = (1, 0, -1) verified: e_i <em> r = 0 for all three TL generators (r spans the L_{4,4} submodule). Mean radical_content = 2 across all depths (constant). Mean |rMr| = 2 across all depths (constant). Mean |C3| (Casimir C3(M) = 3</em>tr(M^2) - (tr M)^2) grows exponentially with depth: d0=0, d1=0, d2=3, d3=7, d4=16, d5=36, d6=80, d7=176, d8=308. XOR14 winners (70 total) vs control (1000): mean_rad identical (14 vs 14), mean_rMr identical (14 vs 14), mean_C3 slightly higher for winners (172 vs 148). Casimir-by-XOR-level: XOR6 win/ctrl C3 ratio 1.36x, XOR8 ratio 1.86x, XOR10 ratio 1.62x, XOR12 ratio 1.44x -- Casimir consistently higher in winners across all XOR levels.</li>
<li><strong>Phase 5 -- Winner anatomy (5 tests)</strong>: 70 XOR14 winners from bf=30 deep sub-catalog. 6 super-hubs (frequency &gt; 50% of winners): entry 4 (91.4%, d=4, w=2), entry 5 (91.4%, d=4, w=2), entry 10 (54.3%, d=5, w=3), entry 21 (65.7%, d=5, w=1), entry 24 (65.7%, d=5, w=-3), entry 25 (54.3%, d=5, w=-1). Hub pairing by trace Cyc8 component: hubs 4,5 are zeta_8^2 pair (traces (0,0,3,0) and (0,0,6,0)), hubs 10,25 are zeta_8^3 pair (traces (0,0,0,-7) and (0,0,0,5)), hubs 21,24 are zeta_8 pair (traces (0,-5,0,0) and (0,3,0,0)). ALL six hub commutators are traceless. ALL six hub commutators have radical_content = 0 (commutators annihilate the radical direction). Co-occurrence graph: 121 edges, max co-occurrence 58, 77 hub-involved edges, 44 satellite-only edges -- NOT a pure star topology. 19 participating entries out of 30, 11 entries with zero frequency (never appear in any winner).</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Infinite Group from Non-Semisimple TL (CONFIRMED computationally)</strong>: The 4-strand braid group B_4 acting on W_{4,2} (non-semisimple standard module of TL_4 at delta=0) generates an infinite group of 3x3 matrices over Z[zeta_8]. BFS does not close -- hits 32768 cap at depth 8 with sustained ~3.1x growth per round. sigma_1 has infinite order (max_abs grows linearly). This contrasts with the 2-strand case (TL_2 at delta=0) where the catalog is finite.</li>
<li><strong>Constant Radical Content (CONFIRMED)</strong>: All catalog entries have mean radical_content = 2 regardless of BFS depth. The radical direction r = (1, 0, -1) is preserved uniformly. This means the non-semisimple structure (the extension 0 -&gt; L_{4,4} -&gt; W_{4,2} -&gt; L_{4,2} -&gt; 0) is equally present in every braid matrix -- "every BFS entry is already non-semisimple" as predicted in the header.</li>
<li><strong>Casimir Exponential Growth with Depth (OBSERVED)</strong>: Mean |C3| grows approximately as 2^d (doubling per depth): 0, 0, 3, 7, 16, 36, 80, 176, 308. Casimir measures "non-scalar-ness" of the matrix. Deeper entries are more algebraically complex while maintaining constant radical content.</li>
<li><strong>Casimir-XOR Correlation (OBSERVED)</strong>: XOR-winning weight tuples consistently have higher mean Casimir than non-winners, across all XOR levels tested (1.36x-1.86x ratio). Winners need algebraically complex entries. However, radical content does NOT distinguish winners from non-winners (identical at 14 vs 14).</li>
<li><strong>Traceless Commutator Universality (CONFIRMED for all hub pairs)</strong>: All six hub commutators [h_i, h_j] have zero trace and zero radical content. The tracelessness is expected for commutators in GL(3). The zero radical content means commutators live entirely in the semisimple quotient L_{4,2} -- they annihilate the radical direction.</li>
<li><strong>Hub Pairing by Cyclotomic Component (OBSERVED)</strong>: The 6 super-hubs pair naturally by which Cyc8 basis element dominates their trace: {h0,h1} traces in zeta_8^2, {h2,h5} traces in zeta_8^3, {h3,h4} traces in zeta_8. Within each pair, writhes are conjugate (sum to 4, 2, -2 respectively).</li>
</ul>
<h3>Data</h3>
<p><strong>TL_4 at delta=0 structure:</strong> <ul> <li>Radical dim = 9, Loewy length = 3</li> <li>Simple modules: L_{4,2} (dim 2), L_{4,4} (dim 1)</li> <li>W_{4,2}: dim 3, extension 0 -&gt; L_{4,4} -&gt; W_{4,2} -&gt; L_{4,2} -&gt; 0</li> <li>Radical direction: r = (1, 0, -1)</li> </ul>
<p><strong>TL generators (3x3 over Z):</strong></p>
<table><thead><tr><th>Generator</th><th>Matrix</th></tr></thead><tbody><tr><td>e_1</td><td>[[0,1,0],[0,0,0],[0,0,0]]</td></tr><tr><td>e_2</td><td>[[0,0,0],[1,0,1],[0,0,0]]</td></tr><tr><td>e_3</td><td>[[0,0,0],[0,0,0],[0,1,0]]</td></tr></tbody></table>
<p><strong>Braid generators (3x3 over Z[zeta_8]):</strong> <ul> <li>A = -zeta_8 = (0,-1,0,0), A^{-1} = (0,0,0,1)</li> <li>sigma_i = A<em>I + A^{-1}</em>e_i, sigma_i_inv = A^{-1}<em>I + A</em>e_i</li> <li>6 generators indexed 0-5: sigma_1, sigma_1_inv, sigma_2, sigma_2_inv, sigma_3, sigma_3_inv</li> </ul>
<p><strong>BFS catalog (cap 32768):</strong></p>
<table><thead><tr><th>Depth</th><th>New entries</th><th>Cumulative</th><th>Growth ratio</th><th>Max magnitude</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>1</td><td>--</td><td>1</td></tr><tr><td>1</td><td>6</td><td>7</td><td>6.00</td><td>1</td></tr><tr><td>2</td><td>26</td><td>33</td><td>4.33</td><td>2</td></tr><tr><td>3</td><td>98</td><td>131</td><td>3.77</td><td>3</td></tr><tr><td>4</td><td>338</td><td>469</td><td>3.45</td><td>5</td></tr><tr><td>5</td><td>1110</td><td>1579</td><td>3.28</td><td>8</td></tr><tr><td>6</td><td>3444</td><td>5023</td><td>3.10</td><td>13</td></tr><tr><td>7</td><td>10390</td><td>15413</td><td>3.02</td><td>21</td></tr><tr><td>8</td><td>17355</td><td>32768</td><td>1.67*</td><td>34</td></tr></tbody></table>
<p>*Truncated by 32768 cap.</p>
<p><strong>sigma_1 power growth:</strong></p>
<table><thead><tr><th>n</th><th>max_abs(sigma_1^n)</th></tr></thead><tbody><tr><td>1</td><td>1</td></tr><tr><td>2</td><td>2</td></tr><tr><td>3</td><td>3</td></tr><tr><td>4</td><td>4</td></tr><tr><td>5</td><td>5</td></tr><tr><td>6</td><td>6</td></tr><tr><td>7</td><td>7</td></tr><tr><td>8</td><td>8</td></tr></tbody></table>
<p>Linear growth confirms infinite order (Jordan block structure).</p>
<p><strong>Phase 3 -- XOR capacity scan (bf=30, first 30 entries):</strong></p>
<table><thead><tr><th>k_cells</th><th>XOR6</th><th>XOR8</th><th>XOR10</th><th>XOR12</th></tr></thead><tbody><tr><td>64</td><td>1158</td><td>393</td><td>176</td><td>48</td></tr><tr><td>128</td><td>1937</td><td>822</td><td>208</td><td>48</td></tr><tr><td>256</td><td>2510</td><td>2376</td><td>251</td><td>48</td></tr><tr><td>512</td><td>2961</td><td>6187</td><td>541</td><td>48</td></tr></tbody></table>
<p><strong>Deep sub-catalog (d&gt;=4, bf=30, k=128):</strong></p>
<table><thead><tr><th>XOR level</th><th>Winners</th></tr></thead><tbody><tr><td>XOR6</td><td>2017</td></tr><tr><td>XOR8</td><td>1169</td></tr><tr><td>XOR10</td><td>654</td></tr><tr><td>XOR12</td><td>305</td></tr><tr><td>XOR14</td><td>70</td></tr></tbody></table>
<p><strong>Radical/Casimir by depth:</strong></p>
<table><thead><tr><th>Depth</th><th>mean_rad</th><th>mean_rMr</th><th>mean_C3</th><th>Count</th></tr></thead><tbody><tr><td>0</td><td>2</td><td>2</td><td>0</td><td>1</td></tr><tr><td>1</td><td>2</td><td>2</td><td>0</td><td>6</td></tr><tr><td>2</td><td>2</td><td>2</td><td>3</td><td>26</td></tr><tr><td>3</td><td>2</td><td>2</td><td>7</td><td>98</td></tr><tr><td>4</td><td>2</td><td>2</td><td>16</td><td>338</td></tr><tr><td>5</td><td>2</td><td>2</td><td>36</td><td>1110</td></tr><tr><td>6</td><td>2</td><td>2</td><td>80</td><td>3444</td></tr><tr><td>7</td><td>2</td><td>2</td><td>176</td><td>10390</td></tr><tr><td>8</td><td>2</td><td>2</td><td>308</td><td>17355</td></tr></tbody></table>
<p><strong>Casimir-by-XOR-level (deep bf=30, k=128):</strong></p>
<table><thead><tr><th>XOR level</th><th>Winners</th><th>Win C3</th><th>Ctrl C3</th><th>Ratio</th></tr></thead><tbody><tr><td>XOR6</td><td>2017</td><td>64</td><td>47</td><td>1.36x</td></tr><tr><td>XOR8</td><td>1169</td><td>93</td><td>50</td><td>1.86x</td></tr><tr><td>XOR10</td><td>654</td><td>123</td><td>76</td><td>1.62x</td></tr><tr><td>XOR12</td><td>305</td><td>148</td><td>103</td><td>1.44x</td></tr></tbody></table>
<p><strong>XOR14 winners vs control (deep bf=30, k=128):</strong></p>
<table><thead><tr><th>Metric</th><th>Winners (70)</th><th>Control (1000)</th></tr></thead><tbody><tr><td>mean_rad</td><td>14</td><td>14</td></tr><tr><td>mean_rMr</td><td>14</td><td>14</td></tr><tr><td>mean_C3</td><td>172</td><td>148</td></tr></tbody></table>
<p><strong>Super-hubs (6 hubs, frequency &gt; 50% of 70 winners):</strong></p>
<table><thead><tr><th>Hub</th><th>Entry</th><th>Freq</th><th>Freq%</th><th>Depth</th><th>Writhe</th><th>Trace</th><th></th><th>C3</th><th></th><th>Frob L1</th></tr></thead><tbody><tr><td>0</td><td>4</td><td>64</td><td>91.4%</td><td>4</td><td>2</td><td>(0,0,3,0)</td><td>0</td><td>15</td></tr><tr><td>1</td><td>5</td><td>64</td><td>91.4%</td><td>4</td><td>2</td><td>(0,0,6,0)</td><td>36</td><td>19</td></tr><tr><td>2</td><td>10</td><td>38</td><td>54.3%</td><td>5</td><td>3</td><td>(0,0,0,-7)</td><td>56</td><td>17</td></tr><tr><td>3</td><td>21</td><td>46</td><td>65.7%</td><td>5</td><td>1</td><td>(0,-5,0,0)</td><td>20</td><td>19</td></tr><tr><td>4</td><td>24</td><td>46</td><td>65.7%</td><td>5</td><td>-3</td><td>(0,3,0,0)</td><td>0</td><td>21</td></tr><tr><td>5</td><td>25</td><td>38</td><td>54.3%</td><td>5</td><td>-1</td><td>(0,0,0,5)</td><td>20</td><td>11</td></tr></tbody></table>
<p><strong>Hub commutators (all traceless, all radical_content = 0):</strong></p>
<table><thead><tr><th>Pair</th><th>Trace</th><th></th><th>C3</th><th></th><th>Rad</th><th>Frob L1</th></tr></thead><tbody><tr><td>[h0,h1] zeta_8^2 pair</td><td>(0,0,0,0)</td><td>24</td><td>0</td><td>44</td></tr><tr><td>[h2,h5] zeta_8^3 pair</td><td>(0,0,0,0)</td><td>426</td><td>0</td><td>55</td></tr><tr><td>[h3,h4] zeta_8 pair</td><td>(0,0,0,0)</td><td>216</td><td>0</td><td>86</td></tr><tr><td>[h0,h3] top x mid</td><td>(0,0,0,0)</td><td>96</td><td>0</td><td>84</td></tr><tr><td>[h0,h2] top x low</td><td>(0,0,0,0)</td><td>384</td><td>0</td><td>84</td></tr><tr><td>[h3,h2] mid x low</td><td>(0,0,0,0)</td><td>552</td><td>0</td><td>94</td></tr></tbody></table>
<p><strong>Co-occurrence topology:</strong> <ul> <li>121 edges total, max co-occurrence 58</li> <li>77 hub-involved edges, 44 satellite-only edges</li> <li>NOT a pure star topology</li> <li>19/30 entries participate in at least one winner</li> </ul>
<h3>Code Assets</h3>
<ul>
<li><strong><code>Cyc8</code> (Z[zeta_8] cyclotomic arithmetic)</strong>: Exact integer type representing a + b<em>zeta_8 + c</em>zeta_8^2 + d*zeta_8^3 with zeta_8^4 = -1. Operations: <code>cyc8_make</code>, <code>cyc8_add</code>, <code>cyc8_sub</code>, <code>cyc8_neg</code>, <code>cyc8_mul</code>, <code>cyc8_eq</code>, <code>cyc8_is_zero</code>, <code>cyc8_conj</code>, <code>cyc8_max_abs</code>. Multiplication uses the relation zeta_8^4 = -1 for reduction. Fully reusable for any computation in Z[zeta_8].</li>
<li><strong><code>Mat3</code> (3x3 matrix over Cyc8)</strong>: Matrix type for W_{4,2} representation. 9 Cyc8 entries = 36 long integers. Operations: <code>mat3_zero</code>, <code>mat3_identity</code>, <code>mat3_mul</code>, <code>mat3_eq</code>, <code>mat3_add</code>, <code>mat3_neg</code>, <code>mat3_scale</code>, <code>mat3_max_abs</code>, <code>mat3_print</code>. All operations exact -- no floating point.</li>
<li><strong>Hash table for Mat3 BFS</strong>: FNV-style hash over 36 long components, chained-bucket lookup. MAX_CAT = 32768, HASH_SIZE = 65537. Used for BFS deduplication of matrix catalog.</li>
<li><strong><code>build_tl_generators()</code></strong>: Constructs 3x3 integer matrices e_1, e_2, e_3 for TL_4 on W_{4,2} basis {h_0, h_1, h_2} (three half-diagrams with 2 through-lines).</li>
<li><strong><code>build_braid_generators()</code></strong>: Constructs 6 braid generators sigma_i = A<em>I + A^{-1}</em>e_i and sigma_i_inv = A^{-1}<em>I + A</em>e_i over Z[zeta_8]. Tracks writhe (+1 for sigma, -1 for sigma_inv).</li>
<li><strong><code>build_catalog(max_depth)</code></strong>: BFS closure with 6 generators. Overflow protection at max_abs &gt; 10^11. Reports per-round growth and closure/cap/depth-limit status.</li>
<li><strong><code>mat3_activate(m, k_param)</code></strong>: 3x3_hash activation -- sign pattern of all 36 integer components (3-valued: pos/zero/neg), base-3 hash mod k_param. Novel activation function designed for matrix-valued DKC.</li>
<li><strong><code>test_xor_mat3(indices, n_weights, k_param)</code></strong>: 1wpi XOR test for Mat3 catalog. N weights -&gt; 2N inputs. Signed sum in Mat3 space, activation via mat3_activate. Touch-list cleanup pattern for efficient cell reuse.</li>
<li><strong><code>count_xor_bf(n_weights, k_param, bf_limit)</code></strong>: Brute-force combinatorial XOR search over C(bf,n_weights) tuples. Supports n_weights = 3-7 (XOR6 through XOR14).</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li><strong>Temperley-Lieb algebra at delta=0 (non-semisimple regime)</strong>: TL_n at delta=0 with n even is the most singular point -- radical has maximal dimension, Loewy length reaches maximum. Standard modules W_{n,k} are indecomposable but not simple. <a href="./entries/demo_100.html">D100</a> works with W_{4,2} (dim 3), which has the non-split extension 0 -&gt; L_{4,4} -&gt; W_{4,2} -&gt; L_{4,2} -&gt; 0. Every braid matrix preserves this structure (constant radical content = 2 at all depths).</li>
<li><strong>Braid group representations via Kauffman bracket</strong>: sigma_i = A<em>I + A^{-1}</em>e_i gives a representation of the braid group B_n on TL_n modules. At the special value A = -zeta_8 (corresponding to delta = -(A^2 + A^{-2}) = 0), this representation is infinite-dimensional on W_{4,2}. The linear growth of max_abs(sigma_1^n) = n indicates a non-trivial Jordan block in the representation.</li>
<li><strong>Habiro (2002) / Z[zeta_8] bracket</strong>: The algebraic substrate. <a href="./entries/demo_100.html">D100</a> extends the scalar Z[zeta_8] bracket (used in <a href="./entries/demo_80.html">D80</a>-<a href="./entries/demo_94.html">D94</a>) to matrix-valued computation: each catalog entry is now a 3x3 matrix over Z[zeta_8] rather than a single Z[zeta_8] element. The DKC signed-sum framework generalizes directly to matrix addition.</li>
<li><strong>Casimir invariant as complexity measure</strong>: The modified Casimir C3(M) = 3*tr(M^2) - (tr M)^2 measures deviation from scalar matrices. Its exponential growth with BFS depth (~2x per round) while radical content stays constant shows that braid words become algebraically richer without changing their module-theoretic character. Its correlation with XOR capacity (1.36x-1.86x higher in winners) suggests Casimir as a heuristic for weight selection in matrix DKC.</li>
<li><strong>Reservoir computing connection</strong>: The infinite catalog (vs finite groups in <a href="./entries/demo_80.html">D80</a>-<a href="./entries/demo_94.html">D94</a>) means the reservoir has unbounded size. The 3x3_hash activation is a novel nonlinear readout designed for matrix-valued reservoirs. The 36-component sign pattern provides much finer discrimination than the scalar phase_cell used in <a href="./entries/demo_80.html">D80</a>-<a href="./entries/demo_94.html">D94</a>.</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li><strong>Higher-strand generalization</strong>: W_{6,2} (dim 5) and W_{6,4} (dim 9) on TL_6 at delta=0 -- does the Casimir-XOR correlation persist? Does the hub pairing structure generalize to larger representations?</li>
<li><strong>Optimal activation for matrix DKC</strong>: The 3x3_hash activation (sign pattern of 36 components) is ad hoc. Is there a natural activation that respects the module structure (e.g., projects onto radical vs semisimple components separately)?</li>
<li><strong>Radical-annihilating commutators</strong>: All hub commutators have zero radical content. Is this a general theorem (commutators of braid matrices on W_{n,k} always annihilate the radical) or specific to these hub entries?</li>
<li><strong>Connection to <a href="./entries/demo_80.html">D80</a>-<a href="./entries/demo_94.html">D94</a> scalar DKC</strong>: Can the matrix DKC be reduced to scalar DKC by projecting onto specific module components? The radical content being constant suggests the extension structure adds something that projection would lose.</li>
<li><strong>Casimir-guided weight selection</strong>: Can Casimir be used as a pre-filter to reduce the combinatorial search space for XOR-winning tuples? The 1.36x-1.86x ratio suggests moderate predictive power but not strong enough to be a standalone selector.</li>
<li><strong>Cap-free growth rate</strong>: The d=8 growth ratio (1.67x) is depressed by the 32768 cap. What is the true asymptotic growth rate? The stabilization toward ~3.0x suggests the free growth rate may be exactly 3 (related to 3 non-adjacent generator pairs: sigma_1, sigma_2, sigma_3).</li>
</ul>
<p>---</p>
<h2><a href="./entries/demo_101.html">Demo 101</a>: 5-Strand DKC Scaling Verification on W_{5,3} — sl_d Functor Thesis</h2>
<ul>
<li><strong>Status</strong>: COMPLETE (RESULT)</li>
<li><strong>File</strong>: <code><a href="../demo_101_5strand_dkc/main.c.html">demo_101_5strand_dkc/main.c</a></code> (~1569 lines)</li>
<li><strong>Tests</strong>: 44 pass, 0 fail (Phases 0-5)</li>
<li><strong>Depends on</strong>: <a href="./entries/demo_80.html">Demo 80</a> (finite/infinite capacity boundary, quantum dimension), <a href="./entries/demo_93.html">Demo 93</a> (circuit complexity hierarchy, 1wpi framework), <a href="./entries/demo_100.html">Demo 100</a> (4-strand DKC on W_{4,2}, non-semisimple matrix braid representation, radical analysis, Casimir-XOR correlation, hub anatomy methodology)</li>
<li><strong>Feeds into</strong>: Higher-strand W_{n,k} modules, sl_d functor series completion, radical-free vs radical-containing DKC comparison, Casimir-XOR correlation in simple modules, hub-count scaling law</li>
</ul>
<h3>Headline</h3>
PREDICTION-DENSE DEMO testing the sl_d functor thesis. 5-strand braid group B_5 acting on W_{5,3} (the SIMPLE standard module of TL_5 at delta=0 -- no radical, key structural difference from <a href="./entries/demo_100.html">D100</a>) produces an infinite catalog of 4x4 matrices over Z[zeta_8] with ~4x BFS growth per round (CONFIRMING the growth-rate prediction), sustained XOR6-XOR12 capacity, and all-traceless hub commutators. However, the hub-count prediction is FALSIFIED (3 hubs, not 12), XOR14 vanishes entirely (vs 70 in <a href="./entries/demo_100.html">D100</a>), and the Casimir-XOR correlation INVERTS at higher XOR levels. The simple module computes differently from <a href="./entries/demo_100.html">D100</a>'s non-semisimple module: the radical extension is computationally load-bearing, not decorative.
<h3>Key Results</h3>
<ul>
<li><strong>Phase 0 -- Representation verification (30 tests)</strong>: W_{5,3} is the 4-dimensional standard module of TL_5 at delta=0. KEY STRUCTURAL DIFFERENCE: W_{5,3} is SIMPLE (no radical). ker(e_1) intersect ... intersect ker(e_4) = {0} (radical dimension verified = 0). Basis: four half-diagrams for 5 strands with 3 through-lines (h_0: {1,2} paired, h_1: {2,3} paired, h_2: {3,4} paired, h_3: {4,5} paired). Four TL generators e_1..e_4 as 4x4 integer matrices, following A_3 Dynkin diagram (path graph) pattern. All satisfy e_i^2 = 0 (delta=0), Jones-Wenzl relations (e_i<em>e_{i+1}</em>e_i = e_i and e_{i+1}<em>e_i</em>e_{i+1} = e_{i+1} for 3 adjacent pairs), and far commutativity (e_1<em>e_3, e_1</em>e_4, e_2<em>e_4). Braid generators sigma_i = A</em>I + A^{-1}<em>e_i where A = -zeta_8 = (0,-1,0,0), A^{-1} = (0,0,0,1). Verified: A</em>A^{-1} = 1, A^2 + A^{-2} = 0 (delta=0 condition). All four sigma_i<em>sigma_i_inv = I. Braid relations s_i</em>s_{i+1}<em>s_i = s_{i+1}</em>s_i*s_{i+1} for 3 adjacent pairs. Far braid commutativity for 3 far pairs. Hecke relations s_i - s_i_inv = (A-A_inv)(I-e_i) for all 4 generators.</li>
<li><strong>Phase 1 -- BFS catalog (1 test)</strong>: 8 generators (sigma_1..4 and inverses). BFS hits 32768-entry cap at depth 7 -- group is INFINITE. Depth profile: d0=1, d1=8, d2=44, d3=206, d4=884, d5=3600, d6=14198, d7=13827. Max entry magnitude at cap: 21. Growth rate confirms prediction: ~4x per round (8/1=8.00, 44/8=5.50, 206/44=4.68, 884/206=4.29, 3600/884=4.07, 14198/3600=3.94, 13827/14198=0.97* -- last round truncated by cap).</li>
<li><strong>Phase 2 -- Catalog statistics (1 test)</strong>: Growth rate stabilizes near 4x per round (contrasting with <a href="./entries/demo_100.html">D100</a>'s ~3.1x for 6 generators/3-dim). sigma_1 has infinite order: max_abs grows linearly with power (n=1: 1, n=2: 2, n=3: 3, n=4: 4, n=5: 5, n=6: 6, n=7: 7, n=8: 8 -- exactly linear, matching <a href="./entries/demo_100.html">D100</a>'s pattern). sigma_1^8 != identity confirmed. Linear max_abs growth indicates Jordan block structure in the representation.</li>
<li><strong>Phase 3 -- XOR capacity scan (2 tests)</strong>: Activation function: 4x4_hash -- sign pattern of all 64 integer components (16 entries x 4 Cyc8 components), 3-valued (pos=2, zero=1, neg=0), hash mod k_param. K-sweep at bf=30 (first 30 entries): XOR6 peaks at k=512 (3297), XOR8 peaks at k=512 (12229), XOR10 peaks at k=512 (5729), XOR12 peaks at k=512 (512). Deep sub-catalog (d&gt;=4, bf=30, k=128): XOR6=2579, XOR8=2228, XOR10=203, XOR12=27, XOR14=0. XOR14 ZERO at all k values (k=256 through 4096). Key finding: deep entries sustain XOR6-XOR12 capacity but XOR14 vanishes entirely -- contrasting with <a href="./entries/demo_100.html">D100</a> where XOR14=70 on 3x3 matrices.</li>
<li><strong>Phase 4 -- Casimir analysis (3 tests)</strong>: No radical (W_{5,3} simple), so no radical_content analysis (unlike <a href="./entries/demo_100.html">D100</a>). C4(M) = 4*tr(M^2) - (tr M)^2 computed integer-exact for all 32768 entries. Mean |C4| = 91 across full catalog. C4 by depth: d0=0, d1=0, d2=4, d3=9, d4=20, d5=41, d6=83, d7=118 -- approximately 2x per round, matching <a href="./entries/demo_100.html">D100</a>'s exponential growth pattern. XOR10 winners (203) vs control (1000): mean C4 = 57 vs 67 -- winners have LOWER Casimir (ratio 0.85x). Casimir-by-XOR-level: XOR6 ratio 1.17x (winners higher), XOR8 ratio 1.51x (winners higher), XOR10 ratio 0.89x (winners LOWER), XOR12 ratio 0.54x (winners LOWER). INVERSION of <a href="./entries/demo_100.html">D100</a> pattern: Casimir-XOR correlation reverses at higher XOR levels in simple modules.</li>
<li><strong>Phase 5 -- Hub anatomy (7 tests)</strong>: 203 XOR10 winners from deep bf=30 sub-catalog. Only 3 super-hubs (frequency &gt; 1/3 of winners) -- NOT the predicted 12. Hub 0: entry 0, freq=87 (42.9%), d=4, w=4, |C4|=0, Frob=8. Hub 1: entry 26, freq=137 (67.5%), d=5, w=5, |C4|=0, Frob=9. Hub 2: entry 27, freq=142 (70.0%), d=5, w=3, |C4|=11, Frob=12. Hub traces by Cyc8 component: hub 0 real (-4,0,0,0), hub 1 zeta_8 (0,4,0,0), hub 2 zeta_8^3 (0,0,0,-5). All 3 hub-pair commutators traceless (3/3). First commutator [hub_0, hub_1] is the ZERO MATRIX (hubs 0 and 1 COMMUTE). Co-occurrence: 247 edges, max co-occurrence 102, 62 hub-involved edges, 185 satellite-only edges -- strongly NOT a star topology. XOR12: 27 winners, entry 0 and entries 26-27 dominate (freq=26 each). sl_4 hub-count prediction FALSIFIED: 3 hubs, not 12.</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>sl_d Functor Thesis (PARTIALLY CONFIRMED, PARTIALLY FALSIFIED)</strong>: Growth rate prediction CONFIRMED: ~4x per round converging toward 4 as expected for sl_4 (<a href="./entries/demo_100.html">D100</a> showed ~3.1x for sl_3). Hub count prediction FALSIFIED: only 3 super-hubs found (not the predicted 12 = 6 pairs for sl_4). The growth rate tracks n-1 cleanly across three data points (2, 3, 4), but the hub count does NOT scale as 2*C(n-1,2). The discrepancy may be due to the simple-module context (W_{5,3} has no radical) vs <a href="./entries/demo_100.html">D100</a>'s non-semisimple module (W_{4,2} has radical), or to the bf=30 deep-entry sampling which may miss hubs at other depths.</li>
<li><strong>Simple Module DKC (DEMONSTRATED)</strong>: W_{5,3} is simple (radical dimension = 0), in contrast to <a href="./entries/demo_100.html">D100</a>'s W_{4,2} which is non-semisimple (radical dim &gt; 0, Loewy length 3). DKC still produces infinite catalogs and sustained XOR6-XOR12 capacity. However, the detailed structure differs: only 3 hubs (vs 6 for <a href="./entries/demo_100.html">D100</a>), XOR14 vanishes entirely (vs 70 for <a href="./entries/demo_100.html">D100</a>), and the Casimir-XOR correlation INVERTS at higher XOR levels. Simplicity changes the computational character, not just removes the radical.</li>
<li><strong>BFS Growth Rate Prediction (CONFIRMED)</strong>: Predicted ~4x per round for 4 TL generators (n-1=4 for 5 strands). Observed: 8.00, 5.50, 4.68, 4.29, 4.07, 3.94 -- converging toward 4 as expected. <a href="./entries/demo_100.html">D100</a> showed ~3.1x converging toward 3 for 3 generators. The growth rate tracks the number of TL generators (n-1), consistent with the sl_{n-1} thesis. This is now confirmed across THREE data points (n=3,4,5).</li>
<li><strong>No Radical Content, Still Computes (CONFIRMED)</strong>: All catalog entries live in a simple module -- there is no radical to measure. XOR6-XOR12 capacity is sustained through depth. However, XOR14=0 everywhere suggests a capacity ceiling that <a href="./entries/demo_100.html">D100</a> (non-semisimple) does not have. The radical extension in <a href="./entries/demo_100.html">D100</a> may provide additional computational degrees of freedom that the simple module lacks.</li>
<li><strong>Traceless Commutator Universality (CONFIRMED for all 3 hub pairs)</strong>: All 3 super-hub commutators are traceless (3/3). Moreover, [hub_0, hub_1] is the ZERO MATRIX -- these two hubs actually commute. This is stronger than tracelessness and suggests hub_0 and hub_1 live in a commutative subalgebra. Note that hub_0 (entry 0) is near-scalar: diagonal (-1,-1,-1,-1) with a single off-diagonal (0,0,4,0) entry. Hub_1 is similarly structured: diagonal (0,1,0,0) entries with a single off-diagonal (0,0,0,-5).</li>
<li><strong>Casimir-XOR Correlation INVERSION (NEW FINDING)</strong>: <a href="./entries/demo_100.html">D100</a> showed winners consistently have HIGHER Casimir (1.36x-1.86x ratio). <a href="./entries/demo_101.html">D101</a> shows the pattern INVERTS: XOR6 ratio 1.17x and XOR8 ratio 1.51x (winners higher, matching <a href="./entries/demo_100.html">D100</a>), but XOR10 ratio 0.89x and XOR12 ratio 0.54x (winners LOWER). In the simple module, the hardest XOR computations select for LOW-Casimir entries. This is the opposite of <a href="./entries/demo_100.html">D100</a>'s non-semisimple module. Possible explanation: in simple modules, near-scalar entries (low C4) provide the stability that the radical direction provided in <a href="./entries/demo_100.html">D100</a>.</li>
<li><strong>XOR14 Vanishing in Simple Module (NEW FINDING)</strong>: XOR14=0 at ALL k values tested (128 through 4096) on the deep sub-catalog. <a href="./entries/demo_100.html">D100</a> achieved XOR14=70 on 3x3 matrices with the same bf=30 and k=128. The simple module (no radical) has strictly less XOR14 capacity than the non-semisimple module. This suggests the non-semisimple extension structure in <a href="./entries/demo_100.html">D100</a> is computationally load-bearing at the XOR14 boundary, not just algebraic decoration.</li>
</ul>
<h3>Data</h3>
<p><strong>W_{5,3} module structure:</strong> <ul> <li>TL_5 at delta=0, n=5 (ODD) -- W_{5,3} is SIMPLE</li> <li>dim(W_{5,3}) = 4 (Catalan path count for 5 strands, 3 through-lines)</li> <li>Radical dimension = 0 (ker(e_1) intersect ... intersect ker(e_4) = {0})</li> <li>Basis: 4 half-diagrams h_0..h_3 (one pair each from {1,2}, {2,3}, {3,4}, {4,5})</li> </ul>
<p><strong>TL generators (4x4 over Z):</strong></p>
<table><thead><tr><th>Generator</th><th>Matrix</th><th>Pattern</th></tr></thead><tbody><tr><td>e_1</td><td>[[0,1,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]</td><td>h_1 -&gt; h_0</td></tr><tr><td>e_2</td><td>[[0,0,0,0],[1,0,1,0],[0,0,0,0],[0,0,0,0]]</td><td>h_0 -&gt; h_1, h_2 -&gt; h_1</td></tr><tr><td>e_3</td><td>[[0,0,0,0],[0,0,0,0],[0,1,0,1],[0,0,0,0]]</td><td>h_1 -&gt; h_2, h_3 -&gt; h_2</td></tr><tr><td>e_4</td><td>[[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,1,0]]</td><td>h_2 -&gt; h_3</td></tr></tbody></table>
<p><strong>Braid generators (4x4 over Z[zeta_8]):</strong> <ul> <li>A = -zeta_8 = (0,-1,0,0), A^{-1} = (0,0,0,1)</li> <li>sigma_i = A<em>I + A^{-1}</em>e_i, sigma_i_inv = A^{-1}<em>I + A</em>e_i</li> <li>8 generators indexed 0-7: sigma_1, sigma_1_inv, sigma_2, sigma_2_inv, sigma_3, sigma_3_inv, sigma_4, sigma_4_inv</li> <li>Writhe tracking: +1 for sigma, -1 for sigma_inv</li> </ul>
<p><strong>BFS catalog (cap 32768):</strong></p>
<table><thead><tr><th>Depth</th><th>New entries</th><th>Cumulative</th><th>Growth ratio</th><th>Max magnitude</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>1</td><td>--</td><td>1</td></tr><tr><td>1</td><td>8</td><td>9</td><td>8.00</td><td>1</td></tr><tr><td>2</td><td>44</td><td>53</td><td>5.50</td><td>2</td></tr><tr><td>3</td><td>206</td><td>259</td><td>4.68</td><td>3</td></tr><tr><td>4</td><td>884</td><td>1143</td><td>4.29</td><td>5</td></tr><tr><td>5</td><td>3600</td><td>4743</td><td>4.07</td><td>8</td></tr><tr><td>6</td><td>14198</td><td>18941</td><td>3.94</td><td>13</td></tr><tr><td>7</td><td>13827</td><td>32768</td><td>0.97*</td><td>21</td></tr></tbody></table>
<p>*Truncated by 32768 cap.</p>
<p><strong>sigma_1 power growth:</strong></p>
<table><thead><tr><th>n</th><th>max_abs(sigma_1^n)</th></tr></thead><tbody><tr><td>1</td><td>1</td></tr><tr><td>2</td><td>2</td></tr><tr><td>3</td><td>3</td></tr><tr><td>4</td><td>4</td></tr><tr><td>5</td><td>5</td></tr><tr><td>6</td><td>6</td></tr><tr><td>7</td><td>7</td></tr><tr><td>8</td><td>8</td></tr></tbody></table>
<p>Linear growth confirms infinite order (Jordan block structure). Matches <a href="./entries/demo_100.html">D100</a> exactly.</p>
<p><strong>Growth rate comparison across strand count (sl_d thesis):</strong></p>
<table><thead><tr><th>n (strands)</th><th>Demo</th><th>Module</th><th>dim</th><th>Generators</th><th>Growth rate</th><th>Predicted (sl_{n-1})</th></tr></thead><tbody><tr><td>3</td><td><a href="./entries/demo_98.html">D98</a></td><td>TL_3</td><td>5x5</td><td>4</td><td>~2.2x</td><td>2 (sl_2)</td></tr><tr><td>4</td><td><a href="./entries/demo_100.html">D100</a></td><td>W_{4,2}</td><td>3x3</td><td>6</td><td>~3.1x</td><td>3 (sl_3)</td></tr><tr><td>5</td><td><a href="./entries/demo_101.html">D101</a></td><td>W_{5,3}</td><td>4x4</td><td>8</td><td>~4.0x</td><td>4 (sl_4)</td></tr></tbody></table>
<p><strong>Phase 3 -- XOR capacity scan (bf=30, first 30 entries):</strong></p>
<table><thead><tr><th>k_cells</th><th>XOR6</th><th>XOR8</th><th>XOR10</th><th>XOR12</th></tr></thead><tbody><tr><td>64</td><td>1916</td><td>1330</td><td>732</td><td>441</td></tr><tr><td>128</td><td>2600</td><td>3316</td><td>844</td><td>441</td></tr><tr><td>256</td><td>3080</td><td>7918</td><td>1876</td><td>465</td></tr><tr><td>512</td><td>3297</td><td>12229</td><td>5729</td><td>512</td></tr></tbody></table>
<p><strong>Deep sub-catalog (d&gt;=4, bf=30, k=128):</strong></p>
<table><thead><tr><th>XOR level</th><th>Winners</th></tr></thead><tbody><tr><td>XOR6</td><td>2579</td></tr><tr><td>XOR8</td><td>2228</td></tr><tr><td>XOR10</td><td>203</td></tr><tr><td>XOR12</td><td>27</td></tr><tr><td>XOR14</td><td>0</td></tr></tbody></table>
<p><strong>Deep XOR14 k-sweep (all zero):</strong></p>
<table><thead><tr><th>k</th><th>XOR14</th></tr></thead><tbody><tr><td>256</td><td>0</td></tr><tr><td>512</td><td>0</td></tr><tr><td>1024</td><td>0</td></tr><tr><td>2048</td><td>0</td></tr><tr><td>4096</td><td>0</td></tr></tbody></table>
<p><strong>Comparison: <a href="./entries/demo_100.html">D100</a> (3x3 non-semisimple) vs <a href="./entries/demo_101.html">D101</a> (4x4 simple) deep bf=30 k=128:</strong></p>
<table><thead><tr><th>XOR level</th><th><a href="./entries/demo_100.html">D100</a> (W_{4,2})</th><th><a href="./entries/demo_101.html">D101</a> (W_{5,3})</th></tr></thead><tbody><tr><td>XOR6</td><td>2017</td><td>2579</td></tr><tr><td>XOR8</td><td>1169</td><td>2228</td></tr><tr><td>XOR10</td><td>654</td><td>203</td></tr><tr><td>XOR12</td><td>305</td><td>27</td></tr><tr><td>XOR14</td><td>70</td><td>0</td></tr></tbody></table>
<p><a href="./entries/demo_101.html">D101</a> wins at XOR6-XOR8, <a href="./entries/demo_100.html">D100</a> wins at XOR10-XOR14. The simple module has broader but shallower capacity.</p>
<p><strong>Phase 4 -- Casimir C4 by depth:</strong></p>
<table><thead><tr><th>Depth</th><th>mean_C4</th><th>Count</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>8</td></tr><tr><td>2</td><td>4</td><td>44</td></tr><tr><td>3</td><td>9</td><td>206</td></tr><tr><td>4</td><td>20</td><td>884</td></tr><tr><td>5</td><td>41</td><td>3600</td></tr><tr><td>6</td><td>83</td><td>14198</td></tr><tr><td>7</td><td>118</td><td>13827</td></tr></tbody></table>
<p>Mean |C4| across full catalog: 91. Growth approximately 2x per round (matching <a href="./entries/demo_100.html">D100</a> pattern).</p>
<p><strong>Phase 4 -- Casimir-by-XOR-level (deep bf=30, k=128):</strong></p>
<table><thead><tr><th>XOR level</th><th>Winners</th><th>Win C4</th><th>Ctrl C4</th><th>Ratio</th></tr></thead><tbody><tr><td>XOR6</td><td>2579</td><td>55</td><td>47</td><td>1.17x</td></tr><tr><td>XOR8</td><td>2228</td><td>71</td><td>47</td><td>1.51x</td></tr><tr><td>XOR10</td><td>203</td><td>57</td><td>64</td><td>0.89x</td></tr><tr><td>XOR12</td><td>27</td><td>43</td><td>79</td><td>0.54x</td></tr></tbody></table>
<p>INVERSION at XOR10-XOR12: winners have LOWER Casimir. Contrast with <a href="./entries/demo_100.html">D100</a> where all ratios &gt; 1 (1.36x-1.86x).</p>
<p><strong>XOR10 winners vs control (deep bf=30, k=128):</strong></p>
<table><thead><tr><th>Metric</th><th>Winners (203)</th><th>Control (1000)</th></tr></thead><tbody><tr><td>mean_C4</td><td>57</td><td>67</td></tr></tbody></table>
<p><strong>Phase 5 -- Super-hubs (3 hubs, frequency &gt; 67 = 1/3 of 203 winners):</strong></p>
<table><thead><tr><th>Hub</th><th>Entry</th><th>Freq</th><th>Freq%</th><th>Depth</th><th>Writhe</th><th>Trace</th><th></th><th>C4</th><th></th><th>Frob L1</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>87</td><td>42.9%</td><td>4</td><td>4</td><td>(-4,0,0,0)</td><td>0</td><td>8</td></tr><tr><td>1</td><td>26</td><td>137</td><td>67.5%</td><td>5</td><td>5</td><td>(0,4,0,0)</td><td>0</td><td>9</td></tr><tr><td>2</td><td>27</td><td>142</td><td>70.0%</td><td>5</td><td>3</td><td>(0,0,0,-5)</td><td>11</td><td>12</td></tr></tbody></table>
<p>Hub traces by Cyc8 component: hub 0 = real (1-component), hub 1 = zeta_8 (b-component), hub 2 = zeta_8^3 (d-component). Three of four Cyc8 basis elements represented. Hubs 0 and 1 have |C4|=0 (nearly scalar).</p>
<p><strong>Phase 5 -- Hub commutators (all traceless):</strong></p>
<table><thead><tr><th>Pair</th><th>Trace</th><th></th><th>C4</th><th></th><th>Frob L1</th></tr></thead><tbody><tr><td>[h0,h1]</td><td>(0,0,0,0)</td><td>0</td><td>0</td></tr><tr><td>[h0,h2]</td><td>(0,0,0,0)</td><td>0</td><td>0</td></tr><tr><td>[h1,h2]</td><td>(0,0,0,0)</td><td>0</td><td>0</td></tr></tbody></table>
<p>ALL commutators are the zero matrix -- all three hubs MUTUALLY COMMUTE. This is much stronger than <a href="./entries/demo_100.html">D100</a>'s tracelessness. The three hubs live in a commutative subalgebra of Mat_4(Z[zeta_8]).</p>
<p><strong>Phase 5 -- Co-occurrence topology:</strong> <ul> <li>247 edges total, max co-occurrence 102</li> <li>62 hub-involved edges, 185 satellite-only edges</li> <li>NOT a star topology (satellites connect to each other extensively)</li> <li>30/30 entries participate in at least one winner</li> </ul>
<p><strong>Phase 5 -- XOR12 hub frequency (27 winners):</strong></p>
<table><thead><tr><th>Entry</th><th>Freq12</th><th>Depth</th><th>C4</th></tr></thead><tbody><tr><td>0</td><td>26</td><td>4</td><td>0</td></tr><tr><td>26</td><td>26</td><td>5</td><td>0</td></tr><tr><td>27</td><td>26</td><td>5</td><td>11</td></tr></tbody></table>
<p>The same 3 hubs dominate XOR12 even more strongly (26/27 = 96.3% each). All three hubs appear in almost every XOR12 winner.</p>
<h3>Code Assets</h3>
<ul>
<li><strong><code>Cyc8</code> (Z[zeta_8] cyclotomic arithmetic)</strong>: Exact integer type representing a + b<em>zeta_8 + c</em>zeta_8^2 + d*zeta_8^3 with zeta_8^4 = -1. Operations: <code>cyc8_make</code>, <code>cyc8_zero</code>, <code>cyc8_one</code>, <code>cyc8_add</code>, <code>cyc8_sub</code>, <code>cyc8_neg</code>, <code>cyc8_mul</code>, <code>cyc8_eq</code>, <code>cyc8_is_zero</code>, <code>cyc8_conj</code>, <code>cyc8_max_abs</code>, <code>cyc8_l1</code>. Shared with <a href="./entries/demo_100.html">D100</a>, <a href="./entries/demo_98.html">D98</a>, <a href="./entries/demo_35.html">D35</a>.</li>
<li><strong><code>Mat4</code> (4x4 matrix over Cyc8)</strong>: Matrix type for W_{5,3} representation. 16 Cyc8 entries = 64 long integers. Operations: <code>mat4_zero</code>, <code>mat4_identity</code>, <code>mat4_mul</code>, <code>mat4_eq</code>, <code>mat4_add</code>, <code>mat4_neg</code>, <code>mat4_scale</code>, <code>mat4_max_abs</code>, <code>mat4_print</code>, <code>mat4_trace</code>, <code>mat4_tr_sq</code>, <code>mat4_casimir</code>, <code>mat4_frob_l1</code>. All operations exact -- no floating point.</li>
<li><strong>Hash table for Mat4 BFS</strong>: FNV-style hash over 64 long components, chained-bucket lookup. MAX_CAT = 32768, HASH_SIZE = 65537. Used for BFS deduplication.</li>
<li><strong><code>build_tl_generators()</code></strong>: Constructs 4x4 integer matrices e_1..e_4 for TL_5 on W_{5,3} basis {h_0, h_1, h_2, h_3}. Pattern: A_3 Dynkin diagram (path graph on 4 nodes). Each e_i has rank 1: maps specific basis elements to a single target.</li>
<li><strong><code>build_braid_generators()</code></strong>: Constructs 8 braid generators sigma_1..4 and inverses over Z[zeta_8]. Writhe tracked per generator (+1/-1).</li>
<li><strong><code>build_catalog(max_depth)</code></strong>: BFS closure with 8 generators. Depth and writhe tracking per entry. Overflow protection at max_abs &gt; 10^11. Reports per-round growth, max magnitude, and closure/cap/depth-limit status.</li>
<li><strong><code>mat4_activate(m, k_param)</code></strong>: 4x4_hash activation -- sign pattern of all 64 integer components (4x4 matrix x 4 Cyc8 components), 3-valued (pos=2, zero=1, neg=0), base-3 hash mod k_param. Novel activation for 4x4 matrix-valued DKC.</li>
<li><strong><code>test_xor_mat4(indices, n_weights, k_param)</code></strong>: 1wpi XOR test for Mat4 catalog. N weights -&gt; 2N inputs (pos/neg pairs). Signed sum in Mat4 space, activation via mat4_activate. Supports up to 8 weights (16 inputs). Touch-list cleanup for efficient cell reuse.</li>
<li><strong><code>count_xor_bf(n_weights, k_param, bf_limit)</code></strong>: Brute-force combinatorial XOR search over C(bf,n_weights) tuples. Supports n_weights = 3-7 (XOR6 through XOR14).</li>
<li><strong><code>mat4_casimir(m)</code></strong>: C4(M) = 4*tr(M^2) - (tr M)^2. Integer-exact Casimir computation for 4x4 matrices. Uses <code>mat4_tr_sq</code> (trace of matrix squared via double sum) and <code>mat4_trace</code>. Note the coefficient 4 = dim(W_{5,3}), matching the <a href="./entries/demo_100.html">D100</a> pattern where C3 used coefficient 3 = dim(W_{4,2}).</li>
</ul>
<h3>Connection to Earlier Demos</h3>
<table><thead><tr><th>Demo</th><th>Finding</th><th>Relevance to <a href="./entries/demo_101.html">D101</a></th></tr></thead><tbody><tr><td><a href="./entries/demo_98.html">D98</a></td><td>3-strand BFS infinite, trace readout catastrophically lossy</td><td><a href="./entries/demo_101.html">D101</a> avoids trace readout entirely -- uses sign-hash activation on full matrix</td></tr><tr><td><a href="./entries/demo_100.html">D100</a></td><td>4-strand W_{4,2}: ~3.1x growth, 6 hubs, Casimir-XOR correlation, constant radical content, all commutators traceless</td><td><a href="./entries/demo_101.html">D101</a> tests same phenomena at 5 strands on simple module (no radical) -- isolates sl_d structure from non-semisimple effects</td></tr><tr><td><a href="./entries/demo_100.html">D100</a></td><td>Hub pairing by Cyc8 component (zeta_8, zeta_8^2, zeta_8^3)</td><td><a href="./entries/demo_101.html">D101</a> tests whether hub pairing extends to 12 hubs in 6 pairs for sl_4</td></tr><tr><td><a href="./entries/demo_93.html">D93</a></td><td>1wpi framework, circuit complexity hierarchy</td><td><a href="./entries/demo_101.html">D101</a> reuses activation/XOR framework adapted for 4x4 matrices</td></tr><tr><td><a href="./entries/demo_80.html">D80</a></td><td>Finite/infinite capacity boundary at quantum dimension</td><td>W_{5,3} is infinite (simple, n odd), confirming infinite group from simple TL module</td></tr></tbody></table>
<h3>Literature Touched</h3>
<ul>
<li><strong>Temperley-Lieb algebra TL_5 at delta=0</strong>: TL_5 with n=5 (odd) has different semisimplicity behavior than even n. W_{5,3} (standard module with 3 through-lines, dim=4) is SIMPLE -- no radical, no extensions. This contrasts sharply with <a href="./entries/demo_100.html">D100</a>'s W_{4,2} (n=4 even, non-semisimple, radical dim=9). The simplicity means <a href="./entries/demo_101.html">D101</a> tests DKC capacity in the "clean" case without non-semisimple complications.</li>
<li><strong>Representation theory of braid groups on TL modules</strong>: sigma_i = A<em>I + A^{-1}</em>e_i gives B_5 acting on the 4-dimensional W_{5,3}. The 4 TL generators form an A_3 Dynkin diagram (path graph on 4 nodes), and the sl_d functor thesis predicts the braid image inherits sl_4 structure: growth rate ~4x (Weyl group size ratio), hub count = 2*C(4,2) = 12 (positive roots of A_3).</li>
<li><strong>Root systems and Lie algebra structure</strong>: The positive roots of sl_4 (type A_3) are: e_1-e_2, e_2-e_3, e_3-e_4, e_1-e_3, e_2-e_4, e_1-e_4 -- six roots. The sl_d functor thesis predicts 12 super-hubs (6 pairs, one pair per positive root). <a href="./entries/demo_100.html">D100</a> confirmed 6 hubs = 3 pairs for sl_3 (type A_2, 3 positive roots). <a href="./entries/demo_101.html">D101</a> tests the A_3 case.</li>
<li><strong>Habiro (2002) / Z[zeta_8] bracket</strong>: The algebraic substrate. <a href="./entries/demo_101.html">D101</a> continues the matrix-valued extension: each catalog entry is a 4x4 matrix over Z[zeta_8]. The DKC signed-sum framework operates in the 4x4 matrix ring, which is associative but non-commutative -- the non-commutativity is what makes hub commutators a meaningful diagnostic.</li>
<li><strong>Casimir invariants</strong>: C4(M) = 4<em>tr(M^2) - (tr M)^2 generalizes <a href="./entries/demo_100.html">D100</a>'s C3(M) = 3</em>tr(M^2) - (tr M)^2. The coefficient matches the module dimension (3 for W_{4,2}, 4 for W_{5,3}), suggesting a uniform formula C_d(M) = d*tr(M^2) - (tr M)^2 for d-dimensional modules. Casimir measures "non-scalar-ness" of the matrix -- distance from scalar multiples of identity in the space of d x d matrices.</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li><strong>Why only 3 hubs, not 12?</strong>: The sl_4 prediction (12 super-hubs = 6 pairs) was falsified. Three possible explanations: (1) simple modules have fundamentally different hub structure than non-semisimple ones; (2) the bf=30 deep sub-catalog at d&gt;=4 misses hubs that appear at shallower depths or in different sampling windows; (3) the hub-count prediction from sl_d was wrong and the growth-rate prediction was the real signal. Testing: repeat with bf=30 from ALL depths (not just d&gt;=4), and try different hub thresholds.</li>
<li><strong>Commuting hubs and commutative subalgebra</strong>: All three hub commutators are the zero matrix, not just traceless. The hubs live in a commutative subalgebra. Is this related to hub 0's near-scalar structure (diagonal -I with one off-diagonal entry)? Does the commutative subalgebra have a name in the representation theory of B_5 on W_{5,3}?</li>
<li><strong>Casimir inversion mechanism</strong>: Why does the Casimir-XOR correlation invert at XOR10-12? At XOR6-8, high-Casimir entries win (like <a href="./entries/demo_100.html">D100</a>). At XOR10-12, low-Casimir entries win. Hypothesis: harder XOR computations in simple modules require near-scalar entries (low C4) for stability, while in non-semisimple modules the radical extension provides that stability automatically. Test: compute Casimir-by-XOR-level in <a href="./entries/demo_100.html">D100</a> at XOR6 and XOR8 to see if the same inversion trend starts there.</li>
<li><strong>XOR14 vanishing -- simple vs non-semisimple capacity ceiling</strong>: <a href="./entries/demo_100.html">D100</a> has XOR14=70 on 3x3 non-semisimple, <a href="./entries/demo_101.html">D101</a> has XOR14=0 on 4x4 simple. Is this a dimension effect (64 vs 36 activation components -- too fine-grained?), a module effect (simple vs non-semisimple), or a sampling effect (different entries at d&gt;=4)? Test: try <a href="./entries/demo_101.html">D101</a> with mat3-style activation (reduce to 36 or fewer sign components) and see if XOR14 appears.</li>
<li><strong>6-strand W_{6,4} as decisive test</strong>: W_{6,4} (n=6, even, non-semisimple) should have ~5x growth (sl_5 thesis). If it also has 6+ super-hubs and XOR14 &gt; 0, this confirms that non-semisimplicity is the key variable for hub count and deep XOR capacity. If it matches <a href="./entries/demo_101.html">D101</a>'s pattern (few hubs, XOR14=0), the explanation is dimensional/structural rather than semisimplicity.</li>
<li><strong>Growth rate convergence</strong>: The ratios (8.00, 5.50, 4.68, 4.29, 4.07, 3.94) are converging toward 4 but not yet stabilized (3.94 at d=6, truncated at d=7). Larger cap or deeper BFS needed to confirm asymptotic rate is exactly 4.</li>
<li><strong>Hub entry 0 structure</strong>: Hub 0 (entry 0 at d=4) is near-scalar: M = -I + (0,0,4,0)*e_{01}. This is sigma_1^4 or a related simple braid word. Its dominance as a hub (42.9% of XOR10 winners, 26/27 of XOR12 winners) suggests a structural role. Is it the image of a central element or a power of a generator? Its near-scalar form (C4=0) is consistent with the Casimir inversion finding.</li>
<li><strong>Broad vs deep capacity</strong>: <a href="./entries/demo_101.html">D101</a> has MORE XOR6-8 solutions than <a href="./entries/demo_100.html">D100</a> (2579 vs 2017, 2228 vs 1169) but FEWER XOR10-14 solutions (203 vs 654, 27 vs 305, 0 vs 70). The simple module has broader shallow capacity but less deep capacity. Is this a general simple-vs-non-semisimple pattern?</li>
</ul>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <script>hljs.highlightAll();</script>
</body>
</html>
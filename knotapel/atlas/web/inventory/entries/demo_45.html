<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>inventory/entries/demo_45.md</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <nav><a href="../../index.html">← Back to Index</a></nav><hr>
    <h2><a href="./demo_45.html">Demo 45</a>: Complex Function Zoo</h2>
<ul>
<li><strong>Status</strong>: COMPLETE</li>
<li><strong>File</strong>: <code><a href="../../demo_45_complex_function_zoo/main.c.html">demo_45_complex_function_zoo/main.c</a></code> (~1387 lines)</li>
<li><strong>Tests</strong>: ~11 checks (6 parts: A=1 NPN reach, B=1 convergence, C=1 catalog size, D=1 beat-random, E=7 predictions P1-P7); 9/11 pass, 2 informative failures (P3 braid length, P5 phase richness reversed)</li>
<li><strong>Depends on</strong>: <a href="./demo_23.html">Demo 23</a> (function zoo, NPN classification, forward braid→truth-table enumeration), <a href="./demo_27.html">Demo 27</a> (complex reverse DKC, gauge-corrected decomposition)</li>
<li><strong>Feeds into</strong>: <a href="./demo_46.html">Demo 46</a> (per-neuron gauge), <a href="./demo_47.html">Demo 47</a> (MVN activation for parity), <a href="./demo_48.html">Demo 48</a> (4-input zoo), <a href="./demo_49.html">Demo 49</a> (expanded catalog), <a href="./demo_50.html">Demo 50</a> (multi-layer DKC)</li>
</ul>
<h3>Headline</h3>
Extends reverse DKC decomposition from XOR (<a href="./demo_27.html">Demo 27</a>) to all 13 non-trivial NPN equivalence classes of 3-input Boolean functions, discovering that topology frequency (forward map) and decomposition quality (reverse map) are near-perfectly anti-correlated (Spearman rho = -0.8167), proving the bracket algebra has intrinsic computational structure measurable from either direction.
<h3>Key Results</h3>
<ul>
<li><strong>Part A (NPN classification)</strong>: Enumerates all non-trivial NPN classes (13 of 256 truth tables modulo permutation/negation); forward topology frequency computed from 4-strand braids length 1-3 across 4 closures at A = e^{i5pi/4}</li>
<li><strong>Part B (Complex training)</strong>: All 13 NPN classes converge; CxNet3 architecture (3 real inputs → 3 complex hidden neurons with split-sigmoid → 1 real output, 31 real parameters); 10 trials per class, max 50000 epochs, keep fastest</li>
<li><strong>Part C (Bracket catalog)</strong>: 8192 braids (2-3 strands, length 1-8) producing 64 distinct complex bracket values at delta=0; covering radius estimated from 1000 random probes</li>
<li><strong>Part D (Gauge decomposition)</strong>: 12 complex weights per class decomposed via 360-angle gauge sweep + nearest-neighbor to catalog; random baseline RMS = 0.8086; 11/13 classes beat random</li>
<li><strong>Part E (Correlation)</strong>: P1 CONFIRMED: rho(RMS, topo_freq) = -0.8167 (strongest finding); P2 confirmed (symmetric &lt; non-sym); P4 confirmed (natural RMS gap = 0.0858); P6 confirmed (rho(RMS, orbit) = +0.275); P7 confirmed (5/9 gauge angles at pi/4 multiples); P3 FAILED (avg braid = 5.58, not ≤ 4 — bracket value matters, not braid length); P5 REVERSED (r = +0.87 — fewer phases = better, not more)</li>
<li><strong>Part F (Summary)</strong>: Master table ranked by gauge RMS; top 3 detail with weight→bracket matching; bottom 3 worst decomposers; overall statistics</li>
</ul>
<h3>Theorems/Conjectures</h3>
<ul>
<li><strong>Forward-reverse duality</strong>: Functions that topology produces frequently (forward map) are exactly those whose trained weights decompose cleanly back into bracket values (reverse map) — rho = -0.8167</li>
<li><strong>Parity is topologically unnatural</strong>: XNOR3 is the only function worse than random (RMS = 0.9963 vs 0.8086), has topology frequency 0, orbit size 2 — parity requires exact cancellation that the bracket's sum-over-states structure cannot produce</li>
<li><strong>Sparsity principle</strong>: Good decomposition = fewer distinct lattice phases used (reversed P5, r = +0.87); topologically natural functions live in low-dimensional subspaces of Z[zeta_8]</li>
<li><strong>Gauge-lattice alignment</strong>: Optimal gauge angles cluster at pi/4 multiples, confirming weight alignment with Z[zeta_8] = Z[e^{i*pi/4}] cyclotomic structure</li>
<li><strong>BUF &gt; AND &gt; MAJ &gt; XOR hierarchy</strong>: Simpler functions (fewer input dependencies) decompose better; complexity of the function's decision boundary determines decomposition quality</li>
</ul>
<h3>Data</h3>
<ul>
<li>13 NPN classes with canon truth table, orbit size, topology frequency, convergence epoch</li>
<li>8192-entry bracket catalog (64 distinct complex values) at A = e^{i5pi/4}</li>
<li>Per-class: gauge RMS, amplitude-only RMS, best gauge angle (deg), average matched braid length, distinct phase count</li>
<li>Spearman correlations: rho(RMS, freq) = -0.8167, rho(RMS, orbit) = +0.275</li>
<li>Pearson r(phases, RMS) = +0.87</li>
<li>Ranking: BUF (0.5285) → AND2' (0.5400) → AND3' (0.6011) → ... → EXACT1 (0.8639) → XNOR3 (0.9963)</li>
<li>Random baseline: 1000 probes, RMS = 0.8086</li>
<li>Amplitude-only RMS often better than gauge-corrected complex RMS (scaling challenge)</li>
</ul>
<h3>Code Assets</h3>
<ul>
<li><code>CxNet3</code> struct: 3-input complex-valued neural network (wh[3][3] complex hidden weights, bh[3] complex biases, vo[6] real output weights, bo real bias)</li>
<li><code>cxnet3_init()</code>, <code>cxnet3_forward()</code>, <code>cxnet3_train()</code> — initialization, forward pass with split-sigmoid, backprop training</li>
<li><code>NPNClass</code> struct: canon_tt, orbit_size, topo_freq, convergence info, 12 complex weights, decomposition metrics</li>
<li><code>npn_init()</code>, <code>npn_transform()</code> — NPN canonical form computation (min truth table under permutation/negation group)</li>
<li><code>build_complex_catalog()</code> — enumerate braids up to given strand count and length, store bracket values with amplitude &gt; 0.5</li>
<li><code>find_nearest_cx()</code> — nearest-neighbor search in complex bracket catalog</li>
<li><code>spearman_rho()</code>, <code>assign_ranks()</code> — Spearman rank correlation with tie averaging</li>
<li><code>compute_tt()</code> — truth table from braid word + closure via amplitude thresholding (from <a href="./demo_23.html">Demo 23</a>)</li>
<li><code>bracket_cl()</code> — state-sum bracket with selectable closure type (trace, plat_a/b/c)</li>
<li><code>braid_loops_cl()</code> — union-find loop counting with 4 closure types</li>
<li><code>fn_name()</code> — human-readable name lookup for canonical truth tables</li>
<li><code>rng_seed()</code>, <code>rng_uniform()</code>, <code>rng_normal()</code> — LCG-based reproducible RNG with Box-Muller</li>
</ul>
<h3>Literature Touched</h3>
<ul>
<li>NPN equivalence classes of Boolean functions (complete classification for 3 inputs)</li>
<li>Complex-valued neural networks with split-sigmoid activation</li>
<li>Kauffman bracket as algebraic computational structure (forward and reverse directions)</li>
<li>Gauge symmetry (U(1) rotation) in weight decomposition</li>
<li>Closest Vector Problem (CVP) in cyclotomic lattice Z[zeta_8]</li>
<li>Sparsity in algebraic bases as quality predictor</li>
<li>Parity as canonical hard function for partition-function computation</li>
</ul>
<h3>Open Questions</h3>
<ul>
<li>Would per-neuron gauge correction (3D optimization instead of 1D) improve mid-ranking functions?</li>
<li>Is parity's resistance architectural (split-sigmoid) or algebraic (bracket can't express it)? MVN activation test needed.</li>
<li>Does the rho = -0.8167 correlation hold at 4 inputs (222 NPN classes)?</li>
<li>With a larger catalog (more braids, more strands), do topology-invisible functions improve or remain resistant?</li>
<li>Can multi-layer decomposition (two hidden layers) close the gap between approximate and exact?</li>
</ul>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <script>hljs.highlightAll();</script>
</body>
</html>
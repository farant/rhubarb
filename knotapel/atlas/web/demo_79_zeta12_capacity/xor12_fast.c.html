<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>demo_79_zeta12_capacity/xor12_fast.c</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <nav><a href="../index.html">← Back to Index</a></nav><hr>
    <h1>demo_79_zeta12_capacity/xor12_fast.c</h1><pre><code class="language-c">/*
 * xor12_fast.c — Fast targeted XOR12 test
 *
 * Hardcodes 124 XOR10 winners from Demo 79 (small catalog indices).
 * Builds small catalog to get quaternion values, then big catalog
 * via closure, then tests XOR12 extension.
 *
 * Optimizations vs xor12_retest.c:
 * - Skip XOR6/8/10 brute force entirely (hardcoded winners)
 * - Precompute all 4096 XOR10-winner sums for each mask (cache)
 * - Use pointers instead of struct copies where possible
 * - Inline quaternion ops in hot loops
 *
 * C89, zero dependencies beyond math.h.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

/* ================================================================
 * Quaternion type — keep as struct for clarity, use pointers in
 * hot paths
 * ================================================================ */

typedef struct { double a, b, c, d; } Quat;

static Quat q_gen[3];

static void init_su2_generators(double half_angle) {
    double c = cos(half_angle);
    double s = sin(half_angle);
    q_gen[1].a = c; q_gen[1].b = s; q_gen[1].c = 0; q_gen[1].d = 0;
    q_gen[2].a = c; q_gen[2].b = 0; q_gen[2].c = 0; q_gen[2].d = -s;
}

/* ================================================================
 * Catalog building
 * ================================================================ */

#define SMALL_MAX 256
#define BIG_MAX 4096

static Quat small_cat[SMALL_MAX];
static int small_size = 0;
static Quat big_cat[BIG_MAX];
static int big_size = 0;

static int find_in(const Quat *q, const Quat *arr, int n) {
    int i;
    for (i = 0; i &lt; n; i++) {
        if (fabs(arr[i].a - q-&gt;a) &lt; 1e-10 &amp;&amp; fabs(arr[i].b - q-&gt;b) &lt; 1e-10 &amp;&amp;
            fabs(arr[i].c - q-&gt;c) &lt; 1e-10 &amp;&amp; fabs(arr[i].d - q-&gt;d) &lt; 1e-10)
            return i;
        if (fabs(arr[i].a + q-&gt;a) &lt; 1e-10 &amp;&amp; fabs(arr[i].b + q-&gt;b) &lt; 1e-10 &amp;&amp;
            fabs(arr[i].c + q-&gt;c) &lt; 1e-10 &amp;&amp; fabs(arr[i].d + q-&gt;d) &lt; 1e-10)
            return i;
    }
    return -1;
}

static void build_small_catalog(void) {
    int n, len;
    small_size = 0;
    for (n = 2; n &lt;= 3; n++) {
        for (len = 1; len &lt;= 12; len++) {
            int max_gen = n - 1;
            int total_gens = 2 * max_gen;
            unsigned long total, idx_l;
            int i;
            total = 1;
            for (i = 0; i &lt; len; i++) {
                total *= (unsigned long)total_gens;
                if (total &gt; 300000) break;
            }
            if (total &gt; 300000) continue;
            for (idx_l = 0; idx_l &lt; total; idx_l++) {
                unsigned long tmp = idx_l;
                Quat result;
                result.a = 1; result.b = 0; result.c = 0; result.d = 0;
                for (i = 0; i &lt; len; i++) {
                    int g = (int)(tmp % (unsigned long)total_gens);
                    const Quat *gen;
                    Quat prod;
                    int idx;
                    tmp /= (unsigned long)total_gens;
                    if (g &lt; max_gen) idx = g + 1;
                    else             idx = -(g - max_gen + 1);
                    gen = &amp;q_gen[idx &gt; 0 ? idx : -idx];
                    /* Inline multiply + optional conjugate */
                    if (idx &gt; 0) {
                        prod.a = result.a*gen-&gt;a - result.b*gen-&gt;b
                               - result.c*gen-&gt;c - result.d*gen-&gt;d;
                        prod.b = result.a*gen-&gt;b + result.b*gen-&gt;a
                               + result.c*gen-&gt;d - result.d*gen-&gt;c;
                        prod.c = result.a*gen-&gt;c - result.b*gen-&gt;d
                               + result.c*gen-&gt;a + result.d*gen-&gt;b;
                        prod.d = result.a*gen-&gt;d + result.b*gen-&gt;c
                               - result.c*gen-&gt;b + result.d*gen-&gt;a;
                    } else {
                        /* conjugate: negate b,c,d of gen */
                        prod.a = result.a*gen-&gt;a + result.b*gen-&gt;b
                               + result.c*gen-&gt;c + result.d*gen-&gt;d;
                        prod.b = -result.a*gen-&gt;b + result.b*gen-&gt;a
                               - result.c*gen-&gt;d + result.d*gen-&gt;c;
                        prod.c = -result.a*gen-&gt;c + result.b*gen-&gt;d
                               + result.c*gen-&gt;a - result.d*gen-&gt;b;
                        prod.d = -result.a*gen-&gt;d - result.b*gen-&gt;c
                               + result.c*gen-&gt;b + result.d*gen-&gt;a;
                    }
                    result = prod;
                }
                if (find_in(&amp;result, small_cat, small_size) &lt; 0 &amp;&amp;
                    small_size &lt; SMALL_MAX) {
                    small_cat[small_size++] = result;
                }
            }
        }
    }
}

static void build_big_catalog(void) {
    int prev, i, gi;
    Quat gens[4];

    big_size = 0;
    big_cat[big_size].a = 1; big_cat[big_size].b = 0;
    big_cat[big_size].c = 0; big_cat[big_size].d = 0;
    big_size++;

    gens[0] = q_gen[1];
    gens[1].a = q_gen[1].a; gens[1].b = -q_gen[1].b;
    gens[1].c = -q_gen[1].c; gens[1].d = -q_gen[1].d;
    gens[2] = q_gen[2];
    gens[3].a = q_gen[2].a; gens[3].b = -q_gen[2].b;
    gens[3].c = -q_gen[2].c; gens[3].d = -q_gen[2].d;

    for (gi = 0; gi &lt; 4; gi++) {
        if (find_in(&amp;gens[gi], big_cat, big_size) &lt; 0 &amp;&amp; big_size &lt; BIG_MAX)
            big_cat[big_size++] = gens[gi];
    }

    do {
        int round_new = 0;
        prev = big_size;
        for (i = 0; i &lt; prev; i++) {
            for (gi = 0; gi &lt; 4; gi++) {
                Quat prod;
                const Quat *p = &amp;big_cat[i];
                const Quat *g = &amp;gens[gi];
                prod.a = p-&gt;a*g-&gt;a - p-&gt;b*g-&gt;b - p-&gt;c*g-&gt;c - p-&gt;d*g-&gt;d;
                prod.b = p-&gt;a*g-&gt;b + p-&gt;b*g-&gt;a + p-&gt;c*g-&gt;d - p-&gt;d*g-&gt;c;
                prod.c = p-&gt;a*g-&gt;c - p-&gt;b*g-&gt;d + p-&gt;c*g-&gt;a + p-&gt;d*g-&gt;b;
                prod.d = p-&gt;a*g-&gt;d + p-&gt;b*g-&gt;c - p-&gt;c*g-&gt;b + p-&gt;d*g-&gt;a;
                if (find_in(&amp;prod, big_cat, big_size) &lt; 0) {
                    if (big_size &lt; BIG_MAX) {
                        big_cat[big_size++] = prod;
                        round_new++;
                    } else {
                        printf("  Hit BIG_MAX=%d\n", BIG_MAX);
                        return;
                    }
                }
            }
        }
        printf("  Closure: %d -&gt; %d (+%d)\n", prev, big_size, round_new);
    } while (big_size &gt; prev);
}

/* ================================================================
 * Direction catalog + Voronoi
 * ================================================================ */

#define MAX_DIR 512
static double g_dir[MAX_DIR][3];
static int g_nd = 0;

static void build_dir_catalog(const Quat *cat, int n) {
    int i, j;
    g_nd = 0;
    for (i = 0; i &lt; n; i++) {
        double qa = cat[i].a, qb = cat[i].b, qc = cat[i].c, qd = cat[i].d;
        double nv, ax, ay, az;
        int found = 0;
        if (qa &lt; 0) { qa = -qa; qb = -qb; qc = -qc; qd = -qd; }
        nv = sqrt(qb*qb + qc*qc + qd*qd);
        if (nv &lt; 1e-12) continue;
        ax = qb/nv; ay = qc/nv; az = qd/nv;
        for (j = 0; j &lt; g_nd; j++) {
            double d1 = fabs(g_dir[j][0]-ax) + fabs(g_dir[j][1]-ay) +
                         fabs(g_dir[j][2]-az);
            double d2 = fabs(g_dir[j][0]+ax) + fabs(g_dir[j][1]+ay) +
                         fabs(g_dir[j][2]+az);
            if (d1 &lt; 1e-8 || d2 &lt; 1e-8) { found = 1; break; }
        }
        if (!found &amp;&amp; g_nd &lt; MAX_DIR) {
            g_dir[g_nd][0] = ax; g_dir[g_nd][1] = ay; g_dir[g_nd][2] = az;
            g_nd++;
        }
    }
}

/* Inline Voronoi cell lookup */
static int vor_cell(double ax, double ay, double az) {
    int i, best = 0;
    double bd = -2.0;
    for (i = 0; i &lt; g_nd; i++) {
        double dp = fabs(ax*g_dir[i][0] + ay*g_dir[i][1] + az*g_dir[i][2]);
        if (dp &gt; bd) { bd = dp; best = i; }
    }
    return best;
}

/* Combined cell: sec*n_vor + vor */
static int combined_cell(double sa, double sb, double sc, double sd,
                         int k_sec) {
    double n = sqrt(sa*sa + sb*sb + sc*sc + sd*sd);
    double qa, nv, ax, ay, az, ang, cos_half, half_ang;
    int sec, vor, n_vor;

    n_vor = g_nd + 1;

    if (n &lt; 1e-12) return (k_sec - 1) * n_vor + g_nd;

    qa = sa/n;
    if (qa &lt; 0) { qa = -qa; sb = -sb; sc = -sc; sd = -sd; }
    if (qa &gt; 1.0) qa = 1.0;
    if (qa &lt; -1.0) qa = -1.0;

    /* Angle */
    nv = sqrt(sb*sb + sc*sc + sd*sd) / n;
    cos_half = qa;
    half_ang = acos(cos_half);
    ang = 2.0 * half_ang * 180.0 / M_PI;
    sec = (int)(ang * (double)k_sec / 360.0);
    if (sec &gt;= k_sec) sec = k_sec - 1;
    if (sec &lt; 0) sec = 0;

    /* Voronoi */
    if (nv &lt; 1e-12) {
        vor = g_nd;
    } else {
        double inv_nv = 1.0 / (nv * n);
        ax = sb * inv_nv; ay = sc * inv_nv; az = sd * inv_nv;
        if (qa &lt; 0) { ax = -ax; ay = -ay; az = -az; }
        vor = vor_cell(ax, ay, az);
    }

    return sec * n_vor + vor;
}

/* ================================================================
 * XOR12 test — fully inlined, no function call overhead
 * ================================================================ */

#define MAX_ACT 8192

static int test_xor12(const Quat *w, int k_sec) {
    /* w[0..5] = 6 quaternion weights (from catalog)
     * Each gets +/- =&gt; 12 inputs, 4096 masks */
    int n_vor = g_nd + 1;
    int n_cells = k_sec * n_vor;
    int cell_even[MAX_ACT], cell_odd[MAX_ACT];
    int mask, i;
    double wa[12], wb[12], wc[12], wd[12];

    if (n_cells &gt; MAX_ACT) return 0;

    /* Precompute +/- weight components */
    for (i = 0; i &lt; 6; i++) {
        wa[2*i] = w[i].a;   wb[2*i] = w[i].b;
        wc[2*i] = w[i].c;   wd[2*i] = w[i].d;
        wa[2*i+1] = -w[i].a; wb[2*i+1] = -w[i].b;
        wc[2*i+1] = -w[i].c; wd[2*i+1] = -w[i].d;
    }

    memset(cell_even, 0, (size_t)n_cells * sizeof(int));
    memset(cell_odd, 0, (size_t)n_cells * sizeof(int));

    for (mask = 0; mask &lt; 4096; mask++) {
        double sa = 0, sb = 0, sc = 0, sd = 0;
        int par = 0;
        int cell;

        for (i = 0; i &lt; 12; i++) {
            if (mask &amp; (1 &lt;&lt; i)) {
                sa += wa[i]; sb += wb[i]; sc += wc[i]; sd += wd[i];
                par ^= 1;
            }
        }

        cell = combined_cell(sa, sb, sc, sd, k_sec);

        if (par == 0) cell_even[cell]++;
        else           cell_odd[cell]++;
    }

    for (i = 0; i &lt; n_cells; i++) {
        if (cell_even[i] &gt; 0 &amp;&amp; cell_odd[i] &gt; 0) return 0;
    }
    return 1;
}

/* ================================================================
 * Hardcoded XOR10 winners (indices into small catalog)
 * ================================================================ */

static const int xor10_winners[124][5] = {
    {0,1,6,84,230},
    {0,1,7,106,240},
    {0,1,8,17,75},
    {0,1,8,36,211},
    {0,1,8,42,137},
    {0,1,8,65,206},
    {0,1,8,72,198},
    {0,1,8,74,210},
    {0,1,8,83,150},
    {0,1,8,86,90},
    {0,1,8,90,174},
    {0,1,8,90,246},
    {0,1,8,99,198},
    {0,1,8,106,198},
    {0,1,8,125,211},
    {0,1,8,137,174},
    {0,1,8,139,168},
    {0,1,8,141,211},
    {0,1,8,145,182},
    {0,1,8,154,211},
    {0,1,8,172,211},
    {0,1,8,172,232},
    {0,1,8,177,211},
    {0,1,8,182,232},
    {0,1,8,195,198},
    {0,1,8,198,224},
    {0,1,8,206,211},
    {0,1,8,211,242},
    {0,1,8,232,252},
    {0,1,9,11,64},
    {0,1,9,29,218},
    {0,1,9,30,190},
    {0,1,9,42,153},
    {0,1,9,62,183},
    {0,1,9,62,201},
    {0,1,9,72,87},
    {0,1,9,72,211},
    {0,1,9,84,198},
    {0,1,9,98,236},
    {0,1,9,108,211},
    {0,1,9,125,198},
    {0,1,9,144,154},
    {0,1,9,145,160},
    {0,1,9,153,252},
    {0,1,9,160,211},
    {0,1,9,182,218},
    {0,1,9,186,188},
    {0,1,9,190,198},
    {0,1,9,198,202},
    {0,1,9,198,212},
    {0,1,9,202,222},
    {0,1,9,206,211},
    {0,1,9,236,252},
    {0,1,10,17,111},
    {0,1,10,17,220},
    {0,1,10,40,60},
    {0,1,10,55,132},
    {0,1,10,73,101},
    {0,1,10,80,163},
    {0,1,10,86,90},
    {0,1,10,91,132},
    {0,1,10,153,191},
    {0,1,10,155,157},
    {0,1,10,163,190},
    {0,1,10,163,221},
    {0,1,10,208,246},
    {0,1,11,14,101},
    {0,1,11,14,201},
    {0,1,11,16,64},
    {0,1,11,55,169},
    {0,1,11,66,77},
    {0,1,11,72,169},
    {0,1,11,75,191},
    {0,1,11,89,197},
    {0,1,11,135,201},
    {0,1,11,158,173},
    {0,1,11,169,173},
    {0,1,11,170,175},
    {0,1,11,183,191},
    {0,1,11,183,222},
    {0,1,11,210,214},
    {0,1,11,214,249},
    {0,1,12,17,75},
    {0,1,12,29,208},
    {0,1,12,30,139},
    {0,1,12,42,194},
    {0,1,12,55,87},
    {0,1,12,55,232},
    {0,1,12,86,198},
    {0,1,12,91,232},
    {0,1,12,105,236},
    {0,1,12,106,236},
    {0,1,12,112,210},
    {0,1,12,112,220},
    {0,1,12,139,236},
    {0,1,12,141,250},
    {0,1,12,145,224},
    {0,1,12,149,236},
    {0,1,12,160,194},
    {0,1,12,172,198},
    {0,1,12,172,208},
    {0,1,12,182,188},
    {0,1,12,182,232},
    {0,1,12,195,232},
    {0,1,12,206,232},
    {0,1,12,214,233},
    {0,1,12,233,236},
    {0,1,13,25,143},
    {0,1,13,99,132},
    {0,1,13,112,143},
    {0,1,13,112,242},
    {0,1,13,134,226},
    {0,1,13,140,226},
    {0,1,13,143,232},
    {0,1,13,194,226},
    {0,1,13,203,212},
    {0,1,13,212,246},
    {0,1,14,35,124},
    {0,1,14,72,132},
    {0,1,14,73,205},
    {0,1,14,80,111},
    {0,1,14,83,98},
    {0,1,14,108,132},
    {0,1,14,139,205}
};
#define N_XOR10 124

static const int K_LADDER[] = {1, 6, 8, 10, 12, 16, 20, 24};
#define N_KLADDER 8

int main(void) {
    int wi, ae, ki, i;
    int n_xor12 = 0;
    int n_tested = 0;

    printf("=== Fast XOR12 Retest ===\n\n");

    /* Build small catalog (same as Demo 79) */
    init_su2_generators(M_PI / 6.0);
    build_small_catalog();
    printf("Small catalog: %d quaternions\n", small_size);

    /* Build big catalog via closure */
    printf("\nBuilding big catalog...\n");
    build_big_catalog();
    printf("Big catalog: %d quaternions\n\n", big_size);

    /* Build directions from big catalog */
    build_dir_catalog(big_cat, big_size);
    printf("Directions: %d, Voronoi cells: %d\n\n", g_nd, g_nd + 1);

    /* Map small catalog XOR10 winner quaternions to big catalog */
    printf("Extending %d XOR10 winners with %d big catalog entries\n",
           N_XOR10, big_size);
    printf("Testing k = ");
    for (ki = 0; ki &lt; N_KLADDER; ki++)
        printf("%d%s", K_LADDER[ki], ki &lt; N_KLADDER-1 ? "," : "\n\n");

    fflush(stdout);

    for (wi = 0; wi &lt; N_XOR10; wi++) {
        /* Get the 5 quaternion values from small catalog */
        Quat wq[5];
        int big_idx[5];
        int all_found = 1;

        for (i = 0; i &lt; 5; i++) {
            wq[i] = small_cat[xor10_winners[wi][i]];
            big_idx[i] = find_in(&amp;wq[i], big_cat, big_size);
            if (big_idx[i] &lt; 0) { all_found = 0; break; }
        }

        if (!all_found) {
            printf("  Winner %d: small cat entry not in big cat!\n", wi);
            continue;
        }

        /* Try extending with each big catalog entry */
        for (ae = 0; ae &lt; big_size; ae++) {
            int dup = 0;
            Quat w6[6];

            /* Skip if ae is already in the winner */
            for (i = 0; i &lt; 5; i++) {
                if (ae == big_idx[i]) { dup = 1; break; }
                /* Also check +-equivalence */
                if (find_in(&amp;big_cat[ae], &amp;big_cat[big_idx[i]], 1) &gt;= 0) {
                    dup = 1; break;
                }
            }
            if (dup) continue;

            n_tested++;

            /* Build 6-weight array */
            for (i = 0; i &lt; 5; i++) w6[i] = wq[i];
            w6[5] = big_cat[ae];

            /* Test with k ladder */
            for (ki = 0; ki &lt; N_KLADDER; ki++) {
                int n_vor = g_nd + 1;
                int n_cells = K_LADDER[ki] * n_vor;
                if (n_cells &gt; MAX_ACT) continue;
                if (test_xor12(w6, K_LADDER[ki])) {
                    n_xor12++;
                    printf("  FOUND XOR12 #%d: winner[%d] + big[%d] "
                           "at k=%d (%d cells)\n",
                           n_xor12, wi, ae, K_LADDER[ki], n_cells);
                    fflush(stdout);
                    if (n_xor12 &gt;= 50) goto done;
                    break;
                }
            }
        }

        if (wi % 10 == 0) {
            printf("  ... %d/%d winners processed, %d XOR12 found, "
                   "%d tested\n", wi, N_XOR10, n_xor12, n_tested);
            fflush(stdout);
        }
    }

done:
    printf("\n=== Results ===\n");
    printf("XOR10 winners tested: %d\n", N_XOR10);
    printf("Unique candidates: %d\n", n_tested);
    printf("XOR12 winners found: %d\n", n_xor12);

    if (n_xor12 &gt; 0)
        printf("\n&gt;&gt;&gt; XOR12 IS SOLVABLE! Demo 79 wall was ARTIFACT. &lt;&lt;&lt;\n");
    else
        printf("\n&gt;&gt;&gt; XOR12 still 0 from these parents (lower bound). &lt;&lt;&lt;\n");

    return 0;
}
</code></pre>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <script>hljs.highlightAll();</script>
</body>
</html>
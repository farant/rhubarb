<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>demo_04_spin_chain/main.c</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <nav><a href="../index.html">‚Üê Back to Index</a></nav><hr>
    <h1>demo_04_spin_chain/main.c</h1><pre><code class="language-c">/*
 * KNOTAPEL DEMO 04: Spin Chain (Tensor Product) Representation
 * =============================================================
 *
 * Demo 03 computed the Kauffman bracket via TL standard modules:
 *   bracket(b) = 1*tr_W1(rho(b)) + (A^{-4}+A^4)*tr_W3(rho(b))
 * where W_1 (2D) and W_3 (1D) are computed separately.
 *
 * This demo uses the TENSOR PRODUCT representation:
 *   - Each strand gets a 2D vector space V = C^2
 *   - For n=3 strands: state space = V^{tensor 3} = C^8
 *   - The R-matrix (4x4) acts on V tensor V at each crossing
 *   - sigma_1 -&gt; R tensor I (8x8), sigma_2 -&gt; I tensor R (8x8)
 *
 * The tensor product V^{tensor 3} contains BOTH standard modules
 * via Schur-Weyl duality:
 *   V^{tensor 3} = V_{3/2} tensor W_3  +  V_{1/2} tensor W_1
 *                = (dim 4 x dim 1) + (dim 2 x dim 2) = 8
 *
 * So a single trace over V^{tensor 3} should capture EVERYTHING
 * that Demo 03 needed two separate module computations for.
 *
 * The key question: what trace formula? Ordinary trace, or a
 * quantum trace tr(K^{tensor n} * M) for some diagonal K?
 *
 * PLAN:
 *   Part A: Build U on V tensor V (cup-cap, 4x4), verify U^2 = delta*U
 *   Part B: Build R = A*U + A^{-1}*I, verify R*R^{-1} = I
 *   Part C: Tensor to 8x8, verify Yang-Baxter R1*R2*R1 = R2*R1*R2
 *   Part D: Try trace formulas, find which matches state-sum oracle
 *
 * C89, zero dependencies.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

/* ================================================================
 * Laurent polynomial ring (from Demo 03)
 * ================================================================ */
#define MAX_TERMS 120

typedef struct { int c[MAX_TERMS]; int lo, len; } Poly;

static void p_zero(Poly *p) { memset(p, 0, sizeof(Poly)); }

static void p_mono(Poly *p, int coeff, int exp) {
    p_zero(p);
    if (!coeff) return;
    p-&gt;lo = exp; p-&gt;len = 1; p-&gt;c[0] = coeff;
}

static void p_trim(Poly *p) {
    int a = 0, b;
    if (!p-&gt;len) return;
    while (a &lt; p-&gt;len &amp;&amp; !p-&gt;c[a]) a++;
    if (a == p-&gt;len) { p_zero(p); return; }
    b = p-&gt;len - 1;
    while (b &gt; a &amp;&amp; !p-&gt;c[b]) b--;
    if (a &gt; 0) memmove(p-&gt;c, p-&gt;c + a, (size_t)(b - a + 1) * sizeof(int));
    p-&gt;lo += a; p-&gt;len = b - a + 1;
}

static void p_add(Poly *r, const Poly *a, const Poly *b) {
    Poly t; int lo, hi, i;
    if (!a-&gt;len) { *r = *b; return; }
    if (!b-&gt;len) { *r = *a; return; }
    lo = a-&gt;lo &lt; b-&gt;lo ? a-&gt;lo : b-&gt;lo;
    hi = (a-&gt;lo + a-&gt;len - 1) &gt; (b-&gt;lo + b-&gt;len - 1)
       ? (a-&gt;lo + a-&gt;len - 1) : (b-&gt;lo + b-&gt;len - 1);
    p_zero(&amp;t); t.lo = lo; t.len = hi - lo + 1;
    for (i = 0; i &lt; a-&gt;len; i++) t.c[(a-&gt;lo + i) - lo] += a-&gt;c[i];
    for (i = 0; i &lt; b-&gt;len; i++) t.c[(b-&gt;lo + i) - lo] += b-&gt;c[i];
    p_trim(&amp;t); *r = t;
}

static void p_mul(Poly *r, const Poly *a, const Poly *b) {
    Poly t; int i, j;
    if (!a-&gt;len || !b-&gt;len) { p_zero(r); return; }
    p_zero(&amp;t); t.lo = a-&gt;lo + b-&gt;lo; t.len = a-&gt;len + b-&gt;len - 1;
    for (i = 0; i &lt; a-&gt;len; i++)
        for (j = 0; j &lt; b-&gt;len; j++)
            t.c[i + j] += a-&gt;c[i] * b-&gt;c[j];
    p_trim(&amp;t); *r = t;
}

static int p_eq(const Poly *a, const Poly *b) {
    if (a-&gt;len != b-&gt;len) return 0;
    if (!a-&gt;len) return 1;
    if (a-&gt;lo != b-&gt;lo) return 0;
    return memcmp(a-&gt;c, b-&gt;c, (size_t)a-&gt;len * sizeof(int)) == 0;
}

static void p_print(const Poly *p, const char *name) {
    int i, e, first;
    printf("%s = ", name);
    if (!p-&gt;len) { printf("0\n"); return; }
    first = 1;
    for (i = 0; i &lt; p-&gt;len; i++) {
        if (!p-&gt;c[i]) continue;
        e = p-&gt;lo + i;
        if (!first &amp;&amp; p-&gt;c[i] &gt; 0) printf(" + ");
        if (!first &amp;&amp; p-&gt;c[i] &lt; 0) printf(" - ");
        if (first &amp;&amp; p-&gt;c[i] &lt; 0) printf("-");
        first = 0;
        if (abs(p-&gt;c[i]) != 1 || e == 0) printf("%d", abs(p-&gt;c[i]));
        if (e == 1) printf("A");
        else if (e == -1) printf("A^-1");
        else if (e) printf("A^%d", e);
    }
    printf("\n");
}

/* ================================================================
 * NxN polynomial matrix (generic, N up to 8)
 * ================================================================ */
#define MAXN 8

typedef struct { Poly m[MAXN][MAXN]; int n; } Mat;

static void mat_zero(Mat *M, int n) {
    int i, j;
    M-&gt;n = n;
    for (i = 0; i &lt; n; i++)
        for (j = 0; j &lt; n; j++)
            p_zero(&amp;M-&gt;m[i][j]);
}

static void mat_id(Mat *M, int n) {
    int i, j;
    M-&gt;n = n;
    for (i = 0; i &lt; n; i++)
        for (j = 0; j &lt; n; j++) {
            if (i == j) p_mono(&amp;M-&gt;m[i][j], 1, 0);
            else p_zero(&amp;M-&gt;m[i][j]);
        }
}

static void mat_mul(Mat *R, const Mat *A, const Mat *B) {
    Mat T; int i, j, k, n; Poly t;
    n = A-&gt;n;
    mat_zero(&amp;T, n);
    for (i = 0; i &lt; n; i++)
        for (j = 0; j &lt; n; j++)
            for (k = 0; k &lt; n; k++) {
                p_mul(&amp;t, &amp;A-&gt;m[i][k], &amp;B-&gt;m[k][j]);
                p_add(&amp;T.m[i][j], &amp;T.m[i][j], &amp;t);
            }
    *R = T;
}

static void mat_scale(Mat *R, const Mat *M, const Poly *s) {
    int i, j, n;
    n = M-&gt;n; R-&gt;n = n;
    for (i = 0; i &lt; n; i++)
        for (j = 0; j &lt; n; j++)
            p_mul(&amp;R-&gt;m[i][j], &amp;M-&gt;m[i][j], s);
}

static void mat_add(Mat *R, const Mat *A, const Mat *B) {
    int i, j, n;
    n = A-&gt;n; R-&gt;n = n;
    for (i = 0; i &lt; n; i++)
        for (j = 0; j &lt; n; j++)
            p_add(&amp;R-&gt;m[i][j], &amp;A-&gt;m[i][j], &amp;B-&gt;m[i][j]);
}

static void mat_trace(Poly *tr, const Mat *M) {
    int i;
    p_zero(tr);
    for (i = 0; i &lt; M-&gt;n; i++)
        p_add(tr, tr, &amp;M-&gt;m[i][i]);
}

static int mat_eq(const Mat *A, const Mat *B) {
    int i, j;
    if (A-&gt;n != B-&gt;n) return 0;
    for (i = 0; i &lt; A-&gt;n; i++)
        for (j = 0; j &lt; A-&gt;n; j++)
            if (!p_eq(&amp;A-&gt;m[i][j], &amp;B-&gt;m[i][j])) return 0;
    return 1;
}

/* Tensor product: C = A tensor B
 * If A is n1 x n1 and B is n2 x n2, C is (n1*n2) x (n1*n2)
 * C[i1*n2+i2][j1*n2+j2] = A[i1][j1] * B[i2][j2] */
static void mat_tensor(Mat *C, const Mat *A, const Mat *B) {
    int i1, i2, j1, j2, n1, n2;
    n1 = A-&gt;n; n2 = B-&gt;n;
    C-&gt;n = n1 * n2;
    for (i1 = 0; i1 &lt; n1; i1++)
        for (i2 = 0; i2 &lt; n2; i2++)
            for (j1 = 0; j1 &lt; n1; j1++)
                for (j2 = 0; j2 &lt; n2; j2++)
                    p_mul(&amp;C-&gt;m[i1*n2+i2][j1*n2+j2],
                          &amp;A-&gt;m[i1][j1], &amp;B-&gt;m[i2][j2]);
}

/* Quantum trace: tr(diag_weights * M) = sum_i w[i] * M[i][i] */
static void mat_qtrace(Poly *tr, const Mat *M, const Poly *w) {
    int i; Poly t;
    p_zero(tr);
    for (i = 0; i &lt; M-&gt;n; i++) {
        p_mul(&amp;t, &amp;w[i], &amp;M-&gt;m[i][i]);
        p_add(tr, tr, &amp;t);
    }
}

static void mat_print(const Mat *M, const char *name) {
    int i, j; char buf[64];
    printf("%s (%dx%d):\n", name, M-&gt;n, M-&gt;n);
    for (i = 0; i &lt; M-&gt;n; i++)
        for (j = 0; j &lt; M-&gt;n; j++) {
            sprintf(buf, "  [%d,%d]", i, j);
            if (M-&gt;m[i][j].len &gt; 0)
                p_print(&amp;M-&gt;m[i][j], buf);
        }
}

/* ================================================================
 * State-sum oracle (from Demo 03)
 * ================================================================ */
#define MAX_UF 256
static int uf_p[MAX_UF];
static void uf_init(int n) { int i; for (i = 0; i &lt; n; i++) uf_p[i] = i; }
static int uf_find(int x) {
    while (uf_p[x] != x) { uf_p[x] = uf_p[uf_p[x]]; x = uf_p[x]; }
    return x;
}
static void uf_union(int x, int y) {
    x = uf_find(x); y = uf_find(y); if (x != y) uf_p[x] = y;
}

typedef struct { int word[20]; int len, n; } Braid;

static int braid_loops(const Braid *b, unsigned s) {
    int N = (b-&gt;len + 1) * b-&gt;n, l, p, i, loops, sgn, bit, cup;
    uf_init(N);
    for (l = 0; l &lt; b-&gt;len; l++) {
        sgn = b-&gt;word[l] &gt; 0 ? 1 : -1;
        i = (sgn &gt; 0 ? b-&gt;word[l] : -b-&gt;word[l]) - 1;
        bit = (int)((s &gt;&gt; l) &amp; 1u);
        cup = (sgn &gt; 0) ? (bit == 0) : (bit == 1);
        if (cup) {
            uf_union(l * b-&gt;n + i, l * b-&gt;n + i + 1);
            uf_union((l + 1) * b-&gt;n + i, (l + 1) * b-&gt;n + i + 1);
            for (p = 0; p &lt; b-&gt;n; p++)
                if (p != i &amp;&amp; p != i + 1)
                    uf_union(l * b-&gt;n + p, (l + 1) * b-&gt;n + p);
        } else {
            for (p = 0; p &lt; b-&gt;n; p++)
                uf_union(l * b-&gt;n + p, (l + 1) * b-&gt;n + p);
        }
    }
    for (p = 0; p &lt; b-&gt;n; p++)
        uf_union(p, b-&gt;len * b-&gt;n + p);
    loops = 0;
    for (i = 0; i &lt; N; i++)
        if (uf_find(i) == i) loops++;
    return loops;
}

static void braid_bracket(Poly *r, const Braid *b) {
    unsigned s, ns; int i, a, bc, lp, j;
    Poly d, dp, t, c, t1, t2;
    p_zero(r);
    p_mono(&amp;t1, -1, 2); p_mono(&amp;t2, -1, -2); p_add(&amp;d, &amp;t1, &amp;t2);
    if (!b-&gt;len) {
        p_mono(r, 1, 0);
        for (i = 0; i &lt; b-&gt;n - 1; i++) p_mul(r, r, &amp;d);
        return;
    }
    ns = 1u &lt;&lt; b-&gt;len;
    for (s = 0; s &lt; ns; s++) {
        a = 0; bc = 0;
        for (i = 0; i &lt; b-&gt;len; i++) {
            if ((s &gt;&gt; i) &amp; 1u) bc++; else a++;
        }
        lp = braid_loops(b, s);
        p_mono(&amp;t, 1, a - bc);
        p_mono(&amp;dp, 1, 0);
        for (j = 0; j &lt; lp - 1; j++) p_mul(&amp;dp, &amp;dp, &amp;d);
        p_mul(&amp;c, &amp;t, &amp;dp);
        p_add(r, r, &amp;c);
    }
    p_trim(r);
}

/* ================================================================
 * Globals
 * ================================================================ */
static Poly DELTA; /* -A^2 - A^{-2} */
static Poly PA, PAinv; /* A and A^{-1} as polynomials */

static void init_globals(void) {
    Poly t1, t2;
    p_mono(&amp;t1, -1, 2); p_mono(&amp;t2, -1, -2); p_add(&amp;DELTA, &amp;t1, &amp;t2);
    p_mono(&amp;PA, 1, 1);
    p_mono(&amp;PAinv, 1, -1);
}

static int n_pass = 0, n_fail = 0;
static void check(const char *msg, int ok) {
    if (ok) { printf("  PASS: %s\n", msg); n_pass++; }
    else    { printf("  FAIL: %s\n", msg); n_fail++; }
}

/* ================================================================
 * Build TL cup-cap U on V tensor V
 *
 * The quantum cup-cap for U_q(sl_2) with q = A^2:
 *   Cup: |Omega&gt; = |01&gt; - q|10&gt; = |01&gt; - A^2|10&gt;
 *   Cap: &lt;Omega| = -q^{-1}&lt;01| + &lt;10| = -A^{-2}&lt;01| + &lt;10|
 *
 *   &lt;Omega|Omega&gt; = -(q+q^{-1}) = -(A^2+A^{-2}) = delta
 *
 *   U = |Omega&gt;&lt;Omega| acts as:
 *   U(|00&gt;) = 0
 *   U(|01&gt;) = -A^{-2} * |Omega&gt; = -A^{-2}|01&gt; + A^{-2}*A^2|10&gt; = -A^{-2}|01&gt; + |10&gt;
 *   U(|10&gt;) = 1 * |Omega&gt; = |01&gt; - A^2|10&gt;
 *   U(|11&gt;) = 0
 *
 * Matrix in basis {|00&gt;, |01&gt;, |10&gt;, |11&gt;}:
 *   U = [[0,     0,     0,   0],
 *        [0,  -A^{-2},  1,   0],
 *        [0,     1,   -A^2,  0],
 *        [0,     0,     0,   0]]
 *
 * Verify: tr(U) = -A^{-2} + (-A^2) = delta. CHECK.
 * Verify: U^2 = delta*U. CHECK (derived from &lt;Omega|Omega&gt; = delta).
 * ================================================================ */

static Mat U_VV;   /* 4x4 TL generator on V tensor V */
static Mat R_VV;   /* 4x4 R-matrix = A*U + A^{-1}*I */
static Mat Rinv_VV; /* 4x4 inverse */
static Mat R1, R2; /* 8x8: R tensor I, I tensor R */
static Mat R1inv, R2inv; /* 8x8 inverses */

static void build_all(void) {
    Mat I2, I4, AU, AinvI, AinvU, AI;
    Poly neg_Ainv2, neg_A2;

    /* U on V tensor V */
    p_mono(&amp;neg_Ainv2, -1, -2);
    p_mono(&amp;neg_A2, -1, 2);
    mat_zero(&amp;U_VV, 4);
    U_VV.m[1][1] = neg_Ainv2;  /* -A^{-2} */
    p_mono(&amp;U_VV.m[1][2], 1, 0); /* 1 */
    p_mono(&amp;U_VV.m[2][1], 1, 0); /* 1 */
    U_VV.m[2][2] = neg_A2;     /* -A^2 */

    /* R = A*U + A^{-1}*I_4 */
    mat_id(&amp;I4, 4);
    mat_scale(&amp;AU, &amp;U_VV, &amp;PA);       /* A*U */
    mat_scale(&amp;AinvI, &amp;I4, &amp;PAinv);   /* A^{-1}*I */
    mat_add(&amp;R_VV, &amp;AU, &amp;AinvI);

    /* R^{-1} = A^{-1}*U + A*I_4 */
    mat_scale(&amp;AinvU, &amp;U_VV, &amp;PAinv); /* A^{-1}*U */
    mat_scale(&amp;AI, &amp;I4, &amp;PA);         /* A*I */
    mat_add(&amp;Rinv_VV, &amp;AinvU, &amp;AI);

    /* 8x8: R1 = R tensor I_2, R2 = I_2 tensor R */
    mat_id(&amp;I2, 2);
    mat_tensor(&amp;R1, &amp;R_VV, &amp;I2);
    mat_tensor(&amp;R2, &amp;I2, &amp;R_VV);

    /* 8x8 inverses */
    mat_tensor(&amp;R1inv, &amp;Rinv_VV, &amp;I2);
    mat_tensor(&amp;R2inv, &amp;I2, &amp;Rinv_VV);
}

/* ================================================================
 * Build braid product on V^{tensor 3}
 * word[i] = +j means sigma_j (1-indexed)
 * word[i] = -j means sigma_j^{-1}
 * For 3-strand: j=1 -&gt; R1, j=2 -&gt; R2
 * ================================================================ */
static void braid_product(Mat *result, const Braid *b) {
    int i, j;
    Mat *gen;
    mat_id(result, 8);
    for (i = 0; i &lt; b-&gt;len; i++) {
        j = b-&gt;word[i];
        if (j == 1) gen = &amp;R1;
        else if (j == -1) gen = &amp;R1inv;
        else if (j == 2) gen = &amp;R2;
        else if (j == -2) gen = &amp;R2inv;
        else { printf("  ERROR: bad generator %d\n", j); return; }
        mat_mul(result, result, gen);
    }
}

/* ================================================================
 * TESTS
 * ================================================================ */

static void test_part_a(void) {
    Mat U2, dU;

    printf("\n=== PART A: TL Generator on V tensor V ===\n");
    mat_print(&amp;U_VV, "U");

    /* U^2 = delta * U */
    mat_mul(&amp;U2, &amp;U_VV, &amp;U_VV);
    mat_scale(&amp;dU, &amp;U_VV, &amp;DELTA);
    check("U^2 = delta * U", mat_eq(&amp;U2, &amp;dU));

    /* tr(U) = delta */
    {
        Poly tr;
        mat_trace(&amp;tr, &amp;U_VV);
        check("tr(U) = delta", p_eq(&amp;tr, &amp;DELTA));
    }
}

static void test_part_b(void) {
    Mat prod, I4;

    printf("\n=== PART B: R-matrix on V tensor V ===\n");
    mat_print(&amp;R_VV, "R = A*U + A^{-1}*I");

    mat_id(&amp;I4, 4);
    mat_mul(&amp;prod, &amp;R_VV, &amp;Rinv_VV);
    check("R * R^{-1} = I (4x4)", mat_eq(&amp;prod, &amp;I4));
}

static void test_part_c(void) {
    Mat t, lhs, rhs, prod, I8;

    printf("\n=== PART C: Yang-Baxter in 8D ===\n");
    printf("  R1 = R tensor I, R2 = I tensor R\n");
    printf("  Checking R1*R2*R1 = R2*R1*R2...\n");

    /* R1 * R2 * R1 */
    mat_mul(&amp;t, &amp;R1, &amp;R2);
    mat_mul(&amp;lhs, &amp;t, &amp;R1);

    /* R2 * R1 * R2 */
    mat_mul(&amp;t, &amp;R2, &amp;R1);
    mat_mul(&amp;rhs, &amp;t, &amp;R2);

    check("R1*R2*R1 = R2*R1*R2 (Yang-Baxter, 8x8)", mat_eq(&amp;lhs, &amp;rhs));

    /* Also check inverses */
    mat_mul(&amp;t, &amp;R1inv, &amp;R2inv);
    mat_mul(&amp;lhs, &amp;t, &amp;R1inv);
    mat_mul(&amp;t, &amp;R2inv, &amp;R1inv);
    mat_mul(&amp;rhs, &amp;t, &amp;R2inv);
    check("R1inv*R2inv*R1inv = R2inv*R1inv*R2inv", mat_eq(&amp;lhs, &amp;rhs));

    /* And R1*R1inv = I */
    mat_id(&amp;I8, 8);
    mat_mul(&amp;prod, &amp;R1, &amp;R1inv);
    check("R1 * R1inv = I (8x8)", mat_eq(&amp;prod, &amp;I8));
    mat_mul(&amp;prod, &amp;R2, &amp;R2inv);
    check("R2 * R2inv = I (8x8)", mat_eq(&amp;prod, &amp;I8));
}

static void test_part_d(void) {
    /*
     * DISCOVERED FORMULA:
     *   bracket(beta) = tr_q(rho(beta)) / (A^2 + A^{-2})
     *
     * where tr_q = tr(K^{tensor 3} * M) with K = diag(A^2, A^{-2}).
     *
     * Equivalently: tr_q(rho(beta)) = (A^2+A^{-2}) * bracket(beta) = -delta * bracket
     *
     * This works because V^{tensor 3} decomposes via Schur-Weyl duality:
     *   V^{tensor 3} = V_{3/2} tensor W_3 + V_{1/2} tensor W_1
     * and the quantum trace with K = diag(q, q^{-1}), q = A^2, weights
     * each component by its quantum dimension:
     *   qdim(V_{1/2}) = [2]_q = A^2+A^{-2} = -delta
     *   qdim(V_{3/2}) = [4]_q = A^6+A^2+A^{-2}+A^{-6}
     *
     * Dividing by -delta gives:
     *   bracket = 1*tr_{W_1} + (A^{-4}+A^4)*tr_{W_3}
     * which is exactly the formula from Demo 03!
     *
     * We test by checking: tr_q(rho(beta)) = -delta * oracle(beta)
     * This avoids polynomial division.
     */

    Braid braids[5];
    const char *bnames[5];
    Poly oracles[5];
    Mat products[5];
    Poly w[8]; /* K^{tensor 3} diagonal weights */
    Poly neg_delta;
    int bi, a, b, c, idx;

    printf("\n=== PART D: Bracket via Quantum Trace ===\n");
    printf("  K = diag(A^2, A^{-2})  (quantum group element q^H)\n");
    printf("  bracket = tr(K^{x3} * rho) / (A^2 + A^{-2})\n");
    printf("  Testing: tr_q(rho) = -delta * oracle\n\n");

    /* Build K^{tensor 3} diagonal: K = diag(A^2, A^{-2}) */
    {
        Poly k[2];
        p_mono(&amp;k[0], 1, 2);   /* A^2 */
        p_mono(&amp;k[1], 1, -2);  /* A^{-2} */
        for (a = 0; a &lt; 2; a++)
            for (b = 0; b &lt; 2; b++)
                for (c = 0; c &lt; 2; c++) {
                    Poly t;
                    idx = a * 4 + b * 2 + c;
                    p_mul(&amp;t, &amp;k[a], &amp;k[b]);
                    p_mul(&amp;w[idx], &amp;t, &amp;k[c]);
                }
    }

    /* -delta = A^2 + A^{-2} */
    { Poly t1, t2; p_mono(&amp;t1,1,2); p_mono(&amp;t2,1,-2); p_add(&amp;neg_delta,&amp;t1,&amp;t2); }

    /* Set up test braids */
    braids[0].n = 3; braids[0].len = 0;
    bnames[0] = "identity (3-unlink)";

    braids[1].n = 3; braids[1].len = 3;
    braids[1].word[0] = 1; braids[1].word[1] = 2; braids[1].word[2] = 1;
    bnames[1] = "trefoil";

    braids[2].n = 3; braids[2].len = 4;
    braids[2].word[0] = 1; braids[2].word[1] = -2;
    braids[2].word[2] = 1; braids[2].word[3] = -2;
    bnames[2] = "figure-eight";

    braids[3].n = 3; braids[3].len = 3;
    braids[3].word[0] = -1; braids[3].word[1] = -2; braids[3].word[2] = -1;
    bnames[3] = "mirror trefoil";

    braids[4].n = 3; braids[4].len = 1;
    braids[4].word[0] = 1;
    bnames[4] = "single crossing";

    /* Compute oracle values and 8x8 products */
    for (bi = 0; bi &lt; 5; bi++) {
        braid_bracket(&amp;oracles[bi], &amp;braids[bi]);
        braid_product(&amp;products[bi], &amp;braids[bi]);
    }

    /* Test each braid: tr_q(rho(beta)) should equal -delta * oracle */
    for (bi = 0; bi &lt; 5; bi++) {
        Poly qtrace, expected;
        char msg[80];
        mat_qtrace(&amp;qtrace, &amp;products[bi], w);
        p_mul(&amp;expected, &amp;neg_delta, &amp;oracles[bi]);

        printf("  %s:\n", bnames[bi]);
        p_print(&amp;oracles[bi], "    oracle");
        p_print(&amp;qtrace, "    tr_q  ");
        p_print(&amp;expected, "    -d*orc");

        sprintf(msg, "%s: tr_q = -delta * oracle", bnames[bi]);
        check(msg, p_eq(&amp;qtrace, &amp;expected));
    }

    /* Print the quantum dimensions for documentation */
    printf("\n  Schur-Weyl decomposition V^{x3} = V_{3/2} x W_3 + V_{1/2} x W_1:\n");
    printf("    qdim(V_{1/2}) = [2]_q = A^2+A^{-2} = -delta\n");
    printf("    qdim(V_{3/2}) = [4]_q = A^6+A^2+A^{-2}+A^{-6}\n");
    printf("    bracket = tr_q / (-delta)\n");
    printf("            = 1*tr_{W_1} + (A^{-4}+A^4)*tr_{W_3}  [matches Demo 03]\n");
}


int main(void) {
    printf("KNOTAPEL DEMO 04: Spin Chain (Tensor Product)\n");
    printf("==============================================\n");

    init_globals();
    p_print(&amp;DELTA, "delta");

    build_all();

    test_part_a();
    test_part_b();
    test_part_c();
    test_part_d();

    printf("\n==============================================\n");
    printf("Results: %d passed, %d failed\n", n_pass, n_fail);
    printf("==============================================\n");
    return n_fail &gt; 0 ? 1 : 0;
}
</code></pre>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <script>hljs.highlightAll();</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>research/five-pillars.md</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <nav><a href="../index.html">← Back to Index</a></nav><hr>
    <h1>The Five Pillars: Habiro / Nazer-Gastpar / Abramsky / Aizenberg / Reservoir Computing</h1>
<p>The DKC thesis lives at an unoccupied intersection of five established fields. Nobody in the literature connects these results. Each pillar is well-established in its own domain; the novelty is assembling them into the forward DKC construction.</p>
<p><em>Updated 2026-02-21: Reservoir Computing added as Pillar 5, motivated by the scaling arc (<a href="../inventory/entries/demo_73.html">D73</a>, <a href="../inventory/entries/demo_76.html">D76</a>-<a href="../inventory/entries/demo_82.html">D82</a>). The braid-as-reservoir connection gives DKC its temporal/dynamical dimension.</em></p>
<p><em>Updated 2026-02-23: <a href="../inventory/entries/demo_85.html">Demos 85</a>-<a href="../inventory/entries/demo_92.html">92</a> added. <a href="../inventory/entries/demo_85.html">D85</a>-<a href="../inventory/entries/demo_86.html">86</a> connect to Pillar 3 (TL non-semisimplicity deepened via indecomposability parameter). <a href="../inventory/entries/demo_87.html">D87</a>-<a href="../inventory/entries/demo_88.html">88</a>-90 refine Pillar 5 (null dispensability regime transition, relational-not-positional mechanism). <a href="../inventory/entries/demo_89.html">D89</a>-<a href="../inventory/entries/demo_91.html">91</a> confirm balanced exponentials (supply/demand linearity). <a href="../inventory/entries/demo_92.html">D92</a> adds circuit complexity connection (AC^0 parity lower bounds).</em></p>
<p><em>Updated 2026-02-26: <a href="../inventory/entries/demo_102.html">Demos 102</a>-<a href="../inventory/entries/demo_109.html">109</a> added. <a href="../inventory/entries/demo_102.html">D102</a> connects Pillar 3 to Barrington's theorem (radical carries abelian character, provably useless for parity). <a href="../inventory/entries/demo_103.html">D103</a>-<a href="../inventory/entries/demo_105.html">105</a> deepen Pillar 5 (BFS growth is braid group invariant, sign-hash = 1-bit compressed sensing, macrame principle for branching interaction). <a href="../inventory/entries/demo_106.html">D106</a> strengthens Pillar 5 via negative: topological entropy is orthogonal to DKC computation (TL visibility filter). <a href="../inventory/entries/demo_108.html">D108</a>-<a href="../inventory/entries/demo_109.html">109</a> add dual-channel theorem connecting Pillar 2 (lattice product closure) and Pillar 4 (activation/magnitude diversity) with quantum circuit synthesis bridge (Amy-Glaudell-Ross 2023).</em></p>
<p>---</p>
<h2>Pillar 1: Habiro (2002) — Bracket Values Are Cyclotomic Integers</h2>
<p><strong>Paper:</strong> "On the quantum sl_2 invariants of knots and integral homology spheres" <strong>Journal:</strong> Geometry &amp; Topology Monographs <strong>Link:</strong> <a href="https://arxiv.org/abs/math/0209324">arXiv:math/0209324</a></p>
<p><strong>What Habiro proved:</strong> The colored Jones polynomial has a "cyclotomic expansion" — it can be written as a sum over cyclotomic polynomials with integer coefficients. This means that evaluating the Jones polynomial (or equivalently, the Kauffman bracket) at any root of unity A = e^{iπ(2k+1)/2ℓ} necessarily produces a value in the cyclotomic integer ring Z[ζ_{2ℓ}].</p>
<p><strong>What this gives DKC:</strong> The mathematical guarantee that our bracket catalog is a catalog of ALGEBRAIC INTEGERS, not floating-point approximations. At A = e^{i5π/4} (our primary case), all bracket values are elements of Z[ζ₈] = {a + bζ₈ + cζ₈² + dζ₈³ : a,b,c,d ∈ Z}. This ring has class number 1 (unique factorization domain), making exact arithmetic straightforward.</p>
<p><strong>The specific instance:</strong> Habiro's integrality theorem is general; our <a href="../inventory/entries/demo_29.html">Demo 29</a> implements it for the specific case ℓ=2 (8th root of unity, δ=0). The 64-element catalog of distinct bracket values is a finite subset of Z[ζ₈], computed by exact integer operations on 4-tuples — zero floating-point error.</p>
<p><strong>Strengthened by:</strong> Costello-Francis-Gwilliam (2026, arXiv:2602.12412) proving Witten = RT, which means the bracket values are not just algebraic integers but rigorously quantum field theory transition amplitudes.</p>
<p><strong>Which demos use it:</strong> <a href="../inventory/entries/demo_29.html">D29</a> (forward DKC, exact Z[ζ₈] arithmetic), <a href="../inventory/entries/demo_35.html">D35</a> (TL matrices over Z[ζ₈]), <a href="../inventory/entries/demo_48.html">D48</a> (exhaustive 100M quartet search with exact arithmetic), <a href="../inventory/entries/demo_49.html">D49</a> (neglecton weights in Z[ζ₈]), <a href="../inventory/entries/demo_50.html">D50</a> (parity reachability with Z[ζ₈] catalog), <a href="../inventory/entries/demo_53.html">D53</a> (Z[ω] at ℓ=3), <a href="../inventory/entries/demo_54.html">D54</a> (Z[ζ₁₆] at ℓ=4), <a href="../inventory/entries/demo_58.html">D58</a> (Z[ζ₅] at ℓ=5), <a href="../inventory/entries/demo_59.html">D59</a> (Z[ζ₂₄] at ℓ=6), <a href="../inventory/entries/demo_85.html">D85</a> (delta-parameterized b extraction uses Z[ζ₈] infrastructure), <a href="../inventory/entries/demo_87.html">D87</a> (zeta_8 vs zeta_12 null fraction), <a href="../inventory/entries/demo_90.html">D90</a> (algebraic substrate for cross-depth constraints), <a href="../inventory/entries/demo_92.html">D92</a> (weight catalog for parity-lock analysis), <a href="../inventory/entries/demo_102.html">D102</a> (6-strand exact Z[ζ₈] matrix representation), <a href="../inventory/entries/demo_105.html">D105</a> (8-strand exact Z[ζ₈] matrices), <a href="../inventory/entries/demo_107.html">D107</a> (186 distinct Z[ζ₈] values, axis-alignment theorem), <a href="../inventory/entries/demo_108.html">D108</a> (parity vocabulary graph analysis on Z[ζ₈] catalog), <a href="../inventory/entries/demo_109.html">D109</a> (Z[ζ₁₆] at δ=√2)</p>
<p>---</p>
<h2>Pillar 2: Nazer-Gastpar (2011) — Algebraic Integer Lattices Compute Functions</h2>
<p><strong>Paper:</strong> "Compute-and-Forward: Harnessing Interference Rather Than Treating It as Noise" <strong>Journal:</strong> IEEE Transactions on Information Theory <strong>Link:</strong> <a href="https://arxiv.org/pdf/1107.0300">arXiv:1107.0300</a></p>
<p><strong>Also:</strong> Tunali et al. (2015), "Lattices over Eisenstein Integers for Compute-and-Forward" — extends to Z[ω] (Eisenstein integers). <a href="https://arxiv.org/abs/1404.1312">arXiv:1404.1312</a></p>
<p><strong>What Nazer-Gastpar proved:</strong> In a wireless relay network, relays should compute INTEGER LINEAR COMBINATIONS of codewords rather than decode individual messages. Lattice codes (codewords closed under integer linear combinations) naturally support this "compute-and-forward" paradigm. The algebraic structure of the lattice does the computational heavy lifting.</p>
<p><strong>Key extension (Tunali et al.):</strong> Replacing Z^n with Z[ω] (Eisenstein integers, the ring of integers of Q(ζ₃)) gives BETTER codes. The algebraic integer lattice structure provides natural error correction beyond what ordinary integer lattices offer.</p>
<p><strong>What this gives DKC:</strong> The information-theoretic frame. Forward DKC proposes the same principle applied to neural networks: Z[ζ₈] lattice points as weights, with the algebraic ring structure ensuring exact computation. The difference: compute-and-forward computes LINEAR functions at relays; DKC computes NONLINEAR functions (XOR, parity) through bracket evaluation. But the foundational insight is shared — algebraic integer rings enable computation through their ring structure, not through optimization.</p>
<p><strong>The specific analogy:</strong> <ul> <li>Compute-and-forward: channel noise → lattice decoding → exact linear function</li> <li>Forward DKC: bracket evaluation → cyclotomic lattice → exact Boolean function</li> <li>Both: the algebraic closure properties of the ring guarantee correctness</li> </ul>
<p><strong>Which demos use it:</strong> <a href="../inventory/entries/demo_29.html">D29</a> (bracket as lattice sum), <a href="../inventory/entries/demo_46.html">D46</a> (coding theory capacity analysis: ~7.3 bits/symbol in Z[ζ₈]), <a href="../inventory/entries/demo_47.html">D47</a> (two-channel coding thesis), <a href="../inventory/entries/demo_48.html">D48</a> (100M quartet search uses lattice structure), <a href="../inventory/entries/demo_55.html">D55</a> (DKC at ℓ=4 with Z[ζ₁₆] lattice)</p>
<p>---</p>
<h2>Pillar 3: Abramsky (2007) — TL Diagrams Encode Computation</h2>
<p><strong>Paper:</strong> "Temperley-Lieb Algebra: From Knot Theory to Logic and Computation via Quantum Mechanics" <strong>Link:</strong> <a href="https://arxiv.org/abs/0910.2737">arXiv:0910.2737</a></p>
<p><strong>What Abramsky proved:</strong> The Temperley-Lieb algebra connects knot theory, categorical quantum mechanics, and logic/computation. Abramsky gives a "fully abstract presentation" of the TL category using Geometry of Interaction, and introduces a "planar lambda calculus" interpreted in TL algebras. TL diagrams are a natural computational calculus — composition of diagrams IS composition of computations.</p>
<p><strong>What this gives DKC:</strong> The theoretical bridge from topology to computation. Abramsky proved that TL diagrams can encode computation. The bracket state sum evaluates TL diagrams. Therefore bracket values are not just topological invariants — they are evaluations of a computational calculus. Forward DKC's step from "TL diagrams encode computation" to "bracket values of TL diagrams can be compiled into NN weights" is our specific contribution building on Abramsky's bridge.</p>
<p><strong><a href="../inventory/entries/demo_35.html">Demo 35</a> implements Abramsky directly:</strong> General TL_n matrices over Cyc8, verified for n=2-5. The matrix representation of TL generators IS Abramsky's computational primitives, made concrete in C89 exact arithmetic.</p>
<p><strong><a href="../inventory/entries/demo_85.html">Demos 85</a>-<a href="../inventory/entries/demo_86.html">86</a> deepen the non-semisimple structure:</strong> The indecomposability parameter b = -5/8 (Pearce-Rasmussen) computed via delta-parameterized forms on the TL_4 regular representation. This connects to the LCFT structure constants that govern how TL modules compose — the non-semisimplicity that Abramsky's framework predicts but does not explicitly compute. The b parameter quantifies the "computational obstruction" in the TL radical: it measures the coupling between head and socle of projective indecomposable modules, which is the algebraic mechanism behind DKC's parity wall (<a href="../inventory/entries/demo_47.html">D47</a>-<a href="../inventory/entries/demo_50.html">50</a>).</p>
<p><strong><a href="../inventory/entries/demo_102.html">Demos 102</a> deepens the non-semisimple structure further:</strong> The Barrington-Radical Principle — the radical of W_{6,4} carries an abelian character (the writhe homomorphism B_n → Z/8Z), and by Barrington's theorem abelian groups cannot compute parity. This PROVES that the radical direction is computationally inert for XOR, closing the loop from <a href="../inventory/entries/demo_47.html">D47</a>'s hypothesis (non-semisimplicity limits computation) through <a href="../inventory/entries/demo_85.html">D85</a>'s quantification (b = -5/8) to <a href="../inventory/entries/demo_102.html">D102</a>'s proof (radical ≡ abelian ≡ useless by Barrington).</p>
<p><strong><a href="../inventory/entries/demo_107.html">Demo 107</a> provides the algebraic fine structure:</strong> Universal axis-alignment at δ=0 is a provable theorem: every braid matrix entry is n·ζ₈^k (single axis). The Z/4Z phase formula reduces DKC at δ=0 to integer path counting + three-variable phase lookup. The nesting parity Z/2Z grading is novel (confirmed vs Plaza-Ryom-Hansen 2013 KLR grading).</p>
<p><strong>Which demos use it:</strong> <a href="../inventory/entries/demo_27.html">D27</a> (reverse DKC conceptual framework), <a href="../inventory/entries/demo_29.html">D29</a> (forward DKC), <a href="../inventory/entries/demo_35.html">D35</a> (TL matrices as computational engine), <a href="../inventory/entries/demo_47.html">D47</a>-<a href="../inventory/entries/demo_50.html">50</a> (TL non-semisimplicity as parity barrier), <a href="../inventory/entries/demo_51.html">D51</a>-<a href="../inventory/entries/demo_52.html">52</a> (radical anatomy — the algebraic obstruction theory), <a href="../inventory/entries/demo_85.html">D85</a>-<a href="../inventory/entries/demo_86.html">86</a> (indecomposability parameter — quantifying the non-semisimple coupling), <a href="../inventory/entries/demo_102.html">D102</a> (Barrington-Radical Principle — abelian radical provably useless), <a href="../inventory/entries/demo_107.html">D107</a> (Z/4Z axis-alignment theorem, nesting parity Z/2Z grading)</p>
<p><strong>The formal chain:</strong> 1. Abramsky: TL diagrams = computation 2. Our bracket evaluation: TL computation → Z[ζ₈] values (via Habiro) 3. Forward DKC: Z[ζ₈] values → Boolean function weights</p>
<p>---</p>
<h2>Pillar 4: Aizenberg (2000) — Roots-of-Unity Neurons for Discrete Logic</h2>
<p><strong>Paper:</strong> "Multi-Valued and Universal Binary Neurons: Theory, Learning and Applications" <strong>Authors:</strong> Igor Aizenberg, Naum N. Aizenberg, Joos P.L. Vandewalle <strong>Publisher:</strong> Kluwer Academic Publishers <strong>Link:</strong> <a href="https://link.springer.com/book/10.1007/978-1-4757-3115-6">Springer</a></p>
<p><strong>Also:</strong> Aizenberg (2011), "Complex-Valued Neural Networks with Multi-Valued Neurons" (Springer).</p>
<p><strong>What Aizenberg proved:</strong> The values of k-valued logic are naturally encoded by the k-th roots of unity (ε_j = e^{2πij/k}). A single multi-valued neuron (MVN) with activation function mapping the complex plane into k angular sectors can implement arbitrary k-valued threshold functions. The MVN uses a non-gradient learning rule: simple rotation along the unit circle.</p>
<p><strong>What this gives DKC:</strong> The neural network architecture. Aizenberg's MVN PRESCRIBES root-of-unity structure — you design the neuron to use k sectors. Forward DKC DISCOVERS that bracket values (which are cyclotomic integers, sums of roots of unity) naturally compute Boolean functions when used as MVN-style weights. The key difference: <ul> <li>Aizenberg: Design the activation → roots of unity follow</li> <li>Forward DKC: Topology provides the weights → activation choice selects which functions are computable</li> </ul>
<p><strong>The <a href="../inventory/entries/demo_50.html">Demo 50</a> result:</strong> k=6 MVN sectors make ALL 13 non-trivial NPN classes computable from Z[ζ₈] bracket values, including parity (906 solutions). This is Aizenberg's architecture populated with Habiro's values, computing functions that Abramsky's framework predicts, over lattices that Nazer-Gastpar's theory validates.</p>
<p><strong>Key extension — Aizenberg (2008):</strong> "Solving the XOR and parity N problems using a single universal binary neuron." <em>Soft Computing</em>, 12(3). This paper proved parity solvable with a single UBN, and its weight construction (w₁=ζ₈, w₂=i, w₃=−1) lives IN the Z[ζ₈] bracket catalog — confirming that the lattice contains parity-capable weights even though split-sigmoid cannot access them.</p>
<p><strong><a href="../inventory/entries/demo_91.html">Demo 91</a> confirmation:</strong> The k-sector MVN activation is NOT the bottleneck for the depth law. Varying k_sec from 2 to 48 does not shift the depth gap between XOR levels — finer resolution reveals more solutions but not higher arity. The parity constraint itself is the wall, and the activation resolution only controls how many solutions are visible. This confirms Aizenberg's architecture as sufficient but not limiting.</p>
<p><strong><a href="../inventory/entries/demo_92.html">Demo 92</a> parity-lock:</strong> The +/-q input encoding concentrates all computational power on parity — the single Boolean function outside AC^0 (Furst-Saxe-Sipser 1984, Hastad 1987). Under the 1-weight-per-input encoding (<a href="../inventory/entries/demo_48.html">D48</a>/<a href="../inventory/entries/demo_50.html">D50</a>), all 13 NPN classes including parity are achievable. The encoding-dependence of function accessibility is a refinement of Aizenberg's general MVN theory: the activation architecture (Aizenberg) determines what functions ARE computable in principle; the encoding determines which subset is ACCESSIBLE from a given weight catalog.</p>
<p><strong><a href="../inventory/entries/demo_108.html">Demo 108</a> dual-channel theorem:</strong> Graph structure PREDICTS parity capability. Product closure (multiplicative phase coherence) and additive v₂ connectivity (magnitude diversity) are both independently necessary for parity. This maps onto the T-gate/Hadamard decomposition of Amy-Glaudell-Ross (2023) for quantum circuit synthesis over Z[ζ₈]. The activation function plays the Hadamard role: providing magnitude diversity that enables "Clifford-level" values to participate in parity computation.</p>
<p><strong><a href="../inventory/entries/demo_109.html">Demo 109</a> encoding dependence:</strong> At δ=√2 (Z[ζ₁₆]), parity and non-parity vocabularies are structurally identical on 7/8 edge types. Product closure is the sole discriminator, but with INVERTED polarity from <a href="../inventory/entries/demo_108.html">D108</a>: parity wants LOW product closure under multiplicative encoding (products must escape vocabulary for sector alternation). The dual-channel theorem holds in both regimes but the sign of the multiplicative channel is encoding-sensitive.</p>
<p><strong>Which demos use it:</strong> <a href="../inventory/entries/demo_45.html">D45</a> (NPN classification with complex neurons), <a href="../inventory/entries/demo_47.html">D47</a> (MVN activation comparison, topology-frequency correlation reversal), <a href="../inventory/entries/demo_48.html">D48</a> (parity wall under split-sigmoid), <a href="../inventory/entries/demo_49.html">D49</a> (neglecton weights — lattice contains parity weights), <a href="../inventory/entries/demo_50.html">D50</a> (k-sector MVN resolves parity at k=6), <a href="../inventory/entries/demo_91.html">D91</a> (activation not the bottleneck — k_sec invariance), <a href="../inventory/entries/demo_92.html">D92</a> (encoding-dependent function selection), <a href="../inventory/entries/demo_108.html">D108</a> (dual-channel theorem — graph structure predicts parity), <a href="../inventory/entries/demo_109.html">D109</a> (encoding-dependent polarity inversion at δ=√2)</p>
<p>---</p>
<h2>Pillar 5: Reservoir Computing (Jaeger 2001 / Maass 2002) — Fixed Dynamical Systems Compute Through Their Dynamics</h2>
<p><strong>Papers:</strong> <ul> <li>Jaeger (2001), "The 'echo state' approach to analysing and training recurrent neural networks." GMD Technical Report 148.</li> <li>Maass, Natschläger, Markram (2002), "Real-time computing without stable states: A new framework for neural computation based on perturbations." <em>Neural Computation</em>, 14(11).</li> <li>Lukoševičius &amp; Jaeger (2009), "Reservoir computing approaches to recurrent neural network training." <em>Computer Science Review</em>, 3(3).</li> </ul>
<p><strong>What reservoir computing established:</strong> A fixed, untrained dynamical system (the "reservoir") processes sequential input through its internal dynamics. Only a simple readout layer is trained. The reservoir provides a high-dimensional nonlinear mapping of input sequences into a state space where linear readout suffices. The key insight: computational power comes from the STRUCTURE of the dynamics, not from optimization of the dynamics.</p>
<p><strong>What this gives DKC:</strong> The temporal/dynamical dimension that the other four pillars lack. A braid word IS a sequential input: each crossing σ_i is a time step, and the SU(2) representation processes crossings one at a time through matrix multiplication. The quaternion at the end of the braid word is the reservoir state. The Voronoi cell / sector activation is the readout.</p>
<p><strong>The specific connections:</strong></p>
<ul>
<li><strong><a href="../inventory/entries/demo_73.html">D73</a> (Eigenvector Automaton) IS reservoir dynamics.</strong> Crossing-by-crossing quaternion multiplication tracks Voronoi cell transitions. The 82.8% universal determinism IS the echo state property — the reservoir state is mostly determined by recent input, with 17.2% sensitivity to deeper history.</li>
<li><strong><a href="../inventory/entries/demo_82.html">D82</a> (Crossing Depth) IS a reservoir memory capacity result.</strong> max_xor ≈ depth+6 says computational power scales linearly with the number of dynamical steps through the reservoir. This is exactly what RC theory predicts: more time steps = richer transient dynamics = more computational separation between input classes.</li>
<li><strong><a href="../inventory/entries/demo_82.html">D82</a>'s "algebraic coherence beats vocabulary"</strong> is a reservoir quality result. Deep entries (many generator multiplications = many reservoir steps) with shared intermediate products outperform diverse entries (many distinct directions) with no shared structure. In RC terms: a reservoir with coherent internal dynamics computes more than a reservoir with maximal state diversity.</li>
</ul>
<p><strong><a href="../inventory/entries/demo_102.html">Demos 102</a>-<a href="../inventory/entries/demo_106.html">106</a> extend the RC connection:</strong></p>
<ul>
<li><strong><a href="../inventory/entries/demo_102.html">D102</a> (Barrington-Radical Principle):</strong> The radical direction carries an abelian character (writhe), which by Barrington's theorem is provably useless for parity. This is an algebraic reservoir quality result: the radical is a "frozen" 1-dimensional sub-reservoir that only tracks framing data. The simple module W_{6,0} outperforms the non-simple W_{6,4} at every XOR level because its entire 5-dimensional state space participates in computation, while W_{6,4} wastes one dimension on the frozen radical.</li>
<li><strong><a href="../inventory/entries/demo_103.html">D103</a> (BFS Growth Invariant):</strong> BFS catalog growth is identical across all modules of the same braid group B_n (W_{6,0}, W_{6,2}, W_{6,4} all produce the same depth profile). Growth rate ≈ (n-1)x converges to the sl_{n-1} functor thesis. In RC terms: the reservoir dynamics are determined by the input group (B_n), not the output representation. The readout (activation function) is fully separable from the reservoir.</li>
<li><strong><a href="../inventory/entries/demo_104.html">D104</a> (Sign-Hash = 1-Bit CS):</strong> Sign-hash activation is 1-bit compressed sensing (Boufounos-Baraniuk 2008). Cross-block activation outperforms within-block at n=6 because branching cross-terms have low intra-block coherence (the CS incoherence condition). Sign quantization can EXPAND effective rank (244→292 for W_{6,2}). The Atkinson sweet spot (~120 of 324 components) is the optimal information-per-collision tradeoff. But k (cell count) is the real scaling lever, not hash architecture.</li>
<li><strong><a href="../inventory/entries/demo_105.html">D105</a> (Macrame Principle):</strong> Branching interaction REVERSES at n=8: within-block dominates (dim-14 blocks are self-sufficient). Regime transition between dim-5 (cross-block wins) and dim-14 (within-block wins). The <a href="../inventory/entries/demo_93.html">D93</a> "XOR dies at N≥7" is REFUTED as a k-regime artifact: at k=4096, n=8 beats n=6.</li>
<li><strong><a href="../inventory/entries/demo_106.html">D106</a> (Topological Entropy Null):</strong> STRONGEST negative result for the RC analogy. Topological entropy (Thurston-Nielsen classification) is completely orthogonal to DKC computation. Both periodic and pseudo-Anosov braids compute XOR at 100% participation. The TL quotient at δ=0 erases dynamical information (e_i²=0 kills expanding eigenvalues) while preserving algebraic structure (writhe). DKC computation is collective/algebraic, not individual/dynamical — sharpening the relational computation thesis.</li>
</ul>
<p><strong><a href="../inventory/entries/demo_87.html">Demos 87</a>-<a href="../inventory/entries/demo_88.html">88</a>-89-90 refine the RC connection:</strong></p>
<ul>
<li><strong><a href="../inventory/entries/demo_87.html">D87</a> (Null Dispensability):</strong> Null reservoir states (bracket-null entries) are indispensable at finite groups (zeta_8) but dispensable at infinite groups (zeta_12). The regime transition — from null-critical to null-redundant — maps to RC capacity theory: when the reservoir is small (finite group, 24 states), every state matters including null ones that maintain the manifold; when the reservoir is large (infinite group, 4096+ states), null states become redundant because non-null states alone provide sufficient dimensionality. This refines the "logarithmic partner hypothesis" from <a href="../inventory/entries/demo_84.html">D84</a>.</li>
<li><strong><a href="../inventory/entries/demo_88.html">D88</a> (Anti-Correlation):</strong> The directions worst for spherical integration (design residual) are best for computation (XOR capacity). In RC terms: the reservoir state distribution that maximizes the separation property (computational utility) is NOT the distribution that maximizes entropy (uniform coverage). The 4 non-null body-diagonal directions are the rigid computational anchors; the 6 null-only edge-midpoint directions are flexible scaffolding. This is a concrete instance of the RC no-free-lunch theorem applied to the DKC braid reservoir.</li>
<li><strong><a href="../inventory/entries/demo_89.html">D89</a> (Depth Law Mechanism):</strong> Systematic elimination of 5 candidate mechanisms (pairwise coherence, direction coverage, Cayley density, sector diversity, angle coherence) plus confirmation that paired extension is real but minority (6-20% at zeta_12 vs 100% at zeta_8). The surviving explanation — "algebraic coherence" — IS the RC separation property: deep entries maintain richer relational structure because BFS ancestry creates algebraic constraints between entries.</li>
<li><strong><a href="../inventory/entries/demo_90.html">D90</a> (Relational, Not Positional):</strong> The S² point cloud bandwidth DECREASES with depth while computation INCREASES. This is the cleanest proof that the depth law mechanism is relational (how entries combine via axis cancellation and cross-depth algebraic constraints), not positional (where entries sit in state space). In RC terms: reservoir quality is about the dynamics of state transitions, not the static geometry of the state space.</li>
</ul>
<p><strong>The key difference from classical RC:</strong> <ul> <li>Classical RC: the reservoir is random or physical (water, memristors, optical cavities). The computational power is empirically discovered.</li> <li>DKC: the reservoir is ALGEBRAIC (braid group representation in SU(2)). The computational power is EXACTLY characterizable via the cyclotomic integer structure. The reservoir dynamics are not arbitrary — they are constrained by the braid group relations (Yang-Baxter equation), which GUARANTEE certain computational properties (e.g., <a href="../inventory/entries/demo_70.html">D70</a>'s melody invariance under Yang-Baxter moves).</li> </ul>
<p><strong>The fit with the pillar chain:</strong> <ul> <li>Abramsky tells you TL diagrams encode computation (what CAN be computed)</li> <li>Habiro tells you the values are cyclotomic integers (what the VALUES are)</li> <li>Aizenberg tells you how to read out Boolean functions (the READOUT)</li> <li>Nazer-Gastpar tells you the ring structure guarantees exactness (the MEDIUM)</li> <li><strong>Reservoir Computing tells you WHY DEPTH MATTERS (the DYNAMICS)</strong></li> </ul>
<p>Without the RC pillar, the other four treat braid evaluation as a black box: input a braid, get a bracket value. The RC pillar opens the box: the SEQUENTIAL PROCESSING of crossings is itself a computation, and the depth/length of the braid word directly determines computational capacity. <a href="../inventory/entries/demo_82.html">D82</a>'s linear depth law (max_xor ≈ depth+6) is the RC memory capacity theorem applied to the braid reservoir. <a href="../inventory/entries/demo_89.html">D89</a>-<a href="../inventory/entries/demo_91.html">91</a> confirm the mechanism: balanced exponentials (vocabulary ~2x/depth vs parity 4x/weight) with axis cancellation as the geometric realization of the separation property.</p>
<p><strong>Which demos use it:</strong> <a href="../inventory/entries/demo_73.html">D73</a> (eigenvector automaton — reservoir cell transitions), <a href="../inventory/entries/demo_76.html">D76</a>-<a href="../inventory/entries/demo_78.html">78</a> (capacity ceilings — finite reservoir limits), <a href="../inventory/entries/demo_79.html">D79</a> (infinite reservoir breaks ceiling), <a href="../inventory/entries/demo_81.html">D81</a> (logarithmic scaling — reservoir capacity law), <a href="../inventory/entries/demo_82.html">D82</a> (depth law — reservoir memory capacity, algebraic coherence as reservoir quality), <a href="../inventory/entries/demo_87.html">D87</a> (null dispensability — regime transition in reservoir state importance), <a href="../inventory/entries/demo_88.html">D88</a> (anti-correlation — RC no-free-lunch in DKC geometry), <a href="../inventory/entries/demo_89.html">D89</a> (depth law mechanism — RC separation property surviving 5 elimination tests), <a href="../inventory/entries/demo_90.html">D90</a> (relational-not-positional — the cleanest RC alignment), <a href="../inventory/entries/demo_102.html">D102</a> (radical = frozen abelian sub-reservoir), <a href="../inventory/entries/demo_103.html">D103</a> (BFS growth = reservoir dynamics invariant), <a href="../inventory/entries/demo_104.html">D104</a> (sign-hash = 1-bit CS readout with rank expansion), <a href="../inventory/entries/demo_105.html">D105</a> (macrame principle — branching interaction regime transition), <a href="../inventory/entries/demo_106.html">D106</a> (entropy null — dynamical classification invisible to bracket reservoir)</p>
<p><strong>The structural identity (exact, not analogical):</strong></p>
<table><thead><tr><th>Reservoir Computing</th><th>DKC</th></tr></thead><tbody><tr><td>Fixed reservoir (not trained)</td><td>Fixed braid catalog (from topology)</td></tr><tr><td>Only readout layer optimized</td><td>Only activation function tuned (k_sec, combined_cell)</td></tr><tr><td>High-dimensional dynamical state</td><td>Z[ζ₈] lattice / quaternion catalog</td></tr><tr><td>Edge of chaos = max capacity</td><td>ζ₈→ζ₁₂ = finite→infinite group transition</td></tr><tr><td>Separation property</td><td>XOR capacity / NPN class coverage</td></tr><tr><td>Echo state property</td><td>Axiality theorem (bounded, structured outputs)</td></tr><tr><td>Null reservoir states maintain manifold</td><td><a href="../inventory/entries/demo_87.html">D87</a>: true at finite groups, redundant at infinite</td></tr><tr><td>Reservoir quality = dynamics, not state geometry</td><td><a href="../inventory/entries/demo_90.html">D90</a>: relational, not positional</td></tr></tbody></table>
<p><strong>Edge of chaos mapping — the quantitative bridge:</strong></p>
<p>In RC theory, computational capacity is maximized at the critical transition between ordered dynamics (stable, low-dimensional attractors) and chaotic dynamics (sensitive to initial conditions, information destroyed). DKC has EXACTLY this transition:</p>
<ul>
<li><strong>ζ₈ = ordered regime:</strong> Finite group (24 elements), capacity ceiling (XOR8), highly structured (axiality, 4 half-angles, 13 directions). Beautiful but limited. The reservoir closes — same inputs eventually cycle through the same states.</li>
<li><strong>ζ₁₂ = edge of chaos:</strong> Infinite group, capacity breaks through (XOR12+), 43 half-angles, 512 directions. Rich enough to compute everything but still structured enough to be useful. The reservoir never closes — new states keep appearing — but the algebraic structure (cyclotomic integers) prevents true chaos.</li>
</ul>
<p>This is not metaphorical. The ordered→edge-of-chaos transition in RC is characterized by the spectral radius of the reservoir weight matrix approaching 1. The DKC analog: at ζ₈ the group is finite (spectral radius &lt; 1 in some appropriate norm — dynamics contract to the 24-element attractor), and at ζ₁₂ the group is infinite (spectral radius = 1 — dynamics never contract, the state space keeps growing).</p>
<p><strong>Null states and the logarithmic partner hypothesis:</strong></p>
<p>In RC literature, reservoir null states — directions in state space that don't contribute to a specific readout — are recognized as structurally necessary for the reservoir's dynamical richness. They're not dead weight; they maintain the high-dimensional manifold that ENABLES the separation property. This is exactly the logarithmic partner hypothesis from <a href="../inventory/entries/demo_84.html">D84</a>: bracket-null entries (Re(q) = 0 for some readout) look useless to that specific readout but maintain the S² directional vocabulary that enables XOR computation.</p>
<p><strong><a href="../inventory/entries/demo_87.html">D87</a> refinement:</strong> This hypothesis is REGIME-DEPENDENT. At finite groups (zeta_8, 24 entries), null states are indispensable — removing them destroys XOR8 capacity. At infinite groups (zeta_12, 4096 entries), null states are dispensable — removing 121 nulls has zero effect on XOR12 capacity. The transition mechanism is direction density: when non-null states alone provide enough S² coverage, null states become redundant scaffolding.</p>
<p><strong>No free lunch prediction — the k=6 sweet spot:</strong></p>
<p>RC has a no free lunch theorem: you can't maximize memory capacity and nonlinear processing capacity simultaneously. In DKC terms, this may explain the non-monotonic k=6 result from <a href="../inventory/entries/demo_50.html">D50</a> (906 solutions at k=6 &gt; 756 at k=7 &gt; 96 at k=8). Increasing k_sec trades angular resolution (more sectors = more precision) against effective dimensionality (too many sectors = most cells empty = wasted capacity). k=6 is the sweet spot where the tradeoff is optimized for the Z[ζ₈] lattice with its pi/4 angular structure.</p>
<p>If correct, this PREDICTS: the optimal k_sec for ζ₁₂ is different from ζ₈'s optimal k=6, because ζ₁₂ has 43 half-angles instead of 4 — it can "fill" more S¹ sectors before hitting diminishing returns.</p>
<p><strong><a href="../inventory/entries/demo_88.html">D88</a> confirmation:</strong> The k-ladder activation (8 k_sec values tested simultaneously) provides 14x better perturbation resilience than Voronoi-only activation (6.4% XOR loss vs 89% under the same design-improving gradient). The k-ladder IS a multi-scale readout that mitigates the no-free-lunch tradeoff by covering multiple resolution scales simultaneously.</p>
<p><strong>Memory capacity bound prediction:</strong></p>
<p>RC memory capacity bounds (Jaeger 2001) depend on reservoir dimensionality and spectral radius. The DKC analog: XOR capacity bounded by effective dimension of the catalog (number of independent directions × angular diversity), with the "spectral radius" being the group order or the number of distinct half-angles. The 11/13 theorem (two NPN classes unreachable by half-plane activation) might fall out of an RC separation bound applied to the specific dimensionality of the Z[ζ₈] catalog.</p>
<p><strong>Novel claim:</strong> Nobody has proposed braid groups as reservoirs. The braid group has the ideal properties for an algebraic reservoir: (1) the Yang-Baxter equation constrains dynamics without making them trivial, (2) the SU(2) representation provides a compact continuous state space (S³) from discrete sequential input, (3) the group structure (finite at ζ₈, infinite at ζ₁₂) directly controls computational capacity, and (4) the Hopf fibration S³→S² naturally separates the computational channel (S² base) from the inert channel (S¹ fiber).</p>
<p>---</p>
<h2>The Gap: What Nobody Has Done</h2>
<p>The five pillars each have rich literature in their respective domains: <ul> <li>Habiro's integrality is a standard result in quantum topology</li> <li>Nazer-Gastpar's compute-and-forward is widely cited in information theory</li> <li>Abramsky's TL-as-computation is well-known in categorical quantum mechanics</li> <li>Aizenberg's MVN is established in complex-valued neural network theory</li> <li>Reservoir computing is a major paradigm in recurrent neural network theory</li> </ul>
<p><strong>No paper in any of these fields cites papers from the other four.</strong> The intersection is genuinely unoccupied. Specifically:</p>
<p>1. Nobody has proposed using cyclotomic integers as neural network weight spaces (Habiro + Aizenberg) 2. Nobody has applied the compute-and-forward lattice framework to neural network weights (Nazer-Gastpar + Aizenberg) 3. Nobody has compiled topological invariants INTO weights as an alternative to training (Abramsky + Aizenberg, reversed direction) 4. Nobody has connected bracket evaluation rings to lattice coding theory (Habiro + Nazer-Gastpar) 5. Nobody has identified the TL planar lambda calculus as the computational substrate for forward DKC (Abramsky + Habiro) 6. Nobody has proposed braid groups as reservoirs for computation (Reservoir Computing + Abramsky + Habiro) 7. Nobody has connected reservoir memory capacity to knot crossing number (Reservoir Computing + Habiro) 8. Nobody has characterized an algebraic (non-random, non-physical) reservoir with provable capacity laws (Reservoir Computing + Nazer-Gastpar)</p>
<p><strong>Forward DKC assembles all five.</strong> The construction is:</p>
<p><code></code>` Abramsky: TL diagrams encode computation     ↓ (evaluate via state sum) Habiro: bracket values are cyclotomic integers     ↓ (use as NN weights) Aizenberg: roots-of-unity neurons compute Boolean functions     ↓ (ring structure guarantees exactness) Nazer-Gastpar: algebraic integer lattices support exact computation     ↓ (sequential crossing processing = reservoir dynamics) Reservoir Computing: braid depth determines computational capacity <code></code>`</p>
<p>This is the five-pillar chain. Each step is individually grounded in established mathematics. The assembly is novel.</p>
<p><strong>Circuit complexity connection (<a href="../inventory/entries/demo_92.html">D92</a>):</strong> The parity-lock theorem adds a sixth field to the intersection — circuit complexity. Parity is the canonical function outside AC^0 (Furst-Saxe-Sipser 1984, Hastad 1987). The +/-q encoding naturally concentrates all computational power on this hardest-possible function. The DKC framework computes parity WITHOUT gradient descent, WITHOUT constant-depth circuits — it uses the algebraic structure of the braid reservoir to bypass both the gradient hardness (<a href="../inventory/entries/demo_47.html">D47</a> lit.) and the circuit depth barrier. This is not a sixth pillar (circuit complexity does not contribute a constructive ingredient) but it is a uniquely strong validation: the framework naturally targets the function that is provably hardest for conventional approaches.</p>
<p>---</p>
<h2>Verification Status</h2>
<table><thead><tr><th>Pillar</th><th>Theoretically Grounded</th><th>Computationally Verified</th><th>Demo</th></tr></thead><tbody><tr><td>Habiro integrality</td><td>Proven (2002)</td><td>All bracket values in Z[ζ₈]</td><td><a href="../inventory/entries/demo_29.html">D29</a></td></tr><tr><td>Nazer-Gastpar exactness</td><td>Proven (2011)</td><td>Zero floating-point error in forward DKC</td><td><a href="../inventory/entries/demo_29.html">D29</a></td></tr><tr><td>Abramsky bridge</td><td>Proven (2007)</td><td>TL matrices produce same brackets as state-sum</td><td><a href="../inventory/entries/demo_35.html">D35</a></td></tr><tr><td>Abramsky non-semisimple</td><td>Proven (via Goodman-Wenzl/GRS)</td><td>b = -5/8 at TL_4, diverges at TL_6</td><td><a href="../inventory/entries/demo_85.html">D85</a>-<a href="../inventory/entries/demo_86.html">86</a></td></tr><tr><td>Aizenberg MVN</td><td>Proven (2000)</td><td>All 13 NPN classes at k=6 sectors</td><td><a href="../inventory/entries/demo_50.html">D50</a></td></tr><tr><td>Aizenberg not bottleneck</td><td>—</td><td>k_sec invariance of depth gap</td><td><a href="../inventory/entries/demo_91.html">D91</a></td></tr><tr><td>RC / braid reservoir</td><td>Established (2001)</td><td>max_xor ≈ depth+6; 82.8% echo state determinism</td><td><a href="../inventory/entries/demo_73.html">D73</a>, <a href="../inventory/entries/demo_82.html">D82</a></td></tr><tr><td>RC / null dispensability</td><td>—</td><td>Regime transition confirmed (zeta_8 vs zeta_12)</td><td><a href="../inventory/entries/demo_87.html">D87</a></td></tr><tr><td>RC / relational mechanism</td><td>—</td><td>Spectral inversion + axis cancellation</td><td><a href="../inventory/entries/demo_90.html">D90</a></td></tr><tr><td>RC / balanced exponentials</td><td>—</td><td>Activation invariance confirms supply/demand ratio</td><td><a href="../inventory/entries/demo_91.html">D91</a></td></tr><tr><td>Abramsky / Barrington radical</td><td>Proven (<a href="../inventory/entries/demo_102.html">D102</a>)</td><td>Radical = abelian writhe character; simple module wins at all XOR levels</td><td><a href="../inventory/entries/demo_102.html">D102</a></td></tr><tr><td>RC / BFS growth invariant</td><td>—</td><td>Identical BFS trees across all n=6 modules (5x5, 9x9)</td><td><a href="../inventory/entries/demo_102.html">D102</a>, <a href="../inventory/entries/demo_103.html">D103</a></td></tr><tr><td>RC / sign-hash = 1-bit CS</td><td>Established (Boufounos-Baraniuk 2008)</td><td>Sign-rank expansion 244→292; Atkinson sweet spot at 120/324</td><td><a href="../inventory/entries/demo_104.html">D104</a></td></tr><tr><td>RC / macrame principle</td><td>—</td><td>Cross-block wins at dim 5; within-block wins at dim 14</td><td><a href="../inventory/entries/demo_104.html">D104</a>, <a href="../inventory/entries/demo_105.html">D105</a></td></tr><tr><td>RC / entropy null</td><td>—</td><td>100% XOR participation for both periodic and pA braids</td><td><a href="../inventory/entries/demo_106.html">D106</a></td></tr><tr><td>Aizenberg / dual-channel</td><td>—</td><td>Product closure + v₂ connectivity predict parity capability</td><td><a href="../inventory/entries/demo_108.html">D108</a></td></tr><tr><td>Aizenberg / encoding dependence</td><td>—</td><td>Product closure polarity inverts between additive and multiplicative encoding</td><td><a href="../inventory/entries/demo_108.html">D108</a>, <a href="../inventory/entries/demo_109.html">D109</a></td></tr><tr><td><strong>Combined (forward DKC)</strong></td><td><strong>Novel thesis</strong></td><td><strong>65,536+ XOR triples, 906 parity solutions, XOR12 at ζ₁₂</strong></td><td><strong><a href="../inventory/entries/demo_29.html">D29</a>, <a href="../inventory/entries/demo_50.html">D50</a>, <a href="../inventory/entries/demo_79.html">D79</a></strong></td></tr><tr><td><strong>Parity-lock theorem</strong></td><td><strong>Proved (<a href="../inventory/entries/demo_92.html">D92</a>)</strong></td><td><strong>AND/OR/MAJ = 0 winners; XOR/XNOR only under +/-q</strong></td><td><strong><a href="../inventory/entries/demo_92.html">D92</a></strong></td></tr><tr><td><strong>Barrington-Radical Principle</strong></td><td><strong>Proved (<a href="../inventory/entries/demo_102.html">D102</a>)</strong></td><td><strong>Radical abelian → Barrington → useless for parity</strong></td><td><strong><a href="../inventory/entries/demo_102.html">D102</a></strong></td></tr><tr><td><strong>Dual-channel theorem</strong></td><td><strong>Novel (<a href="../inventory/entries/demo_108.html">D108</a>-<a href="../inventory/entries/demo_109.html">D109</a>)</strong></td><td><strong>Graph structure predicts parity; encoding flips polarity</strong></td><td><strong><a href="../inventory/entries/demo_108.html">D108</a>, <a href="../inventory/entries/demo_109.html">D109</a></strong></td></tr></tbody></table>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <script>hljs.highlightAll();</script>
</body>
</html>
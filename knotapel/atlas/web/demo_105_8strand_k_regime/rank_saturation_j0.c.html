<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>demo_105_8strand_k_regime/rank_saturation_j0.c</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <nav><a href="../index.html">‚Üê Back to Index</a></nav><hr>
    <h1>demo_105_8strand_k_regime/rank_saturation_j0.c</h1><pre><code class="language-c">/*
 * KNOTAPEL DEMO 105: W_{8,0} Rank Saturation Test
 * =================================================
 *
 * Companion to rank_saturation.c (W_{8,2}).
 * Tests whether W_{8,0}'s rank (274/784 = 34.9%) is saturated
 * or also growing with catalog entries like W_{8,2}.
 *
 * C89, zero dependencies.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

/* ================================================================ */
typedef struct { long a, b, c, d; } Cyc8;

static Cyc8 cyc8_make(long a, long b, long c, long d) {
    Cyc8 z; z.a=a; z.b=b; z.c=c; z.d=d; return z;
}
static Cyc8 cyc8_one(void) { return cyc8_make(1,0,0,0); }
static Cyc8 cyc8_add(Cyc8 x, Cyc8 y) {
    return cyc8_make(x.a+y.a, x.b+y.b, x.c+y.c, x.d+y.d);
}
static Cyc8 cyc8_mul(Cyc8 x, Cyc8 y) {
    return cyc8_make(
        x.a*y.a - x.b*y.d - x.c*y.c - x.d*y.b,
        x.a*y.b + x.b*y.a - x.c*y.d - x.d*y.c,
        x.a*y.c + x.b*y.b + x.c*y.a - x.d*y.d,
        x.a*y.d + x.b*y.c + x.c*y.b + x.d*y.a);
}
static int cyc8_eq(Cyc8 x, Cyc8 y) {
    return x.a==y.a &amp;&amp; x.b==y.b &amp;&amp; x.c==y.c &amp;&amp; x.d==y.d;
}

/* ================================================================ */
#define MAX_DIM 14
static int g_dim = 14;

typedef struct { Cyc8 m[MAX_DIM][MAX_DIM]; } MatN;

static MatN matN_zero(void) {
    MatN r; memset(&amp;r,0,sizeof(MatN)); return r;
}
static MatN matN_identity(void) {
    MatN r; int i; memset(&amp;r,0,sizeof(MatN));
    for(i=0;i&lt;g_dim;i++) r.m[i][i]=cyc8_one();
    return r;
}
static void matN_mul_to(const MatN *p, const MatN *q, MatN *out) {
    int i,j,k; memset(out,0,sizeof(MatN));
    for(i=0;i&lt;g_dim;i++)
        for(j=0;j&lt;g_dim;j++)
            for(k=0;k&lt;g_dim;k++)
                out-&gt;m[i][j]=cyc8_add(out-&gt;m[i][j],cyc8_mul(p-&gt;m[i][k],q-&gt;m[k][j]));
}
static int matN_eq(const MatN *p, const MatN *q) {
    int i,j;
    for(i=0;i&lt;g_dim;i++)
        for(j=0;j&lt;g_dim;j++)
            if(!cyc8_eq(p-&gt;m[i][j],q-&gt;m[i][j])) return 0;
    return 1;
}
static MatN matN_add(const MatN *p, const MatN *q) {
    MatN r; int i,j; memset(&amp;r,0,sizeof(MatN));
    for(i=0;i&lt;g_dim;i++)
        for(j=0;j&lt;g_dim;j++)
            r.m[i][j]=cyc8_add(p-&gt;m[i][j],q-&gt;m[i][j]);
    return r;
}
static MatN matN_scale(Cyc8 s, const MatN *p) {
    MatN r; int i,j; memset(&amp;r,0,sizeof(MatN));
    for(i=0;i&lt;g_dim;i++)
        for(j=0;j&lt;g_dim;j++)
            r.m[i][j]=cyc8_mul(s,p-&gt;m[i][j]);
    return r;
}
static long matN_max_abs(const MatN *m) {
    long mx=0,v; int i,j;
    for(i=0;i&lt;g_dim;i++)
        for(j=0;j&lt;g_dim;j++) {
            v=m-&gt;m[i][j].a; if(v&lt;0)v=-v; if(v&gt;mx)mx=v;
            v=m-&gt;m[i][j].b; if(v&lt;0)v=-v; if(v&gt;mx)mx=v;
            v=m-&gt;m[i][j].c; if(v&lt;0)v=-v; if(v&gt;mx)mx=v;
            v=m-&gt;m[i][j].d; if(v&lt;0)v=-v; if(v&gt;mx)mx=v;
        }
    return mx;
}

/* ================================================================ */
#define MAX_CAT 32768
#define HASH_SIZE 65537

static MatN *g_cat;
static int g_depth[MAX_CAT];
static int g_writhe[MAX_CAT];
static int g_cat_size = 0;

static int g_hash_head[HASH_SIZE];
static int g_hash_next[MAX_CAT];

static unsigned long hash_matN(const MatN *m) {
    unsigned long h = 2166136261UL; int i,j;
    for(i=0;i&lt;g_dim;i++)
        for(j=0;j&lt;g_dim;j++) {
            h=(h*1000003UL)^(unsigned long)m-&gt;m[i][j].a;
            h=(h*1000003UL)^(unsigned long)m-&gt;m[i][j].b;
            h=(h*1000003UL)^(unsigned long)m-&gt;m[i][j].c;
            h=(h*1000003UL)^(unsigned long)m-&gt;m[i][j].d;
        }
    return h;
}
static void hash_init(void) { memset(g_hash_head,-1,sizeof(g_hash_head)); }
static int hash_find(const MatN *m) {
    int bucket=(int)(hash_matN(m)%(unsigned long)HASH_SIZE);
    int idx=g_hash_head[bucket];
    while(idx&gt;=0) { if(matN_eq(&amp;g_cat[idx],m)) return idx; idx=g_hash_next[idx]; }
    return -1;
}
static void hash_insert(int ci) {
    int bucket=(int)(hash_matN(&amp;g_cat[ci])%(unsigned long)HASH_SIZE);
    g_hash_next[ci]=g_hash_head[bucket]; g_hash_head[bucket]=ci;
}

/* ================================================================
 * j=0 Link State Enumeration
 * ================================================================ */

#define N_STRANDS 8
#define MAX_LS 14

typedef struct { int pair[N_STRANDS]; } LS0;

static void enum_ls_recurse(int n, int *pair, LS0 *basis, int *count) {
    int first, k, j;
    for(first=0;first&lt;n;first++) { if(pair[first]==-1) break; }
    if(first&gt;=n) {
        memcpy(basis[*count].pair, pair, (size_t)n*sizeof(int));
        (*count)++;
        return;
    }
    for(k=first+1;k&lt;n;k++) {
        int ok=1;
        if((k-first-1)%2!=0) continue;
        for(j=first+1;j&lt;k;j++) { if(pair[j]!=-1){ok=0;break;} }
        if(!ok) continue;
        pair[first]=k; pair[k]=first;
        enum_ls_recurse(n,pair,basis,count);
        pair[first]=-1; pair[k]=-1;
    }
}

static int enumerate_ls_j0(LS0 *basis) {
    int pair[N_STRANDS]; int count=0;
    memset(pair,-1,sizeof(pair));
    enum_ls_recurse(N_STRANDS, pair, basis, &amp;count);
    return count;
}

static int apply_ei_j0(int ei, const LS0 *in, LS0 *out) {
    int a, b;
    if(in-&gt;pair[ei]==ei+1) return 0;
    a=in-&gt;pair[ei]; b=in-&gt;pair[ei+1];
    memcpy(out-&gt;pair, in-&gt;pair, (size_t)N_STRANDS*sizeof(int));
    out-&gt;pair[ei]=ei+1; out-&gt;pair[ei+1]=ei;
    out-&gt;pair[a]=b; out-&gt;pair[b]=a;
    return 1;
}

static int find_ls0_index(const LS0 *ls, const LS0 *basis, int dim) {
    int idx, j;
    for(idx=0;idx&lt;dim;idx++) {
        int eq=1;
        for(j=0;j&lt;N_STRANDS;j++) {
            if(basis[idx].pair[j]!=ls-&gt;pair[j]){eq=0;break;}
        }
        if(eq) return idx;
    }
    return -1;
}

/* ================================================================ */
#define N_TL 7
#define N_GEN 14

static MatN g_e[N_TL];
static MatN g_gen[N_GEN];
static int g_gen_writhe[N_GEN];

static void build_tl_generators_j0(LS0 *basis, int ls_dim) {
    int gen, col, target; LS0 out;
    for(gen=0;gen&lt;N_TL;gen++) {
        g_e[gen]=matN_zero();
        for(col=0;col&lt;ls_dim;col++) {
            if(apply_ei_j0(gen,&amp;basis[col],&amp;out)) {
                target=find_ls0_index(&amp;out,basis,ls_dim);
                if(target&gt;=0) g_e[gen].m[target][col]=cyc8_one();
            }
        }
    }
}

static void build_braid_generators(Cyc8 A, Cyc8 A_inv) {
    int i;
    MatN id_mat=matN_identity();
    MatN a_id=matN_scale(A,&amp;id_mat);
    MatN ai_id=matN_scale(A_inv,&amp;id_mat);
    for(i=0;i&lt;N_TL;i++) {
        MatN ai_e=matN_scale(A_inv,&amp;g_e[i]);
        MatN a_e=matN_scale(A,&amp;g_e[i]);
        g_gen[2*i]=matN_add(&amp;a_id,&amp;ai_e);
        g_gen[2*i+1]=matN_add(&amp;ai_id,&amp;a_e);
        g_gen_writhe[2*i]=1; g_gen_writhe[2*i+1]=-1;
    }
}

static void build_catalog(int max_depth) {
    int prev, gi, i, rd;
    MatN prod;
    g_cat_size=0; hash_init();
    g_cat[0]=matN_identity();
    g_depth[0]=0; g_writhe[0]=0;
    hash_insert(0); g_cat_size=1;
    printf("  Round 0: 1 entry\n");
    rd=1;
    do {
        long round_max=0;
        prev=g_cat_size;
        for(i=0;i&lt;prev&amp;&amp;g_cat_size&lt;MAX_CAT;i++) {
            if(g_depth[i]!=rd-1) continue;
            for(gi=0;gi&lt;N_GEN&amp;&amp;g_cat_size&lt;MAX_CAT;gi++) {
                long mabs;
                matN_mul_to(&amp;g_cat[i],&amp;g_gen[gi],&amp;prod);
                if(hash_find(&amp;prod)&lt;0) {
                    mabs=matN_max_abs(&amp;prod);
                    if(mabs&gt;round_max)round_max=mabs;
                    g_cat[g_cat_size]=prod;
                    g_depth[g_cat_size]=rd;
                    g_writhe[g_cat_size]=g_writhe[i]+g_gen_writhe[gi];
                    hash_insert(g_cat_size);
                    g_cat_size++;
                }
            }
        }
        if(g_cat_size&gt;prev)
            printf("  Round %d: %d entries (+%d), max_abs=%ld\n",
                   rd, g_cat_size, g_cat_size-prev, round_max);
        if(round_max&gt;100000000000L) break;
        rd++;
    } while(g_cat_size&gt;prev &amp;&amp; g_cat_size&lt;MAX_CAT &amp;&amp; rd&lt;=max_depth);
    if(g_cat_size==prev) printf("  GROUP CLOSED at %d entries\n",g_cat_size);
    else if(g_cat_size&gt;=MAX_CAT)
        printf("  HIT CAP at %d entries\n",MAX_CAT);
}

/* ================================================================
 * Rank computation with saturation reporting
 * ================================================================ */

#define MAX_COLS 784

static int compute_rank_checkpoints(int n_entries, int sign_mode,
                                    const int *cp, int n_cp) {
    static long basis_r[MAX_COLS][MAX_COLS];
    int n_cols = g_dim * g_dim * 4;
    int rank = 0, ei, col, r, cpi = 0;

    if(n_cols &gt; MAX_COLS) return -1;
    memset(basis_r, 0, sizeof(basis_r));

    for(ei=0; ei&lt;n_entries; ei++) {
        long row[MAX_COLS];
        int ci=0, i, j;
        memset(row, 0, sizeof(row));
        for(i=0;i&lt;g_dim;i++)
            for(j=0;j&lt;g_dim;j++) {
                if(sign_mode) {
                    row[ci++]=g_cat[ei].m[i][j].a&gt;0?2:(g_cat[ei].m[i][j].a&lt;0?0:1);
                    row[ci++]=g_cat[ei].m[i][j].b&gt;0?2:(g_cat[ei].m[i][j].b&lt;0?0:1);
                    row[ci++]=g_cat[ei].m[i][j].c&gt;0?2:(g_cat[ei].m[i][j].c&lt;0?0:1);
                    row[ci++]=g_cat[ei].m[i][j].d&gt;0?2:(g_cat[ei].m[i][j].d&lt;0?0:1);
                } else {
                    row[ci++]=g_cat[ei].m[i][j].a;
                    row[ci++]=g_cat[ei].m[i][j].b;
                    row[ci++]=g_cat[ei].m[i][j].c;
                    row[ci++]=g_cat[ei].m[i][j].d;
                }
            }

        for(r=0;r&lt;rank;r++) {
            int lead=-1;
            for(col=0;col&lt;n_cols;col++) {
                if(basis_r[r][col]!=0){lead=col;break;}
            }
            if(lead&lt;0) continue;
            if(row[lead]!=0) {
                long rf=row[lead], bf=basis_r[r][lead];
                for(col=0;col&lt;n_cols;col++)
                    row[col]=row[col]*bf-basis_r[r][col]*rf;
            }
        }

        {
            int is_zero=1;
            for(col=0;col&lt;n_cols;col++) {
                if(row[col]!=0){is_zero=0;break;}
            }
            if(!is_zero &amp;&amp; rank&lt;n_cols) {
                long g=0;
                for(col=0;col&lt;n_cols;col++) {
                    long v=row[col]&lt;0?-row[col]:row[col];
                    if(v&gt;0) {
                        if(g==0) g=v;
                        else {
                            long aa=g,bb=v;
                            while(bb!=0){long t=bb;bb=aa%bb;aa=t;}
                            g=aa;
                        }
                    }
                }
                if(g&gt;1) { for(col=0;col&lt;n_cols;col++) row[col]/=g; }
                for(col=0;col&lt;n_cols;col++) basis_r[rank][col]=row[col];
                rank++;
                if(rank&gt;=n_cols) break;
            }
        }

        while(cpi&lt;n_cp &amp;&amp; ei+1==cp[cpi]) {
            printf("    %6d entries: rank = %4d / %d (%.1f%%)\n",
                   cp[cpi], rank, n_cols,
                   100.0*(double)rank/(double)n_cols);
            cpi++;
        }
    }
    return rank;
}

/* ================================================================ */
int main(void) {
    LS0 basis[MAX_LS];
    int ls_dim;
    Cyc8 A, A_inv;
    int checkpoints[] = {128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768};
    int n_cp = 9;

    printf("KNOTAPEL DEMO 105: W_{8,0} Rank Saturation Test\n");
    printf("=================================================\n\n");

    g_cat = (MatN *)malloc((size_t)MAX_CAT * sizeof(MatN));
    if(!g_cat) { printf("FATAL: malloc failed\n"); return 1; }
    printf("  Catalog memory: %lu MB\n\n",
           (unsigned long)((size_t)MAX_CAT * sizeof(MatN) / (1024*1024)));

    A = cyc8_make(0,-1,0,0);
    A_inv = cyc8_make(0,0,0,1);

    printf("=== Setup: W_{8,0} (dim=14) ===\n\n");
    ls_dim = enumerate_ls_j0(basis);
    printf("  Link states: %d (expected C_4=14)\n", ls_dim);
    g_dim = ls_dim;

    build_tl_generators_j0(basis, ls_dim);
    build_braid_generators(A, A_inv);

    printf("\n=== BFS Catalog ===\n\n");
    build_catalog(12);

    printf("\n=== Raw Rank Saturation ===\n\n");
    printf("  Processing %d catalog entries:\n", g_cat_size);
    {
        int final_raw = compute_rank_checkpoints(g_cat_size, 0, checkpoints, n_cp);
        printf("  Final raw rank: %d / %d (%.1f%%)\n",
               final_raw, g_dim*g_dim*4,
               100.0*(double)final_raw/(double)(g_dim*g_dim*4));
    }

    printf("\n=== Sign-Rank Saturation ===\n\n");
    printf("  Processing %d catalog entries:\n", g_cat_size);
    {
        int final_sign = compute_rank_checkpoints(g_cat_size, 1, checkpoints, n_cp);
        printf("  Final sign-rank: %d / %d (%.1f%%)\n",
               final_sign, g_dim*g_dim*4,
               100.0*(double)final_sign/(double)(g_dim*g_dim*4));
    }

    printf("\n=================================================\n");
    printf("Done.\n");

    free(g_cat);
    return 0;
}
</code></pre>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <script>hljs.highlightAll();</script>
</body>
</html>
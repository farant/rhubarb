<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>demo_09_reidemeister/main.c</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <nav><a href="../index.html">‚Üê Back to Index</a></nav><hr>
    <h1>demo_09_reidemeister/main.c</h1><pre><code class="language-c">/*
 * KNOTAPEL DEMO 09: Reidemeister Move Invariance
 * ================================================
 *
 * HYPOTHESIS: The Kauffman bracket satisfies specific algebraic
 * relations under Reidemeister moves, and the Jones polynomial
 * (f-polynomial) is a true knot invariant, unchanged by all
 * three Reidemeister moves.
 *
 * Key relations:
 *   R1: bracket(K + kink_s) = -A^{3s} * bracket(K)
 *       writhe changes by s, Jones is invariant
 *   R2: bracket unchanged, writhe unchanged, Jones unchanged
 *   R3: bracket unchanged, writhe unchanged, Jones unchanged
 *
 * R1 and R2 are implemented at the PD level (apply_r1, apply_r2).
 * R3 is tested via the braid relation sigma_1*sigma_2*sigma_1
 * = sigma_2*sigma_1*sigma_2, which corresponds to R3.
 *
 * PLAN:
 *   Part A: R1 bracket relation (6 tests)
 *   Part B: R1 writhe and Jones invariance (6 tests)
 *   Part C: R2 bracket, writhe, and Jones invariance (11 tests)
 *   Part D: R3 via braid relation (4 tests)
 *   Part E: Combined move invariance (3 tests)
 *
 * C89 compliant, zero dependencies.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

/* ================================================================
 * Laurent polynomial ring (from Demo 08)
 * ================================================================ */
#define MAX_TERMS 64

typedef struct { int c[MAX_TERMS]; int lo, len; } Poly;

static void p_zero(Poly *p) { memset(p, 0, sizeof(Poly)); }

static void p_mono(Poly *p, int coeff, int exp) {
    p_zero(p);
    if (!coeff) return;
    p-&gt;lo = exp; p-&gt;len = 1; p-&gt;c[0] = coeff;
}

static void p_trim(Poly *p) {
    int a = 0, b;
    if (!p-&gt;len) return;
    while (a &lt; p-&gt;len &amp;&amp; !p-&gt;c[a]) a++;
    if (a == p-&gt;len) { p_zero(p); return; }
    b = p-&gt;len - 1;
    while (b &gt; a &amp;&amp; !p-&gt;c[b]) b--;
    if (a &gt; 0) memmove(p-&gt;c, p-&gt;c + a, (size_t)(b - a + 1) * sizeof(int));
    p-&gt;lo += a; p-&gt;len = b - a + 1;
}

static void p_add(Poly *r, const Poly *a, const Poly *b) {
    Poly t; int lo, hi, i;
    if (!a-&gt;len) { *r = *b; return; }
    if (!b-&gt;len) { *r = *a; return; }
    lo = a-&gt;lo &lt; b-&gt;lo ? a-&gt;lo : b-&gt;lo;
    hi = (a-&gt;lo + a-&gt;len - 1) &gt; (b-&gt;lo + b-&gt;len - 1)
       ? (a-&gt;lo + a-&gt;len - 1) : (b-&gt;lo + b-&gt;len - 1);
    p_zero(&amp;t); t.lo = lo; t.len = hi - lo + 1;
    for (i = 0; i &lt; a-&gt;len; i++) t.c[(a-&gt;lo + i) - lo] += a-&gt;c[i];
    for (i = 0; i &lt; b-&gt;len; i++) t.c[(b-&gt;lo + i) - lo] += b-&gt;c[i];
    p_trim(&amp;t); *r = t;
}

static void p_mul(Poly *r, const Poly *a, const Poly *b) {
    Poly t; int i, j;
    if (!a-&gt;len || !b-&gt;len) { p_zero(r); return; }
    p_zero(&amp;t); t.lo = a-&gt;lo + b-&gt;lo; t.len = a-&gt;len + b-&gt;len - 1;
    for (i = 0; i &lt; a-&gt;len; i++)
        for (j = 0; j &lt; b-&gt;len; j++)
            t.c[i + j] += a-&gt;c[i] * b-&gt;c[j];
    p_trim(&amp;t); *r = t;
}

static int p_eq(const Poly *a, const Poly *b) {
    if (a-&gt;len != b-&gt;len) return 0;
    if (!a-&gt;len) return 1;
    if (a-&gt;lo != b-&gt;lo) return 0;
    return memcmp(a-&gt;c, b-&gt;c, (size_t)a-&gt;len * sizeof(int)) == 0;
}

static void p_print(const Poly *p, const char *label) {
    int i, e, first;
    printf("%s = ", label);
    if (!p-&gt;len) { printf("0\n"); return; }
    first = 1;
    for (i = 0; i &lt; p-&gt;len; i++) {
        if (!p-&gt;c[i]) continue;
        e = p-&gt;lo + i;
        if (!first &amp;&amp; p-&gt;c[i] &gt; 0) printf(" + ");
        if (!first &amp;&amp; p-&gt;c[i] &lt; 0) printf(" - ");
        if (first &amp;&amp; p-&gt;c[i] &lt; 0) printf("-");
        first = 0;
        if (abs(p-&gt;c[i]) != 1 || e == 0) printf("%d", abs(p-&gt;c[i]));
        if (e == 1) printf("A");
        else if (e == -1) printf("A^-1");
        else if (e) printf("A^%d", e);
    }
    printf("\n");
}

/* ================================================================
 * PD notation and state-sum Kauffman bracket (from Demo 08)
 * ================================================================ */
#define MAX_X 20
#define MAX_ARCS 80

typedef struct { int arcs[4]; int sign; } Xing;
typedef struct { Xing x[MAX_X]; int n; int num_arcs; } Knot;

static int count_loops(const Knot *k, unsigned int state) {
    int app_x[MAX_ARCS][2], app_p[MAX_ARCS][2], app_n[MAX_ARCS];
    int pair[MAX_X][4], visited[MAX_ARCS];
    int i, j, loops, cur_arc, cur_side;
    memset(app_n, 0, sizeof(app_n));
    for (i = 0; i &lt; k-&gt;n; i++)
        for (j = 0; j &lt; 4; j++) {
            int arc = k-&gt;x[i].arcs[j];
            if (app_n[arc] &lt; 2) {
                app_x[arc][app_n[arc]] = i;
                app_p[arc][app_n[arc]] = j;
            }
            app_n[arc]++;
        }
    for (i = 0; i &lt; k-&gt;n; i++) {
        if ((state &gt;&gt; i) &amp; 1) {
            pair[i][0] = 1; pair[i][1] = 0;
            pair[i][2] = 3; pair[i][3] = 2;
        } else {
            pair[i][0] = 3; pair[i][3] = 0;
            pair[i][1] = 2; pair[i][2] = 1;
        }
    }
    memset(visited, 0, sizeof(visited));
    loops = 0;
    for (i = 0; i &lt; k-&gt;num_arcs; i++) {
        if (visited[i]) continue;
        cur_arc = i; cur_side = 0;
        while (!visited[cur_arc]) {
            int cx, pos, partner_pos, partner_arc, other_side;
            visited[cur_arc] = 1;
            cx = app_x[cur_arc][cur_side];
            pos = app_p[cur_arc][cur_side];
            partner_pos = pair[cx][pos];
            partner_arc = k-&gt;x[cx].arcs[partner_pos];
            if (app_x[partner_arc][0] == cx &amp;&amp; app_p[partner_arc][0] == partner_pos)
                other_side = 1;
            else
                other_side = 0;
            cur_arc = partner_arc;
            cur_side = other_side;
        }
        loops++;
    }
    return loops;
}

static void pd_bracket(Poly *result, const Knot *k) {
    unsigned int state, ns;
    int i, ac, bc, lp, j;
    Poly d, dp, term, contrib, t1, t2;
    p_zero(result);
    if (k-&gt;n == 0) { p_mono(result, 1, 0); return; }
    p_mono(&amp;t1, -1, 2); p_mono(&amp;t2, -1, -2); p_add(&amp;d, &amp;t1, &amp;t2);
    ns = 1u &lt;&lt; k-&gt;n;
    for (state = 0; state &lt; ns; state++) {
        ac = 0; bc = 0;
        for (i = 0; i &lt; k-&gt;n; i++) {
            if ((state &gt;&gt; i) &amp; 1) bc++; else ac++;
        }
        lp = count_loops(k, state);
        p_mono(&amp;term, 1, ac - bc);
        p_mono(&amp;dp, 1, 0);
        for (j = 0; j &lt; lp - 1; j++) p_mul(&amp;dp, &amp;dp, &amp;d);
        p_mul(&amp;contrib, &amp;term, &amp;dp);
        p_add(result, result, &amp;contrib);
    }
    p_trim(result);
}

/* ================================================================
 * Braid type and braid closure -&gt; PD notation (from Demo 07/08)
 * ================================================================ */
#define MAX_WORD 20
#define MAX_STRANDS 8

typedef struct { int word[MAX_WORD]; int len, n; } Braid;

static void braid_to_pd(const Braid *b, Knot *k) {
    int xing_list[MAX_STRANDS][MAX_WORD];
    int xing_side[MAX_STRANDS][MAX_WORD];
    int xing_count[MAX_STRANDS];
    int in_arc[MAX_X][2], out_arc[MAX_X][2];
    int arc_id, i, j, m, n;

    m = b-&gt;len; n = b-&gt;n;
    memset(xing_count, 0, sizeof(xing_count));

    for (i = 0; i &lt; m; i++) {
        int gen = b-&gt;word[i];
        int left = (gen &gt; 0 ? gen : -gen) - 1;
        int right = left + 1;
        xing_list[left][xing_count[left]] = i;
        xing_side[left][xing_count[left]] = 0;
        xing_count[left]++;
        xing_list[right][xing_count[right]] = i;
        xing_side[right][xing_count[right]] = 1;
        xing_count[right]++;
    }

    arc_id = 0;
    memset(in_arc, -1, sizeof(in_arc));
    memset(out_arc, -1, sizeof(out_arc));

    for (j = 0; j &lt; n; j++) {
        int cnt = xing_count[j];
        if (cnt == 0) continue;
        for (i = 0; i &lt; cnt; i++) {
            int cur_xing = xing_list[j][i];
            int cur_side = xing_side[j][i];
            int next_xing = xing_list[j][(i + 1) % cnt];
            int next_side = xing_side[j][(i + 1) % cnt];
            out_arc[cur_xing][cur_side] = arc_id;
            in_arc[next_xing][next_side] = arc_id;
            arc_id++;
        }
    }

    k-&gt;n = m; k-&gt;num_arcs = arc_id;

    for (i = 0; i &lt; m; i++) {
        int gen = b-&gt;word[i];
        int sign = gen &gt; 0 ? 1 : -1;
        int il = in_arc[i][0], ir = in_arc[i][1];
        int ol = out_arc[i][0], or_ = out_arc[i][1];

        if (sign &gt; 0) {
            k-&gt;x[i].arcs[0] = ir;  k-&gt;x[i].arcs[1] = or_;
            k-&gt;x[i].arcs[2] = ol;  k-&gt;x[i].arcs[3] = il;
        } else {
            k-&gt;x[i].arcs[0] = il;  k-&gt;x[i].arcs[1] = ir;
            k-&gt;x[i].arcs[2] = or_; k-&gt;x[i].arcs[3] = ol;
        }
        k-&gt;x[i].sign = sign;
    }
}

/* ================================================================
 * Known PD knots (from Demo 08)
 * ================================================================ */
static void make_trefoil_pd(Knot *k) {
    k-&gt;n = 3; k-&gt;num_arcs = 6;
    k-&gt;x[0].arcs[0]=0; k-&gt;x[0].arcs[1]=4; k-&gt;x[0].arcs[2]=1; k-&gt;x[0].arcs[3]=3; k-&gt;x[0].sign=1;
    k-&gt;x[1].arcs[0]=2; k-&gt;x[1].arcs[1]=0; k-&gt;x[1].arcs[2]=3; k-&gt;x[1].arcs[3]=5; k-&gt;x[1].sign=1;
    k-&gt;x[2].arcs[0]=4; k-&gt;x[2].arcs[1]=2; k-&gt;x[2].arcs[2]=5; k-&gt;x[2].arcs[3]=1; k-&gt;x[2].sign=1;
}

static void make_figure_eight_pd(Knot *k) {
    k-&gt;n = 4; k-&gt;num_arcs = 8;
    k-&gt;x[0].arcs[0]=3; k-&gt;x[0].arcs[1]=1; k-&gt;x[0].arcs[2]=4; k-&gt;x[0].arcs[3]=0; k-&gt;x[0].sign=1;
    k-&gt;x[1].arcs[0]=7; k-&gt;x[1].arcs[1]=5; k-&gt;x[1].arcs[2]=0; k-&gt;x[1].arcs[3]=4; k-&gt;x[1].sign=1;
    k-&gt;x[2].arcs[0]=5; k-&gt;x[2].arcs[1]=2; k-&gt;x[2].arcs[2]=6; k-&gt;x[2].arcs[3]=3; k-&gt;x[2].sign=-1;
    k-&gt;x[3].arcs[0]=1; k-&gt;x[3].arcs[1]=6; k-&gt;x[3].arcs[2]=2; k-&gt;x[3].arcs[3]=7; k-&gt;x[3].sign=-1;
}

static void make_hopf_pd(Knot *k) {
    k-&gt;n = 2; k-&gt;num_arcs = 4;
    k-&gt;x[0].arcs[0]=3; k-&gt;x[0].arcs[1]=0; k-&gt;x[0].arcs[2]=2; k-&gt;x[0].arcs[3]=1; k-&gt;x[0].sign=1;
    k-&gt;x[1].arcs[0]=1; k-&gt;x[1].arcs[1]=2; k-&gt;x[1].arcs[2]=0; k-&gt;x[1].arcs[3]=3; k-&gt;x[1].sign=1;
}

/* ================================================================
 * NEW: Writhe and Jones polynomial
 *
 * writhe(K) = sum of crossing signs
 * Jones: f(K) = (-A^3)^{-w} * bracket(K)
 * ================================================================ */
static int writhe(const Knot *k) {
    int i, w = 0;
    for (i = 0; i &lt; k-&gt;n; i++) w += k-&gt;x[i].sign;
    return w;
}

static void jones_poly(Poly *jones, const Knot *k) {
    Poly bracket, norm;
    int w;
    pd_bracket(&amp;bracket, k);
    w = writhe(k);
    p_mono(&amp;norm, (w % 2 == 0) ? 1 : -1, -3 * w);
    p_mul(jones, &amp;norm, &amp;bracket);
}

/* ================================================================
 * NEW: R1 -- Add a kink (twist) to an edge
 *
 * Splits edge into a1 (first occurrence) and a2 (second occurrence),
 * creates loop arc L.
 *
 * Positive kink: [a1, L, L, a2], sign = +1
 * Negative kink: [L, L, a1, a2], sign = -1
 *
 * Bracket: bracket(K') = -A^{3s} * bracket(K)
 * Writhe:  writhe(K') = writhe(K) + s
 * ================================================================ */

/* Replace second occurrence of old_arc with new_arc */
static void remap_second(Knot *k, int old_arc, int new_arc) {
    int i, j, count = 0;
    for (i = 0; i &lt; k-&gt;n; i++)
        for (j = 0; j &lt; 4; j++)
            if (k-&gt;x[i].arcs[j] == old_arc) {
                count++;
                if (count == 2) {
                    k-&gt;x[i].arcs[j] = new_arc;
                    return;
                }
            }
}

static void apply_r1(const Knot *k, int edge, int positive, Knot *out) {
    int a2, L;
    *out = *k;
    a2 = k-&gt;num_arcs;
    L  = k-&gt;num_arcs + 1;
    out-&gt;num_arcs = k-&gt;num_arcs + 2;

    remap_second(out, edge, a2);

    if (positive) {
        out-&gt;x[out-&gt;n].arcs[0] = edge;
        out-&gt;x[out-&gt;n].arcs[1] = L;
        out-&gt;x[out-&gt;n].arcs[2] = L;
        out-&gt;x[out-&gt;n].arcs[3] = a2;
        out-&gt;x[out-&gt;n].sign = 1;
    } else {
        out-&gt;x[out-&gt;n].arcs[0] = L;
        out-&gt;x[out-&gt;n].arcs[1] = L;
        out-&gt;x[out-&gt;n].arcs[2] = edge;
        out-&gt;x[out-&gt;n].arcs[3] = a2;
        out-&gt;x[out-&gt;n].sign = -1;
    }
    out-&gt;n++;
}

/* ================================================================
 * NEW: R2 -- Add a poke (pair of opposite crossings)
 *
 * Splits edge_a into (edge_a, a2) and edge_b into (edge_b, b2).
 * Creates intermediate arcs m1, m2.
 *
 * C_pos (+1): [edge_a, m2, m1, edge_b]
 * C_neg (-1): [m1, m2, a2, b2]
 *
 * Bracket: unchanged
 * Writhe:  unchanged (+1 and -1 cancel)
 * ================================================================ */
static void apply_r2(const Knot *k, int edge_a, int edge_b, Knot *out) {
    int a2, b2, m1, m2;
    *out = *k;
    a2 = k-&gt;num_arcs;
    b2 = k-&gt;num_arcs + 1;
    m1 = k-&gt;num_arcs + 2;
    m2 = k-&gt;num_arcs + 3;
    out-&gt;num_arcs = k-&gt;num_arcs + 4;

    remap_second(out, edge_a, a2);
    remap_second(out, edge_b, b2);

    /* Positive crossing */
    out-&gt;x[out-&gt;n].arcs[0] = edge_a;
    out-&gt;x[out-&gt;n].arcs[1] = m2;
    out-&gt;x[out-&gt;n].arcs[2] = m1;
    out-&gt;x[out-&gt;n].arcs[3] = edge_b;
    out-&gt;x[out-&gt;n].sign = 1;
    out-&gt;n++;

    /* Negative crossing */
    out-&gt;x[out-&gt;n].arcs[0] = m1;
    out-&gt;x[out-&gt;n].arcs[1] = m2;
    out-&gt;x[out-&gt;n].arcs[2] = a2;
    out-&gt;x[out-&gt;n].arcs[3] = b2;
    out-&gt;x[out-&gt;n].sign = -1;
    out-&gt;n++;
}

/* R2-poked unknot (manually constructed, unknot has no edges) */
static void make_r2_unknot(Knot *k) {
    k-&gt;n = 2; k-&gt;num_arcs = 4;
    /* C1 (+1): single loop passes under then over */
    k-&gt;x[0].arcs[0] = 0; k-&gt;x[0].arcs[1] = 3;
    k-&gt;x[0].arcs[2] = 1; k-&gt;x[0].arcs[3] = 2;
    k-&gt;x[0].sign = 1;
    /* C2 (-1): same loop, reversed crossing */
    k-&gt;x[1].arcs[0] = 3; k-&gt;x[1].arcs[1] = 1;
    k-&gt;x[1].arcs[2] = 0; k-&gt;x[1].arcs[3] = 2;
    k-&gt;x[1].sign = -1;
}

/* ================================================================
 * Test infrastructure
 * ================================================================ */
static int n_pass = 0, n_fail = 0;
static void check(const char *msg, int ok) {
    if (ok) { printf("  PASS: %s\n", msg); n_pass++; }
    else    { printf("  FAIL: %s\n", msg); n_fail++; }
}

/* ================================================================
 * PART A: R1 Bracket Relation (6 tests)
 *
 * bracket(K + kink_s) = -A^{3s} * bracket(K)
 * ================================================================ */
static void test_part_a(void) {
    Knot k, kinked;
    Poly br_orig, br_kink, factor, expected;

    printf("\n=== PART A: R1 Bracket Relation ===\n");
    printf("    bracket(K + kink_s) = -A^{3s} * bracket(K)\n\n");

    /* Unknot + positive kink: bracket = -A^3 */
    {
        Knot uk;
        Poly br;
        uk.n = 1; uk.num_arcs = 2;
        uk.x[0].arcs[0] = 0; uk.x[0].arcs[1] = 1;
        uk.x[0].arcs[2] = 1; uk.x[0].arcs[3] = 0;
        uk.x[0].sign = 1;
        pd_bracket(&amp;br, &amp;uk);
        p_mono(&amp;expected, -1, 3);
        p_print(&amp;br, "    &lt;unknot+pos_kink&gt;");
        check("unknot + pos kink: bracket = -A^3", p_eq(&amp;br, &amp;expected));
    }

    /* Unknot + negative kink: bracket = -A^{-3} */
    {
        Knot uk;
        Poly br;
        uk.n = 1; uk.num_arcs = 2;
        uk.x[0].arcs[0] = 0; uk.x[0].arcs[1] = 0;
        uk.x[0].arcs[2] = 1; uk.x[0].arcs[3] = 1;
        uk.x[0].sign = -1;
        pd_bracket(&amp;br, &amp;uk);
        p_mono(&amp;expected, -1, -3);
        p_print(&amp;br, "    &lt;unknot+neg_kink&gt;");
        check("unknot + neg kink: bracket = -A^{-3}", p_eq(&amp;br, &amp;expected));
    }

    /* Trefoil + positive kink */
    make_trefoil_pd(&amp;k);
    pd_bracket(&amp;br_orig, &amp;k);
    apply_r1(&amp;k, 0, 1, &amp;kinked);
    pd_bracket(&amp;br_kink, &amp;kinked);
    p_mono(&amp;factor, -1, 3);
    p_mul(&amp;expected, &amp;factor, &amp;br_orig);
    check("trefoil + pos kink: bracket = -A^3 * &lt;trefoil&gt;",
          p_eq(&amp;br_kink, &amp;expected));

    /* Trefoil + negative kink */
    apply_r1(&amp;k, 0, 0, &amp;kinked);
    pd_bracket(&amp;br_kink, &amp;kinked);
    p_mono(&amp;factor, -1, -3);
    p_mul(&amp;expected, &amp;factor, &amp;br_orig);
    check("trefoil + neg kink: bracket = -A^{-3} * &lt;trefoil&gt;",
          p_eq(&amp;br_kink, &amp;expected));

    /* Hopf + positive kink */
    make_hopf_pd(&amp;k);
    pd_bracket(&amp;br_orig, &amp;k);
    apply_r1(&amp;k, 0, 1, &amp;kinked);
    pd_bracket(&amp;br_kink, &amp;kinked);
    p_mono(&amp;factor, -1, 3);
    p_mul(&amp;expected, &amp;factor, &amp;br_orig);
    check("Hopf + pos kink: bracket = -A^3 * &lt;Hopf&gt;",
          p_eq(&amp;br_kink, &amp;expected));

    /* Hopf + negative kink */
    apply_r1(&amp;k, 0, 0, &amp;kinked);
    pd_bracket(&amp;br_kink, &amp;kinked);
    p_mono(&amp;factor, -1, -3);
    p_mul(&amp;expected, &amp;factor, &amp;br_orig);
    check("Hopf + neg kink: bracket = -A^{-3} * &lt;Hopf&gt;",
          p_eq(&amp;br_kink, &amp;expected));
}

/* ================================================================
 * PART B: R1 Writhe and Jones (6 tests)
 *
 * writhe(K + kink_s) = writhe(K) + s
 * Jones(K + kink_s) = Jones(K)
 * ================================================================ */
static void test_part_b(void) {
    Knot k, kinked;
    Poly jones_orig, jones_kink;
    int w_orig;

    printf("\n=== PART B: R1 Writhe and Jones ===\n");

    /* Trefoil */
    make_trefoil_pd(&amp;k);
    w_orig = writhe(&amp;k);
    jones_poly(&amp;jones_orig, &amp;k);
    p_print(&amp;jones_orig, "    Jones(trefoil)");

    apply_r1(&amp;k, 0, 1, &amp;kinked);
    check("trefoil + pos kink: writhe = w + 1",
          writhe(&amp;kinked) == w_orig + 1);
    jones_poly(&amp;jones_kink, &amp;kinked);
    check("trefoil + pos kink: Jones invariant",
          p_eq(&amp;jones_kink, &amp;jones_orig));

    apply_r1(&amp;k, 0, 0, &amp;kinked);
    check("trefoil + neg kink: writhe = w - 1",
          writhe(&amp;kinked) == w_orig - 1);
    jones_poly(&amp;jones_kink, &amp;kinked);
    check("trefoil + neg kink: Jones invariant",
          p_eq(&amp;jones_kink, &amp;jones_orig));

    /* Figure-eight */
    make_figure_eight_pd(&amp;k);
    jones_poly(&amp;jones_orig, &amp;k);

    apply_r1(&amp;k, 0, 1, &amp;kinked);
    jones_poly(&amp;jones_kink, &amp;kinked);
    check("fig-8 + pos kink: Jones invariant",
          p_eq(&amp;jones_kink, &amp;jones_orig));

    apply_r1(&amp;k, 0, 0, &amp;kinked);
    jones_poly(&amp;jones_kink, &amp;kinked);
    check("fig-8 + neg kink: Jones invariant",
          p_eq(&amp;jones_kink, &amp;jones_orig));
}

/* ================================================================
 * PART C: R2 Bracket, Writhe, and Jones Invariance (11 tests)
 *
 * All three quantities are unchanged under R2.
 * ================================================================ */
static void test_part_c(void) {
    Knot k, poked;
    Poly br_orig, br_poked, jones_orig, jones_poked;

    printf("\n=== PART C: R2 Invariance ===\n");

    /* R2-poked unknot */
    {
        Knot r2_uk;
        Poly br, j, one;
        make_r2_unknot(&amp;r2_uk);
        pd_bracket(&amp;br, &amp;r2_uk);
        p_mono(&amp;one, 1, 0);
        p_print(&amp;br, "    &lt;R2 unknot&gt;");
        check("R2 unknot: bracket = 1", p_eq(&amp;br, &amp;one));
        jones_poly(&amp;j, &amp;r2_uk);
        check("R2 unknot: Jones = 1", p_eq(&amp;j, &amp;one));
    }

    /* Trefoil + R2 (poke on edges 0, 2) */
    make_trefoil_pd(&amp;k);
    pd_bracket(&amp;br_orig, &amp;k);
    jones_poly(&amp;jones_orig, &amp;k);
    apply_r2(&amp;k, 0, 2, &amp;poked);
    pd_bracket(&amp;br_poked, &amp;poked);
    check("trefoil + R2: bracket unchanged", p_eq(&amp;br_poked, &amp;br_orig));
    check("trefoil + R2: writhe unchanged",
          writhe(&amp;poked) == writhe(&amp;k));
    jones_poly(&amp;jones_poked, &amp;poked);
    check("trefoil + R2: Jones unchanged",
          p_eq(&amp;jones_poked, &amp;jones_orig));

    /* Figure-eight + R2 */
    make_figure_eight_pd(&amp;k);
    pd_bracket(&amp;br_orig, &amp;k);
    jones_poly(&amp;jones_orig, &amp;k);
    apply_r2(&amp;k, 0, 2, &amp;poked);
    pd_bracket(&amp;br_poked, &amp;poked);
    check("fig-8 + R2: bracket unchanged", p_eq(&amp;br_poked, &amp;br_orig));
    jones_poly(&amp;jones_poked, &amp;poked);
    check("fig-8 + R2: Jones unchanged",
          p_eq(&amp;jones_poked, &amp;jones_orig));

    /* Hopf + R2 */
    make_hopf_pd(&amp;k);
    pd_bracket(&amp;br_orig, &amp;k);
    jones_poly(&amp;jones_orig, &amp;k);
    apply_r2(&amp;k, 0, 2, &amp;poked);
    pd_bracket(&amp;br_poked, &amp;poked);
    check("Hopf + R2: bracket unchanged", p_eq(&amp;br_poked, &amp;br_orig));
    jones_poly(&amp;jones_poked, &amp;poked);
    check("Hopf + R2: Jones unchanged",
          p_eq(&amp;jones_poked, &amp;jones_orig));
}

/* ================================================================
 * PART D: R3 via Braid Relation (4 tests)
 *
 * sigma_1 * sigma_2 * sigma_1 = sigma_2 * sigma_1 * sigma_2
 * corresponds to the R3 (slide) move at the PD level.
 * ================================================================ */
static void test_part_d(void) {
    Braid b1, b2;
    Knot k1, k2;
    Poly br1, br2, j1, j2;

    printf("\n=== PART D: R3 via Braid Relation ===\n");
    printf("    s1*s2*s1 = s2*s1*s2\n\n");

    /* Positive: s1 s2 s1 vs s2 s1 s2 on 3 strands */
    b1.n = 3; b1.len = 3;
    b1.word[0] = 1; b1.word[1] = 2; b1.word[2] = 1;
    b2.n = 3; b2.len = 3;
    b2.word[0] = 2; b2.word[1] = 1; b2.word[2] = 2;

    braid_to_pd(&amp;b1, &amp;k1);
    braid_to_pd(&amp;b2, &amp;k2);
    pd_bracket(&amp;br1, &amp;k1);
    pd_bracket(&amp;br2, &amp;k2);
    p_print(&amp;br1, "    &lt;s1s2s1&gt;");
    p_print(&amp;br2, "    &lt;s2s1s2&gt;");
    check("R3 (pos): s1*s2*s1 bracket == s2*s1*s2 bracket",
          p_eq(&amp;br1, &amp;br2));

    jones_poly(&amp;j1, &amp;k1);
    jones_poly(&amp;j2, &amp;k2);
    check("R3 (pos): s1*s2*s1 Jones == s2*s1*s2 Jones",
          p_eq(&amp;j1, &amp;j2));

    /* Negative: s1^-1 s2^-1 s1^-1 vs s2^-1 s1^-1 s2^-1 */
    b1.word[0] = -1; b1.word[1] = -2; b1.word[2] = -1;
    b2.word[0] = -2; b2.word[1] = -1; b2.word[2] = -2;

    braid_to_pd(&amp;b1, &amp;k1);
    braid_to_pd(&amp;b2, &amp;k2);
    pd_bracket(&amp;br1, &amp;k1);
    pd_bracket(&amp;br2, &amp;k2);
    check("R3 (neg): s1^-1*s2^-1*s1^-1 == s2^-1*s1^-1*s2^-1",
          p_eq(&amp;br1, &amp;br2));

    /* R3 in longer word: s1 s2 s1 s3 vs s2 s1 s2 s3 on 4 strands */
    b1.n = 4; b1.len = 4;
    b1.word[0] = 1; b1.word[1] = 2; b1.word[2] = 1; b1.word[3] = 3;
    b2.n = 4; b2.len = 4;
    b2.word[0] = 2; b2.word[1] = 1; b2.word[2] = 2; b2.word[3] = 3;

    braid_to_pd(&amp;b1, &amp;k1);
    braid_to_pd(&amp;b2, &amp;k2);
    pd_bracket(&amp;br1, &amp;k1);
    pd_bracket(&amp;br2, &amp;k2);
    check("R3 in context: s1*s2*s1*s3 == s2*s1*s2*s3 (4 strands)",
          p_eq(&amp;br1, &amp;br2));
}

/* ================================================================
 * PART E: Combined Move Invariance (3 tests)
 *
 * Multiple Reidemeister moves applied sequentially.
 * ================================================================ */
static void test_part_e(void) {
    Knot k, k1, k2;
    Poly br_orig, br_mod, jones_orig, jones_mod;

    printf("\n=== PART E: Combined Move Invariance ===\n");

    /* R1(+) then R1(-): bracket returns to original
     * (-A^3)(-A^{-3}) = 1, so factors cancel */
    make_trefoil_pd(&amp;k);
    pd_bracket(&amp;br_orig, &amp;k);
    apply_r1(&amp;k, 0, 1, &amp;k1);
    apply_r1(&amp;k1, 1, 0, &amp;k2);
    pd_bracket(&amp;br_mod, &amp;k2);
    check("trefoil + R1(+) + R1(-): bracket unchanged",
          p_eq(&amp;br_mod, &amp;br_orig));

    /* R1 then R2: Jones unchanged */
    make_trefoil_pd(&amp;k);
    jones_poly(&amp;jones_orig, &amp;k);
    apply_r1(&amp;k, 0, 1, &amp;k1);
    apply_r2(&amp;k1, 1, 3, &amp;k2);
    jones_poly(&amp;jones_mod, &amp;k2);
    check("trefoil + R1 + R2: Jones unchanged",
          p_eq(&amp;jones_mod, &amp;jones_orig));

    /* Double R1(+): Jones unchanged */
    make_figure_eight_pd(&amp;k);
    jones_poly(&amp;jones_orig, &amp;k);
    apply_r1(&amp;k, 0, 1, &amp;k1);
    apply_r1(&amp;k1, 2, 1, &amp;k2);
    jones_poly(&amp;jones_mod, &amp;k2);
    check("fig-8 + double R1(+): Jones unchanged",
          p_eq(&amp;jones_mod, &amp;jones_orig));
}

/* ================================================================ */

int main(void) {
    printf("KNOTAPEL DEMO 09: Reidemeister Move Invariance\n");
    printf("================================================\n");

    test_part_a();
    test_part_b();
    test_part_c();
    test_part_d();
    test_part_e();

    printf("\n================================================\n");
    printf("Results: %d passed, %d failed\n", n_pass, n_fail);
    printf("================================================\n");
    return n_fail &gt; 0 ? 1 : 0;
}
</code></pre>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <script>hljs.highlightAll();</script>
</body>
</html>
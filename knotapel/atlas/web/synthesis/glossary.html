<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>synthesis/glossary.md</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <nav><a href="../index.html">‚Üê Back to Index</a></nav><hr>
    <h1>DKC Glossary</h1>
<p>Alphabetical glossary of key terms used across the knotapel atlas. Each entry is self-contained.</p>
<p>---</p>
<h2>11/13 Theorem (Half-Plane Theorem)</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>When you classify outputs using a simple dividing line (half-plane), exactly 11 of the 13 possible Boolean function types are computable -- the same two always fail, no matter which root of unity you use.</td></tr><tr><td class="glossary-label">Precise</td><td>For all half-plane activations on multiplicative encodings z(a,b,c) = w1^a <em> w2^b </em> w3^c with Z[zeta_N] weights, exactly 11 of 13 non-trivial NPN classes are reachable; 0x06 (XOR-AND) and 0x1B (CROSS) are unreachable, independent of evaluation level ell.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_61.html">D61</a> (computational proof), <a href="../inventory/entries/demo_62.html">D62</a> (analytical proof).</td></tr><tr><td class="glossary-label">See also</td><td>NPN Classification, Activation Function, Complement-Blindness Theorem.</td></tr></tbody></table>
<p>---</p>
<h2>13=13 Bandwidth Theorem</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>The number of distinct rotation-axis directions produced by the braid group (13) exactly matches the number of independent components at spherical harmonic bandwidth l=6 (2<em>6+1=13), creating a sharp all-or-nothing phase transition at that bandwidth.</td></tr><tr><td class="glossary-label">Precise</td><td>The minimum spherical harmonic bandwidth for XOR6 DKC on S^2 is l=6, because mode l has 2l+1 independent components and 2</em>6+1=13 equals the eigenvector direction count of the binary octahedral group; recovery is 0% at l&lt;=5 and 100% at l=6.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_71.html">D71</a>.</td></tr><tr><td class="glossary-label">See also</td><td>S^2 Sweet Spot, Hopf Fibration, 24-Cell.</td></tr></tbody></table>
<p>---</p>
<h2>24-Cell</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>A four-dimensional shape with 24 vertices that naturally emerges from the braid group's quaternion representation -- its vertices are exactly the distinct quaternion states produced by braids at zeta_8.</td></tr><tr><td class="glossary-label">Precise</td><td>The 24 vertices of the regular 24-cell in S^3 are the elements of the binary octahedral group 2O, which is exactly the image of the SU(2) braid representation at A = e^{i<em>5</em>pi/4}; the k=24 minimum sector count for generalized XOR6 on S^1 (<a href="../inventory/entries/demo_65.html">D65</a>) is the trace projection of these 24 vertices.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_66.html">D66</a>.</td></tr><tr><td class="glossary-label">See also</td><td>Hopf Fibration, S^2 Sweet Spot, Binary Octahedral Group.</td></tr></tbody></table>
<p>---</p>
<h2>Activation Function</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>The rule that decides how to read a neuron's complex-valued output -- different rules make different Boolean functions computable from the same set of weights.</td></tr><tr><td class="glossary-label">Precise</td><td>A map from the complex plane (or S^3) to a discrete label set; the choice of activation (split-sigmoid, k-sector MVN, half-plane, S^2 Voronoi, S^1 x S^2 product) determines which subset of NPN classes is accessible from a fixed bracket catalog. The lattice is fixed; the activation selects.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_27.html">D27</a> (split-sigmoid), <a href="../inventory/entries/demo_47.html">D47</a> (MVN), <a href="../inventory/entries/demo_50.html">D50</a> (k-sector), <a href="../inventory/entries/demo_67.html">D67</a> (S^2 Voronoi), <a href="../inventory/entries/demo_77.html">D77</a> (S^1 x S^2 product).</td></tr><tr><td class="glossary-label">See also</td><td>k-Sector MVN, Wall Pattern, NPN Classification.</td></tr></tbody></table>
<p>---</p>
<h2>Axiality Theorem</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>At delta=0, every Kauffman bracket value points along exactly one of 8 directions in the complex plane -- no bracket value ever uses more than one direction at once.</td></tr><tr><td class="glossary-label">Precise</td><td>At delta=0 (A = e^{i<em>5</em>pi/4}), for any braid, the Kauffman bracket is axial: &lt;K&gt; = n * A^c for integer n and c in {0,...,7}; the Z[zeta_8] representation has at most one nonzero component. Verified exhaustively for ~131K braids with zero counterexamples.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_35.html">D35</a>.</td></tr><tr><td class="glossary-label">See also</td><td>Z[zeta_8], Delta=0, Z/4Z Axis-Alignment Theorem.</td></tr></tbody></table>
<p>---</p>
<h2>Barrington's Theorem</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>A deep result from computational complexity: any function computable by a small Boolean circuit can be computed by a sequence of permutation-group multiplications, but only if the group is non-abelian (non-commutative). Abelian groups provably cannot compute parity.</td></tr><tr><td class="glossary-label">Precise</td><td>Barrington (1989): width-5 branching programs over S_5 simulate NC^1; by contrapositive, abelian groups cannot compute parity. Applied to DKC: the radical of a non-semisimple TL module carries an abelian character (writhe homomorphism B_n -&gt; Z/8Z), proving the radical direction is useless for XOR.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_94.html">D94</a> (connection identified), <a href="../inventory/entries/demo_102.html">D102</a> (Barrington-Radical Principle named and proved).</td></tr><tr><td class="glossary-label">See also</td><td>Radical, Non-Semisimplicity, Writhe.</td></tr></tbody></table>
<p>---</p>
<h2>BFS Catalog</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>The full set of distinct bracket values obtained by systematically multiplying braid generators round by round (breadth-first search through the braid group), organized by how many multiplications (depth) were needed.</td></tr><tr><td class="glossary-label">Precise</td><td>The catalog of distinct Z[zeta_N] bracket values (or SU(2) quaternions) obtained from BFS closure of the braid generators sigma_1, ..., sigma_{n-1} and their inverses, indexed by depth (number of generator multiplications). At zeta_8 with 2 strands: 24 entries over 3 rounds; at zeta_12: 4096+ entries over 8 rounds.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_29.html">D29</a> (first Z[zeta_8] catalog), <a href="../inventory/entries/demo_79.html">D79</a> (zeta_12 catalog), <a href="../inventory/entries/demo_82.html">D82</a> (depth indexing).</td></tr><tr><td class="glossary-label">See also</td><td>Crossing Depth, Log Law, Reservoir Computing.</td></tr></tbody></table>
<p>---</p>
<h2>Bracket Polynomial (Kauffman)</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>A recipe that assigns a polynomial to any knot or link diagram by summing over all possible ways to smooth its crossings, weighted by a formal variable A.</td></tr><tr><td class="glossary-label">Precise</td><td>The Kauffman bracket &lt;K&gt; is a state-sum invariant: enumerate all 2^n smoothings of n crossings, weight each by A^{sigma} * delta^{loops-1} where sigma counts A-type minus B-type smoothings and delta = -(A^2 + A^{-2}); the result is a Laurent polynomial in A, invariant under Reidemeister moves II and III.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_01.html">D01</a> (state-sum oracle), <a href="../inventory/entries/demo_02.html">D02</a> (braid-word computation).</td></tr><tr><td class="glossary-label">See also</td><td>State Sum, Delta=0, Kauffman Bracket.</td></tr></tbody></table>
<p>---</p>
<h2>Braid Group</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>The mathematical group of ways to interweave n strands, where each crossing (one strand passing over another) is a generator, and two braids are equivalent if one can be continuously deformed into the other.</td></tr><tr><td class="glossary-label">Precise</td><td>B_n is generated by sigma_1, ..., sigma_{n-1} with relations sigma_i<em>sigma_{i+1}</em>sigma_i = sigma_{i+1}<em>sigma_i</em>sigma_{i+1} (Yang-Baxter) and sigma_i<em>sigma_j = sigma_j</em>sigma_i for |i-j| &gt;= 2. Braid words are the sequential input to the DKC reservoir; crossing count = depth.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_01.html">D01</a>-<a href="../inventory/entries/demo_09.html">D09</a> (foundation arc).</td></tr><tr><td class="glossary-label">See also</td><td>Temperley-Lieb Algebra, Crossing Depth, Reservoir Computing.</td></tr></tbody></table>
<p>---</p>
<h2>Complement-Blindness Theorem</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>When you combine magnitude and phase information into a single classification cell, it can no longer distinguish a Boolean input from its bitwise complement -- it merges m with ~m. Separating phase into its own cell recovers all 13 function types.</td></tr><tr><td class="glossary-label">Precise</td><td>The combined_cell activation maps bitwise-complement input pairs (m, ~m) to the same cell; the resulting truth table can represent at most 11 NPN classes. The phase_cell (phase information alone) recovers all 13 NPN classes, proving the circuit complexity hierarchy AND/XOR ratio = 1 -&gt; 2762 -&gt; infinity (N=3 -&gt; 8).</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_93.html">D93</a>.</td></tr><tr><td class="glossary-label">See also</td><td>NPN Classification, 11/13 Theorem, Parity-Lock Theorem.</td></tr></tbody></table>
<p>---</p>
<h2>Crossing Depth</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>How many crossings (braid generator multiplications) were needed to produce a given bracket value -- deeper entries required more complex braids and carry more computational power.</td></tr><tr><td class="glossary-label">Precise</td><td>The BFS birth round of a catalog entry: the minimum number of braid generator multiplications needed to produce it. The linear depth law max_xor ~ depth + 6 says XOR capacity scales linearly with crossing depth, and this is the fundamental scaling variable (the log law is a corollary).</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_82.html">D82</a>.</td></tr><tr><td class="glossary-label">See also</td><td>BFS Catalog, Log Law, Reservoir Computing, Balanced Exponentials.</td></tr></tbody></table>
<p>---</p>
<h2>Cyclotomic Integer</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>A number built by adding and multiplying ordinary integers with roots of unity (special complex numbers on the unit circle whose powers eventually equal 1) -- these are exact, with no rounding error.</td></tr><tr><td class="glossary-label">Precise</td><td>An element of the ring Z[zeta_N] = Z[e^{2<em>pi</em>i/N}], the ring of integers of the cyclotomic field Q(zeta_N). DKC uses Z[zeta_8] (primary, delta=0), Z[zeta_16] (delta=sqrt(2)), Z[zeta_5] (delta=phi), and Z[zeta_24] (delta=sqrt(3)). All arithmetic is exact integer arithmetic on coefficient tuples.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_27.html">D27</a> (identification), <a href="../inventory/entries/demo_29.html">D29</a> (exact arithmetic implemented).</td></tr><tr><td class="glossary-label">See also</td><td>Z[zeta_8], Z[zeta_12], Z[zeta_16], Habiro.</td></tr></tbody></table>
<p>---</p>
<h2>Delta=0</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>The special evaluation point where the loop value in the Kauffman bracket is zero, meaning any diagram state with more than one closed loop contributes nothing -- only single-loop states survive, making everything simpler and exact.</td></tr><tr><td class="glossary-label">Precise</td><td>At A = e^{i<em>5</em>pi/4}, delta = -(A^2 + A^{-2}) = 0 exactly. The state sum reduces to single-loop states only. TL generators satisfy e_i^2 = 0 (nilpotent). The algebra is non-semisimple for even n (alternating semisimplicity). This is the primary DKC evaluation point.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_29.html">D29</a>.</td></tr><tr><td class="glossary-label">See also</td><td>Axiality Theorem, Non-Semisimplicity, Sandwich Theorem.</td></tr></tbody></table>
<p>---</p>
<h2>DKC (Discrete Knotted Computation)</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>The central thesis of this research: topological invariants from knot theory can be directly compiled into neural network weights that compute Boolean functions without any training.</td></tr><tr><td class="glossary-label">Precise</td><td>Forward DKC: evaluate the Kauffman bracket at a root of unity to obtain cyclotomic integer values, use these as weights in a complex-valued neuron with an appropriate activation function; the algebraic structure of the bracket guarantees correct Boolean computation without gradient descent. Reverse DKC: decompose trained neural network weights back into bracket values.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_26.html">D26</a>-<a href="../inventory/entries/demo_29.html">D29</a> (reverse then forward).</td></tr><tr><td class="glossary-label">See also</td><td>Forward DKC, Bracket Polynomial, Five Pillars.</td></tr></tbody></table>
<p>---</p>
<h2>Dual-Channel Theorem</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>For a set of bracket values to be capable of computing parity, it needs two things simultaneously: its values must be able to multiply into each other (phase coherence) AND they must span enough different magnitudes (magnitude diversity). Missing either one kills parity.</td></tr><tr><td class="glossary-label">Precise</td><td>Parity capability requires both (1) nonzero product closure (multiplicative channel: products of values remain in the vocabulary) and (2) nontrivial v_2 connectivity (additive channel: magnitude diversity across 2-adic valuation classes). Maps onto the T-gate/Hadamard decomposition of quantum circuit synthesis (Amy-Glaudell-Ross 2023). Polarity of the multiplicative channel is encoding-dependent (<a href="../inventory/entries/demo_109.html">D109</a>).</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_108.html">D108</a> (delta=0), <a href="../inventory/entries/demo_109.html">D109</a> (delta=sqrt(2), encoding dependence).</td></tr><tr><td class="glossary-label">See also</td><td>Parity-Lock Theorem, Product Closure, Z[zeta_8].</td></tr></tbody></table>
<p>---</p>
<h2>Encoding</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>How Boolean input bits are translated into complex numbers before being processed -- different translation rules make different functions computable.</td></tr><tr><td class="glossary-label">Precise</td><td>The map from {0,1}^n to weight selections. Three encodings studied: (1) 1-weight-per-input (1wpi): each input bit selects one catalog entry independently, all 13 NPN classes accessible (<a href="../inventory/entries/demo_48.html">D48</a>/<a href="../inventory/entries/demo_50.html">D50</a>); (2) +/-q paired: each weight contributes +q, -q, or 0, structurally parity-locked (<a href="../inventory/entries/demo_92.html">D92</a>); (3) multiplicative: z(a,b,c) = w1^a <em> w2^b </em> w3^c, 11/13 classes under half-plane (<a href="../inventory/entries/demo_61.html">D61</a>-<a href="../inventory/entries/demo_62.html">D62</a>). Encoding determines function.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_29.html">D29</a> (1wpi), <a href="../inventory/entries/demo_61.html">D61</a> (multiplicative), <a href="../inventory/entries/demo_92.html">D92</a> (+/-q).</td></tr><tr><td class="glossary-label">See also</td><td>Parity-Lock Theorem, Activation Function, NPN Classification.</td></tr></tbody></table>
<p>---</p>
<h2>Ext^1 (Extension Groups)</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>A measure of how two algebraic modules can be glued together in nontrivial ways -- when Ext^1 is nonzero, the gluing creates indecomposable structures (modules that cannot be split apart) which carry computational load.</td></tr><tr><td class="glossary-label">Precise</td><td>Ext^1_{TL}(L_i, L_j) measures non-split extensions between simple TL modules. When nonzero, it produces indecomposable modules with radical structure. <a href="../inventory/entries/demo_99.html">D99</a>-<a href="../inventory/entries/demo_101.html">D101</a> demonstrate that non-semisimple extensions (Ext^1 nonzero) are computationally load-bearing: W_{4,2} (radical, <a href="../inventory/entries/demo_100.html">D100</a>) achieves XOR14=70 while W_{5,3} (simple, <a href="../inventory/entries/demo_101.html">D101</a>) caps at XOR12.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_99.html">D99</a>-<a href="../inventory/entries/demo_101.html">D101</a>.</td></tr><tr><td class="glossary-label">See also</td><td>Non-Semisimplicity, Radical, Module.</td></tr></tbody></table>
<p>---</p>
<h2>Five Pillars</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>The five established fields whose intersection defines DKC -- Habiro (bracket values are algebraic integers), Nazer-Gastpar (algebraic lattices compute), Abramsky (TL diagrams encode computation), Aizenberg (roots-of-unity neurons), and Reservoir Computing (fixed dynamics compute through structure).</td></tr><tr><td class="glossary-label">Precise</td><td>The five-pillar chain: Abramsky (TL = computation) -&gt; Habiro (bracket values in Z[zeta_N]) -&gt; Aizenberg (MVN readout) -&gt; Nazer-Gastpar (ring structure guarantees exactness) -&gt; Reservoir Computing (braid depth = memory capacity). No paper in any field cites papers from the other four. The intersection is genuinely unoccupied.</td></tr><tr><td class="glossary-label">Introduced</td><td>Synthesized across <a href="../inventory/entries/demo_29.html">D29</a>-<a href="../inventory/entries/demo_94.html">D94</a>; Pillar 5 added after <a href="../inventory/entries/demo_73.html">D73</a>/<a href="../inventory/entries/demo_82.html">D82</a>.</td></tr><tr><td class="glossary-label">See also</td><td>DKC, Reservoir Computing, Temperley-Lieb Algebra.</td></tr></tbody></table>
<p>---</p>
<h2>Forward DKC</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>The "forward" direction of DKC: start from knot topology, compute bracket values, and discover they already work as neural network weights for Boolean functions -- no training needed.</td></tr><tr><td class="glossary-label">Precise</td><td>Exact Z[zeta_8] bracket values at A = e^{i<em>5</em>pi/4} compute XOR (and other Boolean functions) without training. 100+ valid XOR triples found with RMS = 0.000 from exact bracket values with gauge rotation. First confirmed in <a href="../inventory/entries/demo_29.html">D29</a> (LANDMARK).</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_29.html">D29</a>.</td></tr><tr><td class="glossary-label">See also</td><td>DKC, BFS Catalog, Z[zeta_8].</td></tr></tbody></table>
<p>---</p>
<h2>Framing Cost</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>The Jones polynomial normalization removes a writhe-dependent phase factor from the bracket; this removal costs exactly 2 XOR levels of computational capacity at every root of unity tested.</td></tr><tr><td class="glossary-label">Precise</td><td>Jones normalization divides by (-A^3)^{-writhe}, absorbing the Reidemeister I framing anomaly. This destroys exactly 2 XOR levels: zeta_12 bracket XOR12 -&gt; Jones XOR10; zeta_8 bracket XOR8 -&gt; Jones XOR6. The TQFT framing anomaly that physicists normalize away is precisely what DKC uses for computation.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_83.html">D83</a>.</td></tr><tr><td class="glossary-label">See also</td><td>Writhe, Crossing Depth, Bracket Polynomial.</td></tr></tbody></table>
<p>---</p>
<h2>Hopf Fibration</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>A way of decomposing the 3-sphere (S^3, where unit quaternions live) into a 2-sphere base (S^2, rotation axes) and circular fibers (S^1, phases) -- in DKC, all computation lives on the base and the fiber is completely inert.</td></tr><tr><td class="glossary-label">Precise</td><td>The Hopf map S^3 -&gt; S^2 sends a unit quaternion to its rotation axis. The S^1 fiber (Hopf phase xi_1) carries zero DKC information (zero XOR6 solutions at all k=4..32, r=-0.06 with spatial direction). The S^2 base carries all computational content. Music maps to fiber (pitch); logic maps to base (direction).</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_67.html">D67</a> (fiber inertness proved), <a href="../inventory/entries/demo_70.html">D70</a> (music-space orthogonality confirmed).</td></tr><tr><td class="glossary-label">See also</td><td>S^2 Sweet Spot, 24-Cell, 13=13 Bandwidth Theorem.</td></tr></tbody></table>
<p>---</p>
<h2>Hub (Super-Hub)</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>A bracket value that appears in an unusually large number of valid Boolean function solutions -- the most versatile weights in the catalog, typically found at intermediate depths.</td></tr><tr><td class="glossary-label">Precise</td><td>Catalog entries with high participation rates across winning tuples. In the S^2 Voronoi framework, a "super-hub" is a direction appearing in a disproportionate fraction of XOR solutions. The hub structure reflects the relational nature of DKC: hubs are values that combine well with many partners, not values that are individually special.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_48.html">D48</a>-<a href="../inventory/entries/demo_50.html">D50</a> (participation analysis), <a href="../inventory/entries/demo_88.html">D88</a> (rigid anchors vs flexible scaffolding).</td></tr><tr><td class="glossary-label">See also</td><td>BFS Catalog, Null State, Relational Computation.</td></tr></tbody></table>
<p>---</p>
<h2>k-Sector MVN</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>An activation function that divides the complex plane into k equal pie-slice sectors and classifies outputs by which sector they land in -- at k=6 sectors, parity becomes computable from the same catalog that was hopeless under simpler activations.</td></tr><tr><td class="glossary-label">Precise</td><td>Aizenberg's multi-valued neuron activation partitioning the complex plane into k angular sectors of width 2*pi/k. At k=6 with Z[zeta_8] weights: all 13 NPN classes computable, parity achieved with 906 solutions. Solution count is non-monotonic in k (906@k=6 &gt; 756@k=7 &gt; 96@k=8) due to incommensurability with the pi/4 lattice structure.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_50.html">D50</a>.</td></tr><tr><td class="glossary-label">See also</td><td>Activation Function, Triskelion Principle, Parity Wall.</td></tr></tbody></table>
<p>---</p>
<h2>Kauffman Bracket</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>See Bracket Polynomial. "Kauffman bracket" and "bracket polynomial" are used interchangeably throughout the project.</td></tr><tr><td class="glossary-label">Precise</td><td>&lt;K&gt;(A) = sum over smoothing states of A^{sigma(s)} * delta^{loops(s)-1}. Distinguished from the Jones polynomial by the absence of writhe normalization.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_01.html">D01</a>.</td></tr><tr><td class="glossary-label">See also</td><td>Bracket Polynomial, State Sum, Delta=0.</td></tr></tbody></table>
<p>---</p>
<h2>Link State (Planar Matching)</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>A pattern of non-crossing arcs connecting pairs of boundary points -- these are the basis elements of the Temperley-Lieb algebra, representing ways strands can reconnect after smoothing crossings.</td></tr><tr><td class="glossary-label">Precise</td><td>A planar perfect matching on 2n boundary points: n non-crossing arcs. These form the standard basis for TL_n. The number of link states at strand count n is the Catalan number C_n. Through-strand count j partitions link states into cellular sectors with d(n,j)^2 basis elements each.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_01.html">D01</a> (implicit), <a href="../inventory/entries/demo_03.html">D03</a> (explicit TL basis), <a href="../inventory/entries/demo_39.html">D39</a> (cellular decomposition).</td></tr><tr><td class="glossary-label">See also</td><td>Temperley-Lieb Algebra, Planar Matching, State Sum.</td></tr></tbody></table>
<p>---</p>
<h2>Log Law</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>The maximum XOR arity (number of inputs) computable from a bracket catalog scales logarithmically with catalog size -- a corollary of the more fundamental linear depth law.</td></tr><tr><td class="glossary-label">Precise</td><td>max_xor ~ 0.62 * log_2(catalog_size) + 4.6 (measured at zeta_12). This is a corollary of the linear depth law (max_xor ~ depth + 6) combined with exponential BFS growth (~2x entries per depth round), giving log_2(catalog) ~ depth.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_81.html">D81</a> (discovered), <a href="../inventory/entries/demo_82.html">D82</a> (explained as corollary of depth law).</td></tr><tr><td class="glossary-label">See also</td><td>Crossing Depth, Balanced Exponentials, BFS Catalog.</td></tr></tbody></table>
<p>---</p>
<h2>Module (Standard, Projective, Simple, Non-Semisimple)</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>Different "representations" of the Temperley-Lieb algebra -- standard modules are the basic ones (indexed by through-strand count), simple modules are the irreducible building blocks, projective modules are their "covers," and non-semisimple modules are those that cannot be split into simple pieces.</td></tr><tr><td class="glossary-label">Precise</td><td>Standard module W_{n,j} = TL_n acting on link states with j through-strands, dimension d(n,j). Simple module L_j = W_{n,j}/rad(W_{n,j}). Projective indecomposable P_{j,j} = projective cover of L_j, dimension C_{n/2+1} for j=0. Non-semisimple = has nonzero radical; at delta=0 this occurs for even n.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_03.html">D03</a> (standard), <a href="../inventory/entries/demo_38.html">D38</a> (quotient), <a href="../inventory/entries/demo_51.html">D51</a> (radical anatomy), <a href="../inventory/entries/demo_85.html">D85</a>-<a href="../inventory/entries/demo_86.html">D86</a> (projective covers), <a href="../inventory/entries/demo_99.html">D99</a>-<a href="../inventory/entries/demo_101.html">D101</a> (multi-strand modules).</td></tr><tr><td class="glossary-label">See also</td><td>Temperley-Lieb Algebra, Radical, Sandwich Theorem, Ext^1.</td></tr></tbody></table>
<p>---</p>
<h2>Neglecton</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>A bracket value that is normally invisible (zero at delta=0) but becomes visible under a small perturbation away from delta=0 -- these capture information from two-loop states that the strict delta=0 evaluation kills.</td></tr><tr><td class="glossary-label">Precise</td><td>First-order perturbation bracket values around delta=0: from states with loops=2, weighted by scale factor 4 = d(delta)/d(epsilon). 148 new Z[zeta_8] values from 15,242 previously invisible braids. All 116 genuinely new values share angles with existing standard values -- no new angular directions. The perturbation approach is closed.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_49.html">D49</a>.</td></tr><tr><td class="glossary-label">See also</td><td>Delta=0, Null State, Axiality Theorem.</td></tr></tbody></table>
<p>---</p>
<h2>Non-Semisimplicity</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>A property of the TL algebra at certain evaluation points where it cannot be decomposed into independent simple pieces -- there are "stuck-together" parts (the radical) that create both obstacles and opportunities for computation.</td></tr><tr><td class="glossary-label">Precise</td><td>TL_n(delta) is non-semisimple when the radical rad(TL_n) is nonzero. At delta=0, this occurs for even n (alternating semisimplicity). Non-semisimplicity creates the sandwich structure (Loewy length 3), enables exact DKC via single-loop reduction, but blocks parity through radical-carried abelian characters (Barrington-Radical Principle).</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_38.html">D38</a> (dimension reduction), <a href="../inventory/entries/demo_51.html">D51</a> (sandwich theorem), <a href="../inventory/entries/demo_85.html">D85</a> (indecomposability parameter b=-5/8), <a href="../inventory/entries/demo_102.html">D102</a> (Barrington connection).</td></tr><tr><td class="glossary-label">See also</td><td>Radical, Sandwich Theorem, Barrington's Theorem, Delta=0.</td></tr></tbody></table>
<p>---</p>
<h2>NPN Classification</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>A way of grouping Boolean functions into equivalence classes by allowing input/output negation and input permutation -- for 3 inputs there are exactly 14 classes (1 trivial + 13 nontrivial), and DKC's goal is to compute as many as possible.</td></tr><tr><td class="glossary-label">Precise</td><td>NPN (Negation-Permutation-Negation) equivalence classes of Boolean functions. For n=3 inputs: 256 functions collapse to 14 NPN classes. DKC achieves all 13 nontrivial classes at k=6 MVN (<a href="../inventory/entries/demo_50.html">D50</a>), 11/13 under half-plane (<a href="../inventory/entries/demo_61.html">D61</a>-<a href="../inventory/entries/demo_62.html">D62</a>). The four-tier hierarchy (k=2:5, k=3:+1, k=4:+6, k=6:+1) partitions classes by minimum sector count.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_23.html">D23</a> (classification system), <a href="../inventory/entries/demo_45.html">D45</a> (all 13 mapped), <a href="../inventory/entries/demo_50.html">D50</a> (all 13 achieved).</td></tr><tr><td class="glossary-label">See also</td><td>Activation Function, 11/13 Theorem, Parity Wall.</td></tr></tbody></table>
<p>---</p>
<h2>Null State</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>A bracket catalog entry whose Kauffman trace is zero -- invisible to the standard topological measurement, yet indispensable for computation at finite groups because they provide unique directions in the quaternion space.</td></tr><tr><td class="glossary-label">Precise</td><td>Catalog entries with Re(q) = 0 (bracket-null). At zeta_8: 9 of 24 entries, covering 6 exclusive S^2 directions (cube-edge midpoints). Removing nulls drops XOR from 8 to 6 (below random baseline). Null indispensability is regime-dependent: critical at finite groups (zeta_8), dispensable at infinite groups (zeta_12, <a href="../inventory/entries/demo_87.html">D87</a>). Related to LCFT Jordan-cell logarithmic partners.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_84.html">D84</a> (null indispensability), <a href="../inventory/entries/demo_87.html">D87</a> (regime transition).</td></tr><tr><td class="glossary-label">See also</td><td>BFS Catalog, Crossing Depth, Non-Semisimplicity.</td></tr></tbody></table>
<p>---</p>
<h2>Parity Lock (Parity-Lock Theorem)</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>Under the +/-q paired encoding, the only Boolean functions that can ever be computed are XOR and XNOR -- AND, OR, majority, and threshold functions are structurally impossible regardless of activation or depth.</td></tr><tr><td class="glossary-label">Precise</td><td>Under +/-q encoding with k weights, the (0,0)=(1,1) collision creates 3^k equivalence classes. XOR/XNOR are the only standard Boolean functions constant on all classes. Sign-flip symmetry combined_cell(S) = combined_cell(-S) further halves distinguishable groups. Formally proved (P04, proofs/parity-lock-theorem.md).</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_92.html">D92</a>.</td></tr><tr><td class="glossary-label">See also</td><td>Encoding, Parity Wall, Circuit Complexity.</td></tr></tbody></table>
<p>---</p>
<h2>Parity Wall</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>An apparent impossibility barrier where parity (XOR) seems unreachable -- the project encounters and resolves this wall three times, each time locating the obstruction in a different component (activation, activation again, then group finiteness).</td></tr><tr><td class="glossary-label">Precise</td><td>The "wall was X not Y" pattern: (1) <a href="../inventory/entries/demo_48.html">D48</a>-&gt;<a href="../inventory/entries/demo_50.html">D50</a>: wall was activation (split-sigmoid), not lattice; resolved by k-sector. (2) <a href="../inventory/entries/demo_76.html">D76</a>-&gt;<a href="../inventory/entries/demo_77.html">D77</a>: wall was activation (S^2-only), not root; resolved by S^1 x S^2 product. (3) <a href="../inventory/entries/demo_78.html">D78</a>-&gt;<a href="../inventory/entries/demo_79.html">D79</a>: wall was group finiteness (binary octahedral, 24 elements), not architecture; resolved by zeta_12 (infinite group).</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_48.html">D48</a> (first wall), <a href="../inventory/entries/demo_76.html">D76</a> (second wall), <a href="../inventory/entries/demo_78.html">D78</a> (third wall).</td></tr><tr><td class="glossary-label">See also</td><td>Wall Pattern, Activation Function, k-Sector MVN.</td></tr></tbody></table>
<p>---</p>
<h2>Planar Matching</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>See Link State. A non-crossing pairing of boundary points, forming the basis of the TL algebra.</td></tr><tr><td class="glossary-label">Precise</td><td>A perfect matching on {1,...,2n} with no crossing arcs. Counted by the Catalan number C_n. Planar matchings are both the TL basis and the smoothing states of the bracket state sum.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_01.html">D01</a>.</td></tr><tr><td class="glossary-label">See also</td><td>Link State, Temperley-Lieb Algebra, State Sum.</td></tr></tbody></table>
<p>---</p>
<h2>Product Closure</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>Whether multiplying two values from a vocabulary set produces another value still in that set -- in DKC, high product closure is the single strongest algebraic predictor of parity capability (at delta=0 with additive encoding).</td></tr><tr><td class="glossary-label">Precise</td><td>For a set V of Z[zeta_N] values, product closure counts pairs (v_i, v_j) where v_i * v_j (modulo axis, i.e., ignoring the zeta_8^k phase factor) is also in V. At delta=0: parity-capable values have 17 product closure edges (connected graph); poison values have 0 (empty graph). Polarity inverts under multiplicative encoding (<a href="../inventory/entries/demo_109.html">D109</a>).</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_108.html">D108</a> (product closure as discriminator), <a href="../inventory/entries/demo_109.html">D109</a> (encoding-dependent polarity).</td></tr><tr><td class="glossary-label">See also</td><td>Dual-Channel Theorem, Z[zeta_8], Encoding.</td></tr></tbody></table>
<p>---</p>
<h2>Radical</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>The "stuck-together" part of a non-semisimple algebra -- elements that act as zero in every simple quotient. In DKC, the radical carries only writhe (framing) information and is provably useless for computing parity.</td></tr><tr><td class="glossary-label">Precise</td><td>rad(TL_n) = intersection of all maximal left ideals. At delta=0 for even n: rad(TL_{2k}) has dimension C_{2k} - C_{2k-1}; rad^2 has dimension C_{2k-1}; Loewy length is exactly 3 (Sandwich Theorem). The radical carries an abelian character (writhe homomorphism), making it computationally inert by Barrington's theorem.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_38.html">D38</a> (dimension), <a href="../inventory/entries/demo_51.html">D51</a> (anatomy), <a href="../inventory/entries/demo_52.html">D52</a> (cross-ell), <a href="../inventory/entries/demo_85.html">D85</a> (indecomposability parameter b=-5/8), <a href="../inventory/entries/demo_102.html">D102</a> (Barrington-Radical Principle).</td></tr><tr><td class="glossary-label">See also</td><td>Sandwich Theorem, Non-Semisimplicity, Barrington's Theorem.</td></tr></tbody></table>
<p>---</p>
<h2>Raqiya</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>A reusable C89 library for analyzing cyclotomic integer values, providing exact arithmetic and six relationship detectors that reveal algebraic structure in bracket catalogs.</td></tr><tr><td class="glossary-label">Precise</td><td>Single-header C89 library (raqiya/raqiya.h) implementing Z[zeta_8] arithmetic and 6 detectors: root orbits, norm classes, Galois orbits, axis alignment, pair histograms, and full analysis. Used for algebraic fingerprinting of bracket catalogs. 86 unit tests. See CLAUDE.md for compilation and usage.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_107.html">D107</a> (library created and validated).</td></tr><tr><td class="glossary-label">See also</td><td>Scrutinium, Z[zeta_8], Cyclotomic Integer.</td></tr></tbody></table>
<p>---</p>
<h2>Reservoir Computing</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>A framework where a fixed, untrained dynamical system processes sequential inputs and only a simple output layer is trained -- DKC is exactly this, with the braid group as the reservoir and the activation function as the readout.</td></tr><tr><td class="glossary-label">Precise</td><td>DKC maps to RC: braid word = sequential input, SU(2) matrix multiplication = reservoir dynamics, quaternion state = reservoir state, Voronoi/sector activation = readout. The linear depth law (max_xor ~ depth + 6) is the RC memory capacity theorem applied to the braid reservoir. The finite-to-infinite group transition (zeta_8 -&gt; zeta_12) maps to the ordered-to-edge-of-chaos transition. Pillar 5 of the five-pillar framework.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_73.html">D73</a> (eigenvector automaton = reservoir), <a href="../inventory/entries/demo_82.html">D82</a> (depth law = memory capacity).</td></tr><tr><td class="glossary-label">See also</td><td>Five Pillars, Crossing Depth, BFS Catalog, Braid Group.</td></tr></tbody></table>
<p>---</p>
<h2>S^2 Sweet Spot</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>The 2-sphere of rotation axes is the natural arena for DKC computation -- it outperforms both the full quaternion space (S^3, which has a redundant fiber) and the flat plane (R^2, which loses essential curvature).</td></tr><tr><td class="glossary-label">Precise</td><td>A custom 13-direction Voronoi on S^2 (eigenvector directions of the binary octahedral group) achieves 36 XOR6 solutions at 14 cells, exceeding the 25-cell S^3 Voronoi (35 solutions). Platonic solid Voronois yield zero. Euclidean R^2 metric gives zero (<a href="../inventory/entries/demo_68.html">D68</a>: intrinsically curved). The computation lives on S^2, not S^3 or R^2.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_67.html">D67</a> (S^2 beats S^3), <a href="../inventory/entries/demo_68.html">D68</a> (intrinsic curvature), <a href="../inventory/entries/demo_72.html">D72</a> (algebraic not geometric).</td></tr><tr><td class="glossary-label">See also</td><td>Hopf Fibration, 13=13 Bandwidth Theorem, 24-Cell.</td></tr></tbody></table>
<p>---</p>
<h2>Sandwich Theorem (Loewy Length 3)</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>The non-semisimple TL algebra at delta=0 has a three-layer structure: a semisimple top, a middle "radical" layer, and a semisimple bottom that is a dimensional mirror of the top -- like a sandwich.</td></tr><tr><td class="glossary-label">Precise</td><td>For k &gt;= 2, TL_{2k}(delta=0) has Loewy length exactly 3: Top = TL_{2k}/rad (dim C_{2k-1}, isomorphic to TL_{2k-1}(0)), Middle = rad/rad^2 (dim C_{2k} - 2*C_{2k-1}), Bottom = rad^2 (dim C_{2k-1}, isomorphic to TL_{2k-1}(0) as bimodule). NOVEL result -- papers prove head=socle for individual PIMs but never identify rad^2 AS the previous odd TL algebra.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_51.html">D51</a>.</td></tr><tr><td class="glossary-label">See also</td><td>Radical, Non-Semisimplicity, Module.</td></tr></tbody></table>
<p>---</p>
<h2>Scrutinium</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>A generic algebraic analysis framework that provides 14-18 universal detectors for any algebraic type, replacing hand-written per-type analysis code with a single reusable scaffolding system.</td></tr><tr><td class="glossary-label">Precise</td><td>Generic algebraic analysis library (scrutinium.h) using scaffolding + genus vtable pattern. 14-18 universal detectors auto-registered per type, ~50 lines to adopt a new type. 13 SCR_WRAP_* macros for wrapper boilerplate reduction (~47%). Includes Scr_Signatura for partition lattice topology fingerprinting. 230 tests across 4 suites, 3 validated types (Z[i], Z[omega], Z[zeta_8]).</td></tr><tr><td class="glossary-label">Introduced</td><td>Built as generalization of Raqiya detectors.</td></tr><tr><td class="glossary-label">See also</td><td>Raqiya, Z[zeta_8], Cyclotomic Integer.</td></tr></tbody></table>
<p>---</p>
<h2>Sign-Hash</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>An activation function that projects each entry of a braid representation matrix to its sign ({-1, 0, +1}), creating a binary/ternary fingerprint -- equivalent to 1-bit compressed sensing.</td></tr><tr><td class="glossary-label">Precise</td><td>Ternary sign quantization of TL module matrix entries: each entry maps to sgn(entry) in {-1, 0, +1}. Equivalent to 1-bit compressed sensing (Boufounos-Baraniuk 2008). Can expand effective rank beyond Z-linear rank (sign-rank expansion: W_{6,2} goes from 244 to 292). Optimal component count follows an Atkinson sweet-spot curve.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_104.html">D104</a>.</td></tr><tr><td class="glossary-label">See also</td><td>Activation Function, k-Sector MVN, Module.</td></tr></tbody></table>
<p>---</p>
<h2>State Sum</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>A computation that sums over all possible configurations (states) of a system, weighting each by some algebraic factor -- the Kauffman bracket is computed this way by summing over all possible crossing smoothings.</td></tr><tr><td class="glossary-label">Precise</td><td>&lt;K&gt; = sum_{s in {A,B}^n} A^{sigma(s)} * delta^{loops(s)-1}, where sigma(s) counts A-choices minus B-choices and loops(s) counts closed curves after smoothing. At delta=0, only single-loop states (loops=1) survive.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_01.html">D01</a> (first implementation).</td></tr><tr><td class="glossary-label">See also</td><td>Bracket Polynomial, Delta=0, Link State.</td></tr></tbody></table>
<p>---</p>
<h2>Temperley-Lieb Algebra (TL_n)</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>A finite-dimensional algebra whose basis elements are non-crossing strand diagrams, with multiplication defined by stacking diagrams and replacing closed loops with a scalar delta -- the algebraic engine that connects knot theory to computation.</td></tr><tr><td class="glossary-label">Precise</td><td>TL_n(delta) is generated by e_1, ..., e_{n-1} with relations e_i^2 = delta<em>e_i, e_i</em>e_{i+1}<em>e_i = e_i, e_i</em>e_j = e_j*e_i (|i-j|&gt;=2). Dimension = Catalan number C_n. The bracket factors through TL: braids map to TL via the Kauffman functor, and the bracket is the Markov trace on TL. At delta=0, generators are nilpotent (e_i^2=0).</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_03.html">D03</a> (first TL implementation), <a href="../inventory/entries/demo_35.html">D35</a> (TL matrices over Z[zeta_8]).</td></tr><tr><td class="glossary-label">See also</td><td>Bracket Polynomial, Module, Radical, Non-Semisimplicity.</td></tr></tbody></table>
<p>---</p>
<h2>Topological Entropy</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>A measure of how chaotic a braid's dynamics are (how fast nearby points separate under the braid's action) -- surprisingly, this is completely irrelevant to DKC computation.</td></tr><tr><td class="glossary-label">Precise</td><td>Thurston-Nielsen classification assigns braids as periodic (zero entropy) or pseudo-Anosov (positive entropy). <a href="../inventory/entries/demo_106.html">D106</a> proves topological entropy is completely orthogonal to DKC: both types compute XOR at 100% participation with near-identical scores. The TL quotient at delta=0 (e_i^2=0) kills expanding eigenvalues, erasing all dynamical information while preserving algebraic structure.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_106.html">D106</a> (proved null).</td></tr><tr><td class="glossary-label">See also</td><td>Reservoir Computing, Crossing Depth, Relational Computation.</td></tr></tbody></table>
<p>---</p>
<h2>Triskelion Principle</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>For 3-input parity at k=6 sectors, each of the 3 input weights must occupy its own odd-numbered sector at roughly 120-degree spacing -- a three-armed geometric pattern.</td></tr><tr><td class="glossary-label">Precise</td><td>For 3-input parity with k=6 MVN sectors on Z[zeta_8], all three weights are confined to octants {2,4,5,7} (class-1 angles) and must interleave around the unit circle. Generalizes: 4-input uses tetraskelion at k=8, 5-input uses pentaskelion at k=15. Specific to each input arity; the k=2n generalization was falsified.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_50.html">D50</a> (discovery), <a href="../inventory/entries/demo_63.html">D63</a> (generalization and falsification).</td></tr><tr><td class="glossary-label">See also</td><td>k-Sector MVN, Parity Wall, NPN Classification.</td></tr></tbody></table>
<p>---</p>
<h2>Wall Pattern ("Wall Was X Not Y")</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>A recurring structural pattern in the project: an apparent impossibility is confirmed exhaustively, then the specific component causing the wall is identified and changed, resolving the impossibility while keeping everything else fixed.</td></tr><tr><td class="glossary-label">Precise</td><td>Three instances: (1) <a href="../inventory/entries/demo_48.html">D48</a>-&gt;<a href="../inventory/entries/demo_50.html">D50</a>: wall was activation (split-sigmoid), resolution k=6 MVN. (2) <a href="../inventory/entries/demo_76.html">D76</a>-&gt;<a href="../inventory/entries/demo_77.html">D77</a>: wall was activation (S^2-only), resolution S^1 x S^2 product. (3) <a href="../inventory/entries/demo_78.html">D78</a>-&gt;<a href="../inventory/entries/demo_79.html">D79</a>: wall was group finiteness (24-element binary octahedral), resolution zeta_12 (infinite group). The pattern teaches: locate the specific component enforcing the wall before concluding a function is unreachable.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_48.html">D48</a> (first instance).</td></tr><tr><td class="glossary-label">See also</td><td>Parity Wall, Activation Function, DKC.</td></tr></tbody></table>
<p>---</p>
<h2>Writhe</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>The net signed crossing count of a braid -- how much it twists overall in one direction versus the other. In DKC, writhe is an independent computational resource worth +2 XOR levels.</td></tr><tr><td class="glossary-label">Precise</td><td>writhe(beta) = sum of signs of crossings in the braid word (sigma_i contributes +1, sigma_i^{-1} contributes -1). Jones normalization removes the factor (-A^3)^{-writhe}. Writhe is independent of depth (r=0.14 correlation). The radical carries the writhe as an abelian character (B_n -&gt; Z/8Z via A=-zeta_8), proved computationally for all 32,768 entries of W_{6,4} (<a href="../inventory/entries/demo_102.html">D102</a>).</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_09.html">D09</a> (Reidemeister moves), <a href="../inventory/entries/demo_83.html">D83</a> (computational resource), <a href="../inventory/entries/demo_102.html">D102</a> (writhe character theorem).</td></tr><tr><td class="glossary-label">See also</td><td>Framing Cost, Barrington's Theorem, Radical.</td></tr></tbody></table>
<p>---</p>
<h2>Z[zeta_8]</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>The ring of integers built from the 8th root of unity -- every element is a 4-tuple of ordinary integers (a + b<em>zeta_8 + c</em>zeta_8^2 + d<em>zeta_8^3). This is the primary number system for DKC at delta=0, enabling exact computation with zero floating-point error.</td></tr><tr><td class="glossary-label">Precise</td><td>Z[zeta_8] = Z[e^{2</em>pi*i/8}], the ring of integers of Q(zeta_8). Basis {1, zeta_8, zeta_8^2, zeta_8^3} with zeta_8^4 = -1. Class number 1 (unique factorization domain). The BFS catalog at 2 strands contains 24 distinct values; at delta=0 the axiality theorem ensures each value uses at most one basis direction.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_27.html">D27</a> (identified), <a href="../inventory/entries/demo_29.html">D29</a> (implemented).</td></tr><tr><td class="glossary-label">See also</td><td>Cyclotomic Integer, Axiality Theorem, Delta=0, Raqiya.</td></tr></tbody></table>
<p>---</p>
<h2>Z[zeta_12]</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>The cyclotomic ring at the 12th root of unity, used when zeta_8's finite group (24 elements) is too small -- its infinite braid group breaks through the XOR8 ceiling, reaching XOR12 and beyond.</td></tr><tr><td class="glossary-label">Precise</td><td>Z[zeta_12] = Z[e^{2<em>pi</em>i/12}], evaluation at half-angle pi/6. The SU(2) braid group at zeta_12 is infinite (&gt;4096 entries at 8 closure rounds), breaking the capacity ceiling imposed by zeta_8's finite binary octahedral group. max_xor ~ 0.62 * log_2(catalog) + 4.6. Null fraction drops to 3% (vs 37.5% at zeta_8).</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_79.html">D79</a> (first use), <a href="../inventory/entries/demo_81.html">D81</a> (scaling law), <a href="../inventory/entries/demo_82.html">D82</a> (depth law).</td></tr><tr><td class="glossary-label">See also</td><td>Z[zeta_8], BFS Catalog, Log Law, Reservoir Computing.</td></tr></tbody></table>
<p>---</p>
<h2>Z[zeta_16]</h2>
<table class="glossary-entry"><tbody><tr><td class="glossary-label">Plain</td><td>The cyclotomic ring at the 16th root of unity, corresponding to delta=sqrt(2) -- a richer algebraic setting where bracket values use a 2D subspace (Gaussian integers times axes) instead of the 1D axiality of zeta_8.</td></tr><tr><td class="glossary-label">Precise</td><td>Z[zeta_16] = Z[e^{2<em>pi</em>i/16}], evaluation at ell=4, delta=sqrt(2). Bracket values are Z[i]-axial (2D subspace). The parity ceiling n=5 is unchanged from Z[zeta_8] under standard activations, but generalized XOR6 appears at k=24 (<a href="../inventory/entries/demo_65.html">D65</a>). <a href="../inventory/entries/demo_109.html">D109</a> uses this ring to demonstrate encoding-dependent polarity inversion of the dual-channel theorem.</td></tr><tr><td class="glossary-label">Introduced</td><td><a href="../inventory/entries/demo_54.html">D54</a> (Z[i]-axiality), <a href="../inventory/entries/demo_65.html">D65</a> (generalized XOR6 at k=24), <a href="../inventory/entries/demo_109.html">D109</a> (dual-channel encoding dependence).</td></tr><tr><td class="glossary-label">See also</td><td>Z[zeta_8], Cyclotomic Integer, Axiality Theorem, Dual-Channel Theorem.</td></tr></tbody></table>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <script>hljs.highlightAll();</script>
</body>
</html>
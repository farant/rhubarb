<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>demo_29_cyclotomic_arithmetic/main.c</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <nav><a href="../index.html">← Back to Index</a></nav><hr>
    <h1>demo_29_cyclotomic_arithmetic/main.c</h1><pre><code class="language-c">/*
 * KNOTAPEL DEMO 29: Cyclotomic Arithmetic — Forward DKC
 * =====================================================
 *
 * THESIS: Demos 26-28 showed REVERSE DKC: trained weights approximate bracket
 * values (Z[zeta_8] lattice points). Demo 29 goes FORWARD: start from exact
 * Z[zeta_8] lattice points and verify they compute XOR WITHOUT training.
 *
 * If forward DKC works, Training-as-Focusing is confirmed: the topological
 * structure is SUFFICIENT, training merely finds it.
 *
 * KEY INSIGHT: Z[zeta_8] = {a + b*zeta_8 + c*zeta_8^2 + d*zeta_8^3 : a,b,c,d in Z}
 * where zeta_8 = e^{i*pi/4}, zeta_8^2 = i, zeta_8^4 = -1.
 * Multiplication uses 16 integer muls, ZERO floating-point.
 *
 * Part A: Exact cyclotomic arithmetic (Z[zeta_8] type + verification)
 * Part B: Build bracket catalog in exact arithmetic
 * Part C: Forward DKC search (262,144 triples x gauge sweep)
 * Part D: Solution manifold analysis
 * Part E: Bracket composition test
 *
 * Theoretical foundation:
 *   Habiro (2002) — bracket values at roots of unity ARE cyclotomic integers
 *   Abramsky (2007) — TL diagrams encode computation
 *   Nazer-Gastpar (2011) — algebraic integer lattices support function computation
 *
 * C89, zero dependencies beyond math.h.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

/* ================================================================
 * Test infrastructure
 * ================================================================ */

static int n_pass = 0, n_fail = 0;

static void check(const char *msg, int ok) {
    if (ok) { printf("  PASS: %s\n", msg); n_pass++; }
    else    { printf("  FAIL: %s\n", msg); n_fail++; }
}

/* ================================================================
 * Complex arithmetic (double precision, for comparison/testing)
 * ================================================================ */

typedef struct { double re, im; } Cx;

static Cx cx_make(double re, double im) { Cx z; z.re = re; z.im = im; return z; }
static Cx cx_zero(void) { return cx_make(0.0, 0.0); }
static Cx cx_one(void)  { return cx_make(1.0, 0.0); }
static Cx cx_add(Cx a, Cx b) { return cx_make(a.re + b.re, a.im + b.im); }
static Cx cx_sub(Cx a, Cx b) { return cx_make(a.re - b.re, a.im - b.im); }
static Cx cx_neg(Cx a) { return cx_make(-a.re, -a.im); }
static Cx cx_mul(Cx a, Cx b) {
    return cx_make(a.re * b.re - a.im * b.im,
                   a.re * b.im + a.im * b.re);
}
static Cx cx_scale(Cx a, double s) { return cx_make(a.re * s, a.im * s); }
static double cx_abs(Cx a) { return sqrt(a.re * a.re + a.im * a.im); }
static Cx cx_exp_i(double theta) { return cx_make(cos(theta), sin(theta)); }

static Cx cx_pow_int(Cx a, int n) {
    Cx r = cx_one();
    Cx base;
    int neg;
    if (n == 0) return r;
    neg = (n &lt; 0);
    if (neg) n = -n;
    base = a;
    while (n &gt; 0) {
        if (n &amp; 1) r = cx_mul(r, base);
        base = cx_mul(base, base);
        n &gt;&gt;= 1;
    }
    if (neg) {
        double d = r.re * r.re + r.im * r.im;
        r = cx_make(r.re / d, -r.im / d);
    }
    return r;
}

/* ================================================================
 * PART A: Exact Cyclotomic Arithmetic — Z[zeta_8]
 *
 * Basis: {1, zeta_8, zeta_8^2, zeta_8^3} with zeta_8^4 = -1
 *
 * Element: a + b*zeta_8 + c*zeta_8^2 + d*zeta_8^3
 *   where zeta_8 = e^{i*pi/4} = (1+i)/sqrt(2)
 *         zeta_8^2 = i
 *         zeta_8^3 = (-1+i)/sqrt(2)
 *
 * Multiplication: (a,b,c,d)*(e,f,g,h) =
 *   1-coeff:       ae - bh - cg - df
 *   zeta_8-coeff:  af + be - ch - dg
 *   zeta_8^2-coeff: ag + bf + ce - dh
 *   zeta_8^3-coeff: ah + bg + cf + de
 *
 * 16 integer muls, 12 adds/subs. Exact.
 * ================================================================ */

typedef struct {
    long a, b, c, d;  /* coefficients in basis {1, zeta_8, zeta_8^2, zeta_8^3} */
} Cyc8;

static Cyc8 cyc8_make(long a, long b, long c, long d) {
    Cyc8 z; z.a = a; z.b = b; z.c = c; z.d = d; return z;
}

static Cyc8 cyc8_zero(void) { return cyc8_make(0, 0, 0, 0); }
static Cyc8 cyc8_one(void)  { return cyc8_make(1, 0, 0, 0); }

static Cyc8 cyc8_add(Cyc8 x, Cyc8 y) {
    return cyc8_make(x.a + y.a, x.b + y.b, x.c + y.c, x.d + y.d);
}

static Cyc8 cyc8_sub(Cyc8 x, Cyc8 y) {
    return cyc8_make(x.a - y.a, x.b - y.b, x.c - y.c, x.d - y.d);
}

static Cyc8 cyc8_neg(Cyc8 x) {
    return cyc8_make(-x.a, -x.b, -x.c, -x.d);
}

static Cyc8 cyc8_mul(Cyc8 x, Cyc8 y) {
    /* (a,b,c,d)*(e,f,g,h) with zeta_8^4 = -1 */
    return cyc8_make(
        x.a * y.a - x.b * y.d - x.c * y.c - x.d * y.b,  /* was wrong in notes, rechecked */
        x.a * y.b + x.b * y.a - x.c * y.d - x.d * y.c,
        x.a * y.c + x.b * y.b + x.c * y.a - x.d * y.d,
        x.a * y.d + x.b * y.c + x.c * y.b + x.d * y.a
    );
}

/* Scale by integer */
static Cyc8 cyc8_scale(Cyc8 x, long s) {
    return cyc8_make(x.a * s, x.b * s, x.c * s, x.d * s);
}

/* Check equality */
static int cyc8_eq(Cyc8 x, Cyc8 y) {
    return x.a == y.a &amp;&amp; x.b == y.b &amp;&amp; x.c == y.c &amp;&amp; x.d == y.d;
}

/* Convert to complex double for comparison */
static Cx cyc8_to_cx(Cyc8 z) {
    /* zeta_8 = (1+i)/sqrt(2), zeta_8^2 = i, zeta_8^3 = (-1+i)/sqrt(2) */
    double inv_sqrt2 = 1.0 / sqrt(2.0);
    double re = (double)z.a + (double)z.b * inv_sqrt2 + (double)z.d * (-inv_sqrt2);
    double im = (double)z.b * inv_sqrt2 + (double)z.c + (double)z.d * inv_sqrt2;
    return cx_make(re, im);
}

/* Complex conjugation on Z[zeta_8]:
 * conj(zeta_8) = zeta_8^{-1} = zeta_8^7 = -zeta_8^3
 * conj(zeta_8^2) = -zeta_8^2,  conj(zeta_8^3) = -zeta_8
 * So conj(a,b,c,d) = (a, -d, -c, -b)
 * For UNITS (|z|=1): z^{-1} = conj(z) */
static Cyc8 cyc8_conj(Cyc8 z) {
    return cyc8_make(z.a, -z.d, -z.c, -z.b);
}

/* Integer power (negative exponents require base to be a unit) */
static Cyc8 cyc8_pow_int(Cyc8 base, int n) {
    Cyc8 r = cyc8_one();
    if (n == 0) return r;
    if (n &lt; 0) {
        n = -n;
        base = cyc8_conj(base); /* base^{-1} for units */
    }
    while (n &gt; 0) {
        if (n &amp; 1) r = cyc8_mul(r, base);
        base = cyc8_mul(base, base);
        n &gt;&gt;= 1;
    }
    return r;
}

/* Pretty print */
static void cyc8_print(const char *label, Cyc8 z) {
    printf("  %s = (%ld, %ld, %ld, %ld)", label, z.a, z.b, z.c, z.d);
    {
        Cx c = cyc8_to_cx(z);
        printf("  [%.4f + %.4fi]", c.re, c.im);
    }
    printf("\n");
}

/* ================================================================
 * State-sum bracket oracle (returns FULL complex value)
 * Copied from Demo 27 for catalog building
 * ================================================================ */

#define MAX_WORD 64
typedef struct { int word[MAX_WORD]; int len, n; } Braid;

#define MAX_UF 4096
static int uf_p[MAX_UF];
static void uf_init(int n) { int i; for (i = 0; i &lt; n; i++) uf_p[i] = i; }
static int uf_find(int x) {
    while (uf_p[x] != x) { uf_p[x] = uf_p[uf_p[x]]; x = uf_p[x]; }
    return x;
}
static void uf_union(int x, int y) {
    x = uf_find(x); y = uf_find(y); if (x != y) uf_p[x] = y;
}

static int braid_loops(const Braid *b, unsigned s) {
    int N = (b-&gt;len + 1) * b-&gt;n, l, p, i, loops, sgn, bit, cup;
    uf_init(N);
    for (l = 0; l &lt; b-&gt;len; l++) {
        sgn = b-&gt;word[l] &gt; 0 ? 1 : -1;
        i = (sgn &gt; 0 ? b-&gt;word[l] : -b-&gt;word[l]) - 1;
        bit = (int)((s &gt;&gt; l) &amp; 1u);
        cup = (sgn &gt; 0) ? (bit == 0) : (bit == 1);
        if (cup) {
            uf_union(l * b-&gt;n + i, l * b-&gt;n + i + 1);
            uf_union((l + 1) * b-&gt;n + i, (l + 1) * b-&gt;n + i + 1);
            for (p = 0; p &lt; b-&gt;n; p++)
                if (p != i &amp;&amp; p != i + 1)
                    uf_union(l * b-&gt;n + p, (l + 1) * b-&gt;n + p);
        } else {
            for (p = 0; p &lt; b-&gt;n; p++)
                uf_union(l * b-&gt;n + p, (l + 1) * b-&gt;n + p);
        }
    }
    for (p = 0; p &lt; b-&gt;n; p++)
        uf_union(p, b-&gt;len * b-&gt;n + p);
    loops = 0;
    for (i = 0; i &lt; N; i++)
        if (uf_find(i) == i) loops++;
    return loops;
}

/* Float-based bracket for comparison */
static Cx braid_bracket_at(const Braid *b, Cx A) {
    unsigned s, ns;
    int i, a_count, b_count, lp, j;
    Cx result, delta, d_power, term, coeff;

    delta = cx_neg(cx_add(cx_pow_int(A, 2), cx_pow_int(A, -2)));

    result = cx_zero();
    if (!b-&gt;len) {
        result = cx_one();
        for (i = 0; i &lt; b-&gt;n - 1; i++)
            result = cx_mul(result, delta);
        return result;
    }

    ns = 1u &lt;&lt; b-&gt;len;
    for (s = 0; s &lt; ns; s++) {
        a_count = 0; b_count = 0;
        for (i = 0; i &lt; b-&gt;len; i++) {
            if ((s &gt;&gt; (unsigned)i) &amp; 1u) b_count++;
            else a_count++;
        }
        lp = braid_loops(b, s);

        coeff = cx_pow_int(A, a_count - b_count);
        d_power = cx_one();
        for (j = 0; j &lt; lp - 1; j++)
            d_power = cx_mul(d_power, delta);
        term = cx_mul(coeff, d_power);
        result = cx_add(result, term);
    }
    return result;
}

/* EXACT bracket computation in Z[zeta_8] */
static Cyc8 braid_bracket_exact(const Braid *b, Cyc8 A) {
    unsigned s, ns;
    int i, a_count, b_count, lp;
    Cyc8 result, delta, d_power, term, coeff;

    /* delta = -(A^2 + A^{-2}) */
    /* A = (0,-1,0,0) = -zeta_8, A^2 = zeta_8^2 = (0,0,1,0) (since (-z8)^2 = z8^2) */
    /* A^{-2} = zeta_8^{-2} = zeta_8^6 = -zeta_8^2 = (0,0,-1,0) */
    /* delta = -(A^2 + A^{-2}) = -((0,0,1,0) + (0,0,-1,0)) = -(0,0,0,0) = (0,0,0,0) */
    /* At delta=0, only single-loop states contribute! */
    delta = cyc8_zero();

    result = cyc8_zero();
    if (!b-&gt;len) {
        result = cyc8_one();
        for (i = 0; i &lt; b-&gt;n - 1; i++)
            result = cyc8_mul(result, delta);
        return result;
    }

    ns = 1u &lt;&lt; b-&gt;len;
    for (s = 0; s &lt; ns; s++) {
        a_count = 0; b_count = 0;
        for (i = 0; i &lt; b-&gt;len; i++) {
            if ((s &gt;&gt; (unsigned)i) &amp; 1u) b_count++;
            else a_count++;
        }
        lp = braid_loops(b, s);

        /* At delta=0, only single-loop states (lp==1) survive */
        if (lp != 1) continue;

        /* coeff = A^(a_count - b_count) */
        coeff = cyc8_pow_int(A, a_count - b_count);

        /* d_power = delta^(lp-1) = delta^0 = 1 (since lp=1) */
        d_power = cyc8_one();

        term = cyc8_mul(coeff, d_power);
        result = cyc8_add(result, term);
    }
    return result;
}

/* ================================================================
 * Activation / network evaluation (split-sigmoid from Demo 27)
 * ================================================================ */

static double sigmoid(double x) { return 1.0 / (1.0 + exp(-x)); }

static Cx cx_sigmoid(Cx z) {
    return cx_make(sigmoid(z.re), sigmoid(z.im));
}

/* Single complex neuron XOR test
 * z = w1*x1 + w2*x2 + b
 * h = split_sigmoid(z)
 * p = h.re*(1-h.im) + (1-h.re)*h.im
 */
static int test_xor_triple(Cx w1, Cx w2, Cx b) {
    double inputs[4][2] = {{0,0}, {0,1}, {1,0}, {1,1}};
    int targets[4] = {0, 1, 1, 0};
    int i;

    for (i = 0; i &lt; 4; i++) {
        Cx z = cx_add(cx_add(cx_scale(w1, inputs[i][0]),
                              cx_scale(w2, inputs[i][1])), b);
        Cx h = cx_sigmoid(z);
        double p = h.re * (1.0 - h.im) + (1.0 - h.re) * h.im;
        if ((p &gt; 0.5) != (targets[i] &gt; 0)) return 0;
    }
    return 1;
}

/* ================================================================
 * PART A: Verify Exact Arithmetic
 * ================================================================ */

static void part_a_exact_arithmetic(void) {
    Cyc8 z8, z8_2, z8_3, z8_4;
    Cyc8 A, A_inv, prod;
    Cx cA, cA_inv;
    char msg[256];

    printf("\n=== PART A: Exact Cyclotomic Arithmetic Z[zeta_8] ===\n");
    printf("  Basis: {1, zeta_8, zeta_8^2, zeta_8^3} with zeta_8^4 = -1\n\n");

    /* zeta_8 = (0,1,0,0) */
    z8 = cyc8_make(0, 1, 0, 0);
    cyc8_print("zeta_8", z8);

    /* zeta_8^2 should be (0,0,1,0) */
    z8_2 = cyc8_mul(z8, z8);
    cyc8_print("zeta_8^2", z8_2);
    check("zeta_8^2 = (0,0,1,0)", cyc8_eq(z8_2, cyc8_make(0, 0, 1, 0)));

    /* zeta_8^3 should be (0,0,0,1) */
    z8_3 = cyc8_mul(z8_2, z8);
    cyc8_print("zeta_8^3", z8_3);
    check("zeta_8^3 = (0,0,0,1)", cyc8_eq(z8_3, cyc8_make(0, 0, 0, 1)));

    /* zeta_8^4 should be -1 = (-1,0,0,0) */
    z8_4 = cyc8_mul(z8_3, z8);
    cyc8_print("zeta_8^4", z8_4);
    check("zeta_8^4 = -1", cyc8_eq(z8_4, cyc8_make(-1, 0, 0, 0)));

    /* A = -zeta_8 = (0,-1,0,0) for A = e^{i*5pi/4} = zeta_8^5 */
    A = cyc8_make(0, -1, 0, 0);
    /* A^{-1} via conjugation: conj(0,-1,0,0) = (0,0,0,1) = zeta_8^3 */
    A_inv = cyc8_conj(A);
    check("conj(A) = (0,0,0,1)", cyc8_eq(A_inv, cyc8_make(0, 0, 0, 1)));

    cyc8_print("A", A);
    cyc8_print("A^{-1}", A_inv);

    /* Verify A * A^{-1} = 1 */
    prod = cyc8_mul(A, A_inv);
    cyc8_print("A * A^{-1}", prod);
    check("A * A^{-1} = 1", cyc8_eq(prod, cyc8_one()));

    /* Verify A^2 + A^{-2} = 0 (delta=0 condition) */
    {
        Cyc8 A2 = cyc8_mul(A, A);
        Cyc8 Ai2 = cyc8_mul(A_inv, A_inv);
        Cyc8 sum = cyc8_add(A2, Ai2);
        cyc8_print("A^2", A2);
        cyc8_print("A^{-2}", Ai2);
        cyc8_print("A^2 + A^{-2}", sum);
        check("delta = 0 (A^2 + A^{-2} = 0)", cyc8_eq(sum, cyc8_zero()));
    }

    /* Cross-check with float */
    cA = cx_exp_i(5.0 * M_PI / 4.0);
    cA_inv = cx_exp_i(3.0 * M_PI / 4.0);
    {
        Cx cA_exact = cyc8_to_cx(A);
        Cx cAi_exact = cyc8_to_cx(A_inv);
        double err_a = cx_abs(cx_sub(cA, cA_exact));
        double err_ai = cx_abs(cx_sub(cA_inv, cAi_exact));
        sprintf(msg, "A float matches exact (err=%.2e)", err_a);
        check(msg, err_a &lt; 1e-10);
        sprintf(msg, "A^{-1} float matches exact (err=%.2e)", err_ai);
        check(msg, err_ai &lt; 1e-10);
    }

    /* Test arithmetic with a bigger example */
    {
        Cyc8 x = cyc8_make(2, -1, 3, 1);
        Cyc8 y = cyc8_make(-1, 2, 0, -3);
        Cyc8 xy = cyc8_mul(x, y);
        Cyc8 x_minus_y = cyc8_sub(x, y);
        Cyc8 neg_x = cyc8_neg(x);
        Cyc8 x_times_3 = cyc8_scale(x, 3);
        Cx cx_x = cyc8_to_cx(x);
        Cx cx_y = cyc8_to_cx(y);
        double err;

        /* mul */
        err = cx_abs(cx_sub(cx_mul(cx_x, cx_y), cyc8_to_cx(xy)));
        cyc8_print("(2,-1,3,1)*(-1,2,0,-3)", xy);
        sprintf(msg, "mul cross-check (err=%.2e)", err);
        check(msg, err &lt; 1e-10);

        /* sub */
        err = cx_abs(cx_sub(cx_sub(cx_x, cx_y), cyc8_to_cx(x_minus_y)));
        cyc8_print("(2,-1,3,1)-(-1,2,0,-3)", x_minus_y);
        sprintf(msg, "sub cross-check (err=%.2e)", err);
        check(msg, err &lt; 1e-10);

        /* neg */
        err = cx_abs(cx_sub(cx_neg(cx_x), cyc8_to_cx(neg_x)));
        cyc8_print("-(2,-1,3,1)", neg_x);
        sprintf(msg, "neg cross-check (err=%.2e)", err);
        check(msg, err &lt; 1e-10);

        /* scale */
        err = cx_abs(cx_sub(cx_scale(cx_x, 3.0), cyc8_to_cx(x_times_3)));
        cyc8_print("3*(2,-1,3,1)", x_times_3);
        sprintf(msg, "scale cross-check (err=%.2e)", err);
        check(msg, err &lt; 1e-10);
    }

    /* Edge case: pow_int with exponent 0 */
    check("pow(zeta_8, 0) = 1", cyc8_eq(cyc8_pow_int(z8, 0), cyc8_one()));

    /* Edge case: full cycle zeta_8^8 = 1 */
    check("zeta_8^8 = 1", cyc8_eq(cyc8_pow_int(z8, 8), cyc8_one()));

    /* Edge case: negative unit power via conjugation */
    check("pow(zeta_8, -1) = conj(zeta_8)",
          cyc8_eq(cyc8_pow_int(z8, -1), cyc8_conj(z8)));

    /* Edge case: negative power chain — A^{-3} computed two ways */
    {
        Cyc8 a_neg3_pow = cyc8_pow_int(A, -3);
        Cyc8 a_neg3_conj = cyc8_pow_int(cyc8_conj(A), 3);
        check("pow(A,-3) = pow(conj(A),3)", cyc8_eq(a_neg3_pow, a_neg3_conj));
    }

    /* Edge case: identity braid sigma_1 * sigma_1^{-1} */
    {
        Braid b_id;
        Cyc8 br_id;
        b_id.n = 2;
        b_id.len = 2;
        b_id.word[0] = 1;
        b_id.word[1] = -1;
        br_id = braid_bracket_exact(&amp;b_id, A);
        /* Identity 2-braid should give bracket = delta^(n-1) = 0^1 = 0 */
        /* Actually: sigma*sigma^{-1} is the identity braid, so bracket = delta^(n-1). */
        /* With n=2: delta^1 = 0. The state sum at delta=0 kills multi-loop states. */
        /* For identity braid (0 crossings effectively), we get delta^(n-1). */
        /* But braid_bracket_exact sees len=2, not len=0, so this tests the state sum. */
        cyc8_print("bracket(sigma_1 * sigma_1^{-1})", br_id);
        /* Value should be 0 since delta=0 and identity braid resolves to delta^1 */
        check("identity braid bracket = 0 (delta=0 kills it)",
              cyc8_eq(br_id, cyc8_zero()));
    }
}

/* ================================================================
 * PART B: Build Exact Bracket Catalog
 * ================================================================ */

typedef struct {
    Braid braid;
    Cyc8 bracket_exact;
    Cx bracket_float;
} CatalogEntry;

#define MAX_CATALOG 8192
static CatalogEntry catalog[MAX_CATALOG];
static int catalog_size = 0;

/* Distinct values (deduplicated) */
#define MAX_DISTINCT 512
static Cyc8 distinct_vals[MAX_DISTINCT];
static Cx distinct_cx[MAX_DISTINCT];
static int distinct_count = 0;

static int find_distinct(Cyc8 val) {
    int i;
    for (i = 0; i &lt; distinct_count; i++) {
        if (cyc8_eq(val, distinct_vals[i])) return i;
    }
    return -1;
}

static void build_exact_catalog(void) {
    Cyc8 A = cyc8_make(0, -1, 0, 0);
    Cx fA = cx_exp_i(5.0 * M_PI / 4.0);
    int n, len;
    Braid b;
    int word_buf[MAX_WORD];

    catalog_size = 0;
    distinct_count = 0;

    for (n = 2; n &lt;= 3; n++) {
        for (len = 1; len &lt;= 8 &amp;&amp; len &lt;= MAX_WORD; len++) {
            int max_gen = n - 1;
            int total_gens = 2 * max_gen;
            unsigned long total, idx;
            int i;

            total = 1;
            for (i = 0; i &lt; len; i++) {
                total *= (unsigned long)total_gens;
                if (total &gt; 100000) break;
            }
            if (total &gt; 100000) continue;

            for (idx = 0; idx &lt; total; idx++) {
                unsigned long tmp = idx;
                Cyc8 bracket_e;
                Cx bracket_f;
                double amp;

                for (i = 0; i &lt; len; i++) {
                    int g = (int)(tmp % (unsigned long)total_gens);
                    tmp /= (unsigned long)total_gens;
                    if (g &lt; max_gen) word_buf[i] = g + 1;
                    else             word_buf[i] = -(g - max_gen + 1);
                }
                b.n = n;
                b.len = len;
                memcpy(b.word, word_buf, (size_t)len * sizeof(int));

                /* Compute exact bracket */
                bracket_e = braid_bracket_exact(&amp;b, A);
                /* Also compute float for comparison */
                bracket_f = braid_bracket_at(&amp;b, fA);
                amp = cx_abs(bracket_f);

                /* Only keep non-trivial */
                if (amp &gt; 0.5 &amp;&amp; catalog_size &lt; MAX_CATALOG) {
                    catalog[catalog_size].braid = b;
                    catalog[catalog_size].bracket_exact = bracket_e;
                    catalog[catalog_size].bracket_float = bracket_f;
                    catalog_size++;

                    /* Track distinct exact values */
                    if (find_distinct(bracket_e) &lt; 0 &amp;&amp; distinct_count &lt; MAX_DISTINCT) {
                        distinct_vals[distinct_count] = bracket_e;
                        distinct_cx[distinct_count] = cyc8_to_cx(bracket_e);
                        distinct_count++;
                    }
                }
            }
        }
    }
}

static void part_b_exact_catalog(void) {
    int i, n_match = 0;
    char msg[256];

    printf("\n=== PART B: Exact Bracket Catalog ===\n");
    printf("  Building catalog: 2-3 strand braids, length 1-8...\n\n");

    build_exact_catalog();

    printf("  Total braids with |bracket| &gt; 0.5: %d\n", catalog_size);
    printf("  Distinct exact Z[zeta_8] values: %d\n\n", distinct_count);

    /* Verify exact matches float */
    for (i = 0; i &lt; catalog_size; i++) {
        Cx exact_as_cx = cyc8_to_cx(catalog[i].bracket_exact);
        double err = cx_abs(cx_sub(exact_as_cx, catalog[i].bracket_float));
        if (err &lt; 0.01) n_match++;
    }
    sprintf(msg, "P3: exact matches float (%d/%d, %.1f%%)",
            n_match, catalog_size, 100.0 * (double)n_match / (double)catalog_size);
    check(msg, n_match == catalog_size);

    /* Show first 20 distinct values */
    printf("\n  Distinct bracket values in Z[zeta_8]:\n");
    for (i = 0; i &lt; distinct_count &amp;&amp; i &lt; 20; i++) {
        Cx c = distinct_cx[i];
        printf("    %2d: (%2ld,%2ld,%2ld,%2ld)  = %.4f + %.4fi  |z|=%.4f\n",
               i, distinct_vals[i].a, distinct_vals[i].b,
               distinct_vals[i].c, distinct_vals[i].d,
               c.re, c.im, cx_abs(c));
    }
    if (distinct_count &gt; 20)
        printf("    ... (%d more)\n", distinct_count - 20);

    sprintf(msg, "catalog has &gt;= 50 distinct values (got %d)", distinct_count);
    check(msg, distinct_count &gt;= 50);
}

/* ================================================================
 * PART C: Forward DKC Search
 *
 * For each triple (v1, v2, v3) from the distinct catalog values,
 * and for each gauge angle theta (sweep at 1-degree resolution),
 * test if the network with weights (v1*e^{-i*theta}, v2*e^{-i*theta},
 * v3*e^{-i*theta}) computes XOR.
 *
 * We optimize by only testing gauge angles at pi/4 increments first
 * (the 8 zeta_8 multiples), then filling in with finer resolution.
 * ================================================================ */

typedef struct {
    int idx_w1, idx_w2, idx_b;  /* indices into distinct_vals */
    int gauge_deg;               /* gauge angle in degrees */
    double magnitude;            /* avg |weight| */
} ValidTriple;

#define MAX_VALID 65536
static ValidTriple valid_triples[MAX_VALID];
static int n_valid = 0;

static void part_c_forward_dkc(void) {
    int i1, i2, i3, gi;
    long total_tested = 0;
    char msg[256];

    printf("\n=== PART C: Forward DKC Search ===\n");
    printf("  Testing %d^3 = %d triples x 360 gauge angles...\n\n",
           distinct_count, distinct_count * distinct_count * distinct_count);

    n_valid = 0;

    for (i1 = 0; i1 &lt; distinct_count; i1++) {
        for (i2 = 0; i2 &lt; distinct_count; i2++) {
            for (i3 = 0; i3 &lt; distinct_count; i3++) {
                /* Sweep gauge angles at 5-degree resolution for speed */
                for (gi = 0; gi &lt; 360; gi += 5) {
                    double theta = 2.0 * M_PI * (double)gi / 360.0;
                    Cx rot = cx_exp_i(-theta);
                    Cx w1 = cx_mul(distinct_cx[i1], rot);
                    Cx w2 = cx_mul(distinct_cx[i2], rot);
                    Cx b  = cx_mul(distinct_cx[i3], rot);

                    total_tested++;

                    if (test_xor_triple(w1, w2, b)) {
                        if (n_valid &lt; MAX_VALID) {
                            valid_triples[n_valid].idx_w1 = i1;
                            valid_triples[n_valid].idx_w2 = i2;
                            valid_triples[n_valid].idx_b = i3;
                            valid_triples[n_valid].gauge_deg = gi;
                            valid_triples[n_valid].magnitude =
                                (cx_abs(distinct_cx[i1]) +
                                 cx_abs(distinct_cx[i2]) +
                                 cx_abs(distinct_cx[i3])) / 3.0;
                            n_valid++;
                        }
                    }
                }
            }
        }

        /* Progress */
        if ((i1 + 1) % 10 == 0 || i1 + 1 == distinct_count)
            printf("  Progress: %d/%d w1 values, %d valid so far, %ld tested\n",
                   i1 + 1, distinct_count, n_valid, total_tested);
    }

    printf("\n  Total triples tested: %ld\n", total_tested);
    printf("  Valid XOR triples found: %d\n", n_valid);

    sprintf(msg, "P1: &gt;= 100 valid triples (got %d)", n_valid);
    check(msg, n_valid &gt;= 100);

    /* Show first 10 */
    if (n_valid &gt; 0) {
        int show = n_valid &lt; 10 ? n_valid : 10;
        printf("\n  First %d valid triples:\n", show);
        for (i1 = 0; i1 &lt; show; i1++) {
            ValidTriple *vt = &amp;valid_triples[i1];
            printf("    #%d: w1=(%ld,%ld,%ld,%ld) w2=(%ld,%ld,%ld,%ld) b=(%ld,%ld,%ld,%ld)"
                   " gauge=%d deg |avg|=%.2f\n",
                   i1,
                   distinct_vals[vt-&gt;idx_w1].a, distinct_vals[vt-&gt;idx_w1].b,
                   distinct_vals[vt-&gt;idx_w1].c, distinct_vals[vt-&gt;idx_w1].d,
                   distinct_vals[vt-&gt;idx_w2].a, distinct_vals[vt-&gt;idx_w2].b,
                   distinct_vals[vt-&gt;idx_w2].c, distinct_vals[vt-&gt;idx_w2].d,
                   distinct_vals[vt-&gt;idx_b].a, distinct_vals[vt-&gt;idx_b].b,
                   distinct_vals[vt-&gt;idx_b].c, distinct_vals[vt-&gt;idx_b].d,
                   vt-&gt;gauge_deg, vt-&gt;magnitude);
        }
    }

    /* P6: Forward RMS = 0.0 (by construction, exact match to bracket) */
    if (n_valid &gt; 0) {
        check("P6: forward DKC weights ARE bracket values (RMS = 0.000 by construction)", 1);
    }
}

/* ================================================================
 * PART D: Solution Manifold Analysis
 * ================================================================ */

static void part_d_manifold_analysis(void) {
    int i;
    double mag_sum = 0.0, mag_min = 1e30, mag_max = 0.0;
    int band_low = 0, band_mid = 0, band_high = 0, band_other = 0;
    int gauge_hist[72];  /* 5-degree bins */
    char msg[256];

    printf("\n=== PART D: Solution Manifold Analysis ===\n\n");

    if (n_valid == 0) {
        printf("  No valid triples found. Skipping analysis.\n");
        return;
    }

    /* Magnitude distribution */
    for (i = 0; i &lt; n_valid; i++) {
        double m = valid_triples[i].magnitude;
        mag_sum += m;
        if (m &lt; mag_min) mag_min = m;
        if (m &gt; mag_max) mag_max = m;

        if (m &lt; 2.0) band_low++;
        else if (m &lt; 4.0) band_mid++;
        else if (m &lt; 9.0) band_high++;
        else band_other++;
    }

    printf("  Magnitude statistics:\n");
    printf("    Min: %.4f  Max: %.4f  Mean: %.4f\n",
           mag_min, mag_max, mag_sum / (double)n_valid);
    printf("    Band [0,2): %d  [2,4): %d  [4,9): %d  [9+): %d\n",
           band_low, band_mid, band_high, band_other);

    {
        int in_bands = band_low + band_mid + band_high;
        double pct = 100.0 * (double)in_bands / (double)n_valid;
        sprintf(msg, "P2: &gt;= 80%% in scale bands (got %.1f%%)", pct);
        check(msg, pct &gt;= 80.0);
    }

    /* Gauge angle distribution */
    memset(gauge_hist, 0, sizeof(gauge_hist));
    for (i = 0; i &lt; n_valid; i++) {
        int bin = valid_triples[i].gauge_deg / 5;
        if (bin &gt;= 0 &amp;&amp; bin &lt; 72)
            gauge_hist[bin]++;
    }

    printf("\n  Gauge angle distribution (non-zero bins):\n");
    for (i = 0; i &lt; 72; i++) {
        if (gauge_hist[i] &gt; 0)
            printf("    %3d-%3d deg: %d\n", i * 5, (i + 1) * 5, gauge_hist[i]);
    }

    /* Check for 45-degree periodicity (zeta_8 orbit structure) */
    {
        int n_periodic = 0;
        for (i = 0; i &lt; 72; i++) {
            int j = (i + 9) % 72;  /* 45 degrees = 9 bins of 5 degrees */
            if (gauge_hist[i] &gt; 0 &amp;&amp; gauge_hist[j] &gt; 0)
                n_periodic++;
        }
        printf("\n  Gauge bins with 45-degree partner: %d\n", n_periodic);
    }

    /* Count unique triples (ignoring gauge) */
    {
        int unique = 0;
        for (i = 0; i &lt; n_valid; i++) {
            int j, dup = 0;
            for (j = 0; j &lt; i; j++) {
                if (valid_triples[j].idx_w1 == valid_triples[i].idx_w1 &amp;&amp;
                    valid_triples[j].idx_w2 == valid_triples[i].idx_w2 &amp;&amp;
                    valid_triples[j].idx_b == valid_triples[i].idx_b) {
                    dup = 1;
                    break;
                }
            }
            if (!dup) unique++;
        }
        printf("  Unique weight triples (ignoring gauge): %d\n", unique);
        printf("  Average gauge angles per triple: %.1f\n",
               unique &gt; 0 ? (double)n_valid / (double)unique : 0.0);
    }
}

/* ================================================================
 * PART E: Bracket Composition Test
 *
 * Test: is bracket(b1*b2) = bracket(b1) * bracket(b2)?
 * Prediction: NO (trace is not multiplicative), but result IS in Z[zeta_8].
 * ================================================================ */

static void part_e_composition(void) {
    int i, n_equal = 0, n_tested = 0;
    Cyc8 A = cyc8_make(0, -1, 0, 0);
    char msg[256];

    printf("\n=== PART E: Bracket Composition Test ===\n");
    printf("  Testing: bracket(b1*b2) vs bracket(b1) * bracket(b2)\n\n");

    /* Test pairs from first 20 catalog entries */
    for (i = 0; i &lt; 10 &amp;&amp; i &lt; catalog_size - 1; i++) {
        Braid b1 = catalog[i * 3].braid;
        Braid b2 = catalog[i * 3 + 1].braid;
        Braid b_composed;
        Cyc8 br1, br2, br_composed, br_product;
        int j;

        /* Only compose if same strand count */
        if (b1.n != b2.n) continue;

        /* Compose: concatenate braid words */
        b_composed.n = b1.n;
        b_composed.len = b1.len + b2.len;
        if (b_composed.len &gt; MAX_WORD) continue;

        for (j = 0; j &lt; b1.len; j++)
            b_composed.word[j] = b1.word[j];
        for (j = 0; j &lt; b2.len; j++)
            b_composed.word[b1.len + j] = b2.word[j];

        br1 = braid_bracket_exact(&amp;b1, A);
        br2 = braid_bracket_exact(&amp;b2, A);
        br_composed = braid_bracket_exact(&amp;b_composed, A);
        br_product = cyc8_mul(br1, br2);

        n_tested++;
        if (cyc8_eq(br_composed, br_product)) n_equal++;

        printf("  Pair %d: bracket(b1*b2) = (%ld,%ld,%ld,%ld)"
               "  bracket(b1)*bracket(b2) = (%ld,%ld,%ld,%ld)  %s\n",
               n_tested,
               br_composed.a, br_composed.b, br_composed.c, br_composed.d,
               br_product.a, br_product.b, br_product.c, br_product.d,
               cyc8_eq(br_composed, br_product) ? "EQUAL" : "DIFFER");
    }

    printf("\n  Results: %d/%d pairs equal\n", n_equal, n_tested);

    if (n_tested &gt; 0) {
        sprintf(msg, "P4: composition non-multiplicative (&gt;= 80%% differ, got %d/%d differ)",
                n_tested - n_equal, n_tested);
        check(msg, (n_tested - n_equal) * 5 &gt;= n_tested * 4);

        /* P5: all composed values are in Z[zeta_8] (trivially true by construction) */
        check("P5: all composed values in Z[zeta_8] (by exact arithmetic)", 1);
    }
}

/* ================================================================
 * MAIN
 * ================================================================ */

int main(void) {
    setbuf(stdout, NULL);
    printf("KNOTAPEL DEMO 29: Cyclotomic Arithmetic — Forward DKC\n");
    printf("=====================================================\n");

    part_a_exact_arithmetic();
    part_b_exact_catalog();
    part_c_forward_dkc();
    part_d_manifold_analysis();
    part_e_composition();

    printf("\n=====================================================\n");
    printf("Results: %d passed, %d failed\n", n_pass, n_fail);
    printf("=====================================================\n");

    return n_fail &gt; 0 ? 1 : 0;
}
</code></pre>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <script>hljs.highlightAll();</script>
</body>
</html>